// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'protocol.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$ImplementationParams {

 TextDocumentIdentifier get textDocument; Position get position; ProgressToken? get partialResultToken; ProgressToken? get workDoneToken;
/// Create a copy of ImplementationParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ImplementationParamsCopyWith<ImplementationParams> get copyWith => _$ImplementationParamsCopyWithImpl<ImplementationParams>(this as ImplementationParams, _$identity);

  /// Serializes this ImplementationParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ImplementationParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.position, position) || other.position == position)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,position,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'ImplementationParams(textDocument: $textDocument, position: $position, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $ImplementationParamsCopyWith<$Res>  {
  factory $ImplementationParamsCopyWith(ImplementationParams value, $Res Function(ImplementationParams) _then) = _$ImplementationParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument, Position position, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;$PositionCopyWith<$Res> get position;

}
/// @nodoc
class _$ImplementationParamsCopyWithImpl<$Res>
    implements $ImplementationParamsCopyWith<$Res> {
  _$ImplementationParamsCopyWithImpl(this._self, this._then);

  final ImplementationParams _self;
  final $Res Function(ImplementationParams) _then;

/// Create a copy of ImplementationParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? position = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of ImplementationParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of ImplementationParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _ImplementationParams implements ImplementationParams {
  const _ImplementationParams({required this.textDocument, required this.position, this.partialResultToken, this.workDoneToken});
  factory _ImplementationParams.fromJson(Map<String, dynamic> json) => _$ImplementationParamsFromJson(json);

@override final  TextDocumentIdentifier textDocument;
@override final  Position position;
@override final  ProgressToken? partialResultToken;
@override final  ProgressToken? workDoneToken;

/// Create a copy of ImplementationParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ImplementationParamsCopyWith<_ImplementationParams> get copyWith => __$ImplementationParamsCopyWithImpl<_ImplementationParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ImplementationParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ImplementationParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.position, position) || other.position == position)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,position,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'ImplementationParams(textDocument: $textDocument, position: $position, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$ImplementationParamsCopyWith<$Res> implements $ImplementationParamsCopyWith<$Res> {
  factory _$ImplementationParamsCopyWith(_ImplementationParams value, $Res Function(_ImplementationParams) _then) = __$ImplementationParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument, Position position, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;@override $PositionCopyWith<$Res> get position;

}
/// @nodoc
class __$ImplementationParamsCopyWithImpl<$Res>
    implements _$ImplementationParamsCopyWith<$Res> {
  __$ImplementationParamsCopyWithImpl(this._self, this._then);

  final _ImplementationParams _self;
  final $Res Function(_ImplementationParams) _then;

/// Create a copy of ImplementationParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? position = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_ImplementationParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of ImplementationParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of ImplementationParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}
}


/// @nodoc
mixin _$Location {

 String get uri; Range get range;
/// Create a copy of Location
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LocationCopyWith<Location> get copyWith => _$LocationCopyWithImpl<Location>(this as Location, _$identity);

  /// Serializes this Location to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Location&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.range, range) || other.range == range));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri,range);

@override
String toString() {
  return 'Location(uri: $uri, range: $range)';
}


}

/// @nodoc
abstract mixin class $LocationCopyWith<$Res>  {
  factory $LocationCopyWith(Location value, $Res Function(Location) _then) = _$LocationCopyWithImpl;
@useResult
$Res call({
 String uri, Range range
});


$RangeCopyWith<$Res> get range;

}
/// @nodoc
class _$LocationCopyWithImpl<$Res>
    implements $LocationCopyWith<$Res> {
  _$LocationCopyWithImpl(this._self, this._then);

  final Location _self;
  final $Res Function(Location) _then;

/// Create a copy of Location
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? uri = null,Object? range = null,}) {
  return _then(_self.copyWith(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,
  ));
}
/// Create a copy of Location
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _Location implements Location {
  const _Location({required this.uri, required this.range});
  factory _Location.fromJson(Map<String, dynamic> json) => _$LocationFromJson(json);

@override final  String uri;
@override final  Range range;

/// Create a copy of Location
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$LocationCopyWith<_Location> get copyWith => __$LocationCopyWithImpl<_Location>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$LocationToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _Location&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.range, range) || other.range == range));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri,range);

@override
String toString() {
  return 'Location(uri: $uri, range: $range)';
}


}

/// @nodoc
abstract mixin class _$LocationCopyWith<$Res> implements $LocationCopyWith<$Res> {
  factory _$LocationCopyWith(_Location value, $Res Function(_Location) _then) = __$LocationCopyWithImpl;
@override @useResult
$Res call({
 String uri, Range range
});


@override $RangeCopyWith<$Res> get range;

}
/// @nodoc
class __$LocationCopyWithImpl<$Res>
    implements _$LocationCopyWith<$Res> {
  __$LocationCopyWithImpl(this._self, this._then);

  final _Location _self;
  final $Res Function(_Location) _then;

/// Create a copy of Location
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? uri = null,Object? range = null,}) {
  return _then(_Location(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,
  ));
}

/// Create a copy of Location
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}


/// @nodoc
mixin _$ImplementationRegistrationOptions {

 dynamic get documentSelector; String? get id; bool? get workDoneProgress;
/// Create a copy of ImplementationRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ImplementationRegistrationOptionsCopyWith<ImplementationRegistrationOptions> get copyWith => _$ImplementationRegistrationOptionsCopyWithImpl<ImplementationRegistrationOptions>(this as ImplementationRegistrationOptions, _$identity);

  /// Serializes this ImplementationRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ImplementationRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.id, id) || other.id == id)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),id,workDoneProgress);

@override
String toString() {
  return 'ImplementationRegistrationOptions(documentSelector: $documentSelector, id: $id, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $ImplementationRegistrationOptionsCopyWith<$Res>  {
  factory $ImplementationRegistrationOptionsCopyWith(ImplementationRegistrationOptions value, $Res Function(ImplementationRegistrationOptions) _then) = _$ImplementationRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 dynamic documentSelector, String? id, bool? workDoneProgress
});




}
/// @nodoc
class _$ImplementationRegistrationOptionsCopyWithImpl<$Res>
    implements $ImplementationRegistrationOptionsCopyWith<$Res> {
  _$ImplementationRegistrationOptionsCopyWithImpl(this._self, this._then);

  final ImplementationRegistrationOptions _self;
  final $Res Function(ImplementationRegistrationOptions) _then;

/// Create a copy of ImplementationRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = freezed,Object? id = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _ImplementationRegistrationOptions implements ImplementationRegistrationOptions {
  const _ImplementationRegistrationOptions({required this.documentSelector, this.id, this.workDoneProgress});
  factory _ImplementationRegistrationOptions.fromJson(Map<String, dynamic> json) => _$ImplementationRegistrationOptionsFromJson(json);

@override final  dynamic documentSelector;
@override final  String? id;
@override final  bool? workDoneProgress;

/// Create a copy of ImplementationRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ImplementationRegistrationOptionsCopyWith<_ImplementationRegistrationOptions> get copyWith => __$ImplementationRegistrationOptionsCopyWithImpl<_ImplementationRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ImplementationRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ImplementationRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.id, id) || other.id == id)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),id,workDoneProgress);

@override
String toString() {
  return 'ImplementationRegistrationOptions(documentSelector: $documentSelector, id: $id, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$ImplementationRegistrationOptionsCopyWith<$Res> implements $ImplementationRegistrationOptionsCopyWith<$Res> {
  factory _$ImplementationRegistrationOptionsCopyWith(_ImplementationRegistrationOptions value, $Res Function(_ImplementationRegistrationOptions) _then) = __$ImplementationRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 dynamic documentSelector, String? id, bool? workDoneProgress
});




}
/// @nodoc
class __$ImplementationRegistrationOptionsCopyWithImpl<$Res>
    implements _$ImplementationRegistrationOptionsCopyWith<$Res> {
  __$ImplementationRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _ImplementationRegistrationOptions _self;
  final $Res Function(_ImplementationRegistrationOptions) _then;

/// Create a copy of ImplementationRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = freezed,Object? id = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_ImplementationRegistrationOptions(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$TypeDefinitionParams {

 TextDocumentIdentifier get textDocument; Position get position; ProgressToken? get partialResultToken; ProgressToken? get workDoneToken;
/// Create a copy of TypeDefinitionParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TypeDefinitionParamsCopyWith<TypeDefinitionParams> get copyWith => _$TypeDefinitionParamsCopyWithImpl<TypeDefinitionParams>(this as TypeDefinitionParams, _$identity);

  /// Serializes this TypeDefinitionParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TypeDefinitionParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.position, position) || other.position == position)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,position,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'TypeDefinitionParams(textDocument: $textDocument, position: $position, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $TypeDefinitionParamsCopyWith<$Res>  {
  factory $TypeDefinitionParamsCopyWith(TypeDefinitionParams value, $Res Function(TypeDefinitionParams) _then) = _$TypeDefinitionParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument, Position position, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;$PositionCopyWith<$Res> get position;

}
/// @nodoc
class _$TypeDefinitionParamsCopyWithImpl<$Res>
    implements $TypeDefinitionParamsCopyWith<$Res> {
  _$TypeDefinitionParamsCopyWithImpl(this._self, this._then);

  final TypeDefinitionParams _self;
  final $Res Function(TypeDefinitionParams) _then;

/// Create a copy of TypeDefinitionParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? position = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of TypeDefinitionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of TypeDefinitionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _TypeDefinitionParams implements TypeDefinitionParams {
  const _TypeDefinitionParams({required this.textDocument, required this.position, this.partialResultToken, this.workDoneToken});
  factory _TypeDefinitionParams.fromJson(Map<String, dynamic> json) => _$TypeDefinitionParamsFromJson(json);

@override final  TextDocumentIdentifier textDocument;
@override final  Position position;
@override final  ProgressToken? partialResultToken;
@override final  ProgressToken? workDoneToken;

/// Create a copy of TypeDefinitionParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TypeDefinitionParamsCopyWith<_TypeDefinitionParams> get copyWith => __$TypeDefinitionParamsCopyWithImpl<_TypeDefinitionParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TypeDefinitionParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TypeDefinitionParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.position, position) || other.position == position)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,position,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'TypeDefinitionParams(textDocument: $textDocument, position: $position, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$TypeDefinitionParamsCopyWith<$Res> implements $TypeDefinitionParamsCopyWith<$Res> {
  factory _$TypeDefinitionParamsCopyWith(_TypeDefinitionParams value, $Res Function(_TypeDefinitionParams) _then) = __$TypeDefinitionParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument, Position position, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;@override $PositionCopyWith<$Res> get position;

}
/// @nodoc
class __$TypeDefinitionParamsCopyWithImpl<$Res>
    implements _$TypeDefinitionParamsCopyWith<$Res> {
  __$TypeDefinitionParamsCopyWithImpl(this._self, this._then);

  final _TypeDefinitionParams _self;
  final $Res Function(_TypeDefinitionParams) _then;

/// Create a copy of TypeDefinitionParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? position = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_TypeDefinitionParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of TypeDefinitionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of TypeDefinitionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}
}


/// @nodoc
mixin _$TypeDefinitionRegistrationOptions {

 dynamic get documentSelector; String? get id; bool? get workDoneProgress;
/// Create a copy of TypeDefinitionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TypeDefinitionRegistrationOptionsCopyWith<TypeDefinitionRegistrationOptions> get copyWith => _$TypeDefinitionRegistrationOptionsCopyWithImpl<TypeDefinitionRegistrationOptions>(this as TypeDefinitionRegistrationOptions, _$identity);

  /// Serializes this TypeDefinitionRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TypeDefinitionRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.id, id) || other.id == id)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),id,workDoneProgress);

@override
String toString() {
  return 'TypeDefinitionRegistrationOptions(documentSelector: $documentSelector, id: $id, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $TypeDefinitionRegistrationOptionsCopyWith<$Res>  {
  factory $TypeDefinitionRegistrationOptionsCopyWith(TypeDefinitionRegistrationOptions value, $Res Function(TypeDefinitionRegistrationOptions) _then) = _$TypeDefinitionRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 dynamic documentSelector, String? id, bool? workDoneProgress
});




}
/// @nodoc
class _$TypeDefinitionRegistrationOptionsCopyWithImpl<$Res>
    implements $TypeDefinitionRegistrationOptionsCopyWith<$Res> {
  _$TypeDefinitionRegistrationOptionsCopyWithImpl(this._self, this._then);

  final TypeDefinitionRegistrationOptions _self;
  final $Res Function(TypeDefinitionRegistrationOptions) _then;

/// Create a copy of TypeDefinitionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = freezed,Object? id = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _TypeDefinitionRegistrationOptions implements TypeDefinitionRegistrationOptions {
  const _TypeDefinitionRegistrationOptions({required this.documentSelector, this.id, this.workDoneProgress});
  factory _TypeDefinitionRegistrationOptions.fromJson(Map<String, dynamic> json) => _$TypeDefinitionRegistrationOptionsFromJson(json);

@override final  dynamic documentSelector;
@override final  String? id;
@override final  bool? workDoneProgress;

/// Create a copy of TypeDefinitionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TypeDefinitionRegistrationOptionsCopyWith<_TypeDefinitionRegistrationOptions> get copyWith => __$TypeDefinitionRegistrationOptionsCopyWithImpl<_TypeDefinitionRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TypeDefinitionRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TypeDefinitionRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.id, id) || other.id == id)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),id,workDoneProgress);

@override
String toString() {
  return 'TypeDefinitionRegistrationOptions(documentSelector: $documentSelector, id: $id, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$TypeDefinitionRegistrationOptionsCopyWith<$Res> implements $TypeDefinitionRegistrationOptionsCopyWith<$Res> {
  factory _$TypeDefinitionRegistrationOptionsCopyWith(_TypeDefinitionRegistrationOptions value, $Res Function(_TypeDefinitionRegistrationOptions) _then) = __$TypeDefinitionRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 dynamic documentSelector, String? id, bool? workDoneProgress
});




}
/// @nodoc
class __$TypeDefinitionRegistrationOptionsCopyWithImpl<$Res>
    implements _$TypeDefinitionRegistrationOptionsCopyWith<$Res> {
  __$TypeDefinitionRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _TypeDefinitionRegistrationOptions _self;
  final $Res Function(_TypeDefinitionRegistrationOptions) _then;

/// Create a copy of TypeDefinitionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = freezed,Object? id = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_TypeDefinitionRegistrationOptions(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$WorkspaceFolder {

 String get uri; String get name;
/// Create a copy of WorkspaceFolder
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkspaceFolderCopyWith<WorkspaceFolder> get copyWith => _$WorkspaceFolderCopyWithImpl<WorkspaceFolder>(this as WorkspaceFolder, _$identity);

  /// Serializes this WorkspaceFolder to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkspaceFolder&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.name, name) || other.name == name));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri,name);

@override
String toString() {
  return 'WorkspaceFolder(uri: $uri, name: $name)';
}


}

/// @nodoc
abstract mixin class $WorkspaceFolderCopyWith<$Res>  {
  factory $WorkspaceFolderCopyWith(WorkspaceFolder value, $Res Function(WorkspaceFolder) _then) = _$WorkspaceFolderCopyWithImpl;
@useResult
$Res call({
 String uri, String name
});




}
/// @nodoc
class _$WorkspaceFolderCopyWithImpl<$Res>
    implements $WorkspaceFolderCopyWith<$Res> {
  _$WorkspaceFolderCopyWithImpl(this._self, this._then);

  final WorkspaceFolder _self;
  final $Res Function(WorkspaceFolder) _then;

/// Create a copy of WorkspaceFolder
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? uri = null,Object? name = null,}) {
  return _then(_self.copyWith(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _WorkspaceFolder implements WorkspaceFolder {
  const _WorkspaceFolder({required this.uri, required this.name});
  factory _WorkspaceFolder.fromJson(Map<String, dynamic> json) => _$WorkspaceFolderFromJson(json);

@override final  String uri;
@override final  String name;

/// Create a copy of WorkspaceFolder
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkspaceFolderCopyWith<_WorkspaceFolder> get copyWith => __$WorkspaceFolderCopyWithImpl<_WorkspaceFolder>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkspaceFolderToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkspaceFolder&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.name, name) || other.name == name));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri,name);

@override
String toString() {
  return 'WorkspaceFolder(uri: $uri, name: $name)';
}


}

/// @nodoc
abstract mixin class _$WorkspaceFolderCopyWith<$Res> implements $WorkspaceFolderCopyWith<$Res> {
  factory _$WorkspaceFolderCopyWith(_WorkspaceFolder value, $Res Function(_WorkspaceFolder) _then) = __$WorkspaceFolderCopyWithImpl;
@override @useResult
$Res call({
 String uri, String name
});




}
/// @nodoc
class __$WorkspaceFolderCopyWithImpl<$Res>
    implements _$WorkspaceFolderCopyWith<$Res> {
  __$WorkspaceFolderCopyWithImpl(this._self, this._then);

  final _WorkspaceFolder _self;
  final $Res Function(_WorkspaceFolder) _then;

/// Create a copy of WorkspaceFolder
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? uri = null,Object? name = null,}) {
  return _then(_WorkspaceFolder(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}


/// @nodoc
mixin _$DidChangeWorkspaceFoldersParams {

 WorkspaceFoldersChangeEvent get event;
/// Create a copy of DidChangeWorkspaceFoldersParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DidChangeWorkspaceFoldersParamsCopyWith<DidChangeWorkspaceFoldersParams> get copyWith => _$DidChangeWorkspaceFoldersParamsCopyWithImpl<DidChangeWorkspaceFoldersParams>(this as DidChangeWorkspaceFoldersParams, _$identity);

  /// Serializes this DidChangeWorkspaceFoldersParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DidChangeWorkspaceFoldersParams&&(identical(other.event, event) || other.event == event));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,event);

@override
String toString() {
  return 'DidChangeWorkspaceFoldersParams(event: $event)';
}


}

/// @nodoc
abstract mixin class $DidChangeWorkspaceFoldersParamsCopyWith<$Res>  {
  factory $DidChangeWorkspaceFoldersParamsCopyWith(DidChangeWorkspaceFoldersParams value, $Res Function(DidChangeWorkspaceFoldersParams) _then) = _$DidChangeWorkspaceFoldersParamsCopyWithImpl;
@useResult
$Res call({
 WorkspaceFoldersChangeEvent event
});


$WorkspaceFoldersChangeEventCopyWith<$Res> get event;

}
/// @nodoc
class _$DidChangeWorkspaceFoldersParamsCopyWithImpl<$Res>
    implements $DidChangeWorkspaceFoldersParamsCopyWith<$Res> {
  _$DidChangeWorkspaceFoldersParamsCopyWithImpl(this._self, this._then);

  final DidChangeWorkspaceFoldersParams _self;
  final $Res Function(DidChangeWorkspaceFoldersParams) _then;

/// Create a copy of DidChangeWorkspaceFoldersParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? event = null,}) {
  return _then(_self.copyWith(
event: null == event ? _self.event : event // ignore: cast_nullable_to_non_nullable
as WorkspaceFoldersChangeEvent,
  ));
}
/// Create a copy of DidChangeWorkspaceFoldersParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$WorkspaceFoldersChangeEventCopyWith<$Res> get event {
  
  return $WorkspaceFoldersChangeEventCopyWith<$Res>(_self.event, (value) {
    return _then(_self.copyWith(event: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DidChangeWorkspaceFoldersParams implements DidChangeWorkspaceFoldersParams {
  const _DidChangeWorkspaceFoldersParams({required this.event});
  factory _DidChangeWorkspaceFoldersParams.fromJson(Map<String, dynamic> json) => _$DidChangeWorkspaceFoldersParamsFromJson(json);

@override final  WorkspaceFoldersChangeEvent event;

/// Create a copy of DidChangeWorkspaceFoldersParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DidChangeWorkspaceFoldersParamsCopyWith<_DidChangeWorkspaceFoldersParams> get copyWith => __$DidChangeWorkspaceFoldersParamsCopyWithImpl<_DidChangeWorkspaceFoldersParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DidChangeWorkspaceFoldersParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DidChangeWorkspaceFoldersParams&&(identical(other.event, event) || other.event == event));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,event);

@override
String toString() {
  return 'DidChangeWorkspaceFoldersParams(event: $event)';
}


}

/// @nodoc
abstract mixin class _$DidChangeWorkspaceFoldersParamsCopyWith<$Res> implements $DidChangeWorkspaceFoldersParamsCopyWith<$Res> {
  factory _$DidChangeWorkspaceFoldersParamsCopyWith(_DidChangeWorkspaceFoldersParams value, $Res Function(_DidChangeWorkspaceFoldersParams) _then) = __$DidChangeWorkspaceFoldersParamsCopyWithImpl;
@override @useResult
$Res call({
 WorkspaceFoldersChangeEvent event
});


@override $WorkspaceFoldersChangeEventCopyWith<$Res> get event;

}
/// @nodoc
class __$DidChangeWorkspaceFoldersParamsCopyWithImpl<$Res>
    implements _$DidChangeWorkspaceFoldersParamsCopyWith<$Res> {
  __$DidChangeWorkspaceFoldersParamsCopyWithImpl(this._self, this._then);

  final _DidChangeWorkspaceFoldersParams _self;
  final $Res Function(_DidChangeWorkspaceFoldersParams) _then;

/// Create a copy of DidChangeWorkspaceFoldersParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? event = null,}) {
  return _then(_DidChangeWorkspaceFoldersParams(
event: null == event ? _self.event : event // ignore: cast_nullable_to_non_nullable
as WorkspaceFoldersChangeEvent,
  ));
}

/// Create a copy of DidChangeWorkspaceFoldersParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$WorkspaceFoldersChangeEventCopyWith<$Res> get event {
  
  return $WorkspaceFoldersChangeEventCopyWith<$Res>(_self.event, (value) {
    return _then(_self.copyWith(event: value));
  });
}
}


/// @nodoc
mixin _$ConfigurationParams {

 List<ConfigurationItem> get items;
/// Create a copy of ConfigurationParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ConfigurationParamsCopyWith<ConfigurationParams> get copyWith => _$ConfigurationParamsCopyWithImpl<ConfigurationParams>(this as ConfigurationParams, _$identity);

  /// Serializes this ConfigurationParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ConfigurationParams&&const DeepCollectionEquality().equals(other.items, items));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(items));

@override
String toString() {
  return 'ConfigurationParams(items: $items)';
}


}

/// @nodoc
abstract mixin class $ConfigurationParamsCopyWith<$Res>  {
  factory $ConfigurationParamsCopyWith(ConfigurationParams value, $Res Function(ConfigurationParams) _then) = _$ConfigurationParamsCopyWithImpl;
@useResult
$Res call({
 List<ConfigurationItem> items
});




}
/// @nodoc
class _$ConfigurationParamsCopyWithImpl<$Res>
    implements $ConfigurationParamsCopyWith<$Res> {
  _$ConfigurationParamsCopyWithImpl(this._self, this._then);

  final ConfigurationParams _self;
  final $Res Function(ConfigurationParams) _then;

/// Create a copy of ConfigurationParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? items = null,}) {
  return _then(_self.copyWith(
items: null == items ? _self.items : items // ignore: cast_nullable_to_non_nullable
as List<ConfigurationItem>,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _ConfigurationParams implements ConfigurationParams {
  const _ConfigurationParams({required final  List<ConfigurationItem> items}): _items = items;
  factory _ConfigurationParams.fromJson(Map<String, dynamic> json) => _$ConfigurationParamsFromJson(json);

 final  List<ConfigurationItem> _items;
@override List<ConfigurationItem> get items {
  if (_items is EqualUnmodifiableListView) return _items;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_items);
}


/// Create a copy of ConfigurationParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ConfigurationParamsCopyWith<_ConfigurationParams> get copyWith => __$ConfigurationParamsCopyWithImpl<_ConfigurationParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ConfigurationParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ConfigurationParams&&const DeepCollectionEquality().equals(other._items, _items));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_items));

@override
String toString() {
  return 'ConfigurationParams(items: $items)';
}


}

/// @nodoc
abstract mixin class _$ConfigurationParamsCopyWith<$Res> implements $ConfigurationParamsCopyWith<$Res> {
  factory _$ConfigurationParamsCopyWith(_ConfigurationParams value, $Res Function(_ConfigurationParams) _then) = __$ConfigurationParamsCopyWithImpl;
@override @useResult
$Res call({
 List<ConfigurationItem> items
});




}
/// @nodoc
class __$ConfigurationParamsCopyWithImpl<$Res>
    implements _$ConfigurationParamsCopyWith<$Res> {
  __$ConfigurationParamsCopyWithImpl(this._self, this._then);

  final _ConfigurationParams _self;
  final $Res Function(_ConfigurationParams) _then;

/// Create a copy of ConfigurationParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? items = null,}) {
  return _then(_ConfigurationParams(
items: null == items ? _self._items : items // ignore: cast_nullable_to_non_nullable
as List<ConfigurationItem>,
  ));
}


}


/// @nodoc
mixin _$DocumentColorParams {

 TextDocumentIdentifier get textDocument; ProgressToken? get partialResultToken; ProgressToken? get workDoneToken;
/// Create a copy of DocumentColorParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentColorParamsCopyWith<DocumentColorParams> get copyWith => _$DocumentColorParamsCopyWithImpl<DocumentColorParams>(this as DocumentColorParams, _$identity);

  /// Serializes this DocumentColorParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentColorParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'DocumentColorParams(textDocument: $textDocument, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $DocumentColorParamsCopyWith<$Res>  {
  factory $DocumentColorParamsCopyWith(DocumentColorParams value, $Res Function(DocumentColorParams) _then) = _$DocumentColorParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$DocumentColorParamsCopyWithImpl<$Res>
    implements $DocumentColorParamsCopyWith<$Res> {
  _$DocumentColorParamsCopyWithImpl(this._self, this._then);

  final DocumentColorParams _self;
  final $Res Function(DocumentColorParams) _then;

/// Create a copy of DocumentColorParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of DocumentColorParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DocumentColorParams implements DocumentColorParams {
  const _DocumentColorParams({required this.textDocument, this.partialResultToken, this.workDoneToken});
  factory _DocumentColorParams.fromJson(Map<String, dynamic> json) => _$DocumentColorParamsFromJson(json);

@override final  TextDocumentIdentifier textDocument;
@override final  ProgressToken? partialResultToken;
@override final  ProgressToken? workDoneToken;

/// Create a copy of DocumentColorParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentColorParamsCopyWith<_DocumentColorParams> get copyWith => __$DocumentColorParamsCopyWithImpl<_DocumentColorParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentColorParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentColorParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'DocumentColorParams(textDocument: $textDocument, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$DocumentColorParamsCopyWith<$Res> implements $DocumentColorParamsCopyWith<$Res> {
  factory _$DocumentColorParamsCopyWith(_DocumentColorParams value, $Res Function(_DocumentColorParams) _then) = __$DocumentColorParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$DocumentColorParamsCopyWithImpl<$Res>
    implements _$DocumentColorParamsCopyWith<$Res> {
  __$DocumentColorParamsCopyWithImpl(this._self, this._then);

  final _DocumentColorParams _self;
  final $Res Function(_DocumentColorParams) _then;

/// Create a copy of DocumentColorParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_DocumentColorParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of DocumentColorParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$ColorInformation {

 Range get range; Color get color;
/// Create a copy of ColorInformation
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ColorInformationCopyWith<ColorInformation> get copyWith => _$ColorInformationCopyWithImpl<ColorInformation>(this as ColorInformation, _$identity);

  /// Serializes this ColorInformation to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ColorInformation&&(identical(other.range, range) || other.range == range)&&(identical(other.color, color) || other.color == color));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,range,color);

@override
String toString() {
  return 'ColorInformation(range: $range, color: $color)';
}


}

/// @nodoc
abstract mixin class $ColorInformationCopyWith<$Res>  {
  factory $ColorInformationCopyWith(ColorInformation value, $Res Function(ColorInformation) _then) = _$ColorInformationCopyWithImpl;
@useResult
$Res call({
 Range range, Color color
});


$RangeCopyWith<$Res> get range;$ColorCopyWith<$Res> get color;

}
/// @nodoc
class _$ColorInformationCopyWithImpl<$Res>
    implements $ColorInformationCopyWith<$Res> {
  _$ColorInformationCopyWithImpl(this._self, this._then);

  final ColorInformation _self;
  final $Res Function(ColorInformation) _then;

/// Create a copy of ColorInformation
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? range = null,Object? color = null,}) {
  return _then(_self.copyWith(
range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,color: null == color ? _self.color : color // ignore: cast_nullable_to_non_nullable
as Color,
  ));
}
/// Create a copy of ColorInformation
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}/// Create a copy of ColorInformation
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ColorCopyWith<$Res> get color {
  
  return $ColorCopyWith<$Res>(_self.color, (value) {
    return _then(_self.copyWith(color: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _ColorInformation implements ColorInformation {
  const _ColorInformation({required this.range, required this.color});
  factory _ColorInformation.fromJson(Map<String, dynamic> json) => _$ColorInformationFromJson(json);

@override final  Range range;
@override final  Color color;

/// Create a copy of ColorInformation
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ColorInformationCopyWith<_ColorInformation> get copyWith => __$ColorInformationCopyWithImpl<_ColorInformation>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ColorInformationToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ColorInformation&&(identical(other.range, range) || other.range == range)&&(identical(other.color, color) || other.color == color));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,range,color);

@override
String toString() {
  return 'ColorInformation(range: $range, color: $color)';
}


}

/// @nodoc
abstract mixin class _$ColorInformationCopyWith<$Res> implements $ColorInformationCopyWith<$Res> {
  factory _$ColorInformationCopyWith(_ColorInformation value, $Res Function(_ColorInformation) _then) = __$ColorInformationCopyWithImpl;
@override @useResult
$Res call({
 Range range, Color color
});


@override $RangeCopyWith<$Res> get range;@override $ColorCopyWith<$Res> get color;

}
/// @nodoc
class __$ColorInformationCopyWithImpl<$Res>
    implements _$ColorInformationCopyWith<$Res> {
  __$ColorInformationCopyWithImpl(this._self, this._then);

  final _ColorInformation _self;
  final $Res Function(_ColorInformation) _then;

/// Create a copy of ColorInformation
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? range = null,Object? color = null,}) {
  return _then(_ColorInformation(
range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,color: null == color ? _self.color : color // ignore: cast_nullable_to_non_nullable
as Color,
  ));
}

/// Create a copy of ColorInformation
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}/// Create a copy of ColorInformation
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ColorCopyWith<$Res> get color {
  
  return $ColorCopyWith<$Res>(_self.color, (value) {
    return _then(_self.copyWith(color: value));
  });
}
}


/// @nodoc
mixin _$DocumentColorRegistrationOptions {

 dynamic get documentSelector; String? get id; bool? get workDoneProgress;
/// Create a copy of DocumentColorRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentColorRegistrationOptionsCopyWith<DocumentColorRegistrationOptions> get copyWith => _$DocumentColorRegistrationOptionsCopyWithImpl<DocumentColorRegistrationOptions>(this as DocumentColorRegistrationOptions, _$identity);

  /// Serializes this DocumentColorRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentColorRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.id, id) || other.id == id)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),id,workDoneProgress);

@override
String toString() {
  return 'DocumentColorRegistrationOptions(documentSelector: $documentSelector, id: $id, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $DocumentColorRegistrationOptionsCopyWith<$Res>  {
  factory $DocumentColorRegistrationOptionsCopyWith(DocumentColorRegistrationOptions value, $Res Function(DocumentColorRegistrationOptions) _then) = _$DocumentColorRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 dynamic documentSelector, String? id, bool? workDoneProgress
});




}
/// @nodoc
class _$DocumentColorRegistrationOptionsCopyWithImpl<$Res>
    implements $DocumentColorRegistrationOptionsCopyWith<$Res> {
  _$DocumentColorRegistrationOptionsCopyWithImpl(this._self, this._then);

  final DocumentColorRegistrationOptions _self;
  final $Res Function(DocumentColorRegistrationOptions) _then;

/// Create a copy of DocumentColorRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = freezed,Object? id = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DocumentColorRegistrationOptions implements DocumentColorRegistrationOptions {
  const _DocumentColorRegistrationOptions({required this.documentSelector, this.id, this.workDoneProgress});
  factory _DocumentColorRegistrationOptions.fromJson(Map<String, dynamic> json) => _$DocumentColorRegistrationOptionsFromJson(json);

@override final  dynamic documentSelector;
@override final  String? id;
@override final  bool? workDoneProgress;

/// Create a copy of DocumentColorRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentColorRegistrationOptionsCopyWith<_DocumentColorRegistrationOptions> get copyWith => __$DocumentColorRegistrationOptionsCopyWithImpl<_DocumentColorRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentColorRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentColorRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.id, id) || other.id == id)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),id,workDoneProgress);

@override
String toString() {
  return 'DocumentColorRegistrationOptions(documentSelector: $documentSelector, id: $id, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$DocumentColorRegistrationOptionsCopyWith<$Res> implements $DocumentColorRegistrationOptionsCopyWith<$Res> {
  factory _$DocumentColorRegistrationOptionsCopyWith(_DocumentColorRegistrationOptions value, $Res Function(_DocumentColorRegistrationOptions) _then) = __$DocumentColorRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 dynamic documentSelector, String? id, bool? workDoneProgress
});




}
/// @nodoc
class __$DocumentColorRegistrationOptionsCopyWithImpl<$Res>
    implements _$DocumentColorRegistrationOptionsCopyWith<$Res> {
  __$DocumentColorRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _DocumentColorRegistrationOptions _self;
  final $Res Function(_DocumentColorRegistrationOptions) _then;

/// Create a copy of DocumentColorRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = freezed,Object? id = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_DocumentColorRegistrationOptions(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$ColorPresentationParams {

 TextDocumentIdentifier get textDocument; Color get color; Range get range; ProgressToken? get partialResultToken; ProgressToken? get workDoneToken;
/// Create a copy of ColorPresentationParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ColorPresentationParamsCopyWith<ColorPresentationParams> get copyWith => _$ColorPresentationParamsCopyWithImpl<ColorPresentationParams>(this as ColorPresentationParams, _$identity);

  /// Serializes this ColorPresentationParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ColorPresentationParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.color, color) || other.color == color)&&(identical(other.range, range) || other.range == range)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,color,range,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'ColorPresentationParams(textDocument: $textDocument, color: $color, range: $range, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $ColorPresentationParamsCopyWith<$Res>  {
  factory $ColorPresentationParamsCopyWith(ColorPresentationParams value, $Res Function(ColorPresentationParams) _then) = _$ColorPresentationParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument, Color color, Range range, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;$ColorCopyWith<$Res> get color;$RangeCopyWith<$Res> get range;

}
/// @nodoc
class _$ColorPresentationParamsCopyWithImpl<$Res>
    implements $ColorPresentationParamsCopyWith<$Res> {
  _$ColorPresentationParamsCopyWithImpl(this._self, this._then);

  final ColorPresentationParams _self;
  final $Res Function(ColorPresentationParams) _then;

/// Create a copy of ColorPresentationParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? color = null,Object? range = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,color: null == color ? _self.color : color // ignore: cast_nullable_to_non_nullable
as Color,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of ColorPresentationParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of ColorPresentationParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ColorCopyWith<$Res> get color {
  
  return $ColorCopyWith<$Res>(_self.color, (value) {
    return _then(_self.copyWith(color: value));
  });
}/// Create a copy of ColorPresentationParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _ColorPresentationParams implements ColorPresentationParams {
  const _ColorPresentationParams({required this.textDocument, required this.color, required this.range, this.partialResultToken, this.workDoneToken});
  factory _ColorPresentationParams.fromJson(Map<String, dynamic> json) => _$ColorPresentationParamsFromJson(json);

@override final  TextDocumentIdentifier textDocument;
@override final  Color color;
@override final  Range range;
@override final  ProgressToken? partialResultToken;
@override final  ProgressToken? workDoneToken;

/// Create a copy of ColorPresentationParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ColorPresentationParamsCopyWith<_ColorPresentationParams> get copyWith => __$ColorPresentationParamsCopyWithImpl<_ColorPresentationParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ColorPresentationParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ColorPresentationParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.color, color) || other.color == color)&&(identical(other.range, range) || other.range == range)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,color,range,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'ColorPresentationParams(textDocument: $textDocument, color: $color, range: $range, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$ColorPresentationParamsCopyWith<$Res> implements $ColorPresentationParamsCopyWith<$Res> {
  factory _$ColorPresentationParamsCopyWith(_ColorPresentationParams value, $Res Function(_ColorPresentationParams) _then) = __$ColorPresentationParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument, Color color, Range range, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;@override $ColorCopyWith<$Res> get color;@override $RangeCopyWith<$Res> get range;

}
/// @nodoc
class __$ColorPresentationParamsCopyWithImpl<$Res>
    implements _$ColorPresentationParamsCopyWith<$Res> {
  __$ColorPresentationParamsCopyWithImpl(this._self, this._then);

  final _ColorPresentationParams _self;
  final $Res Function(_ColorPresentationParams) _then;

/// Create a copy of ColorPresentationParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? color = null,Object? range = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_ColorPresentationParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,color: null == color ? _self.color : color // ignore: cast_nullable_to_non_nullable
as Color,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of ColorPresentationParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of ColorPresentationParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ColorCopyWith<$Res> get color {
  
  return $ColorCopyWith<$Res>(_self.color, (value) {
    return _then(_self.copyWith(color: value));
  });
}/// Create a copy of ColorPresentationParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}


/// @nodoc
mixin _$ColorPresentation {

 String get label; List<TextEdit>? get additionalTextEdits; TextEdit? get textEdit;
/// Create a copy of ColorPresentation
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ColorPresentationCopyWith<ColorPresentation> get copyWith => _$ColorPresentationCopyWithImpl<ColorPresentation>(this as ColorPresentation, _$identity);

  /// Serializes this ColorPresentation to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ColorPresentation&&(identical(other.label, label) || other.label == label)&&const DeepCollectionEquality().equals(other.additionalTextEdits, additionalTextEdits)&&(identical(other.textEdit, textEdit) || other.textEdit == textEdit));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,label,const DeepCollectionEquality().hash(additionalTextEdits),textEdit);

@override
String toString() {
  return 'ColorPresentation(label: $label, additionalTextEdits: $additionalTextEdits, textEdit: $textEdit)';
}


}

/// @nodoc
abstract mixin class $ColorPresentationCopyWith<$Res>  {
  factory $ColorPresentationCopyWith(ColorPresentation value, $Res Function(ColorPresentation) _then) = _$ColorPresentationCopyWithImpl;
@useResult
$Res call({
 String label, List<TextEdit>? additionalTextEdits, TextEdit? textEdit
});


$TextEditCopyWith<$Res>? get textEdit;

}
/// @nodoc
class _$ColorPresentationCopyWithImpl<$Res>
    implements $ColorPresentationCopyWith<$Res> {
  _$ColorPresentationCopyWithImpl(this._self, this._then);

  final ColorPresentation _self;
  final $Res Function(ColorPresentation) _then;

/// Create a copy of ColorPresentation
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? label = null,Object? additionalTextEdits = freezed,Object? textEdit = freezed,}) {
  return _then(_self.copyWith(
label: null == label ? _self.label : label // ignore: cast_nullable_to_non_nullable
as String,additionalTextEdits: freezed == additionalTextEdits ? _self.additionalTextEdits : additionalTextEdits // ignore: cast_nullable_to_non_nullable
as List<TextEdit>?,textEdit: freezed == textEdit ? _self.textEdit : textEdit // ignore: cast_nullable_to_non_nullable
as TextEdit?,
  ));
}
/// Create a copy of ColorPresentation
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextEditCopyWith<$Res>? get textEdit {
    if (_self.textEdit == null) {
    return null;
  }

  return $TextEditCopyWith<$Res>(_self.textEdit!, (value) {
    return _then(_self.copyWith(textEdit: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _ColorPresentation implements ColorPresentation {
  const _ColorPresentation({required this.label, final  List<TextEdit>? additionalTextEdits, this.textEdit}): _additionalTextEdits = additionalTextEdits;
  factory _ColorPresentation.fromJson(Map<String, dynamic> json) => _$ColorPresentationFromJson(json);

@override final  String label;
 final  List<TextEdit>? _additionalTextEdits;
@override List<TextEdit>? get additionalTextEdits {
  final value = _additionalTextEdits;
  if (value == null) return null;
  if (_additionalTextEdits is EqualUnmodifiableListView) return _additionalTextEdits;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

@override final  TextEdit? textEdit;

/// Create a copy of ColorPresentation
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ColorPresentationCopyWith<_ColorPresentation> get copyWith => __$ColorPresentationCopyWithImpl<_ColorPresentation>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ColorPresentationToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ColorPresentation&&(identical(other.label, label) || other.label == label)&&const DeepCollectionEquality().equals(other._additionalTextEdits, _additionalTextEdits)&&(identical(other.textEdit, textEdit) || other.textEdit == textEdit));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,label,const DeepCollectionEquality().hash(_additionalTextEdits),textEdit);

@override
String toString() {
  return 'ColorPresentation(label: $label, additionalTextEdits: $additionalTextEdits, textEdit: $textEdit)';
}


}

/// @nodoc
abstract mixin class _$ColorPresentationCopyWith<$Res> implements $ColorPresentationCopyWith<$Res> {
  factory _$ColorPresentationCopyWith(_ColorPresentation value, $Res Function(_ColorPresentation) _then) = __$ColorPresentationCopyWithImpl;
@override @useResult
$Res call({
 String label, List<TextEdit>? additionalTextEdits, TextEdit? textEdit
});


@override $TextEditCopyWith<$Res>? get textEdit;

}
/// @nodoc
class __$ColorPresentationCopyWithImpl<$Res>
    implements _$ColorPresentationCopyWith<$Res> {
  __$ColorPresentationCopyWithImpl(this._self, this._then);

  final _ColorPresentation _self;
  final $Res Function(_ColorPresentation) _then;

/// Create a copy of ColorPresentation
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? label = null,Object? additionalTextEdits = freezed,Object? textEdit = freezed,}) {
  return _then(_ColorPresentation(
label: null == label ? _self.label : label // ignore: cast_nullable_to_non_nullable
as String,additionalTextEdits: freezed == additionalTextEdits ? _self._additionalTextEdits : additionalTextEdits // ignore: cast_nullable_to_non_nullable
as List<TextEdit>?,textEdit: freezed == textEdit ? _self.textEdit : textEdit // ignore: cast_nullable_to_non_nullable
as TextEdit?,
  ));
}

/// Create a copy of ColorPresentation
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextEditCopyWith<$Res>? get textEdit {
    if (_self.textEdit == null) {
    return null;
  }

  return $TextEditCopyWith<$Res>(_self.textEdit!, (value) {
    return _then(_self.copyWith(textEdit: value));
  });
}
}


/// @nodoc
mixin _$WorkDoneProgressOptions {

 bool? get workDoneProgress;
/// Create a copy of WorkDoneProgressOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkDoneProgressOptionsCopyWith<WorkDoneProgressOptions> get copyWith => _$WorkDoneProgressOptionsCopyWithImpl<WorkDoneProgressOptions>(this as WorkDoneProgressOptions, _$identity);

  /// Serializes this WorkDoneProgressOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkDoneProgressOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'WorkDoneProgressOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $WorkDoneProgressOptionsCopyWith<$Res>  {
  factory $WorkDoneProgressOptionsCopyWith(WorkDoneProgressOptions value, $Res Function(WorkDoneProgressOptions) _then) = _$WorkDoneProgressOptionsCopyWithImpl;
@useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class _$WorkDoneProgressOptionsCopyWithImpl<$Res>
    implements $WorkDoneProgressOptionsCopyWith<$Res> {
  _$WorkDoneProgressOptionsCopyWithImpl(this._self, this._then);

  final WorkDoneProgressOptions _self;
  final $Res Function(WorkDoneProgressOptions) _then;

/// Create a copy of WorkDoneProgressOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _WorkDoneProgressOptions implements WorkDoneProgressOptions {
  const _WorkDoneProgressOptions({this.workDoneProgress});
  factory _WorkDoneProgressOptions.fromJson(Map<String, dynamic> json) => _$WorkDoneProgressOptionsFromJson(json);

@override final  bool? workDoneProgress;

/// Create a copy of WorkDoneProgressOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkDoneProgressOptionsCopyWith<_WorkDoneProgressOptions> get copyWith => __$WorkDoneProgressOptionsCopyWithImpl<_WorkDoneProgressOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkDoneProgressOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkDoneProgressOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'WorkDoneProgressOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$WorkDoneProgressOptionsCopyWith<$Res> implements $WorkDoneProgressOptionsCopyWith<$Res> {
  factory _$WorkDoneProgressOptionsCopyWith(_WorkDoneProgressOptions value, $Res Function(_WorkDoneProgressOptions) _then) = __$WorkDoneProgressOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class __$WorkDoneProgressOptionsCopyWithImpl<$Res>
    implements _$WorkDoneProgressOptionsCopyWith<$Res> {
  __$WorkDoneProgressOptionsCopyWithImpl(this._self, this._then);

  final _WorkDoneProgressOptions _self;
  final $Res Function(_WorkDoneProgressOptions) _then;

/// Create a copy of WorkDoneProgressOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_WorkDoneProgressOptions(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$TextDocumentRegistrationOptions {

 dynamic get documentSelector;
/// Create a copy of TextDocumentRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TextDocumentRegistrationOptionsCopyWith<TextDocumentRegistrationOptions> get copyWith => _$TextDocumentRegistrationOptionsCopyWithImpl<TextDocumentRegistrationOptions>(this as TextDocumentRegistrationOptions, _$identity);

  /// Serializes this TextDocumentRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TextDocumentRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector));

@override
String toString() {
  return 'TextDocumentRegistrationOptions(documentSelector: $documentSelector)';
}


}

/// @nodoc
abstract mixin class $TextDocumentRegistrationOptionsCopyWith<$Res>  {
  factory $TextDocumentRegistrationOptionsCopyWith(TextDocumentRegistrationOptions value, $Res Function(TextDocumentRegistrationOptions) _then) = _$TextDocumentRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 dynamic documentSelector
});




}
/// @nodoc
class _$TextDocumentRegistrationOptionsCopyWithImpl<$Res>
    implements $TextDocumentRegistrationOptionsCopyWith<$Res> {
  _$TextDocumentRegistrationOptionsCopyWithImpl(this._self, this._then);

  final TextDocumentRegistrationOptions _self;
  final $Res Function(TextDocumentRegistrationOptions) _then;

/// Create a copy of TextDocumentRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = freezed,}) {
  return _then(_self.copyWith(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _TextDocumentRegistrationOptions implements TextDocumentRegistrationOptions {
  const _TextDocumentRegistrationOptions({required this.documentSelector});
  factory _TextDocumentRegistrationOptions.fromJson(Map<String, dynamic> json) => _$TextDocumentRegistrationOptionsFromJson(json);

@override final  dynamic documentSelector;

/// Create a copy of TextDocumentRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TextDocumentRegistrationOptionsCopyWith<_TextDocumentRegistrationOptions> get copyWith => __$TextDocumentRegistrationOptionsCopyWithImpl<_TextDocumentRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TextDocumentRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TextDocumentRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector));

@override
String toString() {
  return 'TextDocumentRegistrationOptions(documentSelector: $documentSelector)';
}


}

/// @nodoc
abstract mixin class _$TextDocumentRegistrationOptionsCopyWith<$Res> implements $TextDocumentRegistrationOptionsCopyWith<$Res> {
  factory _$TextDocumentRegistrationOptionsCopyWith(_TextDocumentRegistrationOptions value, $Res Function(_TextDocumentRegistrationOptions) _then) = __$TextDocumentRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 dynamic documentSelector
});




}
/// @nodoc
class __$TextDocumentRegistrationOptionsCopyWithImpl<$Res>
    implements _$TextDocumentRegistrationOptionsCopyWith<$Res> {
  __$TextDocumentRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _TextDocumentRegistrationOptions _self;
  final $Res Function(_TextDocumentRegistrationOptions) _then;

/// Create a copy of TextDocumentRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = freezed,}) {
  return _then(_TextDocumentRegistrationOptions(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,
  ));
}


}


/// @nodoc
mixin _$FoldingRangeParams {

 TextDocumentIdentifier get textDocument; ProgressToken? get partialResultToken; ProgressToken? get workDoneToken;
/// Create a copy of FoldingRangeParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FoldingRangeParamsCopyWith<FoldingRangeParams> get copyWith => _$FoldingRangeParamsCopyWithImpl<FoldingRangeParams>(this as FoldingRangeParams, _$identity);

  /// Serializes this FoldingRangeParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FoldingRangeParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'FoldingRangeParams(textDocument: $textDocument, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $FoldingRangeParamsCopyWith<$Res>  {
  factory $FoldingRangeParamsCopyWith(FoldingRangeParams value, $Res Function(FoldingRangeParams) _then) = _$FoldingRangeParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$FoldingRangeParamsCopyWithImpl<$Res>
    implements $FoldingRangeParamsCopyWith<$Res> {
  _$FoldingRangeParamsCopyWithImpl(this._self, this._then);

  final FoldingRangeParams _self;
  final $Res Function(FoldingRangeParams) _then;

/// Create a copy of FoldingRangeParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of FoldingRangeParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _FoldingRangeParams implements FoldingRangeParams {
  const _FoldingRangeParams({required this.textDocument, this.partialResultToken, this.workDoneToken});
  factory _FoldingRangeParams.fromJson(Map<String, dynamic> json) => _$FoldingRangeParamsFromJson(json);

@override final  TextDocumentIdentifier textDocument;
@override final  ProgressToken? partialResultToken;
@override final  ProgressToken? workDoneToken;

/// Create a copy of FoldingRangeParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$FoldingRangeParamsCopyWith<_FoldingRangeParams> get copyWith => __$FoldingRangeParamsCopyWithImpl<_FoldingRangeParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$FoldingRangeParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _FoldingRangeParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'FoldingRangeParams(textDocument: $textDocument, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$FoldingRangeParamsCopyWith<$Res> implements $FoldingRangeParamsCopyWith<$Res> {
  factory _$FoldingRangeParamsCopyWith(_FoldingRangeParams value, $Res Function(_FoldingRangeParams) _then) = __$FoldingRangeParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$FoldingRangeParamsCopyWithImpl<$Res>
    implements _$FoldingRangeParamsCopyWith<$Res> {
  __$FoldingRangeParamsCopyWithImpl(this._self, this._then);

  final _FoldingRangeParams _self;
  final $Res Function(_FoldingRangeParams) _then;

/// Create a copy of FoldingRangeParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_FoldingRangeParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of FoldingRangeParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$FoldingRange {

 int get startLine; int get endLine; String? get collapsedText; FoldingRangeKind? get kind; int? get endCharacter; int? get startCharacter;
/// Create a copy of FoldingRange
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FoldingRangeCopyWith<FoldingRange> get copyWith => _$FoldingRangeCopyWithImpl<FoldingRange>(this as FoldingRange, _$identity);

  /// Serializes this FoldingRange to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FoldingRange&&(identical(other.startLine, startLine) || other.startLine == startLine)&&(identical(other.endLine, endLine) || other.endLine == endLine)&&(identical(other.collapsedText, collapsedText) || other.collapsedText == collapsedText)&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.endCharacter, endCharacter) || other.endCharacter == endCharacter)&&(identical(other.startCharacter, startCharacter) || other.startCharacter == startCharacter));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,startLine,endLine,collapsedText,kind,endCharacter,startCharacter);

@override
String toString() {
  return 'FoldingRange(startLine: $startLine, endLine: $endLine, collapsedText: $collapsedText, kind: $kind, endCharacter: $endCharacter, startCharacter: $startCharacter)';
}


}

/// @nodoc
abstract mixin class $FoldingRangeCopyWith<$Res>  {
  factory $FoldingRangeCopyWith(FoldingRange value, $Res Function(FoldingRange) _then) = _$FoldingRangeCopyWithImpl;
@useResult
$Res call({
 int startLine, int endLine, String? collapsedText, FoldingRangeKind? kind, int? endCharacter, int? startCharacter
});




}
/// @nodoc
class _$FoldingRangeCopyWithImpl<$Res>
    implements $FoldingRangeCopyWith<$Res> {
  _$FoldingRangeCopyWithImpl(this._self, this._then);

  final FoldingRange _self;
  final $Res Function(FoldingRange) _then;

/// Create a copy of FoldingRange
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? startLine = null,Object? endLine = null,Object? collapsedText = freezed,Object? kind = freezed,Object? endCharacter = freezed,Object? startCharacter = freezed,}) {
  return _then(_self.copyWith(
startLine: null == startLine ? _self.startLine : startLine // ignore: cast_nullable_to_non_nullable
as int,endLine: null == endLine ? _self.endLine : endLine // ignore: cast_nullable_to_non_nullable
as int,collapsedText: freezed == collapsedText ? _self.collapsedText : collapsedText // ignore: cast_nullable_to_non_nullable
as String?,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as FoldingRangeKind?,endCharacter: freezed == endCharacter ? _self.endCharacter : endCharacter // ignore: cast_nullable_to_non_nullable
as int?,startCharacter: freezed == startCharacter ? _self.startCharacter : startCharacter // ignore: cast_nullable_to_non_nullable
as int?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _FoldingRange implements FoldingRange {
  const _FoldingRange({required this.startLine, required this.endLine, this.collapsedText, this.kind, this.endCharacter, this.startCharacter});
  factory _FoldingRange.fromJson(Map<String, dynamic> json) => _$FoldingRangeFromJson(json);

@override final  int startLine;
@override final  int endLine;
@override final  String? collapsedText;
@override final  FoldingRangeKind? kind;
@override final  int? endCharacter;
@override final  int? startCharacter;

/// Create a copy of FoldingRange
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$FoldingRangeCopyWith<_FoldingRange> get copyWith => __$FoldingRangeCopyWithImpl<_FoldingRange>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$FoldingRangeToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _FoldingRange&&(identical(other.startLine, startLine) || other.startLine == startLine)&&(identical(other.endLine, endLine) || other.endLine == endLine)&&(identical(other.collapsedText, collapsedText) || other.collapsedText == collapsedText)&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.endCharacter, endCharacter) || other.endCharacter == endCharacter)&&(identical(other.startCharacter, startCharacter) || other.startCharacter == startCharacter));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,startLine,endLine,collapsedText,kind,endCharacter,startCharacter);

@override
String toString() {
  return 'FoldingRange(startLine: $startLine, endLine: $endLine, collapsedText: $collapsedText, kind: $kind, endCharacter: $endCharacter, startCharacter: $startCharacter)';
}


}

/// @nodoc
abstract mixin class _$FoldingRangeCopyWith<$Res> implements $FoldingRangeCopyWith<$Res> {
  factory _$FoldingRangeCopyWith(_FoldingRange value, $Res Function(_FoldingRange) _then) = __$FoldingRangeCopyWithImpl;
@override @useResult
$Res call({
 int startLine, int endLine, String? collapsedText, FoldingRangeKind? kind, int? endCharacter, int? startCharacter
});




}
/// @nodoc
class __$FoldingRangeCopyWithImpl<$Res>
    implements _$FoldingRangeCopyWith<$Res> {
  __$FoldingRangeCopyWithImpl(this._self, this._then);

  final _FoldingRange _self;
  final $Res Function(_FoldingRange) _then;

/// Create a copy of FoldingRange
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? startLine = null,Object? endLine = null,Object? collapsedText = freezed,Object? kind = freezed,Object? endCharacter = freezed,Object? startCharacter = freezed,}) {
  return _then(_FoldingRange(
startLine: null == startLine ? _self.startLine : startLine // ignore: cast_nullable_to_non_nullable
as int,endLine: null == endLine ? _self.endLine : endLine // ignore: cast_nullable_to_non_nullable
as int,collapsedText: freezed == collapsedText ? _self.collapsedText : collapsedText // ignore: cast_nullable_to_non_nullable
as String?,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as FoldingRangeKind?,endCharacter: freezed == endCharacter ? _self.endCharacter : endCharacter // ignore: cast_nullable_to_non_nullable
as int?,startCharacter: freezed == startCharacter ? _self.startCharacter : startCharacter // ignore: cast_nullable_to_non_nullable
as int?,
  ));
}


}


/// @nodoc
mixin _$FoldingRangeRegistrationOptions {

 dynamic get documentSelector; String? get id; bool? get workDoneProgress;
/// Create a copy of FoldingRangeRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FoldingRangeRegistrationOptionsCopyWith<FoldingRangeRegistrationOptions> get copyWith => _$FoldingRangeRegistrationOptionsCopyWithImpl<FoldingRangeRegistrationOptions>(this as FoldingRangeRegistrationOptions, _$identity);

  /// Serializes this FoldingRangeRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FoldingRangeRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.id, id) || other.id == id)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),id,workDoneProgress);

@override
String toString() {
  return 'FoldingRangeRegistrationOptions(documentSelector: $documentSelector, id: $id, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $FoldingRangeRegistrationOptionsCopyWith<$Res>  {
  factory $FoldingRangeRegistrationOptionsCopyWith(FoldingRangeRegistrationOptions value, $Res Function(FoldingRangeRegistrationOptions) _then) = _$FoldingRangeRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 dynamic documentSelector, String? id, bool? workDoneProgress
});




}
/// @nodoc
class _$FoldingRangeRegistrationOptionsCopyWithImpl<$Res>
    implements $FoldingRangeRegistrationOptionsCopyWith<$Res> {
  _$FoldingRangeRegistrationOptionsCopyWithImpl(this._self, this._then);

  final FoldingRangeRegistrationOptions _self;
  final $Res Function(FoldingRangeRegistrationOptions) _then;

/// Create a copy of FoldingRangeRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = freezed,Object? id = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _FoldingRangeRegistrationOptions implements FoldingRangeRegistrationOptions {
  const _FoldingRangeRegistrationOptions({required this.documentSelector, this.id, this.workDoneProgress});
  factory _FoldingRangeRegistrationOptions.fromJson(Map<String, dynamic> json) => _$FoldingRangeRegistrationOptionsFromJson(json);

@override final  dynamic documentSelector;
@override final  String? id;
@override final  bool? workDoneProgress;

/// Create a copy of FoldingRangeRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$FoldingRangeRegistrationOptionsCopyWith<_FoldingRangeRegistrationOptions> get copyWith => __$FoldingRangeRegistrationOptionsCopyWithImpl<_FoldingRangeRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$FoldingRangeRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _FoldingRangeRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.id, id) || other.id == id)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),id,workDoneProgress);

@override
String toString() {
  return 'FoldingRangeRegistrationOptions(documentSelector: $documentSelector, id: $id, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$FoldingRangeRegistrationOptionsCopyWith<$Res> implements $FoldingRangeRegistrationOptionsCopyWith<$Res> {
  factory _$FoldingRangeRegistrationOptionsCopyWith(_FoldingRangeRegistrationOptions value, $Res Function(_FoldingRangeRegistrationOptions) _then) = __$FoldingRangeRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 dynamic documentSelector, String? id, bool? workDoneProgress
});




}
/// @nodoc
class __$FoldingRangeRegistrationOptionsCopyWithImpl<$Res>
    implements _$FoldingRangeRegistrationOptionsCopyWith<$Res> {
  __$FoldingRangeRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _FoldingRangeRegistrationOptions _self;
  final $Res Function(_FoldingRangeRegistrationOptions) _then;

/// Create a copy of FoldingRangeRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = freezed,Object? id = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_FoldingRangeRegistrationOptions(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DeclarationParams {

 TextDocumentIdentifier get textDocument; Position get position; ProgressToken? get partialResultToken; ProgressToken? get workDoneToken;
/// Create a copy of DeclarationParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DeclarationParamsCopyWith<DeclarationParams> get copyWith => _$DeclarationParamsCopyWithImpl<DeclarationParams>(this as DeclarationParams, _$identity);

  /// Serializes this DeclarationParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DeclarationParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.position, position) || other.position == position)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,position,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'DeclarationParams(textDocument: $textDocument, position: $position, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $DeclarationParamsCopyWith<$Res>  {
  factory $DeclarationParamsCopyWith(DeclarationParams value, $Res Function(DeclarationParams) _then) = _$DeclarationParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument, Position position, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;$PositionCopyWith<$Res> get position;

}
/// @nodoc
class _$DeclarationParamsCopyWithImpl<$Res>
    implements $DeclarationParamsCopyWith<$Res> {
  _$DeclarationParamsCopyWithImpl(this._self, this._then);

  final DeclarationParams _self;
  final $Res Function(DeclarationParams) _then;

/// Create a copy of DeclarationParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? position = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of DeclarationParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of DeclarationParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DeclarationParams implements DeclarationParams {
  const _DeclarationParams({required this.textDocument, required this.position, this.partialResultToken, this.workDoneToken});
  factory _DeclarationParams.fromJson(Map<String, dynamic> json) => _$DeclarationParamsFromJson(json);

@override final  TextDocumentIdentifier textDocument;
@override final  Position position;
@override final  ProgressToken? partialResultToken;
@override final  ProgressToken? workDoneToken;

/// Create a copy of DeclarationParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DeclarationParamsCopyWith<_DeclarationParams> get copyWith => __$DeclarationParamsCopyWithImpl<_DeclarationParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DeclarationParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DeclarationParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.position, position) || other.position == position)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,position,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'DeclarationParams(textDocument: $textDocument, position: $position, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$DeclarationParamsCopyWith<$Res> implements $DeclarationParamsCopyWith<$Res> {
  factory _$DeclarationParamsCopyWith(_DeclarationParams value, $Res Function(_DeclarationParams) _then) = __$DeclarationParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument, Position position, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;@override $PositionCopyWith<$Res> get position;

}
/// @nodoc
class __$DeclarationParamsCopyWithImpl<$Res>
    implements _$DeclarationParamsCopyWith<$Res> {
  __$DeclarationParamsCopyWithImpl(this._self, this._then);

  final _DeclarationParams _self;
  final $Res Function(_DeclarationParams) _then;

/// Create a copy of DeclarationParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? position = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_DeclarationParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of DeclarationParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of DeclarationParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}
}


/// @nodoc
mixin _$DeclarationRegistrationOptions {

 dynamic get documentSelector; String? get id; bool? get workDoneProgress;
/// Create a copy of DeclarationRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DeclarationRegistrationOptionsCopyWith<DeclarationRegistrationOptions> get copyWith => _$DeclarationRegistrationOptionsCopyWithImpl<DeclarationRegistrationOptions>(this as DeclarationRegistrationOptions, _$identity);

  /// Serializes this DeclarationRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DeclarationRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.id, id) || other.id == id)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),id,workDoneProgress);

@override
String toString() {
  return 'DeclarationRegistrationOptions(documentSelector: $documentSelector, id: $id, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $DeclarationRegistrationOptionsCopyWith<$Res>  {
  factory $DeclarationRegistrationOptionsCopyWith(DeclarationRegistrationOptions value, $Res Function(DeclarationRegistrationOptions) _then) = _$DeclarationRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 dynamic documentSelector, String? id, bool? workDoneProgress
});




}
/// @nodoc
class _$DeclarationRegistrationOptionsCopyWithImpl<$Res>
    implements $DeclarationRegistrationOptionsCopyWith<$Res> {
  _$DeclarationRegistrationOptionsCopyWithImpl(this._self, this._then);

  final DeclarationRegistrationOptions _self;
  final $Res Function(DeclarationRegistrationOptions) _then;

/// Create a copy of DeclarationRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = freezed,Object? id = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DeclarationRegistrationOptions implements DeclarationRegistrationOptions {
  const _DeclarationRegistrationOptions({required this.documentSelector, this.id, this.workDoneProgress});
  factory _DeclarationRegistrationOptions.fromJson(Map<String, dynamic> json) => _$DeclarationRegistrationOptionsFromJson(json);

@override final  dynamic documentSelector;
@override final  String? id;
@override final  bool? workDoneProgress;

/// Create a copy of DeclarationRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DeclarationRegistrationOptionsCopyWith<_DeclarationRegistrationOptions> get copyWith => __$DeclarationRegistrationOptionsCopyWithImpl<_DeclarationRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DeclarationRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DeclarationRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.id, id) || other.id == id)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),id,workDoneProgress);

@override
String toString() {
  return 'DeclarationRegistrationOptions(documentSelector: $documentSelector, id: $id, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$DeclarationRegistrationOptionsCopyWith<$Res> implements $DeclarationRegistrationOptionsCopyWith<$Res> {
  factory _$DeclarationRegistrationOptionsCopyWith(_DeclarationRegistrationOptions value, $Res Function(_DeclarationRegistrationOptions) _then) = __$DeclarationRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 dynamic documentSelector, String? id, bool? workDoneProgress
});




}
/// @nodoc
class __$DeclarationRegistrationOptionsCopyWithImpl<$Res>
    implements _$DeclarationRegistrationOptionsCopyWith<$Res> {
  __$DeclarationRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _DeclarationRegistrationOptions _self;
  final $Res Function(_DeclarationRegistrationOptions) _then;

/// Create a copy of DeclarationRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = freezed,Object? id = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_DeclarationRegistrationOptions(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$SelectionRangeParams {

 TextDocumentIdentifier get textDocument; List<Position> get positions; ProgressToken? get partialResultToken; ProgressToken? get workDoneToken;
/// Create a copy of SelectionRangeParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SelectionRangeParamsCopyWith<SelectionRangeParams> get copyWith => _$SelectionRangeParamsCopyWithImpl<SelectionRangeParams>(this as SelectionRangeParams, _$identity);

  /// Serializes this SelectionRangeParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SelectionRangeParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&const DeepCollectionEquality().equals(other.positions, positions)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,const DeepCollectionEquality().hash(positions),const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'SelectionRangeParams(textDocument: $textDocument, positions: $positions, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $SelectionRangeParamsCopyWith<$Res>  {
  factory $SelectionRangeParamsCopyWith(SelectionRangeParams value, $Res Function(SelectionRangeParams) _then) = _$SelectionRangeParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument, List<Position> positions, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$SelectionRangeParamsCopyWithImpl<$Res>
    implements $SelectionRangeParamsCopyWith<$Res> {
  _$SelectionRangeParamsCopyWithImpl(this._self, this._then);

  final SelectionRangeParams _self;
  final $Res Function(SelectionRangeParams) _then;

/// Create a copy of SelectionRangeParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? positions = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,positions: null == positions ? _self.positions : positions // ignore: cast_nullable_to_non_nullable
as List<Position>,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of SelectionRangeParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _SelectionRangeParams implements SelectionRangeParams {
  const _SelectionRangeParams({required this.textDocument, required final  List<Position> positions, this.partialResultToken, this.workDoneToken}): _positions = positions;
  factory _SelectionRangeParams.fromJson(Map<String, dynamic> json) => _$SelectionRangeParamsFromJson(json);

@override final  TextDocumentIdentifier textDocument;
 final  List<Position> _positions;
@override List<Position> get positions {
  if (_positions is EqualUnmodifiableListView) return _positions;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_positions);
}

@override final  ProgressToken? partialResultToken;
@override final  ProgressToken? workDoneToken;

/// Create a copy of SelectionRangeParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SelectionRangeParamsCopyWith<_SelectionRangeParams> get copyWith => __$SelectionRangeParamsCopyWithImpl<_SelectionRangeParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SelectionRangeParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SelectionRangeParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&const DeepCollectionEquality().equals(other._positions, _positions)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,const DeepCollectionEquality().hash(_positions),const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'SelectionRangeParams(textDocument: $textDocument, positions: $positions, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$SelectionRangeParamsCopyWith<$Res> implements $SelectionRangeParamsCopyWith<$Res> {
  factory _$SelectionRangeParamsCopyWith(_SelectionRangeParams value, $Res Function(_SelectionRangeParams) _then) = __$SelectionRangeParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument, List<Position> positions, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$SelectionRangeParamsCopyWithImpl<$Res>
    implements _$SelectionRangeParamsCopyWith<$Res> {
  __$SelectionRangeParamsCopyWithImpl(this._self, this._then);

  final _SelectionRangeParams _self;
  final $Res Function(_SelectionRangeParams) _then;

/// Create a copy of SelectionRangeParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? positions = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_SelectionRangeParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,positions: null == positions ? _self._positions : positions // ignore: cast_nullable_to_non_nullable
as List<Position>,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of SelectionRangeParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$SelectionRange {

 Range get range; SelectionRange? get parent;
/// Create a copy of SelectionRange
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SelectionRangeCopyWith<SelectionRange> get copyWith => _$SelectionRangeCopyWithImpl<SelectionRange>(this as SelectionRange, _$identity);

  /// Serializes this SelectionRange to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SelectionRange&&(identical(other.range, range) || other.range == range)&&(identical(other.parent, parent) || other.parent == parent));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,range,parent);

@override
String toString() {
  return 'SelectionRange(range: $range, parent: $parent)';
}


}

/// @nodoc
abstract mixin class $SelectionRangeCopyWith<$Res>  {
  factory $SelectionRangeCopyWith(SelectionRange value, $Res Function(SelectionRange) _then) = _$SelectionRangeCopyWithImpl;
@useResult
$Res call({
 Range range, SelectionRange? parent
});


$RangeCopyWith<$Res> get range;$SelectionRangeCopyWith<$Res>? get parent;

}
/// @nodoc
class _$SelectionRangeCopyWithImpl<$Res>
    implements $SelectionRangeCopyWith<$Res> {
  _$SelectionRangeCopyWithImpl(this._self, this._then);

  final SelectionRange _self;
  final $Res Function(SelectionRange) _then;

/// Create a copy of SelectionRange
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? range = null,Object? parent = freezed,}) {
  return _then(_self.copyWith(
range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,parent: freezed == parent ? _self.parent : parent // ignore: cast_nullable_to_non_nullable
as SelectionRange?,
  ));
}
/// Create a copy of SelectionRange
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}/// Create a copy of SelectionRange
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SelectionRangeCopyWith<$Res>? get parent {
    if (_self.parent == null) {
    return null;
  }

  return $SelectionRangeCopyWith<$Res>(_self.parent!, (value) {
    return _then(_self.copyWith(parent: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _SelectionRange implements SelectionRange {
  const _SelectionRange({required this.range, this.parent});
  factory _SelectionRange.fromJson(Map<String, dynamic> json) => _$SelectionRangeFromJson(json);

@override final  Range range;
@override final  SelectionRange? parent;

/// Create a copy of SelectionRange
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SelectionRangeCopyWith<_SelectionRange> get copyWith => __$SelectionRangeCopyWithImpl<_SelectionRange>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SelectionRangeToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SelectionRange&&(identical(other.range, range) || other.range == range)&&(identical(other.parent, parent) || other.parent == parent));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,range,parent);

@override
String toString() {
  return 'SelectionRange(range: $range, parent: $parent)';
}


}

/// @nodoc
abstract mixin class _$SelectionRangeCopyWith<$Res> implements $SelectionRangeCopyWith<$Res> {
  factory _$SelectionRangeCopyWith(_SelectionRange value, $Res Function(_SelectionRange) _then) = __$SelectionRangeCopyWithImpl;
@override @useResult
$Res call({
 Range range, SelectionRange? parent
});


@override $RangeCopyWith<$Res> get range;@override $SelectionRangeCopyWith<$Res>? get parent;

}
/// @nodoc
class __$SelectionRangeCopyWithImpl<$Res>
    implements _$SelectionRangeCopyWith<$Res> {
  __$SelectionRangeCopyWithImpl(this._self, this._then);

  final _SelectionRange _self;
  final $Res Function(_SelectionRange) _then;

/// Create a copy of SelectionRange
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? range = null,Object? parent = freezed,}) {
  return _then(_SelectionRange(
range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,parent: freezed == parent ? _self.parent : parent // ignore: cast_nullable_to_non_nullable
as SelectionRange?,
  ));
}

/// Create a copy of SelectionRange
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}/// Create a copy of SelectionRange
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SelectionRangeCopyWith<$Res>? get parent {
    if (_self.parent == null) {
    return null;
  }

  return $SelectionRangeCopyWith<$Res>(_self.parent!, (value) {
    return _then(_self.copyWith(parent: value));
  });
}
}


/// @nodoc
mixin _$SelectionRangeRegistrationOptions {

 dynamic get documentSelector; String? get id; bool? get workDoneProgress;
/// Create a copy of SelectionRangeRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SelectionRangeRegistrationOptionsCopyWith<SelectionRangeRegistrationOptions> get copyWith => _$SelectionRangeRegistrationOptionsCopyWithImpl<SelectionRangeRegistrationOptions>(this as SelectionRangeRegistrationOptions, _$identity);

  /// Serializes this SelectionRangeRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SelectionRangeRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.id, id) || other.id == id)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),id,workDoneProgress);

@override
String toString() {
  return 'SelectionRangeRegistrationOptions(documentSelector: $documentSelector, id: $id, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $SelectionRangeRegistrationOptionsCopyWith<$Res>  {
  factory $SelectionRangeRegistrationOptionsCopyWith(SelectionRangeRegistrationOptions value, $Res Function(SelectionRangeRegistrationOptions) _then) = _$SelectionRangeRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 dynamic documentSelector, String? id, bool? workDoneProgress
});




}
/// @nodoc
class _$SelectionRangeRegistrationOptionsCopyWithImpl<$Res>
    implements $SelectionRangeRegistrationOptionsCopyWith<$Res> {
  _$SelectionRangeRegistrationOptionsCopyWithImpl(this._self, this._then);

  final SelectionRangeRegistrationOptions _self;
  final $Res Function(SelectionRangeRegistrationOptions) _then;

/// Create a copy of SelectionRangeRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = freezed,Object? id = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _SelectionRangeRegistrationOptions implements SelectionRangeRegistrationOptions {
  const _SelectionRangeRegistrationOptions({required this.documentSelector, this.id, this.workDoneProgress});
  factory _SelectionRangeRegistrationOptions.fromJson(Map<String, dynamic> json) => _$SelectionRangeRegistrationOptionsFromJson(json);

@override final  dynamic documentSelector;
@override final  String? id;
@override final  bool? workDoneProgress;

/// Create a copy of SelectionRangeRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SelectionRangeRegistrationOptionsCopyWith<_SelectionRangeRegistrationOptions> get copyWith => __$SelectionRangeRegistrationOptionsCopyWithImpl<_SelectionRangeRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SelectionRangeRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SelectionRangeRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.id, id) || other.id == id)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),id,workDoneProgress);

@override
String toString() {
  return 'SelectionRangeRegistrationOptions(documentSelector: $documentSelector, id: $id, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$SelectionRangeRegistrationOptionsCopyWith<$Res> implements $SelectionRangeRegistrationOptionsCopyWith<$Res> {
  factory _$SelectionRangeRegistrationOptionsCopyWith(_SelectionRangeRegistrationOptions value, $Res Function(_SelectionRangeRegistrationOptions) _then) = __$SelectionRangeRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 dynamic documentSelector, String? id, bool? workDoneProgress
});




}
/// @nodoc
class __$SelectionRangeRegistrationOptionsCopyWithImpl<$Res>
    implements _$SelectionRangeRegistrationOptionsCopyWith<$Res> {
  __$SelectionRangeRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _SelectionRangeRegistrationOptions _self;
  final $Res Function(_SelectionRangeRegistrationOptions) _then;

/// Create a copy of SelectionRangeRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = freezed,Object? id = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_SelectionRangeRegistrationOptions(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$WorkDoneProgressCreateParams {

 ProgressToken get token;
/// Create a copy of WorkDoneProgressCreateParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkDoneProgressCreateParamsCopyWith<WorkDoneProgressCreateParams> get copyWith => _$WorkDoneProgressCreateParamsCopyWithImpl<WorkDoneProgressCreateParams>(this as WorkDoneProgressCreateParams, _$identity);

  /// Serializes this WorkDoneProgressCreateParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkDoneProgressCreateParams&&const DeepCollectionEquality().equals(other.token, token));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(token));

@override
String toString() {
  return 'WorkDoneProgressCreateParams(token: $token)';
}


}

/// @nodoc
abstract mixin class $WorkDoneProgressCreateParamsCopyWith<$Res>  {
  factory $WorkDoneProgressCreateParamsCopyWith(WorkDoneProgressCreateParams value, $Res Function(WorkDoneProgressCreateParams) _then) = _$WorkDoneProgressCreateParamsCopyWithImpl;
@useResult
$Res call({
 ProgressToken token
});




}
/// @nodoc
class _$WorkDoneProgressCreateParamsCopyWithImpl<$Res>
    implements $WorkDoneProgressCreateParamsCopyWith<$Res> {
  _$WorkDoneProgressCreateParamsCopyWithImpl(this._self, this._then);

  final WorkDoneProgressCreateParams _self;
  final $Res Function(WorkDoneProgressCreateParams) _then;

/// Create a copy of WorkDoneProgressCreateParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? token = freezed,}) {
  return _then(_self.copyWith(
token: freezed == token ? _self.token : token // ignore: cast_nullable_to_non_nullable
as ProgressToken,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _WorkDoneProgressCreateParams implements WorkDoneProgressCreateParams {
  const _WorkDoneProgressCreateParams({required this.token});
  factory _WorkDoneProgressCreateParams.fromJson(Map<String, dynamic> json) => _$WorkDoneProgressCreateParamsFromJson(json);

@override final  ProgressToken token;

/// Create a copy of WorkDoneProgressCreateParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkDoneProgressCreateParamsCopyWith<_WorkDoneProgressCreateParams> get copyWith => __$WorkDoneProgressCreateParamsCopyWithImpl<_WorkDoneProgressCreateParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkDoneProgressCreateParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkDoneProgressCreateParams&&const DeepCollectionEquality().equals(other.token, token));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(token));

@override
String toString() {
  return 'WorkDoneProgressCreateParams(token: $token)';
}


}

/// @nodoc
abstract mixin class _$WorkDoneProgressCreateParamsCopyWith<$Res> implements $WorkDoneProgressCreateParamsCopyWith<$Res> {
  factory _$WorkDoneProgressCreateParamsCopyWith(_WorkDoneProgressCreateParams value, $Res Function(_WorkDoneProgressCreateParams) _then) = __$WorkDoneProgressCreateParamsCopyWithImpl;
@override @useResult
$Res call({
 ProgressToken token
});




}
/// @nodoc
class __$WorkDoneProgressCreateParamsCopyWithImpl<$Res>
    implements _$WorkDoneProgressCreateParamsCopyWith<$Res> {
  __$WorkDoneProgressCreateParamsCopyWithImpl(this._self, this._then);

  final _WorkDoneProgressCreateParams _self;
  final $Res Function(_WorkDoneProgressCreateParams) _then;

/// Create a copy of WorkDoneProgressCreateParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? token = freezed,}) {
  return _then(_WorkDoneProgressCreateParams(
token: freezed == token ? _self.token : token // ignore: cast_nullable_to_non_nullable
as ProgressToken,
  ));
}


}


/// @nodoc
mixin _$WorkDoneProgressCancelParams {

 ProgressToken get token;
/// Create a copy of WorkDoneProgressCancelParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkDoneProgressCancelParamsCopyWith<WorkDoneProgressCancelParams> get copyWith => _$WorkDoneProgressCancelParamsCopyWithImpl<WorkDoneProgressCancelParams>(this as WorkDoneProgressCancelParams, _$identity);

  /// Serializes this WorkDoneProgressCancelParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkDoneProgressCancelParams&&const DeepCollectionEquality().equals(other.token, token));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(token));

@override
String toString() {
  return 'WorkDoneProgressCancelParams(token: $token)';
}


}

/// @nodoc
abstract mixin class $WorkDoneProgressCancelParamsCopyWith<$Res>  {
  factory $WorkDoneProgressCancelParamsCopyWith(WorkDoneProgressCancelParams value, $Res Function(WorkDoneProgressCancelParams) _then) = _$WorkDoneProgressCancelParamsCopyWithImpl;
@useResult
$Res call({
 ProgressToken token
});




}
/// @nodoc
class _$WorkDoneProgressCancelParamsCopyWithImpl<$Res>
    implements $WorkDoneProgressCancelParamsCopyWith<$Res> {
  _$WorkDoneProgressCancelParamsCopyWithImpl(this._self, this._then);

  final WorkDoneProgressCancelParams _self;
  final $Res Function(WorkDoneProgressCancelParams) _then;

/// Create a copy of WorkDoneProgressCancelParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? token = freezed,}) {
  return _then(_self.copyWith(
token: freezed == token ? _self.token : token // ignore: cast_nullable_to_non_nullable
as ProgressToken,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _WorkDoneProgressCancelParams implements WorkDoneProgressCancelParams {
  const _WorkDoneProgressCancelParams({required this.token});
  factory _WorkDoneProgressCancelParams.fromJson(Map<String, dynamic> json) => _$WorkDoneProgressCancelParamsFromJson(json);

@override final  ProgressToken token;

/// Create a copy of WorkDoneProgressCancelParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkDoneProgressCancelParamsCopyWith<_WorkDoneProgressCancelParams> get copyWith => __$WorkDoneProgressCancelParamsCopyWithImpl<_WorkDoneProgressCancelParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkDoneProgressCancelParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkDoneProgressCancelParams&&const DeepCollectionEquality().equals(other.token, token));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(token));

@override
String toString() {
  return 'WorkDoneProgressCancelParams(token: $token)';
}


}

/// @nodoc
abstract mixin class _$WorkDoneProgressCancelParamsCopyWith<$Res> implements $WorkDoneProgressCancelParamsCopyWith<$Res> {
  factory _$WorkDoneProgressCancelParamsCopyWith(_WorkDoneProgressCancelParams value, $Res Function(_WorkDoneProgressCancelParams) _then) = __$WorkDoneProgressCancelParamsCopyWithImpl;
@override @useResult
$Res call({
 ProgressToken token
});




}
/// @nodoc
class __$WorkDoneProgressCancelParamsCopyWithImpl<$Res>
    implements _$WorkDoneProgressCancelParamsCopyWith<$Res> {
  __$WorkDoneProgressCancelParamsCopyWithImpl(this._self, this._then);

  final _WorkDoneProgressCancelParams _self;
  final $Res Function(_WorkDoneProgressCancelParams) _then;

/// Create a copy of WorkDoneProgressCancelParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? token = freezed,}) {
  return _then(_WorkDoneProgressCancelParams(
token: freezed == token ? _self.token : token // ignore: cast_nullable_to_non_nullable
as ProgressToken,
  ));
}


}


/// @nodoc
mixin _$CallHierarchyPrepareParams {

 TextDocumentIdentifier get textDocument; Position get position; ProgressToken? get workDoneToken;
/// Create a copy of CallHierarchyPrepareParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CallHierarchyPrepareParamsCopyWith<CallHierarchyPrepareParams> get copyWith => _$CallHierarchyPrepareParamsCopyWithImpl<CallHierarchyPrepareParams>(this as CallHierarchyPrepareParams, _$identity);

  /// Serializes this CallHierarchyPrepareParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CallHierarchyPrepareParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.position, position) || other.position == position)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,position,const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'CallHierarchyPrepareParams(textDocument: $textDocument, position: $position, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $CallHierarchyPrepareParamsCopyWith<$Res>  {
  factory $CallHierarchyPrepareParamsCopyWith(CallHierarchyPrepareParams value, $Res Function(CallHierarchyPrepareParams) _then) = _$CallHierarchyPrepareParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument, Position position, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;$PositionCopyWith<$Res> get position;

}
/// @nodoc
class _$CallHierarchyPrepareParamsCopyWithImpl<$Res>
    implements $CallHierarchyPrepareParamsCopyWith<$Res> {
  _$CallHierarchyPrepareParamsCopyWithImpl(this._self, this._then);

  final CallHierarchyPrepareParams _self;
  final $Res Function(CallHierarchyPrepareParams) _then;

/// Create a copy of CallHierarchyPrepareParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? position = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of CallHierarchyPrepareParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of CallHierarchyPrepareParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _CallHierarchyPrepareParams implements CallHierarchyPrepareParams {
  const _CallHierarchyPrepareParams({required this.textDocument, required this.position, this.workDoneToken});
  factory _CallHierarchyPrepareParams.fromJson(Map<String, dynamic> json) => _$CallHierarchyPrepareParamsFromJson(json);

@override final  TextDocumentIdentifier textDocument;
@override final  Position position;
@override final  ProgressToken? workDoneToken;

/// Create a copy of CallHierarchyPrepareParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CallHierarchyPrepareParamsCopyWith<_CallHierarchyPrepareParams> get copyWith => __$CallHierarchyPrepareParamsCopyWithImpl<_CallHierarchyPrepareParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CallHierarchyPrepareParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CallHierarchyPrepareParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.position, position) || other.position == position)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,position,const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'CallHierarchyPrepareParams(textDocument: $textDocument, position: $position, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$CallHierarchyPrepareParamsCopyWith<$Res> implements $CallHierarchyPrepareParamsCopyWith<$Res> {
  factory _$CallHierarchyPrepareParamsCopyWith(_CallHierarchyPrepareParams value, $Res Function(_CallHierarchyPrepareParams) _then) = __$CallHierarchyPrepareParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument, Position position, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;@override $PositionCopyWith<$Res> get position;

}
/// @nodoc
class __$CallHierarchyPrepareParamsCopyWithImpl<$Res>
    implements _$CallHierarchyPrepareParamsCopyWith<$Res> {
  __$CallHierarchyPrepareParamsCopyWithImpl(this._self, this._then);

  final _CallHierarchyPrepareParams _self;
  final $Res Function(_CallHierarchyPrepareParams) _then;

/// Create a copy of CallHierarchyPrepareParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? position = null,Object? workDoneToken = freezed,}) {
  return _then(_CallHierarchyPrepareParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of CallHierarchyPrepareParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of CallHierarchyPrepareParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}
}


/// @nodoc
mixin _$CallHierarchyItem {

 String get name; SymbolKind get kind; String get uri; Range get range; Range get selectionRange; LSPAny? get data; String? get detail; List<SymbolTag>? get tags;
/// Create a copy of CallHierarchyItem
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CallHierarchyItemCopyWith<CallHierarchyItem> get copyWith => _$CallHierarchyItemCopyWithImpl<CallHierarchyItem>(this as CallHierarchyItem, _$identity);

  /// Serializes this CallHierarchyItem to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CallHierarchyItem&&(identical(other.name, name) || other.name == name)&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.range, range) || other.range == range)&&(identical(other.selectionRange, selectionRange) || other.selectionRange == selectionRange)&&const DeepCollectionEquality().equals(other.data, data)&&(identical(other.detail, detail) || other.detail == detail)&&const DeepCollectionEquality().equals(other.tags, tags));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,name,kind,uri,range,selectionRange,const DeepCollectionEquality().hash(data),detail,const DeepCollectionEquality().hash(tags));

@override
String toString() {
  return 'CallHierarchyItem(name: $name, kind: $kind, uri: $uri, range: $range, selectionRange: $selectionRange, data: $data, detail: $detail, tags: $tags)';
}


}

/// @nodoc
abstract mixin class $CallHierarchyItemCopyWith<$Res>  {
  factory $CallHierarchyItemCopyWith(CallHierarchyItem value, $Res Function(CallHierarchyItem) _then) = _$CallHierarchyItemCopyWithImpl;
@useResult
$Res call({
 String name, SymbolKind kind, String uri, Range range, Range selectionRange, LSPAny? data, String? detail, List<SymbolTag>? tags
});


$RangeCopyWith<$Res> get range;$RangeCopyWith<$Res> get selectionRange;

}
/// @nodoc
class _$CallHierarchyItemCopyWithImpl<$Res>
    implements $CallHierarchyItemCopyWith<$Res> {
  _$CallHierarchyItemCopyWithImpl(this._self, this._then);

  final CallHierarchyItem _self;
  final $Res Function(CallHierarchyItem) _then;

/// Create a copy of CallHierarchyItem
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? name = null,Object? kind = null,Object? uri = null,Object? range = null,Object? selectionRange = null,Object? data = freezed,Object? detail = freezed,Object? tags = freezed,}) {
  return _then(_self.copyWith(
name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as SymbolKind,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,selectionRange: null == selectionRange ? _self.selectionRange : selectionRange // ignore: cast_nullable_to_non_nullable
as Range,data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LSPAny?,detail: freezed == detail ? _self.detail : detail // ignore: cast_nullable_to_non_nullable
as String?,tags: freezed == tags ? _self.tags : tags // ignore: cast_nullable_to_non_nullable
as List<SymbolTag>?,
  ));
}
/// Create a copy of CallHierarchyItem
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}/// Create a copy of CallHierarchyItem
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get selectionRange {
  
  return $RangeCopyWith<$Res>(_self.selectionRange, (value) {
    return _then(_self.copyWith(selectionRange: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _CallHierarchyItem implements CallHierarchyItem {
  const _CallHierarchyItem({required this.name, required this.kind, required this.uri, required this.range, required this.selectionRange, this.data, this.detail, final  List<SymbolTag>? tags}): _tags = tags;
  factory _CallHierarchyItem.fromJson(Map<String, dynamic> json) => _$CallHierarchyItemFromJson(json);

@override final  String name;
@override final  SymbolKind kind;
@override final  String uri;
@override final  Range range;
@override final  Range selectionRange;
@override final  LSPAny? data;
@override final  String? detail;
 final  List<SymbolTag>? _tags;
@override List<SymbolTag>? get tags {
  final value = _tags;
  if (value == null) return null;
  if (_tags is EqualUnmodifiableListView) return _tags;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}


/// Create a copy of CallHierarchyItem
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CallHierarchyItemCopyWith<_CallHierarchyItem> get copyWith => __$CallHierarchyItemCopyWithImpl<_CallHierarchyItem>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CallHierarchyItemToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CallHierarchyItem&&(identical(other.name, name) || other.name == name)&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.range, range) || other.range == range)&&(identical(other.selectionRange, selectionRange) || other.selectionRange == selectionRange)&&const DeepCollectionEquality().equals(other.data, data)&&(identical(other.detail, detail) || other.detail == detail)&&const DeepCollectionEquality().equals(other._tags, _tags));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,name,kind,uri,range,selectionRange,const DeepCollectionEquality().hash(data),detail,const DeepCollectionEquality().hash(_tags));

@override
String toString() {
  return 'CallHierarchyItem(name: $name, kind: $kind, uri: $uri, range: $range, selectionRange: $selectionRange, data: $data, detail: $detail, tags: $tags)';
}


}

/// @nodoc
abstract mixin class _$CallHierarchyItemCopyWith<$Res> implements $CallHierarchyItemCopyWith<$Res> {
  factory _$CallHierarchyItemCopyWith(_CallHierarchyItem value, $Res Function(_CallHierarchyItem) _then) = __$CallHierarchyItemCopyWithImpl;
@override @useResult
$Res call({
 String name, SymbolKind kind, String uri, Range range, Range selectionRange, LSPAny? data, String? detail, List<SymbolTag>? tags
});


@override $RangeCopyWith<$Res> get range;@override $RangeCopyWith<$Res> get selectionRange;

}
/// @nodoc
class __$CallHierarchyItemCopyWithImpl<$Res>
    implements _$CallHierarchyItemCopyWith<$Res> {
  __$CallHierarchyItemCopyWithImpl(this._self, this._then);

  final _CallHierarchyItem _self;
  final $Res Function(_CallHierarchyItem) _then;

/// Create a copy of CallHierarchyItem
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? name = null,Object? kind = null,Object? uri = null,Object? range = null,Object? selectionRange = null,Object? data = freezed,Object? detail = freezed,Object? tags = freezed,}) {
  return _then(_CallHierarchyItem(
name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as SymbolKind,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,selectionRange: null == selectionRange ? _self.selectionRange : selectionRange // ignore: cast_nullable_to_non_nullable
as Range,data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LSPAny?,detail: freezed == detail ? _self.detail : detail // ignore: cast_nullable_to_non_nullable
as String?,tags: freezed == tags ? _self._tags : tags // ignore: cast_nullable_to_non_nullable
as List<SymbolTag>?,
  ));
}

/// Create a copy of CallHierarchyItem
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}/// Create a copy of CallHierarchyItem
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get selectionRange {
  
  return $RangeCopyWith<$Res>(_self.selectionRange, (value) {
    return _then(_self.copyWith(selectionRange: value));
  });
}
}


/// @nodoc
mixin _$CallHierarchyRegistrationOptions {

 dynamic get documentSelector; String? get id; bool? get workDoneProgress;
/// Create a copy of CallHierarchyRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CallHierarchyRegistrationOptionsCopyWith<CallHierarchyRegistrationOptions> get copyWith => _$CallHierarchyRegistrationOptionsCopyWithImpl<CallHierarchyRegistrationOptions>(this as CallHierarchyRegistrationOptions, _$identity);

  /// Serializes this CallHierarchyRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CallHierarchyRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.id, id) || other.id == id)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),id,workDoneProgress);

@override
String toString() {
  return 'CallHierarchyRegistrationOptions(documentSelector: $documentSelector, id: $id, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $CallHierarchyRegistrationOptionsCopyWith<$Res>  {
  factory $CallHierarchyRegistrationOptionsCopyWith(CallHierarchyRegistrationOptions value, $Res Function(CallHierarchyRegistrationOptions) _then) = _$CallHierarchyRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 dynamic documentSelector, String? id, bool? workDoneProgress
});




}
/// @nodoc
class _$CallHierarchyRegistrationOptionsCopyWithImpl<$Res>
    implements $CallHierarchyRegistrationOptionsCopyWith<$Res> {
  _$CallHierarchyRegistrationOptionsCopyWithImpl(this._self, this._then);

  final CallHierarchyRegistrationOptions _self;
  final $Res Function(CallHierarchyRegistrationOptions) _then;

/// Create a copy of CallHierarchyRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = freezed,Object? id = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _CallHierarchyRegistrationOptions implements CallHierarchyRegistrationOptions {
  const _CallHierarchyRegistrationOptions({required this.documentSelector, this.id, this.workDoneProgress});
  factory _CallHierarchyRegistrationOptions.fromJson(Map<String, dynamic> json) => _$CallHierarchyRegistrationOptionsFromJson(json);

@override final  dynamic documentSelector;
@override final  String? id;
@override final  bool? workDoneProgress;

/// Create a copy of CallHierarchyRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CallHierarchyRegistrationOptionsCopyWith<_CallHierarchyRegistrationOptions> get copyWith => __$CallHierarchyRegistrationOptionsCopyWithImpl<_CallHierarchyRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CallHierarchyRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CallHierarchyRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.id, id) || other.id == id)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),id,workDoneProgress);

@override
String toString() {
  return 'CallHierarchyRegistrationOptions(documentSelector: $documentSelector, id: $id, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$CallHierarchyRegistrationOptionsCopyWith<$Res> implements $CallHierarchyRegistrationOptionsCopyWith<$Res> {
  factory _$CallHierarchyRegistrationOptionsCopyWith(_CallHierarchyRegistrationOptions value, $Res Function(_CallHierarchyRegistrationOptions) _then) = __$CallHierarchyRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 dynamic documentSelector, String? id, bool? workDoneProgress
});




}
/// @nodoc
class __$CallHierarchyRegistrationOptionsCopyWithImpl<$Res>
    implements _$CallHierarchyRegistrationOptionsCopyWith<$Res> {
  __$CallHierarchyRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _CallHierarchyRegistrationOptions _self;
  final $Res Function(_CallHierarchyRegistrationOptions) _then;

/// Create a copy of CallHierarchyRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = freezed,Object? id = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_CallHierarchyRegistrationOptions(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$CallHierarchyIncomingCallsParams {

 CallHierarchyItem get item; ProgressToken? get partialResultToken; ProgressToken? get workDoneToken;
/// Create a copy of CallHierarchyIncomingCallsParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CallHierarchyIncomingCallsParamsCopyWith<CallHierarchyIncomingCallsParams> get copyWith => _$CallHierarchyIncomingCallsParamsCopyWithImpl<CallHierarchyIncomingCallsParams>(this as CallHierarchyIncomingCallsParams, _$identity);

  /// Serializes this CallHierarchyIncomingCallsParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CallHierarchyIncomingCallsParams&&(identical(other.item, item) || other.item == item)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,item,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'CallHierarchyIncomingCallsParams(item: $item, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $CallHierarchyIncomingCallsParamsCopyWith<$Res>  {
  factory $CallHierarchyIncomingCallsParamsCopyWith(CallHierarchyIncomingCallsParams value, $Res Function(CallHierarchyIncomingCallsParams) _then) = _$CallHierarchyIncomingCallsParamsCopyWithImpl;
@useResult
$Res call({
 CallHierarchyItem item, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


$CallHierarchyItemCopyWith<$Res> get item;

}
/// @nodoc
class _$CallHierarchyIncomingCallsParamsCopyWithImpl<$Res>
    implements $CallHierarchyIncomingCallsParamsCopyWith<$Res> {
  _$CallHierarchyIncomingCallsParamsCopyWithImpl(this._self, this._then);

  final CallHierarchyIncomingCallsParams _self;
  final $Res Function(CallHierarchyIncomingCallsParams) _then;

/// Create a copy of CallHierarchyIncomingCallsParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? item = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
item: null == item ? _self.item : item // ignore: cast_nullable_to_non_nullable
as CallHierarchyItem,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of CallHierarchyIncomingCallsParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CallHierarchyItemCopyWith<$Res> get item {
  
  return $CallHierarchyItemCopyWith<$Res>(_self.item, (value) {
    return _then(_self.copyWith(item: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _CallHierarchyIncomingCallsParams implements CallHierarchyIncomingCallsParams {
  const _CallHierarchyIncomingCallsParams({required this.item, this.partialResultToken, this.workDoneToken});
  factory _CallHierarchyIncomingCallsParams.fromJson(Map<String, dynamic> json) => _$CallHierarchyIncomingCallsParamsFromJson(json);

@override final  CallHierarchyItem item;
@override final  ProgressToken? partialResultToken;
@override final  ProgressToken? workDoneToken;

/// Create a copy of CallHierarchyIncomingCallsParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CallHierarchyIncomingCallsParamsCopyWith<_CallHierarchyIncomingCallsParams> get copyWith => __$CallHierarchyIncomingCallsParamsCopyWithImpl<_CallHierarchyIncomingCallsParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CallHierarchyIncomingCallsParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CallHierarchyIncomingCallsParams&&(identical(other.item, item) || other.item == item)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,item,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'CallHierarchyIncomingCallsParams(item: $item, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$CallHierarchyIncomingCallsParamsCopyWith<$Res> implements $CallHierarchyIncomingCallsParamsCopyWith<$Res> {
  factory _$CallHierarchyIncomingCallsParamsCopyWith(_CallHierarchyIncomingCallsParams value, $Res Function(_CallHierarchyIncomingCallsParams) _then) = __$CallHierarchyIncomingCallsParamsCopyWithImpl;
@override @useResult
$Res call({
 CallHierarchyItem item, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


@override $CallHierarchyItemCopyWith<$Res> get item;

}
/// @nodoc
class __$CallHierarchyIncomingCallsParamsCopyWithImpl<$Res>
    implements _$CallHierarchyIncomingCallsParamsCopyWith<$Res> {
  __$CallHierarchyIncomingCallsParamsCopyWithImpl(this._self, this._then);

  final _CallHierarchyIncomingCallsParams _self;
  final $Res Function(_CallHierarchyIncomingCallsParams) _then;

/// Create a copy of CallHierarchyIncomingCallsParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? item = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_CallHierarchyIncomingCallsParams(
item: null == item ? _self.item : item // ignore: cast_nullable_to_non_nullable
as CallHierarchyItem,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of CallHierarchyIncomingCallsParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CallHierarchyItemCopyWith<$Res> get item {
  
  return $CallHierarchyItemCopyWith<$Res>(_self.item, (value) {
    return _then(_self.copyWith(item: value));
  });
}
}


/// @nodoc
mixin _$CallHierarchyIncomingCall {

 CallHierarchyItem get from; List<Range> get fromRanges;
/// Create a copy of CallHierarchyIncomingCall
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CallHierarchyIncomingCallCopyWith<CallHierarchyIncomingCall> get copyWith => _$CallHierarchyIncomingCallCopyWithImpl<CallHierarchyIncomingCall>(this as CallHierarchyIncomingCall, _$identity);

  /// Serializes this CallHierarchyIncomingCall to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CallHierarchyIncomingCall&&(identical(other.from, from) || other.from == from)&&const DeepCollectionEquality().equals(other.fromRanges, fromRanges));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,from,const DeepCollectionEquality().hash(fromRanges));

@override
String toString() {
  return 'CallHierarchyIncomingCall(from: $from, fromRanges: $fromRanges)';
}


}

/// @nodoc
abstract mixin class $CallHierarchyIncomingCallCopyWith<$Res>  {
  factory $CallHierarchyIncomingCallCopyWith(CallHierarchyIncomingCall value, $Res Function(CallHierarchyIncomingCall) _then) = _$CallHierarchyIncomingCallCopyWithImpl;
@useResult
$Res call({
 CallHierarchyItem from, List<Range> fromRanges
});


$CallHierarchyItemCopyWith<$Res> get from;

}
/// @nodoc
class _$CallHierarchyIncomingCallCopyWithImpl<$Res>
    implements $CallHierarchyIncomingCallCopyWith<$Res> {
  _$CallHierarchyIncomingCallCopyWithImpl(this._self, this._then);

  final CallHierarchyIncomingCall _self;
  final $Res Function(CallHierarchyIncomingCall) _then;

/// Create a copy of CallHierarchyIncomingCall
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? from = null,Object? fromRanges = null,}) {
  return _then(_self.copyWith(
from: null == from ? _self.from : from // ignore: cast_nullable_to_non_nullable
as CallHierarchyItem,fromRanges: null == fromRanges ? _self.fromRanges : fromRanges // ignore: cast_nullable_to_non_nullable
as List<Range>,
  ));
}
/// Create a copy of CallHierarchyIncomingCall
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CallHierarchyItemCopyWith<$Res> get from {
  
  return $CallHierarchyItemCopyWith<$Res>(_self.from, (value) {
    return _then(_self.copyWith(from: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _CallHierarchyIncomingCall implements CallHierarchyIncomingCall {
  const _CallHierarchyIncomingCall({required this.from, required final  List<Range> fromRanges}): _fromRanges = fromRanges;
  factory _CallHierarchyIncomingCall.fromJson(Map<String, dynamic> json) => _$CallHierarchyIncomingCallFromJson(json);

@override final  CallHierarchyItem from;
 final  List<Range> _fromRanges;
@override List<Range> get fromRanges {
  if (_fromRanges is EqualUnmodifiableListView) return _fromRanges;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_fromRanges);
}


/// Create a copy of CallHierarchyIncomingCall
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CallHierarchyIncomingCallCopyWith<_CallHierarchyIncomingCall> get copyWith => __$CallHierarchyIncomingCallCopyWithImpl<_CallHierarchyIncomingCall>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CallHierarchyIncomingCallToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CallHierarchyIncomingCall&&(identical(other.from, from) || other.from == from)&&const DeepCollectionEquality().equals(other._fromRanges, _fromRanges));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,from,const DeepCollectionEquality().hash(_fromRanges));

@override
String toString() {
  return 'CallHierarchyIncomingCall(from: $from, fromRanges: $fromRanges)';
}


}

/// @nodoc
abstract mixin class _$CallHierarchyIncomingCallCopyWith<$Res> implements $CallHierarchyIncomingCallCopyWith<$Res> {
  factory _$CallHierarchyIncomingCallCopyWith(_CallHierarchyIncomingCall value, $Res Function(_CallHierarchyIncomingCall) _then) = __$CallHierarchyIncomingCallCopyWithImpl;
@override @useResult
$Res call({
 CallHierarchyItem from, List<Range> fromRanges
});


@override $CallHierarchyItemCopyWith<$Res> get from;

}
/// @nodoc
class __$CallHierarchyIncomingCallCopyWithImpl<$Res>
    implements _$CallHierarchyIncomingCallCopyWith<$Res> {
  __$CallHierarchyIncomingCallCopyWithImpl(this._self, this._then);

  final _CallHierarchyIncomingCall _self;
  final $Res Function(_CallHierarchyIncomingCall) _then;

/// Create a copy of CallHierarchyIncomingCall
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? from = null,Object? fromRanges = null,}) {
  return _then(_CallHierarchyIncomingCall(
from: null == from ? _self.from : from // ignore: cast_nullable_to_non_nullable
as CallHierarchyItem,fromRanges: null == fromRanges ? _self._fromRanges : fromRanges // ignore: cast_nullable_to_non_nullable
as List<Range>,
  ));
}

/// Create a copy of CallHierarchyIncomingCall
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CallHierarchyItemCopyWith<$Res> get from {
  
  return $CallHierarchyItemCopyWith<$Res>(_self.from, (value) {
    return _then(_self.copyWith(from: value));
  });
}
}


/// @nodoc
mixin _$CallHierarchyOutgoingCallsParams {

 CallHierarchyItem get item; ProgressToken? get partialResultToken; ProgressToken? get workDoneToken;
/// Create a copy of CallHierarchyOutgoingCallsParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CallHierarchyOutgoingCallsParamsCopyWith<CallHierarchyOutgoingCallsParams> get copyWith => _$CallHierarchyOutgoingCallsParamsCopyWithImpl<CallHierarchyOutgoingCallsParams>(this as CallHierarchyOutgoingCallsParams, _$identity);

  /// Serializes this CallHierarchyOutgoingCallsParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CallHierarchyOutgoingCallsParams&&(identical(other.item, item) || other.item == item)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,item,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'CallHierarchyOutgoingCallsParams(item: $item, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $CallHierarchyOutgoingCallsParamsCopyWith<$Res>  {
  factory $CallHierarchyOutgoingCallsParamsCopyWith(CallHierarchyOutgoingCallsParams value, $Res Function(CallHierarchyOutgoingCallsParams) _then) = _$CallHierarchyOutgoingCallsParamsCopyWithImpl;
@useResult
$Res call({
 CallHierarchyItem item, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


$CallHierarchyItemCopyWith<$Res> get item;

}
/// @nodoc
class _$CallHierarchyOutgoingCallsParamsCopyWithImpl<$Res>
    implements $CallHierarchyOutgoingCallsParamsCopyWith<$Res> {
  _$CallHierarchyOutgoingCallsParamsCopyWithImpl(this._self, this._then);

  final CallHierarchyOutgoingCallsParams _self;
  final $Res Function(CallHierarchyOutgoingCallsParams) _then;

/// Create a copy of CallHierarchyOutgoingCallsParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? item = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
item: null == item ? _self.item : item // ignore: cast_nullable_to_non_nullable
as CallHierarchyItem,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of CallHierarchyOutgoingCallsParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CallHierarchyItemCopyWith<$Res> get item {
  
  return $CallHierarchyItemCopyWith<$Res>(_self.item, (value) {
    return _then(_self.copyWith(item: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _CallHierarchyOutgoingCallsParams implements CallHierarchyOutgoingCallsParams {
  const _CallHierarchyOutgoingCallsParams({required this.item, this.partialResultToken, this.workDoneToken});
  factory _CallHierarchyOutgoingCallsParams.fromJson(Map<String, dynamic> json) => _$CallHierarchyOutgoingCallsParamsFromJson(json);

@override final  CallHierarchyItem item;
@override final  ProgressToken? partialResultToken;
@override final  ProgressToken? workDoneToken;

/// Create a copy of CallHierarchyOutgoingCallsParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CallHierarchyOutgoingCallsParamsCopyWith<_CallHierarchyOutgoingCallsParams> get copyWith => __$CallHierarchyOutgoingCallsParamsCopyWithImpl<_CallHierarchyOutgoingCallsParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CallHierarchyOutgoingCallsParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CallHierarchyOutgoingCallsParams&&(identical(other.item, item) || other.item == item)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,item,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'CallHierarchyOutgoingCallsParams(item: $item, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$CallHierarchyOutgoingCallsParamsCopyWith<$Res> implements $CallHierarchyOutgoingCallsParamsCopyWith<$Res> {
  factory _$CallHierarchyOutgoingCallsParamsCopyWith(_CallHierarchyOutgoingCallsParams value, $Res Function(_CallHierarchyOutgoingCallsParams) _then) = __$CallHierarchyOutgoingCallsParamsCopyWithImpl;
@override @useResult
$Res call({
 CallHierarchyItem item, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


@override $CallHierarchyItemCopyWith<$Res> get item;

}
/// @nodoc
class __$CallHierarchyOutgoingCallsParamsCopyWithImpl<$Res>
    implements _$CallHierarchyOutgoingCallsParamsCopyWith<$Res> {
  __$CallHierarchyOutgoingCallsParamsCopyWithImpl(this._self, this._then);

  final _CallHierarchyOutgoingCallsParams _self;
  final $Res Function(_CallHierarchyOutgoingCallsParams) _then;

/// Create a copy of CallHierarchyOutgoingCallsParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? item = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_CallHierarchyOutgoingCallsParams(
item: null == item ? _self.item : item // ignore: cast_nullable_to_non_nullable
as CallHierarchyItem,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of CallHierarchyOutgoingCallsParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CallHierarchyItemCopyWith<$Res> get item {
  
  return $CallHierarchyItemCopyWith<$Res>(_self.item, (value) {
    return _then(_self.copyWith(item: value));
  });
}
}


/// @nodoc
mixin _$CallHierarchyOutgoingCall {

 CallHierarchyItem get to; List<Range> get fromRanges;
/// Create a copy of CallHierarchyOutgoingCall
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CallHierarchyOutgoingCallCopyWith<CallHierarchyOutgoingCall> get copyWith => _$CallHierarchyOutgoingCallCopyWithImpl<CallHierarchyOutgoingCall>(this as CallHierarchyOutgoingCall, _$identity);

  /// Serializes this CallHierarchyOutgoingCall to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CallHierarchyOutgoingCall&&(identical(other.to, to) || other.to == to)&&const DeepCollectionEquality().equals(other.fromRanges, fromRanges));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,to,const DeepCollectionEquality().hash(fromRanges));

@override
String toString() {
  return 'CallHierarchyOutgoingCall(to: $to, fromRanges: $fromRanges)';
}


}

/// @nodoc
abstract mixin class $CallHierarchyOutgoingCallCopyWith<$Res>  {
  factory $CallHierarchyOutgoingCallCopyWith(CallHierarchyOutgoingCall value, $Res Function(CallHierarchyOutgoingCall) _then) = _$CallHierarchyOutgoingCallCopyWithImpl;
@useResult
$Res call({
 CallHierarchyItem to, List<Range> fromRanges
});


$CallHierarchyItemCopyWith<$Res> get to;

}
/// @nodoc
class _$CallHierarchyOutgoingCallCopyWithImpl<$Res>
    implements $CallHierarchyOutgoingCallCopyWith<$Res> {
  _$CallHierarchyOutgoingCallCopyWithImpl(this._self, this._then);

  final CallHierarchyOutgoingCall _self;
  final $Res Function(CallHierarchyOutgoingCall) _then;

/// Create a copy of CallHierarchyOutgoingCall
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? to = null,Object? fromRanges = null,}) {
  return _then(_self.copyWith(
to: null == to ? _self.to : to // ignore: cast_nullable_to_non_nullable
as CallHierarchyItem,fromRanges: null == fromRanges ? _self.fromRanges : fromRanges // ignore: cast_nullable_to_non_nullable
as List<Range>,
  ));
}
/// Create a copy of CallHierarchyOutgoingCall
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CallHierarchyItemCopyWith<$Res> get to {
  
  return $CallHierarchyItemCopyWith<$Res>(_self.to, (value) {
    return _then(_self.copyWith(to: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _CallHierarchyOutgoingCall implements CallHierarchyOutgoingCall {
  const _CallHierarchyOutgoingCall({required this.to, required final  List<Range> fromRanges}): _fromRanges = fromRanges;
  factory _CallHierarchyOutgoingCall.fromJson(Map<String, dynamic> json) => _$CallHierarchyOutgoingCallFromJson(json);

@override final  CallHierarchyItem to;
 final  List<Range> _fromRanges;
@override List<Range> get fromRanges {
  if (_fromRanges is EqualUnmodifiableListView) return _fromRanges;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_fromRanges);
}


/// Create a copy of CallHierarchyOutgoingCall
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CallHierarchyOutgoingCallCopyWith<_CallHierarchyOutgoingCall> get copyWith => __$CallHierarchyOutgoingCallCopyWithImpl<_CallHierarchyOutgoingCall>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CallHierarchyOutgoingCallToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CallHierarchyOutgoingCall&&(identical(other.to, to) || other.to == to)&&const DeepCollectionEquality().equals(other._fromRanges, _fromRanges));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,to,const DeepCollectionEquality().hash(_fromRanges));

@override
String toString() {
  return 'CallHierarchyOutgoingCall(to: $to, fromRanges: $fromRanges)';
}


}

/// @nodoc
abstract mixin class _$CallHierarchyOutgoingCallCopyWith<$Res> implements $CallHierarchyOutgoingCallCopyWith<$Res> {
  factory _$CallHierarchyOutgoingCallCopyWith(_CallHierarchyOutgoingCall value, $Res Function(_CallHierarchyOutgoingCall) _then) = __$CallHierarchyOutgoingCallCopyWithImpl;
@override @useResult
$Res call({
 CallHierarchyItem to, List<Range> fromRanges
});


@override $CallHierarchyItemCopyWith<$Res> get to;

}
/// @nodoc
class __$CallHierarchyOutgoingCallCopyWithImpl<$Res>
    implements _$CallHierarchyOutgoingCallCopyWith<$Res> {
  __$CallHierarchyOutgoingCallCopyWithImpl(this._self, this._then);

  final _CallHierarchyOutgoingCall _self;
  final $Res Function(_CallHierarchyOutgoingCall) _then;

/// Create a copy of CallHierarchyOutgoingCall
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? to = null,Object? fromRanges = null,}) {
  return _then(_CallHierarchyOutgoingCall(
to: null == to ? _self.to : to // ignore: cast_nullable_to_non_nullable
as CallHierarchyItem,fromRanges: null == fromRanges ? _self._fromRanges : fromRanges // ignore: cast_nullable_to_non_nullable
as List<Range>,
  ));
}

/// Create a copy of CallHierarchyOutgoingCall
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CallHierarchyItemCopyWith<$Res> get to {
  
  return $CallHierarchyItemCopyWith<$Res>(_self.to, (value) {
    return _then(_self.copyWith(to: value));
  });
}
}


/// @nodoc
mixin _$SemanticTokensParams {

 TextDocumentIdentifier get textDocument; ProgressToken? get partialResultToken; ProgressToken? get workDoneToken;
/// Create a copy of SemanticTokensParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SemanticTokensParamsCopyWith<SemanticTokensParams> get copyWith => _$SemanticTokensParamsCopyWithImpl<SemanticTokensParams>(this as SemanticTokensParams, _$identity);

  /// Serializes this SemanticTokensParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SemanticTokensParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'SemanticTokensParams(textDocument: $textDocument, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $SemanticTokensParamsCopyWith<$Res>  {
  factory $SemanticTokensParamsCopyWith(SemanticTokensParams value, $Res Function(SemanticTokensParams) _then) = _$SemanticTokensParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$SemanticTokensParamsCopyWithImpl<$Res>
    implements $SemanticTokensParamsCopyWith<$Res> {
  _$SemanticTokensParamsCopyWithImpl(this._self, this._then);

  final SemanticTokensParams _self;
  final $Res Function(SemanticTokensParams) _then;

/// Create a copy of SemanticTokensParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of SemanticTokensParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _SemanticTokensParams implements SemanticTokensParams {
  const _SemanticTokensParams({required this.textDocument, this.partialResultToken, this.workDoneToken});
  factory _SemanticTokensParams.fromJson(Map<String, dynamic> json) => _$SemanticTokensParamsFromJson(json);

@override final  TextDocumentIdentifier textDocument;
@override final  ProgressToken? partialResultToken;
@override final  ProgressToken? workDoneToken;

/// Create a copy of SemanticTokensParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SemanticTokensParamsCopyWith<_SemanticTokensParams> get copyWith => __$SemanticTokensParamsCopyWithImpl<_SemanticTokensParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SemanticTokensParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SemanticTokensParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'SemanticTokensParams(textDocument: $textDocument, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$SemanticTokensParamsCopyWith<$Res> implements $SemanticTokensParamsCopyWith<$Res> {
  factory _$SemanticTokensParamsCopyWith(_SemanticTokensParams value, $Res Function(_SemanticTokensParams) _then) = __$SemanticTokensParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$SemanticTokensParamsCopyWithImpl<$Res>
    implements _$SemanticTokensParamsCopyWith<$Res> {
  __$SemanticTokensParamsCopyWithImpl(this._self, this._then);

  final _SemanticTokensParams _self;
  final $Res Function(_SemanticTokensParams) _then;

/// Create a copy of SemanticTokensParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_SemanticTokensParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of SemanticTokensParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$SemanticTokens {

 List<int> get data; String? get resultId;
/// Create a copy of SemanticTokens
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SemanticTokensCopyWith<SemanticTokens> get copyWith => _$SemanticTokensCopyWithImpl<SemanticTokens>(this as SemanticTokens, _$identity);

  /// Serializes this SemanticTokens to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SemanticTokens&&const DeepCollectionEquality().equals(other.data, data)&&(identical(other.resultId, resultId) || other.resultId == resultId));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(data),resultId);

@override
String toString() {
  return 'SemanticTokens(data: $data, resultId: $resultId)';
}


}

/// @nodoc
abstract mixin class $SemanticTokensCopyWith<$Res>  {
  factory $SemanticTokensCopyWith(SemanticTokens value, $Res Function(SemanticTokens) _then) = _$SemanticTokensCopyWithImpl;
@useResult
$Res call({
 List<int> data, String? resultId
});




}
/// @nodoc
class _$SemanticTokensCopyWithImpl<$Res>
    implements $SemanticTokensCopyWith<$Res> {
  _$SemanticTokensCopyWithImpl(this._self, this._then);

  final SemanticTokens _self;
  final $Res Function(SemanticTokens) _then;

/// Create a copy of SemanticTokens
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? data = null,Object? resultId = freezed,}) {
  return _then(_self.copyWith(
data: null == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as List<int>,resultId: freezed == resultId ? _self.resultId : resultId // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _SemanticTokens implements SemanticTokens {
  const _SemanticTokens({required final  List<int> data, this.resultId}): _data = data;
  factory _SemanticTokens.fromJson(Map<String, dynamic> json) => _$SemanticTokensFromJson(json);

 final  List<int> _data;
@override List<int> get data {
  if (_data is EqualUnmodifiableListView) return _data;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_data);
}

@override final  String? resultId;

/// Create a copy of SemanticTokens
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SemanticTokensCopyWith<_SemanticTokens> get copyWith => __$SemanticTokensCopyWithImpl<_SemanticTokens>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SemanticTokensToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SemanticTokens&&const DeepCollectionEquality().equals(other._data, _data)&&(identical(other.resultId, resultId) || other.resultId == resultId));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_data),resultId);

@override
String toString() {
  return 'SemanticTokens(data: $data, resultId: $resultId)';
}


}

/// @nodoc
abstract mixin class _$SemanticTokensCopyWith<$Res> implements $SemanticTokensCopyWith<$Res> {
  factory _$SemanticTokensCopyWith(_SemanticTokens value, $Res Function(_SemanticTokens) _then) = __$SemanticTokensCopyWithImpl;
@override @useResult
$Res call({
 List<int> data, String? resultId
});




}
/// @nodoc
class __$SemanticTokensCopyWithImpl<$Res>
    implements _$SemanticTokensCopyWith<$Res> {
  __$SemanticTokensCopyWithImpl(this._self, this._then);

  final _SemanticTokens _self;
  final $Res Function(_SemanticTokens) _then;

/// Create a copy of SemanticTokens
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? data = null,Object? resultId = freezed,}) {
  return _then(_SemanticTokens(
data: null == data ? _self._data : data // ignore: cast_nullable_to_non_nullable
as List<int>,resultId: freezed == resultId ? _self.resultId : resultId // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$SemanticTokensPartialResult {

 List<int> get data;
/// Create a copy of SemanticTokensPartialResult
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SemanticTokensPartialResultCopyWith<SemanticTokensPartialResult> get copyWith => _$SemanticTokensPartialResultCopyWithImpl<SemanticTokensPartialResult>(this as SemanticTokensPartialResult, _$identity);

  /// Serializes this SemanticTokensPartialResult to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SemanticTokensPartialResult&&const DeepCollectionEquality().equals(other.data, data));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(data));

@override
String toString() {
  return 'SemanticTokensPartialResult(data: $data)';
}


}

/// @nodoc
abstract mixin class $SemanticTokensPartialResultCopyWith<$Res>  {
  factory $SemanticTokensPartialResultCopyWith(SemanticTokensPartialResult value, $Res Function(SemanticTokensPartialResult) _then) = _$SemanticTokensPartialResultCopyWithImpl;
@useResult
$Res call({
 List<int> data
});




}
/// @nodoc
class _$SemanticTokensPartialResultCopyWithImpl<$Res>
    implements $SemanticTokensPartialResultCopyWith<$Res> {
  _$SemanticTokensPartialResultCopyWithImpl(this._self, this._then);

  final SemanticTokensPartialResult _self;
  final $Res Function(SemanticTokensPartialResult) _then;

/// Create a copy of SemanticTokensPartialResult
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? data = null,}) {
  return _then(_self.copyWith(
data: null == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as List<int>,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _SemanticTokensPartialResult implements SemanticTokensPartialResult {
  const _SemanticTokensPartialResult({required final  List<int> data}): _data = data;
  factory _SemanticTokensPartialResult.fromJson(Map<String, dynamic> json) => _$SemanticTokensPartialResultFromJson(json);

 final  List<int> _data;
@override List<int> get data {
  if (_data is EqualUnmodifiableListView) return _data;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_data);
}


/// Create a copy of SemanticTokensPartialResult
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SemanticTokensPartialResultCopyWith<_SemanticTokensPartialResult> get copyWith => __$SemanticTokensPartialResultCopyWithImpl<_SemanticTokensPartialResult>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SemanticTokensPartialResultToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SemanticTokensPartialResult&&const DeepCollectionEquality().equals(other._data, _data));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_data));

@override
String toString() {
  return 'SemanticTokensPartialResult(data: $data)';
}


}

/// @nodoc
abstract mixin class _$SemanticTokensPartialResultCopyWith<$Res> implements $SemanticTokensPartialResultCopyWith<$Res> {
  factory _$SemanticTokensPartialResultCopyWith(_SemanticTokensPartialResult value, $Res Function(_SemanticTokensPartialResult) _then) = __$SemanticTokensPartialResultCopyWithImpl;
@override @useResult
$Res call({
 List<int> data
});




}
/// @nodoc
class __$SemanticTokensPartialResultCopyWithImpl<$Res>
    implements _$SemanticTokensPartialResultCopyWith<$Res> {
  __$SemanticTokensPartialResultCopyWithImpl(this._self, this._then);

  final _SemanticTokensPartialResult _self;
  final $Res Function(_SemanticTokensPartialResult) _then;

/// Create a copy of SemanticTokensPartialResult
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? data = null,}) {
  return _then(_SemanticTokensPartialResult(
data: null == data ? _self._data : data // ignore: cast_nullable_to_non_nullable
as List<int>,
  ));
}


}


/// @nodoc
mixin _$SemanticTokensRegistrationOptions {

 dynamic get documentSelector; SemanticTokensLegend get legend; String? get id; dynamic? get full; dynamic? get range; bool? get workDoneProgress;
/// Create a copy of SemanticTokensRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SemanticTokensRegistrationOptionsCopyWith<SemanticTokensRegistrationOptions> get copyWith => _$SemanticTokensRegistrationOptionsCopyWithImpl<SemanticTokensRegistrationOptions>(this as SemanticTokensRegistrationOptions, _$identity);

  /// Serializes this SemanticTokensRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SemanticTokensRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.legend, legend) || other.legend == legend)&&(identical(other.id, id) || other.id == id)&&const DeepCollectionEquality().equals(other.full, full)&&const DeepCollectionEquality().equals(other.range, range)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),legend,id,const DeepCollectionEquality().hash(full),const DeepCollectionEquality().hash(range),workDoneProgress);

@override
String toString() {
  return 'SemanticTokensRegistrationOptions(documentSelector: $documentSelector, legend: $legend, id: $id, full: $full, range: $range, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $SemanticTokensRegistrationOptionsCopyWith<$Res>  {
  factory $SemanticTokensRegistrationOptionsCopyWith(SemanticTokensRegistrationOptions value, $Res Function(SemanticTokensRegistrationOptions) _then) = _$SemanticTokensRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 dynamic documentSelector, SemanticTokensLegend legend, String? id, dynamic? full, dynamic? range, bool? workDoneProgress
});


$SemanticTokensLegendCopyWith<$Res> get legend;

}
/// @nodoc
class _$SemanticTokensRegistrationOptionsCopyWithImpl<$Res>
    implements $SemanticTokensRegistrationOptionsCopyWith<$Res> {
  _$SemanticTokensRegistrationOptionsCopyWithImpl(this._self, this._then);

  final SemanticTokensRegistrationOptions _self;
  final $Res Function(SemanticTokensRegistrationOptions) _then;

/// Create a copy of SemanticTokensRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = freezed,Object? legend = null,Object? id = freezed,Object? full = freezed,Object? range = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,legend: null == legend ? _self.legend : legend // ignore: cast_nullable_to_non_nullable
as SemanticTokensLegend,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,full: freezed == full ? _self.full : full // ignore: cast_nullable_to_non_nullable
as dynamic?,range: freezed == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as dynamic?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}
/// Create a copy of SemanticTokensRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SemanticTokensLegendCopyWith<$Res> get legend {
  
  return $SemanticTokensLegendCopyWith<$Res>(_self.legend, (value) {
    return _then(_self.copyWith(legend: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _SemanticTokensRegistrationOptions implements SemanticTokensRegistrationOptions {
  const _SemanticTokensRegistrationOptions({required this.documentSelector, required this.legend, this.id, this.full, this.range, this.workDoneProgress});
  factory _SemanticTokensRegistrationOptions.fromJson(Map<String, dynamic> json) => _$SemanticTokensRegistrationOptionsFromJson(json);

@override final  dynamic documentSelector;
@override final  SemanticTokensLegend legend;
@override final  String? id;
@override final  dynamic? full;
@override final  dynamic? range;
@override final  bool? workDoneProgress;

/// Create a copy of SemanticTokensRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SemanticTokensRegistrationOptionsCopyWith<_SemanticTokensRegistrationOptions> get copyWith => __$SemanticTokensRegistrationOptionsCopyWithImpl<_SemanticTokensRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SemanticTokensRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SemanticTokensRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.legend, legend) || other.legend == legend)&&(identical(other.id, id) || other.id == id)&&const DeepCollectionEquality().equals(other.full, full)&&const DeepCollectionEquality().equals(other.range, range)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),legend,id,const DeepCollectionEquality().hash(full),const DeepCollectionEquality().hash(range),workDoneProgress);

@override
String toString() {
  return 'SemanticTokensRegistrationOptions(documentSelector: $documentSelector, legend: $legend, id: $id, full: $full, range: $range, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$SemanticTokensRegistrationOptionsCopyWith<$Res> implements $SemanticTokensRegistrationOptionsCopyWith<$Res> {
  factory _$SemanticTokensRegistrationOptionsCopyWith(_SemanticTokensRegistrationOptions value, $Res Function(_SemanticTokensRegistrationOptions) _then) = __$SemanticTokensRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 dynamic documentSelector, SemanticTokensLegend legend, String? id, dynamic? full, dynamic? range, bool? workDoneProgress
});


@override $SemanticTokensLegendCopyWith<$Res> get legend;

}
/// @nodoc
class __$SemanticTokensRegistrationOptionsCopyWithImpl<$Res>
    implements _$SemanticTokensRegistrationOptionsCopyWith<$Res> {
  __$SemanticTokensRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _SemanticTokensRegistrationOptions _self;
  final $Res Function(_SemanticTokensRegistrationOptions) _then;

/// Create a copy of SemanticTokensRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = freezed,Object? legend = null,Object? id = freezed,Object? full = freezed,Object? range = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_SemanticTokensRegistrationOptions(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,legend: null == legend ? _self.legend : legend // ignore: cast_nullable_to_non_nullable
as SemanticTokensLegend,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,full: freezed == full ? _self.full : full // ignore: cast_nullable_to_non_nullable
as dynamic?,range: freezed == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as dynamic?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

/// Create a copy of SemanticTokensRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SemanticTokensLegendCopyWith<$Res> get legend {
  
  return $SemanticTokensLegendCopyWith<$Res>(_self.legend, (value) {
    return _then(_self.copyWith(legend: value));
  });
}
}


/// @nodoc
mixin _$SemanticTokensDeltaParams {

 TextDocumentIdentifier get textDocument; String get previousResultId; ProgressToken? get partialResultToken; ProgressToken? get workDoneToken;
/// Create a copy of SemanticTokensDeltaParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SemanticTokensDeltaParamsCopyWith<SemanticTokensDeltaParams> get copyWith => _$SemanticTokensDeltaParamsCopyWithImpl<SemanticTokensDeltaParams>(this as SemanticTokensDeltaParams, _$identity);

  /// Serializes this SemanticTokensDeltaParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SemanticTokensDeltaParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.previousResultId, previousResultId) || other.previousResultId == previousResultId)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,previousResultId,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'SemanticTokensDeltaParams(textDocument: $textDocument, previousResultId: $previousResultId, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $SemanticTokensDeltaParamsCopyWith<$Res>  {
  factory $SemanticTokensDeltaParamsCopyWith(SemanticTokensDeltaParams value, $Res Function(SemanticTokensDeltaParams) _then) = _$SemanticTokensDeltaParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument, String previousResultId, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$SemanticTokensDeltaParamsCopyWithImpl<$Res>
    implements $SemanticTokensDeltaParamsCopyWith<$Res> {
  _$SemanticTokensDeltaParamsCopyWithImpl(this._self, this._then);

  final SemanticTokensDeltaParams _self;
  final $Res Function(SemanticTokensDeltaParams) _then;

/// Create a copy of SemanticTokensDeltaParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? previousResultId = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,previousResultId: null == previousResultId ? _self.previousResultId : previousResultId // ignore: cast_nullable_to_non_nullable
as String,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of SemanticTokensDeltaParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _SemanticTokensDeltaParams implements SemanticTokensDeltaParams {
  const _SemanticTokensDeltaParams({required this.textDocument, required this.previousResultId, this.partialResultToken, this.workDoneToken});
  factory _SemanticTokensDeltaParams.fromJson(Map<String, dynamic> json) => _$SemanticTokensDeltaParamsFromJson(json);

@override final  TextDocumentIdentifier textDocument;
@override final  String previousResultId;
@override final  ProgressToken? partialResultToken;
@override final  ProgressToken? workDoneToken;

/// Create a copy of SemanticTokensDeltaParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SemanticTokensDeltaParamsCopyWith<_SemanticTokensDeltaParams> get copyWith => __$SemanticTokensDeltaParamsCopyWithImpl<_SemanticTokensDeltaParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SemanticTokensDeltaParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SemanticTokensDeltaParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.previousResultId, previousResultId) || other.previousResultId == previousResultId)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,previousResultId,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'SemanticTokensDeltaParams(textDocument: $textDocument, previousResultId: $previousResultId, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$SemanticTokensDeltaParamsCopyWith<$Res> implements $SemanticTokensDeltaParamsCopyWith<$Res> {
  factory _$SemanticTokensDeltaParamsCopyWith(_SemanticTokensDeltaParams value, $Res Function(_SemanticTokensDeltaParams) _then) = __$SemanticTokensDeltaParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument, String previousResultId, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$SemanticTokensDeltaParamsCopyWithImpl<$Res>
    implements _$SemanticTokensDeltaParamsCopyWith<$Res> {
  __$SemanticTokensDeltaParamsCopyWithImpl(this._self, this._then);

  final _SemanticTokensDeltaParams _self;
  final $Res Function(_SemanticTokensDeltaParams) _then;

/// Create a copy of SemanticTokensDeltaParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? previousResultId = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_SemanticTokensDeltaParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,previousResultId: null == previousResultId ? _self.previousResultId : previousResultId // ignore: cast_nullable_to_non_nullable
as String,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of SemanticTokensDeltaParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$SemanticTokensDelta {

 List<SemanticTokensEdit> get edits; String? get resultId;
/// Create a copy of SemanticTokensDelta
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SemanticTokensDeltaCopyWith<SemanticTokensDelta> get copyWith => _$SemanticTokensDeltaCopyWithImpl<SemanticTokensDelta>(this as SemanticTokensDelta, _$identity);

  /// Serializes this SemanticTokensDelta to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SemanticTokensDelta&&const DeepCollectionEquality().equals(other.edits, edits)&&(identical(other.resultId, resultId) || other.resultId == resultId));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(edits),resultId);

@override
String toString() {
  return 'SemanticTokensDelta(edits: $edits, resultId: $resultId)';
}


}

/// @nodoc
abstract mixin class $SemanticTokensDeltaCopyWith<$Res>  {
  factory $SemanticTokensDeltaCopyWith(SemanticTokensDelta value, $Res Function(SemanticTokensDelta) _then) = _$SemanticTokensDeltaCopyWithImpl;
@useResult
$Res call({
 List<SemanticTokensEdit> edits, String? resultId
});




}
/// @nodoc
class _$SemanticTokensDeltaCopyWithImpl<$Res>
    implements $SemanticTokensDeltaCopyWith<$Res> {
  _$SemanticTokensDeltaCopyWithImpl(this._self, this._then);

  final SemanticTokensDelta _self;
  final $Res Function(SemanticTokensDelta) _then;

/// Create a copy of SemanticTokensDelta
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? edits = null,Object? resultId = freezed,}) {
  return _then(_self.copyWith(
edits: null == edits ? _self.edits : edits // ignore: cast_nullable_to_non_nullable
as List<SemanticTokensEdit>,resultId: freezed == resultId ? _self.resultId : resultId // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _SemanticTokensDelta implements SemanticTokensDelta {
  const _SemanticTokensDelta({required final  List<SemanticTokensEdit> edits, this.resultId}): _edits = edits;
  factory _SemanticTokensDelta.fromJson(Map<String, dynamic> json) => _$SemanticTokensDeltaFromJson(json);

 final  List<SemanticTokensEdit> _edits;
@override List<SemanticTokensEdit> get edits {
  if (_edits is EqualUnmodifiableListView) return _edits;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_edits);
}

@override final  String? resultId;

/// Create a copy of SemanticTokensDelta
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SemanticTokensDeltaCopyWith<_SemanticTokensDelta> get copyWith => __$SemanticTokensDeltaCopyWithImpl<_SemanticTokensDelta>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SemanticTokensDeltaToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SemanticTokensDelta&&const DeepCollectionEquality().equals(other._edits, _edits)&&(identical(other.resultId, resultId) || other.resultId == resultId));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_edits),resultId);

@override
String toString() {
  return 'SemanticTokensDelta(edits: $edits, resultId: $resultId)';
}


}

/// @nodoc
abstract mixin class _$SemanticTokensDeltaCopyWith<$Res> implements $SemanticTokensDeltaCopyWith<$Res> {
  factory _$SemanticTokensDeltaCopyWith(_SemanticTokensDelta value, $Res Function(_SemanticTokensDelta) _then) = __$SemanticTokensDeltaCopyWithImpl;
@override @useResult
$Res call({
 List<SemanticTokensEdit> edits, String? resultId
});




}
/// @nodoc
class __$SemanticTokensDeltaCopyWithImpl<$Res>
    implements _$SemanticTokensDeltaCopyWith<$Res> {
  __$SemanticTokensDeltaCopyWithImpl(this._self, this._then);

  final _SemanticTokensDelta _self;
  final $Res Function(_SemanticTokensDelta) _then;

/// Create a copy of SemanticTokensDelta
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? edits = null,Object? resultId = freezed,}) {
  return _then(_SemanticTokensDelta(
edits: null == edits ? _self._edits : edits // ignore: cast_nullable_to_non_nullable
as List<SemanticTokensEdit>,resultId: freezed == resultId ? _self.resultId : resultId // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$SemanticTokensDeltaPartialResult {

 List<SemanticTokensEdit> get edits;
/// Create a copy of SemanticTokensDeltaPartialResult
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SemanticTokensDeltaPartialResultCopyWith<SemanticTokensDeltaPartialResult> get copyWith => _$SemanticTokensDeltaPartialResultCopyWithImpl<SemanticTokensDeltaPartialResult>(this as SemanticTokensDeltaPartialResult, _$identity);

  /// Serializes this SemanticTokensDeltaPartialResult to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SemanticTokensDeltaPartialResult&&const DeepCollectionEquality().equals(other.edits, edits));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(edits));

@override
String toString() {
  return 'SemanticTokensDeltaPartialResult(edits: $edits)';
}


}

/// @nodoc
abstract mixin class $SemanticTokensDeltaPartialResultCopyWith<$Res>  {
  factory $SemanticTokensDeltaPartialResultCopyWith(SemanticTokensDeltaPartialResult value, $Res Function(SemanticTokensDeltaPartialResult) _then) = _$SemanticTokensDeltaPartialResultCopyWithImpl;
@useResult
$Res call({
 List<SemanticTokensEdit> edits
});




}
/// @nodoc
class _$SemanticTokensDeltaPartialResultCopyWithImpl<$Res>
    implements $SemanticTokensDeltaPartialResultCopyWith<$Res> {
  _$SemanticTokensDeltaPartialResultCopyWithImpl(this._self, this._then);

  final SemanticTokensDeltaPartialResult _self;
  final $Res Function(SemanticTokensDeltaPartialResult) _then;

/// Create a copy of SemanticTokensDeltaPartialResult
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? edits = null,}) {
  return _then(_self.copyWith(
edits: null == edits ? _self.edits : edits // ignore: cast_nullable_to_non_nullable
as List<SemanticTokensEdit>,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _SemanticTokensDeltaPartialResult implements SemanticTokensDeltaPartialResult {
  const _SemanticTokensDeltaPartialResult({required final  List<SemanticTokensEdit> edits}): _edits = edits;
  factory _SemanticTokensDeltaPartialResult.fromJson(Map<String, dynamic> json) => _$SemanticTokensDeltaPartialResultFromJson(json);

 final  List<SemanticTokensEdit> _edits;
@override List<SemanticTokensEdit> get edits {
  if (_edits is EqualUnmodifiableListView) return _edits;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_edits);
}


/// Create a copy of SemanticTokensDeltaPartialResult
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SemanticTokensDeltaPartialResultCopyWith<_SemanticTokensDeltaPartialResult> get copyWith => __$SemanticTokensDeltaPartialResultCopyWithImpl<_SemanticTokensDeltaPartialResult>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SemanticTokensDeltaPartialResultToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SemanticTokensDeltaPartialResult&&const DeepCollectionEquality().equals(other._edits, _edits));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_edits));

@override
String toString() {
  return 'SemanticTokensDeltaPartialResult(edits: $edits)';
}


}

/// @nodoc
abstract mixin class _$SemanticTokensDeltaPartialResultCopyWith<$Res> implements $SemanticTokensDeltaPartialResultCopyWith<$Res> {
  factory _$SemanticTokensDeltaPartialResultCopyWith(_SemanticTokensDeltaPartialResult value, $Res Function(_SemanticTokensDeltaPartialResult) _then) = __$SemanticTokensDeltaPartialResultCopyWithImpl;
@override @useResult
$Res call({
 List<SemanticTokensEdit> edits
});




}
/// @nodoc
class __$SemanticTokensDeltaPartialResultCopyWithImpl<$Res>
    implements _$SemanticTokensDeltaPartialResultCopyWith<$Res> {
  __$SemanticTokensDeltaPartialResultCopyWithImpl(this._self, this._then);

  final _SemanticTokensDeltaPartialResult _self;
  final $Res Function(_SemanticTokensDeltaPartialResult) _then;

/// Create a copy of SemanticTokensDeltaPartialResult
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? edits = null,}) {
  return _then(_SemanticTokensDeltaPartialResult(
edits: null == edits ? _self._edits : edits // ignore: cast_nullable_to_non_nullable
as List<SemanticTokensEdit>,
  ));
}


}


/// @nodoc
mixin _$SemanticTokensRangeParams {

 TextDocumentIdentifier get textDocument; Range get range; ProgressToken? get partialResultToken; ProgressToken? get workDoneToken;
/// Create a copy of SemanticTokensRangeParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SemanticTokensRangeParamsCopyWith<SemanticTokensRangeParams> get copyWith => _$SemanticTokensRangeParamsCopyWithImpl<SemanticTokensRangeParams>(this as SemanticTokensRangeParams, _$identity);

  /// Serializes this SemanticTokensRangeParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SemanticTokensRangeParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.range, range) || other.range == range)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,range,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'SemanticTokensRangeParams(textDocument: $textDocument, range: $range, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $SemanticTokensRangeParamsCopyWith<$Res>  {
  factory $SemanticTokensRangeParamsCopyWith(SemanticTokensRangeParams value, $Res Function(SemanticTokensRangeParams) _then) = _$SemanticTokensRangeParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument, Range range, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;$RangeCopyWith<$Res> get range;

}
/// @nodoc
class _$SemanticTokensRangeParamsCopyWithImpl<$Res>
    implements $SemanticTokensRangeParamsCopyWith<$Res> {
  _$SemanticTokensRangeParamsCopyWithImpl(this._self, this._then);

  final SemanticTokensRangeParams _self;
  final $Res Function(SemanticTokensRangeParams) _then;

/// Create a copy of SemanticTokensRangeParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? range = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of SemanticTokensRangeParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of SemanticTokensRangeParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _SemanticTokensRangeParams implements SemanticTokensRangeParams {
  const _SemanticTokensRangeParams({required this.textDocument, required this.range, this.partialResultToken, this.workDoneToken});
  factory _SemanticTokensRangeParams.fromJson(Map<String, dynamic> json) => _$SemanticTokensRangeParamsFromJson(json);

@override final  TextDocumentIdentifier textDocument;
@override final  Range range;
@override final  ProgressToken? partialResultToken;
@override final  ProgressToken? workDoneToken;

/// Create a copy of SemanticTokensRangeParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SemanticTokensRangeParamsCopyWith<_SemanticTokensRangeParams> get copyWith => __$SemanticTokensRangeParamsCopyWithImpl<_SemanticTokensRangeParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SemanticTokensRangeParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SemanticTokensRangeParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.range, range) || other.range == range)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,range,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'SemanticTokensRangeParams(textDocument: $textDocument, range: $range, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$SemanticTokensRangeParamsCopyWith<$Res> implements $SemanticTokensRangeParamsCopyWith<$Res> {
  factory _$SemanticTokensRangeParamsCopyWith(_SemanticTokensRangeParams value, $Res Function(_SemanticTokensRangeParams) _then) = __$SemanticTokensRangeParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument, Range range, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;@override $RangeCopyWith<$Res> get range;

}
/// @nodoc
class __$SemanticTokensRangeParamsCopyWithImpl<$Res>
    implements _$SemanticTokensRangeParamsCopyWith<$Res> {
  __$SemanticTokensRangeParamsCopyWithImpl(this._self, this._then);

  final _SemanticTokensRangeParams _self;
  final $Res Function(_SemanticTokensRangeParams) _then;

/// Create a copy of SemanticTokensRangeParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? range = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_SemanticTokensRangeParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of SemanticTokensRangeParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of SemanticTokensRangeParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}


/// @nodoc
mixin _$ShowDocumentParams {

 String get uri; Range? get selection; bool? get takeFocus; bool? get external;
/// Create a copy of ShowDocumentParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ShowDocumentParamsCopyWith<ShowDocumentParams> get copyWith => _$ShowDocumentParamsCopyWithImpl<ShowDocumentParams>(this as ShowDocumentParams, _$identity);

  /// Serializes this ShowDocumentParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ShowDocumentParams&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.selection, selection) || other.selection == selection)&&(identical(other.takeFocus, takeFocus) || other.takeFocus == takeFocus)&&(identical(other.external, external) || other.external == external));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri,selection,takeFocus,external);

@override
String toString() {
  return 'ShowDocumentParams(uri: $uri, selection: $selection, takeFocus: $takeFocus, external: $external)';
}


}

/// @nodoc
abstract mixin class $ShowDocumentParamsCopyWith<$Res>  {
  factory $ShowDocumentParamsCopyWith(ShowDocumentParams value, $Res Function(ShowDocumentParams) _then) = _$ShowDocumentParamsCopyWithImpl;
@useResult
$Res call({
 String uri, Range? selection, bool? takeFocus, bool? external
});


$RangeCopyWith<$Res>? get selection;

}
/// @nodoc
class _$ShowDocumentParamsCopyWithImpl<$Res>
    implements $ShowDocumentParamsCopyWith<$Res> {
  _$ShowDocumentParamsCopyWithImpl(this._self, this._then);

  final ShowDocumentParams _self;
  final $Res Function(ShowDocumentParams) _then;

/// Create a copy of ShowDocumentParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? uri = null,Object? selection = freezed,Object? takeFocus = freezed,Object? external = freezed,}) {
  return _then(_self.copyWith(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,selection: freezed == selection ? _self.selection : selection // ignore: cast_nullable_to_non_nullable
as Range?,takeFocus: freezed == takeFocus ? _self.takeFocus : takeFocus // ignore: cast_nullable_to_non_nullable
as bool?,external: freezed == external ? _self.external : external // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}
/// Create a copy of ShowDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res>? get selection {
    if (_self.selection == null) {
    return null;
  }

  return $RangeCopyWith<$Res>(_self.selection!, (value) {
    return _then(_self.copyWith(selection: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _ShowDocumentParams implements ShowDocumentParams {
  const _ShowDocumentParams({required this.uri, this.selection, this.takeFocus, this.external});
  factory _ShowDocumentParams.fromJson(Map<String, dynamic> json) => _$ShowDocumentParamsFromJson(json);

@override final  String uri;
@override final  Range? selection;
@override final  bool? takeFocus;
@override final  bool? external;

/// Create a copy of ShowDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ShowDocumentParamsCopyWith<_ShowDocumentParams> get copyWith => __$ShowDocumentParamsCopyWithImpl<_ShowDocumentParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ShowDocumentParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ShowDocumentParams&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.selection, selection) || other.selection == selection)&&(identical(other.takeFocus, takeFocus) || other.takeFocus == takeFocus)&&(identical(other.external, external) || other.external == external));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri,selection,takeFocus,external);

@override
String toString() {
  return 'ShowDocumentParams(uri: $uri, selection: $selection, takeFocus: $takeFocus, external: $external)';
}


}

/// @nodoc
abstract mixin class _$ShowDocumentParamsCopyWith<$Res> implements $ShowDocumentParamsCopyWith<$Res> {
  factory _$ShowDocumentParamsCopyWith(_ShowDocumentParams value, $Res Function(_ShowDocumentParams) _then) = __$ShowDocumentParamsCopyWithImpl;
@override @useResult
$Res call({
 String uri, Range? selection, bool? takeFocus, bool? external
});


@override $RangeCopyWith<$Res>? get selection;

}
/// @nodoc
class __$ShowDocumentParamsCopyWithImpl<$Res>
    implements _$ShowDocumentParamsCopyWith<$Res> {
  __$ShowDocumentParamsCopyWithImpl(this._self, this._then);

  final _ShowDocumentParams _self;
  final $Res Function(_ShowDocumentParams) _then;

/// Create a copy of ShowDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? uri = null,Object? selection = freezed,Object? takeFocus = freezed,Object? external = freezed,}) {
  return _then(_ShowDocumentParams(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,selection: freezed == selection ? _self.selection : selection // ignore: cast_nullable_to_non_nullable
as Range?,takeFocus: freezed == takeFocus ? _self.takeFocus : takeFocus // ignore: cast_nullable_to_non_nullable
as bool?,external: freezed == external ? _self.external : external // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

/// Create a copy of ShowDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res>? get selection {
    if (_self.selection == null) {
    return null;
  }

  return $RangeCopyWith<$Res>(_self.selection!, (value) {
    return _then(_self.copyWith(selection: value));
  });
}
}


/// @nodoc
mixin _$ShowDocumentResult {

 bool get success;
/// Create a copy of ShowDocumentResult
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ShowDocumentResultCopyWith<ShowDocumentResult> get copyWith => _$ShowDocumentResultCopyWithImpl<ShowDocumentResult>(this as ShowDocumentResult, _$identity);

  /// Serializes this ShowDocumentResult to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ShowDocumentResult&&(identical(other.success, success) || other.success == success));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,success);

@override
String toString() {
  return 'ShowDocumentResult(success: $success)';
}


}

/// @nodoc
abstract mixin class $ShowDocumentResultCopyWith<$Res>  {
  factory $ShowDocumentResultCopyWith(ShowDocumentResult value, $Res Function(ShowDocumentResult) _then) = _$ShowDocumentResultCopyWithImpl;
@useResult
$Res call({
 bool success
});




}
/// @nodoc
class _$ShowDocumentResultCopyWithImpl<$Res>
    implements $ShowDocumentResultCopyWith<$Res> {
  _$ShowDocumentResultCopyWithImpl(this._self, this._then);

  final ShowDocumentResult _self;
  final $Res Function(ShowDocumentResult) _then;

/// Create a copy of ShowDocumentResult
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? success = null,}) {
  return _then(_self.copyWith(
success: null == success ? _self.success : success // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _ShowDocumentResult implements ShowDocumentResult {
  const _ShowDocumentResult({required this.success});
  factory _ShowDocumentResult.fromJson(Map<String, dynamic> json) => _$ShowDocumentResultFromJson(json);

@override final  bool success;

/// Create a copy of ShowDocumentResult
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ShowDocumentResultCopyWith<_ShowDocumentResult> get copyWith => __$ShowDocumentResultCopyWithImpl<_ShowDocumentResult>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ShowDocumentResultToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ShowDocumentResult&&(identical(other.success, success) || other.success == success));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,success);

@override
String toString() {
  return 'ShowDocumentResult(success: $success)';
}


}

/// @nodoc
abstract mixin class _$ShowDocumentResultCopyWith<$Res> implements $ShowDocumentResultCopyWith<$Res> {
  factory _$ShowDocumentResultCopyWith(_ShowDocumentResult value, $Res Function(_ShowDocumentResult) _then) = __$ShowDocumentResultCopyWithImpl;
@override @useResult
$Res call({
 bool success
});




}
/// @nodoc
class __$ShowDocumentResultCopyWithImpl<$Res>
    implements _$ShowDocumentResultCopyWith<$Res> {
  __$ShowDocumentResultCopyWithImpl(this._self, this._then);

  final _ShowDocumentResult _self;
  final $Res Function(_ShowDocumentResult) _then;

/// Create a copy of ShowDocumentResult
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? success = null,}) {
  return _then(_ShowDocumentResult(
success: null == success ? _self.success : success // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}


}


/// @nodoc
mixin _$LinkedEditingRangeParams {

 TextDocumentIdentifier get textDocument; Position get position; ProgressToken? get workDoneToken;
/// Create a copy of LinkedEditingRangeParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LinkedEditingRangeParamsCopyWith<LinkedEditingRangeParams> get copyWith => _$LinkedEditingRangeParamsCopyWithImpl<LinkedEditingRangeParams>(this as LinkedEditingRangeParams, _$identity);

  /// Serializes this LinkedEditingRangeParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LinkedEditingRangeParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.position, position) || other.position == position)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,position,const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'LinkedEditingRangeParams(textDocument: $textDocument, position: $position, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $LinkedEditingRangeParamsCopyWith<$Res>  {
  factory $LinkedEditingRangeParamsCopyWith(LinkedEditingRangeParams value, $Res Function(LinkedEditingRangeParams) _then) = _$LinkedEditingRangeParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument, Position position, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;$PositionCopyWith<$Res> get position;

}
/// @nodoc
class _$LinkedEditingRangeParamsCopyWithImpl<$Res>
    implements $LinkedEditingRangeParamsCopyWith<$Res> {
  _$LinkedEditingRangeParamsCopyWithImpl(this._self, this._then);

  final LinkedEditingRangeParams _self;
  final $Res Function(LinkedEditingRangeParams) _then;

/// Create a copy of LinkedEditingRangeParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? position = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of LinkedEditingRangeParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of LinkedEditingRangeParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _LinkedEditingRangeParams implements LinkedEditingRangeParams {
  const _LinkedEditingRangeParams({required this.textDocument, required this.position, this.workDoneToken});
  factory _LinkedEditingRangeParams.fromJson(Map<String, dynamic> json) => _$LinkedEditingRangeParamsFromJson(json);

@override final  TextDocumentIdentifier textDocument;
@override final  Position position;
@override final  ProgressToken? workDoneToken;

/// Create a copy of LinkedEditingRangeParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$LinkedEditingRangeParamsCopyWith<_LinkedEditingRangeParams> get copyWith => __$LinkedEditingRangeParamsCopyWithImpl<_LinkedEditingRangeParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$LinkedEditingRangeParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _LinkedEditingRangeParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.position, position) || other.position == position)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,position,const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'LinkedEditingRangeParams(textDocument: $textDocument, position: $position, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$LinkedEditingRangeParamsCopyWith<$Res> implements $LinkedEditingRangeParamsCopyWith<$Res> {
  factory _$LinkedEditingRangeParamsCopyWith(_LinkedEditingRangeParams value, $Res Function(_LinkedEditingRangeParams) _then) = __$LinkedEditingRangeParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument, Position position, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;@override $PositionCopyWith<$Res> get position;

}
/// @nodoc
class __$LinkedEditingRangeParamsCopyWithImpl<$Res>
    implements _$LinkedEditingRangeParamsCopyWith<$Res> {
  __$LinkedEditingRangeParamsCopyWithImpl(this._self, this._then);

  final _LinkedEditingRangeParams _self;
  final $Res Function(_LinkedEditingRangeParams) _then;

/// Create a copy of LinkedEditingRangeParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? position = null,Object? workDoneToken = freezed,}) {
  return _then(_LinkedEditingRangeParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of LinkedEditingRangeParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of LinkedEditingRangeParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}
}


/// @nodoc
mixin _$LinkedEditingRanges {

 List<Range> get ranges; String? get wordPattern;
/// Create a copy of LinkedEditingRanges
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LinkedEditingRangesCopyWith<LinkedEditingRanges> get copyWith => _$LinkedEditingRangesCopyWithImpl<LinkedEditingRanges>(this as LinkedEditingRanges, _$identity);

  /// Serializes this LinkedEditingRanges to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LinkedEditingRanges&&const DeepCollectionEquality().equals(other.ranges, ranges)&&(identical(other.wordPattern, wordPattern) || other.wordPattern == wordPattern));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(ranges),wordPattern);

@override
String toString() {
  return 'LinkedEditingRanges(ranges: $ranges, wordPattern: $wordPattern)';
}


}

/// @nodoc
abstract mixin class $LinkedEditingRangesCopyWith<$Res>  {
  factory $LinkedEditingRangesCopyWith(LinkedEditingRanges value, $Res Function(LinkedEditingRanges) _then) = _$LinkedEditingRangesCopyWithImpl;
@useResult
$Res call({
 List<Range> ranges, String? wordPattern
});




}
/// @nodoc
class _$LinkedEditingRangesCopyWithImpl<$Res>
    implements $LinkedEditingRangesCopyWith<$Res> {
  _$LinkedEditingRangesCopyWithImpl(this._self, this._then);

  final LinkedEditingRanges _self;
  final $Res Function(LinkedEditingRanges) _then;

/// Create a copy of LinkedEditingRanges
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? ranges = null,Object? wordPattern = freezed,}) {
  return _then(_self.copyWith(
ranges: null == ranges ? _self.ranges : ranges // ignore: cast_nullable_to_non_nullable
as List<Range>,wordPattern: freezed == wordPattern ? _self.wordPattern : wordPattern // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _LinkedEditingRanges implements LinkedEditingRanges {
  const _LinkedEditingRanges({required final  List<Range> ranges, this.wordPattern}): _ranges = ranges;
  factory _LinkedEditingRanges.fromJson(Map<String, dynamic> json) => _$LinkedEditingRangesFromJson(json);

 final  List<Range> _ranges;
@override List<Range> get ranges {
  if (_ranges is EqualUnmodifiableListView) return _ranges;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_ranges);
}

@override final  String? wordPattern;

/// Create a copy of LinkedEditingRanges
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$LinkedEditingRangesCopyWith<_LinkedEditingRanges> get copyWith => __$LinkedEditingRangesCopyWithImpl<_LinkedEditingRanges>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$LinkedEditingRangesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _LinkedEditingRanges&&const DeepCollectionEquality().equals(other._ranges, _ranges)&&(identical(other.wordPattern, wordPattern) || other.wordPattern == wordPattern));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_ranges),wordPattern);

@override
String toString() {
  return 'LinkedEditingRanges(ranges: $ranges, wordPattern: $wordPattern)';
}


}

/// @nodoc
abstract mixin class _$LinkedEditingRangesCopyWith<$Res> implements $LinkedEditingRangesCopyWith<$Res> {
  factory _$LinkedEditingRangesCopyWith(_LinkedEditingRanges value, $Res Function(_LinkedEditingRanges) _then) = __$LinkedEditingRangesCopyWithImpl;
@override @useResult
$Res call({
 List<Range> ranges, String? wordPattern
});




}
/// @nodoc
class __$LinkedEditingRangesCopyWithImpl<$Res>
    implements _$LinkedEditingRangesCopyWith<$Res> {
  __$LinkedEditingRangesCopyWithImpl(this._self, this._then);

  final _LinkedEditingRanges _self;
  final $Res Function(_LinkedEditingRanges) _then;

/// Create a copy of LinkedEditingRanges
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? ranges = null,Object? wordPattern = freezed,}) {
  return _then(_LinkedEditingRanges(
ranges: null == ranges ? _self._ranges : ranges // ignore: cast_nullable_to_non_nullable
as List<Range>,wordPattern: freezed == wordPattern ? _self.wordPattern : wordPattern // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$LinkedEditingRangeRegistrationOptions {

 dynamic get documentSelector; String? get id; bool? get workDoneProgress;
/// Create a copy of LinkedEditingRangeRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LinkedEditingRangeRegistrationOptionsCopyWith<LinkedEditingRangeRegistrationOptions> get copyWith => _$LinkedEditingRangeRegistrationOptionsCopyWithImpl<LinkedEditingRangeRegistrationOptions>(this as LinkedEditingRangeRegistrationOptions, _$identity);

  /// Serializes this LinkedEditingRangeRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LinkedEditingRangeRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.id, id) || other.id == id)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),id,workDoneProgress);

@override
String toString() {
  return 'LinkedEditingRangeRegistrationOptions(documentSelector: $documentSelector, id: $id, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $LinkedEditingRangeRegistrationOptionsCopyWith<$Res>  {
  factory $LinkedEditingRangeRegistrationOptionsCopyWith(LinkedEditingRangeRegistrationOptions value, $Res Function(LinkedEditingRangeRegistrationOptions) _then) = _$LinkedEditingRangeRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 dynamic documentSelector, String? id, bool? workDoneProgress
});




}
/// @nodoc
class _$LinkedEditingRangeRegistrationOptionsCopyWithImpl<$Res>
    implements $LinkedEditingRangeRegistrationOptionsCopyWith<$Res> {
  _$LinkedEditingRangeRegistrationOptionsCopyWithImpl(this._self, this._then);

  final LinkedEditingRangeRegistrationOptions _self;
  final $Res Function(LinkedEditingRangeRegistrationOptions) _then;

/// Create a copy of LinkedEditingRangeRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = freezed,Object? id = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _LinkedEditingRangeRegistrationOptions implements LinkedEditingRangeRegistrationOptions {
  const _LinkedEditingRangeRegistrationOptions({required this.documentSelector, this.id, this.workDoneProgress});
  factory _LinkedEditingRangeRegistrationOptions.fromJson(Map<String, dynamic> json) => _$LinkedEditingRangeRegistrationOptionsFromJson(json);

@override final  dynamic documentSelector;
@override final  String? id;
@override final  bool? workDoneProgress;

/// Create a copy of LinkedEditingRangeRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$LinkedEditingRangeRegistrationOptionsCopyWith<_LinkedEditingRangeRegistrationOptions> get copyWith => __$LinkedEditingRangeRegistrationOptionsCopyWithImpl<_LinkedEditingRangeRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$LinkedEditingRangeRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _LinkedEditingRangeRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.id, id) || other.id == id)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),id,workDoneProgress);

@override
String toString() {
  return 'LinkedEditingRangeRegistrationOptions(documentSelector: $documentSelector, id: $id, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$LinkedEditingRangeRegistrationOptionsCopyWith<$Res> implements $LinkedEditingRangeRegistrationOptionsCopyWith<$Res> {
  factory _$LinkedEditingRangeRegistrationOptionsCopyWith(_LinkedEditingRangeRegistrationOptions value, $Res Function(_LinkedEditingRangeRegistrationOptions) _then) = __$LinkedEditingRangeRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 dynamic documentSelector, String? id, bool? workDoneProgress
});




}
/// @nodoc
class __$LinkedEditingRangeRegistrationOptionsCopyWithImpl<$Res>
    implements _$LinkedEditingRangeRegistrationOptionsCopyWith<$Res> {
  __$LinkedEditingRangeRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _LinkedEditingRangeRegistrationOptions _self;
  final $Res Function(_LinkedEditingRangeRegistrationOptions) _then;

/// Create a copy of LinkedEditingRangeRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = freezed,Object? id = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_LinkedEditingRangeRegistrationOptions(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$CreateFilesParams {

 List<FileCreate> get files;
/// Create a copy of CreateFilesParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CreateFilesParamsCopyWith<CreateFilesParams> get copyWith => _$CreateFilesParamsCopyWithImpl<CreateFilesParams>(this as CreateFilesParams, _$identity);

  /// Serializes this CreateFilesParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CreateFilesParams&&const DeepCollectionEquality().equals(other.files, files));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(files));

@override
String toString() {
  return 'CreateFilesParams(files: $files)';
}


}

/// @nodoc
abstract mixin class $CreateFilesParamsCopyWith<$Res>  {
  factory $CreateFilesParamsCopyWith(CreateFilesParams value, $Res Function(CreateFilesParams) _then) = _$CreateFilesParamsCopyWithImpl;
@useResult
$Res call({
 List<FileCreate> files
});




}
/// @nodoc
class _$CreateFilesParamsCopyWithImpl<$Res>
    implements $CreateFilesParamsCopyWith<$Res> {
  _$CreateFilesParamsCopyWithImpl(this._self, this._then);

  final CreateFilesParams _self;
  final $Res Function(CreateFilesParams) _then;

/// Create a copy of CreateFilesParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? files = null,}) {
  return _then(_self.copyWith(
files: null == files ? _self.files : files // ignore: cast_nullable_to_non_nullable
as List<FileCreate>,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _CreateFilesParams implements CreateFilesParams {
  const _CreateFilesParams({required final  List<FileCreate> files}): _files = files;
  factory _CreateFilesParams.fromJson(Map<String, dynamic> json) => _$CreateFilesParamsFromJson(json);

 final  List<FileCreate> _files;
@override List<FileCreate> get files {
  if (_files is EqualUnmodifiableListView) return _files;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_files);
}


/// Create a copy of CreateFilesParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CreateFilesParamsCopyWith<_CreateFilesParams> get copyWith => __$CreateFilesParamsCopyWithImpl<_CreateFilesParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CreateFilesParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CreateFilesParams&&const DeepCollectionEquality().equals(other._files, _files));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_files));

@override
String toString() {
  return 'CreateFilesParams(files: $files)';
}


}

/// @nodoc
abstract mixin class _$CreateFilesParamsCopyWith<$Res> implements $CreateFilesParamsCopyWith<$Res> {
  factory _$CreateFilesParamsCopyWith(_CreateFilesParams value, $Res Function(_CreateFilesParams) _then) = __$CreateFilesParamsCopyWithImpl;
@override @useResult
$Res call({
 List<FileCreate> files
});




}
/// @nodoc
class __$CreateFilesParamsCopyWithImpl<$Res>
    implements _$CreateFilesParamsCopyWith<$Res> {
  __$CreateFilesParamsCopyWithImpl(this._self, this._then);

  final _CreateFilesParams _self;
  final $Res Function(_CreateFilesParams) _then;

/// Create a copy of CreateFilesParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? files = null,}) {
  return _then(_CreateFilesParams(
files: null == files ? _self._files : files // ignore: cast_nullable_to_non_nullable
as List<FileCreate>,
  ));
}


}


/// @nodoc
mixin _$WorkspaceEdit {

 Map<ChangeAnnotationIdentifier, ChangeAnnotation>? get changeAnnotations; List<dynamic>? get documentChanges; Map<String, List<TextEdit>>? get changes;
/// Create a copy of WorkspaceEdit
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkspaceEditCopyWith<WorkspaceEdit> get copyWith => _$WorkspaceEditCopyWithImpl<WorkspaceEdit>(this as WorkspaceEdit, _$identity);

  /// Serializes this WorkspaceEdit to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkspaceEdit&&const DeepCollectionEquality().equals(other.changeAnnotations, changeAnnotations)&&const DeepCollectionEquality().equals(other.documentChanges, documentChanges)&&const DeepCollectionEquality().equals(other.changes, changes));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(changeAnnotations),const DeepCollectionEquality().hash(documentChanges),const DeepCollectionEquality().hash(changes));

@override
String toString() {
  return 'WorkspaceEdit(changeAnnotations: $changeAnnotations, documentChanges: $documentChanges, changes: $changes)';
}


}

/// @nodoc
abstract mixin class $WorkspaceEditCopyWith<$Res>  {
  factory $WorkspaceEditCopyWith(WorkspaceEdit value, $Res Function(WorkspaceEdit) _then) = _$WorkspaceEditCopyWithImpl;
@useResult
$Res call({
 Map<ChangeAnnotationIdentifier, ChangeAnnotation>? changeAnnotations, List<dynamic>? documentChanges, Map<String, List<TextEdit>>? changes
});




}
/// @nodoc
class _$WorkspaceEditCopyWithImpl<$Res>
    implements $WorkspaceEditCopyWith<$Res> {
  _$WorkspaceEditCopyWithImpl(this._self, this._then);

  final WorkspaceEdit _self;
  final $Res Function(WorkspaceEdit) _then;

/// Create a copy of WorkspaceEdit
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? changeAnnotations = freezed,Object? documentChanges = freezed,Object? changes = freezed,}) {
  return _then(_self.copyWith(
changeAnnotations: freezed == changeAnnotations ? _self.changeAnnotations : changeAnnotations // ignore: cast_nullable_to_non_nullable
as Map<ChangeAnnotationIdentifier, ChangeAnnotation>?,documentChanges: freezed == documentChanges ? _self.documentChanges : documentChanges // ignore: cast_nullable_to_non_nullable
as List<dynamic>?,changes: freezed == changes ? _self.changes : changes // ignore: cast_nullable_to_non_nullable
as Map<String, List<TextEdit>>?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _WorkspaceEdit implements WorkspaceEdit {
  const _WorkspaceEdit({final  Map<ChangeAnnotationIdentifier, ChangeAnnotation>? changeAnnotations, final  List<dynamic>? documentChanges, final  Map<String, List<TextEdit>>? changes}): _changeAnnotations = changeAnnotations,_documentChanges = documentChanges,_changes = changes;
  factory _WorkspaceEdit.fromJson(Map<String, dynamic> json) => _$WorkspaceEditFromJson(json);

 final  Map<ChangeAnnotationIdentifier, ChangeAnnotation>? _changeAnnotations;
@override Map<ChangeAnnotationIdentifier, ChangeAnnotation>? get changeAnnotations {
  final value = _changeAnnotations;
  if (value == null) return null;
  if (_changeAnnotations is EqualUnmodifiableMapView) return _changeAnnotations;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(value);
}

 final  List<dynamic>? _documentChanges;
@override List<dynamic>? get documentChanges {
  final value = _documentChanges;
  if (value == null) return null;
  if (_documentChanges is EqualUnmodifiableListView) return _documentChanges;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

 final  Map<String, List<TextEdit>>? _changes;
@override Map<String, List<TextEdit>>? get changes {
  final value = _changes;
  if (value == null) return null;
  if (_changes is EqualUnmodifiableMapView) return _changes;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(value);
}


/// Create a copy of WorkspaceEdit
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkspaceEditCopyWith<_WorkspaceEdit> get copyWith => __$WorkspaceEditCopyWithImpl<_WorkspaceEdit>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkspaceEditToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkspaceEdit&&const DeepCollectionEquality().equals(other._changeAnnotations, _changeAnnotations)&&const DeepCollectionEquality().equals(other._documentChanges, _documentChanges)&&const DeepCollectionEquality().equals(other._changes, _changes));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_changeAnnotations),const DeepCollectionEquality().hash(_documentChanges),const DeepCollectionEquality().hash(_changes));

@override
String toString() {
  return 'WorkspaceEdit(changeAnnotations: $changeAnnotations, documentChanges: $documentChanges, changes: $changes)';
}


}

/// @nodoc
abstract mixin class _$WorkspaceEditCopyWith<$Res> implements $WorkspaceEditCopyWith<$Res> {
  factory _$WorkspaceEditCopyWith(_WorkspaceEdit value, $Res Function(_WorkspaceEdit) _then) = __$WorkspaceEditCopyWithImpl;
@override @useResult
$Res call({
 Map<ChangeAnnotationIdentifier, ChangeAnnotation>? changeAnnotations, List<dynamic>? documentChanges, Map<String, List<TextEdit>>? changes
});




}
/// @nodoc
class __$WorkspaceEditCopyWithImpl<$Res>
    implements _$WorkspaceEditCopyWith<$Res> {
  __$WorkspaceEditCopyWithImpl(this._self, this._then);

  final _WorkspaceEdit _self;
  final $Res Function(_WorkspaceEdit) _then;

/// Create a copy of WorkspaceEdit
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? changeAnnotations = freezed,Object? documentChanges = freezed,Object? changes = freezed,}) {
  return _then(_WorkspaceEdit(
changeAnnotations: freezed == changeAnnotations ? _self._changeAnnotations : changeAnnotations // ignore: cast_nullable_to_non_nullable
as Map<ChangeAnnotationIdentifier, ChangeAnnotation>?,documentChanges: freezed == documentChanges ? _self._documentChanges : documentChanges // ignore: cast_nullable_to_non_nullable
as List<dynamic>?,changes: freezed == changes ? _self._changes : changes // ignore: cast_nullable_to_non_nullable
as Map<String, List<TextEdit>>?,
  ));
}


}


/// @nodoc
mixin _$FileOperationRegistrationOptions {

 List<FileOperationFilter> get filters;
/// Create a copy of FileOperationRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FileOperationRegistrationOptionsCopyWith<FileOperationRegistrationOptions> get copyWith => _$FileOperationRegistrationOptionsCopyWithImpl<FileOperationRegistrationOptions>(this as FileOperationRegistrationOptions, _$identity);

  /// Serializes this FileOperationRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FileOperationRegistrationOptions&&const DeepCollectionEquality().equals(other.filters, filters));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(filters));

@override
String toString() {
  return 'FileOperationRegistrationOptions(filters: $filters)';
}


}

/// @nodoc
abstract mixin class $FileOperationRegistrationOptionsCopyWith<$Res>  {
  factory $FileOperationRegistrationOptionsCopyWith(FileOperationRegistrationOptions value, $Res Function(FileOperationRegistrationOptions) _then) = _$FileOperationRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 List<FileOperationFilter> filters
});




}
/// @nodoc
class _$FileOperationRegistrationOptionsCopyWithImpl<$Res>
    implements $FileOperationRegistrationOptionsCopyWith<$Res> {
  _$FileOperationRegistrationOptionsCopyWithImpl(this._self, this._then);

  final FileOperationRegistrationOptions _self;
  final $Res Function(FileOperationRegistrationOptions) _then;

/// Create a copy of FileOperationRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? filters = null,}) {
  return _then(_self.copyWith(
filters: null == filters ? _self.filters : filters // ignore: cast_nullable_to_non_nullable
as List<FileOperationFilter>,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _FileOperationRegistrationOptions implements FileOperationRegistrationOptions {
  const _FileOperationRegistrationOptions({required final  List<FileOperationFilter> filters}): _filters = filters;
  factory _FileOperationRegistrationOptions.fromJson(Map<String, dynamic> json) => _$FileOperationRegistrationOptionsFromJson(json);

 final  List<FileOperationFilter> _filters;
@override List<FileOperationFilter> get filters {
  if (_filters is EqualUnmodifiableListView) return _filters;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_filters);
}


/// Create a copy of FileOperationRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$FileOperationRegistrationOptionsCopyWith<_FileOperationRegistrationOptions> get copyWith => __$FileOperationRegistrationOptionsCopyWithImpl<_FileOperationRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$FileOperationRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _FileOperationRegistrationOptions&&const DeepCollectionEquality().equals(other._filters, _filters));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_filters));

@override
String toString() {
  return 'FileOperationRegistrationOptions(filters: $filters)';
}


}

/// @nodoc
abstract mixin class _$FileOperationRegistrationOptionsCopyWith<$Res> implements $FileOperationRegistrationOptionsCopyWith<$Res> {
  factory _$FileOperationRegistrationOptionsCopyWith(_FileOperationRegistrationOptions value, $Res Function(_FileOperationRegistrationOptions) _then) = __$FileOperationRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 List<FileOperationFilter> filters
});




}
/// @nodoc
class __$FileOperationRegistrationOptionsCopyWithImpl<$Res>
    implements _$FileOperationRegistrationOptionsCopyWith<$Res> {
  __$FileOperationRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _FileOperationRegistrationOptions _self;
  final $Res Function(_FileOperationRegistrationOptions) _then;

/// Create a copy of FileOperationRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? filters = null,}) {
  return _then(_FileOperationRegistrationOptions(
filters: null == filters ? _self._filters : filters // ignore: cast_nullable_to_non_nullable
as List<FileOperationFilter>,
  ));
}


}


/// @nodoc
mixin _$RenameFilesParams {

 List<FileRename> get files;
/// Create a copy of RenameFilesParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RenameFilesParamsCopyWith<RenameFilesParams> get copyWith => _$RenameFilesParamsCopyWithImpl<RenameFilesParams>(this as RenameFilesParams, _$identity);

  /// Serializes this RenameFilesParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RenameFilesParams&&const DeepCollectionEquality().equals(other.files, files));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(files));

@override
String toString() {
  return 'RenameFilesParams(files: $files)';
}


}

/// @nodoc
abstract mixin class $RenameFilesParamsCopyWith<$Res>  {
  factory $RenameFilesParamsCopyWith(RenameFilesParams value, $Res Function(RenameFilesParams) _then) = _$RenameFilesParamsCopyWithImpl;
@useResult
$Res call({
 List<FileRename> files
});




}
/// @nodoc
class _$RenameFilesParamsCopyWithImpl<$Res>
    implements $RenameFilesParamsCopyWith<$Res> {
  _$RenameFilesParamsCopyWithImpl(this._self, this._then);

  final RenameFilesParams _self;
  final $Res Function(RenameFilesParams) _then;

/// Create a copy of RenameFilesParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? files = null,}) {
  return _then(_self.copyWith(
files: null == files ? _self.files : files // ignore: cast_nullable_to_non_nullable
as List<FileRename>,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _RenameFilesParams implements RenameFilesParams {
  const _RenameFilesParams({required final  List<FileRename> files}): _files = files;
  factory _RenameFilesParams.fromJson(Map<String, dynamic> json) => _$RenameFilesParamsFromJson(json);

 final  List<FileRename> _files;
@override List<FileRename> get files {
  if (_files is EqualUnmodifiableListView) return _files;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_files);
}


/// Create a copy of RenameFilesParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RenameFilesParamsCopyWith<_RenameFilesParams> get copyWith => __$RenameFilesParamsCopyWithImpl<_RenameFilesParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$RenameFilesParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _RenameFilesParams&&const DeepCollectionEquality().equals(other._files, _files));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_files));

@override
String toString() {
  return 'RenameFilesParams(files: $files)';
}


}

/// @nodoc
abstract mixin class _$RenameFilesParamsCopyWith<$Res> implements $RenameFilesParamsCopyWith<$Res> {
  factory _$RenameFilesParamsCopyWith(_RenameFilesParams value, $Res Function(_RenameFilesParams) _then) = __$RenameFilesParamsCopyWithImpl;
@override @useResult
$Res call({
 List<FileRename> files
});




}
/// @nodoc
class __$RenameFilesParamsCopyWithImpl<$Res>
    implements _$RenameFilesParamsCopyWith<$Res> {
  __$RenameFilesParamsCopyWithImpl(this._self, this._then);

  final _RenameFilesParams _self;
  final $Res Function(_RenameFilesParams) _then;

/// Create a copy of RenameFilesParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? files = null,}) {
  return _then(_RenameFilesParams(
files: null == files ? _self._files : files // ignore: cast_nullable_to_non_nullable
as List<FileRename>,
  ));
}


}


/// @nodoc
mixin _$DeleteFilesParams {

 List<FileDelete> get files;
/// Create a copy of DeleteFilesParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DeleteFilesParamsCopyWith<DeleteFilesParams> get copyWith => _$DeleteFilesParamsCopyWithImpl<DeleteFilesParams>(this as DeleteFilesParams, _$identity);

  /// Serializes this DeleteFilesParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DeleteFilesParams&&const DeepCollectionEquality().equals(other.files, files));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(files));

@override
String toString() {
  return 'DeleteFilesParams(files: $files)';
}


}

/// @nodoc
abstract mixin class $DeleteFilesParamsCopyWith<$Res>  {
  factory $DeleteFilesParamsCopyWith(DeleteFilesParams value, $Res Function(DeleteFilesParams) _then) = _$DeleteFilesParamsCopyWithImpl;
@useResult
$Res call({
 List<FileDelete> files
});




}
/// @nodoc
class _$DeleteFilesParamsCopyWithImpl<$Res>
    implements $DeleteFilesParamsCopyWith<$Res> {
  _$DeleteFilesParamsCopyWithImpl(this._self, this._then);

  final DeleteFilesParams _self;
  final $Res Function(DeleteFilesParams) _then;

/// Create a copy of DeleteFilesParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? files = null,}) {
  return _then(_self.copyWith(
files: null == files ? _self.files : files // ignore: cast_nullable_to_non_nullable
as List<FileDelete>,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DeleteFilesParams implements DeleteFilesParams {
  const _DeleteFilesParams({required final  List<FileDelete> files}): _files = files;
  factory _DeleteFilesParams.fromJson(Map<String, dynamic> json) => _$DeleteFilesParamsFromJson(json);

 final  List<FileDelete> _files;
@override List<FileDelete> get files {
  if (_files is EqualUnmodifiableListView) return _files;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_files);
}


/// Create a copy of DeleteFilesParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DeleteFilesParamsCopyWith<_DeleteFilesParams> get copyWith => __$DeleteFilesParamsCopyWithImpl<_DeleteFilesParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DeleteFilesParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DeleteFilesParams&&const DeepCollectionEquality().equals(other._files, _files));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_files));

@override
String toString() {
  return 'DeleteFilesParams(files: $files)';
}


}

/// @nodoc
abstract mixin class _$DeleteFilesParamsCopyWith<$Res> implements $DeleteFilesParamsCopyWith<$Res> {
  factory _$DeleteFilesParamsCopyWith(_DeleteFilesParams value, $Res Function(_DeleteFilesParams) _then) = __$DeleteFilesParamsCopyWithImpl;
@override @useResult
$Res call({
 List<FileDelete> files
});




}
/// @nodoc
class __$DeleteFilesParamsCopyWithImpl<$Res>
    implements _$DeleteFilesParamsCopyWith<$Res> {
  __$DeleteFilesParamsCopyWithImpl(this._self, this._then);

  final _DeleteFilesParams _self;
  final $Res Function(_DeleteFilesParams) _then;

/// Create a copy of DeleteFilesParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? files = null,}) {
  return _then(_DeleteFilesParams(
files: null == files ? _self._files : files // ignore: cast_nullable_to_non_nullable
as List<FileDelete>,
  ));
}


}


/// @nodoc
mixin _$MonikerParams {

 TextDocumentIdentifier get textDocument; Position get position; ProgressToken? get partialResultToken; ProgressToken? get workDoneToken;
/// Create a copy of MonikerParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$MonikerParamsCopyWith<MonikerParams> get copyWith => _$MonikerParamsCopyWithImpl<MonikerParams>(this as MonikerParams, _$identity);

  /// Serializes this MonikerParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is MonikerParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.position, position) || other.position == position)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,position,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'MonikerParams(textDocument: $textDocument, position: $position, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $MonikerParamsCopyWith<$Res>  {
  factory $MonikerParamsCopyWith(MonikerParams value, $Res Function(MonikerParams) _then) = _$MonikerParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument, Position position, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;$PositionCopyWith<$Res> get position;

}
/// @nodoc
class _$MonikerParamsCopyWithImpl<$Res>
    implements $MonikerParamsCopyWith<$Res> {
  _$MonikerParamsCopyWithImpl(this._self, this._then);

  final MonikerParams _self;
  final $Res Function(MonikerParams) _then;

/// Create a copy of MonikerParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? position = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of MonikerParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of MonikerParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _MonikerParams implements MonikerParams {
  const _MonikerParams({required this.textDocument, required this.position, this.partialResultToken, this.workDoneToken});
  factory _MonikerParams.fromJson(Map<String, dynamic> json) => _$MonikerParamsFromJson(json);

@override final  TextDocumentIdentifier textDocument;
@override final  Position position;
@override final  ProgressToken? partialResultToken;
@override final  ProgressToken? workDoneToken;

/// Create a copy of MonikerParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$MonikerParamsCopyWith<_MonikerParams> get copyWith => __$MonikerParamsCopyWithImpl<_MonikerParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$MonikerParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _MonikerParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.position, position) || other.position == position)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,position,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'MonikerParams(textDocument: $textDocument, position: $position, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$MonikerParamsCopyWith<$Res> implements $MonikerParamsCopyWith<$Res> {
  factory _$MonikerParamsCopyWith(_MonikerParams value, $Res Function(_MonikerParams) _then) = __$MonikerParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument, Position position, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;@override $PositionCopyWith<$Res> get position;

}
/// @nodoc
class __$MonikerParamsCopyWithImpl<$Res>
    implements _$MonikerParamsCopyWith<$Res> {
  __$MonikerParamsCopyWithImpl(this._self, this._then);

  final _MonikerParams _self;
  final $Res Function(_MonikerParams) _then;

/// Create a copy of MonikerParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? position = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_MonikerParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of MonikerParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of MonikerParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}
}


/// @nodoc
mixin _$Moniker {

 String get scheme; String get identifier; UniquenessLevel get unique; MonikerKind? get kind;
/// Create a copy of Moniker
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$MonikerCopyWith<Moniker> get copyWith => _$MonikerCopyWithImpl<Moniker>(this as Moniker, _$identity);

  /// Serializes this Moniker to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Moniker&&(identical(other.scheme, scheme) || other.scheme == scheme)&&(identical(other.identifier, identifier) || other.identifier == identifier)&&(identical(other.unique, unique) || other.unique == unique)&&(identical(other.kind, kind) || other.kind == kind));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,scheme,identifier,unique,kind);

@override
String toString() {
  return 'Moniker(scheme: $scheme, identifier: $identifier, unique: $unique, kind: $kind)';
}


}

/// @nodoc
abstract mixin class $MonikerCopyWith<$Res>  {
  factory $MonikerCopyWith(Moniker value, $Res Function(Moniker) _then) = _$MonikerCopyWithImpl;
@useResult
$Res call({
 String scheme, String identifier, UniquenessLevel unique, MonikerKind? kind
});




}
/// @nodoc
class _$MonikerCopyWithImpl<$Res>
    implements $MonikerCopyWith<$Res> {
  _$MonikerCopyWithImpl(this._self, this._then);

  final Moniker _self;
  final $Res Function(Moniker) _then;

/// Create a copy of Moniker
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? scheme = null,Object? identifier = null,Object? unique = null,Object? kind = freezed,}) {
  return _then(_self.copyWith(
scheme: null == scheme ? _self.scheme : scheme // ignore: cast_nullable_to_non_nullable
as String,identifier: null == identifier ? _self.identifier : identifier // ignore: cast_nullable_to_non_nullable
as String,unique: null == unique ? _self.unique : unique // ignore: cast_nullable_to_non_nullable
as UniquenessLevel,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as MonikerKind?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _Moniker implements Moniker {
  const _Moniker({required this.scheme, required this.identifier, required this.unique, this.kind});
  factory _Moniker.fromJson(Map<String, dynamic> json) => _$MonikerFromJson(json);

@override final  String scheme;
@override final  String identifier;
@override final  UniquenessLevel unique;
@override final  MonikerKind? kind;

/// Create a copy of Moniker
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$MonikerCopyWith<_Moniker> get copyWith => __$MonikerCopyWithImpl<_Moniker>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$MonikerToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _Moniker&&(identical(other.scheme, scheme) || other.scheme == scheme)&&(identical(other.identifier, identifier) || other.identifier == identifier)&&(identical(other.unique, unique) || other.unique == unique)&&(identical(other.kind, kind) || other.kind == kind));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,scheme,identifier,unique,kind);

@override
String toString() {
  return 'Moniker(scheme: $scheme, identifier: $identifier, unique: $unique, kind: $kind)';
}


}

/// @nodoc
abstract mixin class _$MonikerCopyWith<$Res> implements $MonikerCopyWith<$Res> {
  factory _$MonikerCopyWith(_Moniker value, $Res Function(_Moniker) _then) = __$MonikerCopyWithImpl;
@override @useResult
$Res call({
 String scheme, String identifier, UniquenessLevel unique, MonikerKind? kind
});




}
/// @nodoc
class __$MonikerCopyWithImpl<$Res>
    implements _$MonikerCopyWith<$Res> {
  __$MonikerCopyWithImpl(this._self, this._then);

  final _Moniker _self;
  final $Res Function(_Moniker) _then;

/// Create a copy of Moniker
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? scheme = null,Object? identifier = null,Object? unique = null,Object? kind = freezed,}) {
  return _then(_Moniker(
scheme: null == scheme ? _self.scheme : scheme // ignore: cast_nullable_to_non_nullable
as String,identifier: null == identifier ? _self.identifier : identifier // ignore: cast_nullable_to_non_nullable
as String,unique: null == unique ? _self.unique : unique // ignore: cast_nullable_to_non_nullable
as UniquenessLevel,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as MonikerKind?,
  ));
}


}


/// @nodoc
mixin _$MonikerRegistrationOptions {

 dynamic get documentSelector; bool? get workDoneProgress;
/// Create a copy of MonikerRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$MonikerRegistrationOptionsCopyWith<MonikerRegistrationOptions> get copyWith => _$MonikerRegistrationOptionsCopyWithImpl<MonikerRegistrationOptions>(this as MonikerRegistrationOptions, _$identity);

  /// Serializes this MonikerRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is MonikerRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),workDoneProgress);

@override
String toString() {
  return 'MonikerRegistrationOptions(documentSelector: $documentSelector, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $MonikerRegistrationOptionsCopyWith<$Res>  {
  factory $MonikerRegistrationOptionsCopyWith(MonikerRegistrationOptions value, $Res Function(MonikerRegistrationOptions) _then) = _$MonikerRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 dynamic documentSelector, bool? workDoneProgress
});




}
/// @nodoc
class _$MonikerRegistrationOptionsCopyWithImpl<$Res>
    implements $MonikerRegistrationOptionsCopyWith<$Res> {
  _$MonikerRegistrationOptionsCopyWithImpl(this._self, this._then);

  final MonikerRegistrationOptions _self;
  final $Res Function(MonikerRegistrationOptions) _then;

/// Create a copy of MonikerRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _MonikerRegistrationOptions implements MonikerRegistrationOptions {
  const _MonikerRegistrationOptions({required this.documentSelector, this.workDoneProgress});
  factory _MonikerRegistrationOptions.fromJson(Map<String, dynamic> json) => _$MonikerRegistrationOptionsFromJson(json);

@override final  dynamic documentSelector;
@override final  bool? workDoneProgress;

/// Create a copy of MonikerRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$MonikerRegistrationOptionsCopyWith<_MonikerRegistrationOptions> get copyWith => __$MonikerRegistrationOptionsCopyWithImpl<_MonikerRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$MonikerRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _MonikerRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),workDoneProgress);

@override
String toString() {
  return 'MonikerRegistrationOptions(documentSelector: $documentSelector, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$MonikerRegistrationOptionsCopyWith<$Res> implements $MonikerRegistrationOptionsCopyWith<$Res> {
  factory _$MonikerRegistrationOptionsCopyWith(_MonikerRegistrationOptions value, $Res Function(_MonikerRegistrationOptions) _then) = __$MonikerRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 dynamic documentSelector, bool? workDoneProgress
});




}
/// @nodoc
class __$MonikerRegistrationOptionsCopyWithImpl<$Res>
    implements _$MonikerRegistrationOptionsCopyWith<$Res> {
  __$MonikerRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _MonikerRegistrationOptions _self;
  final $Res Function(_MonikerRegistrationOptions) _then;

/// Create a copy of MonikerRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_MonikerRegistrationOptions(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$TypeHierarchyPrepareParams {

 TextDocumentIdentifier get textDocument; Position get position; ProgressToken? get workDoneToken;
/// Create a copy of TypeHierarchyPrepareParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TypeHierarchyPrepareParamsCopyWith<TypeHierarchyPrepareParams> get copyWith => _$TypeHierarchyPrepareParamsCopyWithImpl<TypeHierarchyPrepareParams>(this as TypeHierarchyPrepareParams, _$identity);

  /// Serializes this TypeHierarchyPrepareParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TypeHierarchyPrepareParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.position, position) || other.position == position)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,position,const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'TypeHierarchyPrepareParams(textDocument: $textDocument, position: $position, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $TypeHierarchyPrepareParamsCopyWith<$Res>  {
  factory $TypeHierarchyPrepareParamsCopyWith(TypeHierarchyPrepareParams value, $Res Function(TypeHierarchyPrepareParams) _then) = _$TypeHierarchyPrepareParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument, Position position, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;$PositionCopyWith<$Res> get position;

}
/// @nodoc
class _$TypeHierarchyPrepareParamsCopyWithImpl<$Res>
    implements $TypeHierarchyPrepareParamsCopyWith<$Res> {
  _$TypeHierarchyPrepareParamsCopyWithImpl(this._self, this._then);

  final TypeHierarchyPrepareParams _self;
  final $Res Function(TypeHierarchyPrepareParams) _then;

/// Create a copy of TypeHierarchyPrepareParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? position = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of TypeHierarchyPrepareParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of TypeHierarchyPrepareParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _TypeHierarchyPrepareParams implements TypeHierarchyPrepareParams {
  const _TypeHierarchyPrepareParams({required this.textDocument, required this.position, this.workDoneToken});
  factory _TypeHierarchyPrepareParams.fromJson(Map<String, dynamic> json) => _$TypeHierarchyPrepareParamsFromJson(json);

@override final  TextDocumentIdentifier textDocument;
@override final  Position position;
@override final  ProgressToken? workDoneToken;

/// Create a copy of TypeHierarchyPrepareParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TypeHierarchyPrepareParamsCopyWith<_TypeHierarchyPrepareParams> get copyWith => __$TypeHierarchyPrepareParamsCopyWithImpl<_TypeHierarchyPrepareParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TypeHierarchyPrepareParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TypeHierarchyPrepareParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.position, position) || other.position == position)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,position,const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'TypeHierarchyPrepareParams(textDocument: $textDocument, position: $position, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$TypeHierarchyPrepareParamsCopyWith<$Res> implements $TypeHierarchyPrepareParamsCopyWith<$Res> {
  factory _$TypeHierarchyPrepareParamsCopyWith(_TypeHierarchyPrepareParams value, $Res Function(_TypeHierarchyPrepareParams) _then) = __$TypeHierarchyPrepareParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument, Position position, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;@override $PositionCopyWith<$Res> get position;

}
/// @nodoc
class __$TypeHierarchyPrepareParamsCopyWithImpl<$Res>
    implements _$TypeHierarchyPrepareParamsCopyWith<$Res> {
  __$TypeHierarchyPrepareParamsCopyWithImpl(this._self, this._then);

  final _TypeHierarchyPrepareParams _self;
  final $Res Function(_TypeHierarchyPrepareParams) _then;

/// Create a copy of TypeHierarchyPrepareParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? position = null,Object? workDoneToken = freezed,}) {
  return _then(_TypeHierarchyPrepareParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of TypeHierarchyPrepareParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of TypeHierarchyPrepareParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}
}


/// @nodoc
mixin _$TypeHierarchyItem {

 String get name; SymbolKind get kind; String get uri; Range get range; Range get selectionRange; LSPAny? get data; String? get detail; List<SymbolTag>? get tags;
/// Create a copy of TypeHierarchyItem
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TypeHierarchyItemCopyWith<TypeHierarchyItem> get copyWith => _$TypeHierarchyItemCopyWithImpl<TypeHierarchyItem>(this as TypeHierarchyItem, _$identity);

  /// Serializes this TypeHierarchyItem to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TypeHierarchyItem&&(identical(other.name, name) || other.name == name)&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.range, range) || other.range == range)&&(identical(other.selectionRange, selectionRange) || other.selectionRange == selectionRange)&&const DeepCollectionEquality().equals(other.data, data)&&(identical(other.detail, detail) || other.detail == detail)&&const DeepCollectionEquality().equals(other.tags, tags));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,name,kind,uri,range,selectionRange,const DeepCollectionEquality().hash(data),detail,const DeepCollectionEquality().hash(tags));

@override
String toString() {
  return 'TypeHierarchyItem(name: $name, kind: $kind, uri: $uri, range: $range, selectionRange: $selectionRange, data: $data, detail: $detail, tags: $tags)';
}


}

/// @nodoc
abstract mixin class $TypeHierarchyItemCopyWith<$Res>  {
  factory $TypeHierarchyItemCopyWith(TypeHierarchyItem value, $Res Function(TypeHierarchyItem) _then) = _$TypeHierarchyItemCopyWithImpl;
@useResult
$Res call({
 String name, SymbolKind kind, String uri, Range range, Range selectionRange, LSPAny? data, String? detail, List<SymbolTag>? tags
});


$RangeCopyWith<$Res> get range;$RangeCopyWith<$Res> get selectionRange;

}
/// @nodoc
class _$TypeHierarchyItemCopyWithImpl<$Res>
    implements $TypeHierarchyItemCopyWith<$Res> {
  _$TypeHierarchyItemCopyWithImpl(this._self, this._then);

  final TypeHierarchyItem _self;
  final $Res Function(TypeHierarchyItem) _then;

/// Create a copy of TypeHierarchyItem
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? name = null,Object? kind = null,Object? uri = null,Object? range = null,Object? selectionRange = null,Object? data = freezed,Object? detail = freezed,Object? tags = freezed,}) {
  return _then(_self.copyWith(
name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as SymbolKind,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,selectionRange: null == selectionRange ? _self.selectionRange : selectionRange // ignore: cast_nullable_to_non_nullable
as Range,data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LSPAny?,detail: freezed == detail ? _self.detail : detail // ignore: cast_nullable_to_non_nullable
as String?,tags: freezed == tags ? _self.tags : tags // ignore: cast_nullable_to_non_nullable
as List<SymbolTag>?,
  ));
}
/// Create a copy of TypeHierarchyItem
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}/// Create a copy of TypeHierarchyItem
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get selectionRange {
  
  return $RangeCopyWith<$Res>(_self.selectionRange, (value) {
    return _then(_self.copyWith(selectionRange: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _TypeHierarchyItem implements TypeHierarchyItem {
  const _TypeHierarchyItem({required this.name, required this.kind, required this.uri, required this.range, required this.selectionRange, this.data, this.detail, final  List<SymbolTag>? tags}): _tags = tags;
  factory _TypeHierarchyItem.fromJson(Map<String, dynamic> json) => _$TypeHierarchyItemFromJson(json);

@override final  String name;
@override final  SymbolKind kind;
@override final  String uri;
@override final  Range range;
@override final  Range selectionRange;
@override final  LSPAny? data;
@override final  String? detail;
 final  List<SymbolTag>? _tags;
@override List<SymbolTag>? get tags {
  final value = _tags;
  if (value == null) return null;
  if (_tags is EqualUnmodifiableListView) return _tags;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}


/// Create a copy of TypeHierarchyItem
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TypeHierarchyItemCopyWith<_TypeHierarchyItem> get copyWith => __$TypeHierarchyItemCopyWithImpl<_TypeHierarchyItem>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TypeHierarchyItemToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TypeHierarchyItem&&(identical(other.name, name) || other.name == name)&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.range, range) || other.range == range)&&(identical(other.selectionRange, selectionRange) || other.selectionRange == selectionRange)&&const DeepCollectionEquality().equals(other.data, data)&&(identical(other.detail, detail) || other.detail == detail)&&const DeepCollectionEquality().equals(other._tags, _tags));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,name,kind,uri,range,selectionRange,const DeepCollectionEquality().hash(data),detail,const DeepCollectionEquality().hash(_tags));

@override
String toString() {
  return 'TypeHierarchyItem(name: $name, kind: $kind, uri: $uri, range: $range, selectionRange: $selectionRange, data: $data, detail: $detail, tags: $tags)';
}


}

/// @nodoc
abstract mixin class _$TypeHierarchyItemCopyWith<$Res> implements $TypeHierarchyItemCopyWith<$Res> {
  factory _$TypeHierarchyItemCopyWith(_TypeHierarchyItem value, $Res Function(_TypeHierarchyItem) _then) = __$TypeHierarchyItemCopyWithImpl;
@override @useResult
$Res call({
 String name, SymbolKind kind, String uri, Range range, Range selectionRange, LSPAny? data, String? detail, List<SymbolTag>? tags
});


@override $RangeCopyWith<$Res> get range;@override $RangeCopyWith<$Res> get selectionRange;

}
/// @nodoc
class __$TypeHierarchyItemCopyWithImpl<$Res>
    implements _$TypeHierarchyItemCopyWith<$Res> {
  __$TypeHierarchyItemCopyWithImpl(this._self, this._then);

  final _TypeHierarchyItem _self;
  final $Res Function(_TypeHierarchyItem) _then;

/// Create a copy of TypeHierarchyItem
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? name = null,Object? kind = null,Object? uri = null,Object? range = null,Object? selectionRange = null,Object? data = freezed,Object? detail = freezed,Object? tags = freezed,}) {
  return _then(_TypeHierarchyItem(
name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as SymbolKind,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,selectionRange: null == selectionRange ? _self.selectionRange : selectionRange // ignore: cast_nullable_to_non_nullable
as Range,data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LSPAny?,detail: freezed == detail ? _self.detail : detail // ignore: cast_nullable_to_non_nullable
as String?,tags: freezed == tags ? _self._tags : tags // ignore: cast_nullable_to_non_nullable
as List<SymbolTag>?,
  ));
}

/// Create a copy of TypeHierarchyItem
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}/// Create a copy of TypeHierarchyItem
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get selectionRange {
  
  return $RangeCopyWith<$Res>(_self.selectionRange, (value) {
    return _then(_self.copyWith(selectionRange: value));
  });
}
}


/// @nodoc
mixin _$TypeHierarchyRegistrationOptions {

 dynamic get documentSelector; String? get id; bool? get workDoneProgress;
/// Create a copy of TypeHierarchyRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TypeHierarchyRegistrationOptionsCopyWith<TypeHierarchyRegistrationOptions> get copyWith => _$TypeHierarchyRegistrationOptionsCopyWithImpl<TypeHierarchyRegistrationOptions>(this as TypeHierarchyRegistrationOptions, _$identity);

  /// Serializes this TypeHierarchyRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TypeHierarchyRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.id, id) || other.id == id)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),id,workDoneProgress);

@override
String toString() {
  return 'TypeHierarchyRegistrationOptions(documentSelector: $documentSelector, id: $id, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $TypeHierarchyRegistrationOptionsCopyWith<$Res>  {
  factory $TypeHierarchyRegistrationOptionsCopyWith(TypeHierarchyRegistrationOptions value, $Res Function(TypeHierarchyRegistrationOptions) _then) = _$TypeHierarchyRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 dynamic documentSelector, String? id, bool? workDoneProgress
});




}
/// @nodoc
class _$TypeHierarchyRegistrationOptionsCopyWithImpl<$Res>
    implements $TypeHierarchyRegistrationOptionsCopyWith<$Res> {
  _$TypeHierarchyRegistrationOptionsCopyWithImpl(this._self, this._then);

  final TypeHierarchyRegistrationOptions _self;
  final $Res Function(TypeHierarchyRegistrationOptions) _then;

/// Create a copy of TypeHierarchyRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = freezed,Object? id = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _TypeHierarchyRegistrationOptions implements TypeHierarchyRegistrationOptions {
  const _TypeHierarchyRegistrationOptions({required this.documentSelector, this.id, this.workDoneProgress});
  factory _TypeHierarchyRegistrationOptions.fromJson(Map<String, dynamic> json) => _$TypeHierarchyRegistrationOptionsFromJson(json);

@override final  dynamic documentSelector;
@override final  String? id;
@override final  bool? workDoneProgress;

/// Create a copy of TypeHierarchyRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TypeHierarchyRegistrationOptionsCopyWith<_TypeHierarchyRegistrationOptions> get copyWith => __$TypeHierarchyRegistrationOptionsCopyWithImpl<_TypeHierarchyRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TypeHierarchyRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TypeHierarchyRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.id, id) || other.id == id)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),id,workDoneProgress);

@override
String toString() {
  return 'TypeHierarchyRegistrationOptions(documentSelector: $documentSelector, id: $id, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$TypeHierarchyRegistrationOptionsCopyWith<$Res> implements $TypeHierarchyRegistrationOptionsCopyWith<$Res> {
  factory _$TypeHierarchyRegistrationOptionsCopyWith(_TypeHierarchyRegistrationOptions value, $Res Function(_TypeHierarchyRegistrationOptions) _then) = __$TypeHierarchyRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 dynamic documentSelector, String? id, bool? workDoneProgress
});




}
/// @nodoc
class __$TypeHierarchyRegistrationOptionsCopyWithImpl<$Res>
    implements _$TypeHierarchyRegistrationOptionsCopyWith<$Res> {
  __$TypeHierarchyRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _TypeHierarchyRegistrationOptions _self;
  final $Res Function(_TypeHierarchyRegistrationOptions) _then;

/// Create a copy of TypeHierarchyRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = freezed,Object? id = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_TypeHierarchyRegistrationOptions(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$TypeHierarchySupertypesParams {

 TypeHierarchyItem get item; ProgressToken? get partialResultToken; ProgressToken? get workDoneToken;
/// Create a copy of TypeHierarchySupertypesParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TypeHierarchySupertypesParamsCopyWith<TypeHierarchySupertypesParams> get copyWith => _$TypeHierarchySupertypesParamsCopyWithImpl<TypeHierarchySupertypesParams>(this as TypeHierarchySupertypesParams, _$identity);

  /// Serializes this TypeHierarchySupertypesParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TypeHierarchySupertypesParams&&(identical(other.item, item) || other.item == item)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,item,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'TypeHierarchySupertypesParams(item: $item, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $TypeHierarchySupertypesParamsCopyWith<$Res>  {
  factory $TypeHierarchySupertypesParamsCopyWith(TypeHierarchySupertypesParams value, $Res Function(TypeHierarchySupertypesParams) _then) = _$TypeHierarchySupertypesParamsCopyWithImpl;
@useResult
$Res call({
 TypeHierarchyItem item, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


$TypeHierarchyItemCopyWith<$Res> get item;

}
/// @nodoc
class _$TypeHierarchySupertypesParamsCopyWithImpl<$Res>
    implements $TypeHierarchySupertypesParamsCopyWith<$Res> {
  _$TypeHierarchySupertypesParamsCopyWithImpl(this._self, this._then);

  final TypeHierarchySupertypesParams _self;
  final $Res Function(TypeHierarchySupertypesParams) _then;

/// Create a copy of TypeHierarchySupertypesParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? item = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
item: null == item ? _self.item : item // ignore: cast_nullable_to_non_nullable
as TypeHierarchyItem,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of TypeHierarchySupertypesParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TypeHierarchyItemCopyWith<$Res> get item {
  
  return $TypeHierarchyItemCopyWith<$Res>(_self.item, (value) {
    return _then(_self.copyWith(item: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _TypeHierarchySupertypesParams implements TypeHierarchySupertypesParams {
  const _TypeHierarchySupertypesParams({required this.item, this.partialResultToken, this.workDoneToken});
  factory _TypeHierarchySupertypesParams.fromJson(Map<String, dynamic> json) => _$TypeHierarchySupertypesParamsFromJson(json);

@override final  TypeHierarchyItem item;
@override final  ProgressToken? partialResultToken;
@override final  ProgressToken? workDoneToken;

/// Create a copy of TypeHierarchySupertypesParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TypeHierarchySupertypesParamsCopyWith<_TypeHierarchySupertypesParams> get copyWith => __$TypeHierarchySupertypesParamsCopyWithImpl<_TypeHierarchySupertypesParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TypeHierarchySupertypesParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TypeHierarchySupertypesParams&&(identical(other.item, item) || other.item == item)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,item,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'TypeHierarchySupertypesParams(item: $item, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$TypeHierarchySupertypesParamsCopyWith<$Res> implements $TypeHierarchySupertypesParamsCopyWith<$Res> {
  factory _$TypeHierarchySupertypesParamsCopyWith(_TypeHierarchySupertypesParams value, $Res Function(_TypeHierarchySupertypesParams) _then) = __$TypeHierarchySupertypesParamsCopyWithImpl;
@override @useResult
$Res call({
 TypeHierarchyItem item, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


@override $TypeHierarchyItemCopyWith<$Res> get item;

}
/// @nodoc
class __$TypeHierarchySupertypesParamsCopyWithImpl<$Res>
    implements _$TypeHierarchySupertypesParamsCopyWith<$Res> {
  __$TypeHierarchySupertypesParamsCopyWithImpl(this._self, this._then);

  final _TypeHierarchySupertypesParams _self;
  final $Res Function(_TypeHierarchySupertypesParams) _then;

/// Create a copy of TypeHierarchySupertypesParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? item = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_TypeHierarchySupertypesParams(
item: null == item ? _self.item : item // ignore: cast_nullable_to_non_nullable
as TypeHierarchyItem,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of TypeHierarchySupertypesParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TypeHierarchyItemCopyWith<$Res> get item {
  
  return $TypeHierarchyItemCopyWith<$Res>(_self.item, (value) {
    return _then(_self.copyWith(item: value));
  });
}
}


/// @nodoc
mixin _$TypeHierarchySubtypesParams {

 TypeHierarchyItem get item; ProgressToken? get partialResultToken; ProgressToken? get workDoneToken;
/// Create a copy of TypeHierarchySubtypesParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TypeHierarchySubtypesParamsCopyWith<TypeHierarchySubtypesParams> get copyWith => _$TypeHierarchySubtypesParamsCopyWithImpl<TypeHierarchySubtypesParams>(this as TypeHierarchySubtypesParams, _$identity);

  /// Serializes this TypeHierarchySubtypesParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TypeHierarchySubtypesParams&&(identical(other.item, item) || other.item == item)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,item,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'TypeHierarchySubtypesParams(item: $item, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $TypeHierarchySubtypesParamsCopyWith<$Res>  {
  factory $TypeHierarchySubtypesParamsCopyWith(TypeHierarchySubtypesParams value, $Res Function(TypeHierarchySubtypesParams) _then) = _$TypeHierarchySubtypesParamsCopyWithImpl;
@useResult
$Res call({
 TypeHierarchyItem item, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


$TypeHierarchyItemCopyWith<$Res> get item;

}
/// @nodoc
class _$TypeHierarchySubtypesParamsCopyWithImpl<$Res>
    implements $TypeHierarchySubtypesParamsCopyWith<$Res> {
  _$TypeHierarchySubtypesParamsCopyWithImpl(this._self, this._then);

  final TypeHierarchySubtypesParams _self;
  final $Res Function(TypeHierarchySubtypesParams) _then;

/// Create a copy of TypeHierarchySubtypesParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? item = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
item: null == item ? _self.item : item // ignore: cast_nullable_to_non_nullable
as TypeHierarchyItem,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of TypeHierarchySubtypesParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TypeHierarchyItemCopyWith<$Res> get item {
  
  return $TypeHierarchyItemCopyWith<$Res>(_self.item, (value) {
    return _then(_self.copyWith(item: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _TypeHierarchySubtypesParams implements TypeHierarchySubtypesParams {
  const _TypeHierarchySubtypesParams({required this.item, this.partialResultToken, this.workDoneToken});
  factory _TypeHierarchySubtypesParams.fromJson(Map<String, dynamic> json) => _$TypeHierarchySubtypesParamsFromJson(json);

@override final  TypeHierarchyItem item;
@override final  ProgressToken? partialResultToken;
@override final  ProgressToken? workDoneToken;

/// Create a copy of TypeHierarchySubtypesParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TypeHierarchySubtypesParamsCopyWith<_TypeHierarchySubtypesParams> get copyWith => __$TypeHierarchySubtypesParamsCopyWithImpl<_TypeHierarchySubtypesParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TypeHierarchySubtypesParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TypeHierarchySubtypesParams&&(identical(other.item, item) || other.item == item)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,item,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'TypeHierarchySubtypesParams(item: $item, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$TypeHierarchySubtypesParamsCopyWith<$Res> implements $TypeHierarchySubtypesParamsCopyWith<$Res> {
  factory _$TypeHierarchySubtypesParamsCopyWith(_TypeHierarchySubtypesParams value, $Res Function(_TypeHierarchySubtypesParams) _then) = __$TypeHierarchySubtypesParamsCopyWithImpl;
@override @useResult
$Res call({
 TypeHierarchyItem item, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


@override $TypeHierarchyItemCopyWith<$Res> get item;

}
/// @nodoc
class __$TypeHierarchySubtypesParamsCopyWithImpl<$Res>
    implements _$TypeHierarchySubtypesParamsCopyWith<$Res> {
  __$TypeHierarchySubtypesParamsCopyWithImpl(this._self, this._then);

  final _TypeHierarchySubtypesParams _self;
  final $Res Function(_TypeHierarchySubtypesParams) _then;

/// Create a copy of TypeHierarchySubtypesParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? item = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_TypeHierarchySubtypesParams(
item: null == item ? _self.item : item // ignore: cast_nullable_to_non_nullable
as TypeHierarchyItem,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of TypeHierarchySubtypesParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TypeHierarchyItemCopyWith<$Res> get item {
  
  return $TypeHierarchyItemCopyWith<$Res>(_self.item, (value) {
    return _then(_self.copyWith(item: value));
  });
}
}


/// @nodoc
mixin _$InlineValueParams {

 TextDocumentIdentifier get textDocument; Range get range; InlineValueContext get context; ProgressToken? get workDoneToken;
/// Create a copy of InlineValueParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlineValueParamsCopyWith<InlineValueParams> get copyWith => _$InlineValueParamsCopyWithImpl<InlineValueParams>(this as InlineValueParams, _$identity);

  /// Serializes this InlineValueParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlineValueParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.range, range) || other.range == range)&&(identical(other.context, context) || other.context == context)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,range,context,const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'InlineValueParams(textDocument: $textDocument, range: $range, context: $context, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $InlineValueParamsCopyWith<$Res>  {
  factory $InlineValueParamsCopyWith(InlineValueParams value, $Res Function(InlineValueParams) _then) = _$InlineValueParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument, Range range, InlineValueContext context, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;$RangeCopyWith<$Res> get range;$InlineValueContextCopyWith<$Res> get context;

}
/// @nodoc
class _$InlineValueParamsCopyWithImpl<$Res>
    implements $InlineValueParamsCopyWith<$Res> {
  _$InlineValueParamsCopyWithImpl(this._self, this._then);

  final InlineValueParams _self;
  final $Res Function(InlineValueParams) _then;

/// Create a copy of InlineValueParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? range = null,Object? context = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,context: null == context ? _self.context : context // ignore: cast_nullable_to_non_nullable
as InlineValueContext,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of InlineValueParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of InlineValueParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}/// Create a copy of InlineValueParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$InlineValueContextCopyWith<$Res> get context {
  
  return $InlineValueContextCopyWith<$Res>(_self.context, (value) {
    return _then(_self.copyWith(context: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _InlineValueParams implements InlineValueParams {
  const _InlineValueParams({required this.textDocument, required this.range, required this.context, this.workDoneToken});
  factory _InlineValueParams.fromJson(Map<String, dynamic> json) => _$InlineValueParamsFromJson(json);

@override final  TextDocumentIdentifier textDocument;
@override final  Range range;
@override final  InlineValueContext context;
@override final  ProgressToken? workDoneToken;

/// Create a copy of InlineValueParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlineValueParamsCopyWith<_InlineValueParams> get copyWith => __$InlineValueParamsCopyWithImpl<_InlineValueParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlineValueParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlineValueParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.range, range) || other.range == range)&&(identical(other.context, context) || other.context == context)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,range,context,const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'InlineValueParams(textDocument: $textDocument, range: $range, context: $context, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$InlineValueParamsCopyWith<$Res> implements $InlineValueParamsCopyWith<$Res> {
  factory _$InlineValueParamsCopyWith(_InlineValueParams value, $Res Function(_InlineValueParams) _then) = __$InlineValueParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument, Range range, InlineValueContext context, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;@override $RangeCopyWith<$Res> get range;@override $InlineValueContextCopyWith<$Res> get context;

}
/// @nodoc
class __$InlineValueParamsCopyWithImpl<$Res>
    implements _$InlineValueParamsCopyWith<$Res> {
  __$InlineValueParamsCopyWithImpl(this._self, this._then);

  final _InlineValueParams _self;
  final $Res Function(_InlineValueParams) _then;

/// Create a copy of InlineValueParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? range = null,Object? context = null,Object? workDoneToken = freezed,}) {
  return _then(_InlineValueParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,context: null == context ? _self.context : context // ignore: cast_nullable_to_non_nullable
as InlineValueContext,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of InlineValueParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of InlineValueParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}/// Create a copy of InlineValueParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$InlineValueContextCopyWith<$Res> get context {
  
  return $InlineValueContextCopyWith<$Res>(_self.context, (value) {
    return _then(_self.copyWith(context: value));
  });
}
}


/// @nodoc
mixin _$InlineValueRegistrationOptions {

 dynamic get documentSelector; String? get id; bool? get workDoneProgress;
/// Create a copy of InlineValueRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlineValueRegistrationOptionsCopyWith<InlineValueRegistrationOptions> get copyWith => _$InlineValueRegistrationOptionsCopyWithImpl<InlineValueRegistrationOptions>(this as InlineValueRegistrationOptions, _$identity);

  /// Serializes this InlineValueRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlineValueRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.id, id) || other.id == id)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),id,workDoneProgress);

@override
String toString() {
  return 'InlineValueRegistrationOptions(documentSelector: $documentSelector, id: $id, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $InlineValueRegistrationOptionsCopyWith<$Res>  {
  factory $InlineValueRegistrationOptionsCopyWith(InlineValueRegistrationOptions value, $Res Function(InlineValueRegistrationOptions) _then) = _$InlineValueRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 dynamic documentSelector, String? id, bool? workDoneProgress
});




}
/// @nodoc
class _$InlineValueRegistrationOptionsCopyWithImpl<$Res>
    implements $InlineValueRegistrationOptionsCopyWith<$Res> {
  _$InlineValueRegistrationOptionsCopyWithImpl(this._self, this._then);

  final InlineValueRegistrationOptions _self;
  final $Res Function(InlineValueRegistrationOptions) _then;

/// Create a copy of InlineValueRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = freezed,Object? id = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _InlineValueRegistrationOptions implements InlineValueRegistrationOptions {
  const _InlineValueRegistrationOptions({required this.documentSelector, this.id, this.workDoneProgress});
  factory _InlineValueRegistrationOptions.fromJson(Map<String, dynamic> json) => _$InlineValueRegistrationOptionsFromJson(json);

@override final  dynamic documentSelector;
@override final  String? id;
@override final  bool? workDoneProgress;

/// Create a copy of InlineValueRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlineValueRegistrationOptionsCopyWith<_InlineValueRegistrationOptions> get copyWith => __$InlineValueRegistrationOptionsCopyWithImpl<_InlineValueRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlineValueRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlineValueRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.id, id) || other.id == id)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),id,workDoneProgress);

@override
String toString() {
  return 'InlineValueRegistrationOptions(documentSelector: $documentSelector, id: $id, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$InlineValueRegistrationOptionsCopyWith<$Res> implements $InlineValueRegistrationOptionsCopyWith<$Res> {
  factory _$InlineValueRegistrationOptionsCopyWith(_InlineValueRegistrationOptions value, $Res Function(_InlineValueRegistrationOptions) _then) = __$InlineValueRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 dynamic documentSelector, String? id, bool? workDoneProgress
});




}
/// @nodoc
class __$InlineValueRegistrationOptionsCopyWithImpl<$Res>
    implements _$InlineValueRegistrationOptionsCopyWith<$Res> {
  __$InlineValueRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _InlineValueRegistrationOptions _self;
  final $Res Function(_InlineValueRegistrationOptions) _then;

/// Create a copy of InlineValueRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = freezed,Object? id = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_InlineValueRegistrationOptions(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$InlayHintParams {

 TextDocumentIdentifier get textDocument; Range get range; ProgressToken? get workDoneToken;
/// Create a copy of InlayHintParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlayHintParamsCopyWith<InlayHintParams> get copyWith => _$InlayHintParamsCopyWithImpl<InlayHintParams>(this as InlayHintParams, _$identity);

  /// Serializes this InlayHintParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlayHintParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.range, range) || other.range == range)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,range,const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'InlayHintParams(textDocument: $textDocument, range: $range, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $InlayHintParamsCopyWith<$Res>  {
  factory $InlayHintParamsCopyWith(InlayHintParams value, $Res Function(InlayHintParams) _then) = _$InlayHintParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument, Range range, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;$RangeCopyWith<$Res> get range;

}
/// @nodoc
class _$InlayHintParamsCopyWithImpl<$Res>
    implements $InlayHintParamsCopyWith<$Res> {
  _$InlayHintParamsCopyWithImpl(this._self, this._then);

  final InlayHintParams _self;
  final $Res Function(InlayHintParams) _then;

/// Create a copy of InlayHintParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? range = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of InlayHintParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of InlayHintParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _InlayHintParams implements InlayHintParams {
  const _InlayHintParams({required this.textDocument, required this.range, this.workDoneToken});
  factory _InlayHintParams.fromJson(Map<String, dynamic> json) => _$InlayHintParamsFromJson(json);

@override final  TextDocumentIdentifier textDocument;
@override final  Range range;
@override final  ProgressToken? workDoneToken;

/// Create a copy of InlayHintParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlayHintParamsCopyWith<_InlayHintParams> get copyWith => __$InlayHintParamsCopyWithImpl<_InlayHintParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlayHintParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlayHintParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.range, range) || other.range == range)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,range,const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'InlayHintParams(textDocument: $textDocument, range: $range, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$InlayHintParamsCopyWith<$Res> implements $InlayHintParamsCopyWith<$Res> {
  factory _$InlayHintParamsCopyWith(_InlayHintParams value, $Res Function(_InlayHintParams) _then) = __$InlayHintParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument, Range range, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;@override $RangeCopyWith<$Res> get range;

}
/// @nodoc
class __$InlayHintParamsCopyWithImpl<$Res>
    implements _$InlayHintParamsCopyWith<$Res> {
  __$InlayHintParamsCopyWithImpl(this._self, this._then);

  final _InlayHintParams _self;
  final $Res Function(_InlayHintParams) _then;

/// Create a copy of InlayHintParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? range = null,Object? workDoneToken = freezed,}) {
  return _then(_InlayHintParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of InlayHintParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of InlayHintParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}


/// @nodoc
mixin _$InlayHint {

 Position get position; dynamic get label; LSPAny? get data; bool? get paddingRight; bool? get paddingLeft; dynamic? get tooltip; List<TextEdit>? get textEdits; InlayHintKind? get kind;
/// Create a copy of InlayHint
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlayHintCopyWith<InlayHint> get copyWith => _$InlayHintCopyWithImpl<InlayHint>(this as InlayHint, _$identity);

  /// Serializes this InlayHint to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlayHint&&(identical(other.position, position) || other.position == position)&&const DeepCollectionEquality().equals(other.label, label)&&const DeepCollectionEquality().equals(other.data, data)&&(identical(other.paddingRight, paddingRight) || other.paddingRight == paddingRight)&&(identical(other.paddingLeft, paddingLeft) || other.paddingLeft == paddingLeft)&&const DeepCollectionEquality().equals(other.tooltip, tooltip)&&const DeepCollectionEquality().equals(other.textEdits, textEdits)&&(identical(other.kind, kind) || other.kind == kind));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,position,const DeepCollectionEquality().hash(label),const DeepCollectionEquality().hash(data),paddingRight,paddingLeft,const DeepCollectionEquality().hash(tooltip),const DeepCollectionEquality().hash(textEdits),kind);

@override
String toString() {
  return 'InlayHint(position: $position, label: $label, data: $data, paddingRight: $paddingRight, paddingLeft: $paddingLeft, tooltip: $tooltip, textEdits: $textEdits, kind: $kind)';
}


}

/// @nodoc
abstract mixin class $InlayHintCopyWith<$Res>  {
  factory $InlayHintCopyWith(InlayHint value, $Res Function(InlayHint) _then) = _$InlayHintCopyWithImpl;
@useResult
$Res call({
 Position position, dynamic label, LSPAny? data, bool? paddingRight, bool? paddingLeft, dynamic? tooltip, List<TextEdit>? textEdits, InlayHintKind? kind
});


$PositionCopyWith<$Res> get position;

}
/// @nodoc
class _$InlayHintCopyWithImpl<$Res>
    implements $InlayHintCopyWith<$Res> {
  _$InlayHintCopyWithImpl(this._self, this._then);

  final InlayHint _self;
  final $Res Function(InlayHint) _then;

/// Create a copy of InlayHint
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? position = null,Object? label = freezed,Object? data = freezed,Object? paddingRight = freezed,Object? paddingLeft = freezed,Object? tooltip = freezed,Object? textEdits = freezed,Object? kind = freezed,}) {
  return _then(_self.copyWith(
position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,label: freezed == label ? _self.label : label // ignore: cast_nullable_to_non_nullable
as dynamic,data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LSPAny?,paddingRight: freezed == paddingRight ? _self.paddingRight : paddingRight // ignore: cast_nullable_to_non_nullable
as bool?,paddingLeft: freezed == paddingLeft ? _self.paddingLeft : paddingLeft // ignore: cast_nullable_to_non_nullable
as bool?,tooltip: freezed == tooltip ? _self.tooltip : tooltip // ignore: cast_nullable_to_non_nullable
as dynamic?,textEdits: freezed == textEdits ? _self.textEdits : textEdits // ignore: cast_nullable_to_non_nullable
as List<TextEdit>?,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as InlayHintKind?,
  ));
}
/// Create a copy of InlayHint
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _InlayHint implements InlayHint {
  const _InlayHint({required this.position, required this.label, this.data, this.paddingRight, this.paddingLeft, this.tooltip, final  List<TextEdit>? textEdits, this.kind}): _textEdits = textEdits;
  factory _InlayHint.fromJson(Map<String, dynamic> json) => _$InlayHintFromJson(json);

@override final  Position position;
@override final  dynamic label;
@override final  LSPAny? data;
@override final  bool? paddingRight;
@override final  bool? paddingLeft;
@override final  dynamic? tooltip;
 final  List<TextEdit>? _textEdits;
@override List<TextEdit>? get textEdits {
  final value = _textEdits;
  if (value == null) return null;
  if (_textEdits is EqualUnmodifiableListView) return _textEdits;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

@override final  InlayHintKind? kind;

/// Create a copy of InlayHint
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlayHintCopyWith<_InlayHint> get copyWith => __$InlayHintCopyWithImpl<_InlayHint>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlayHintToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlayHint&&(identical(other.position, position) || other.position == position)&&const DeepCollectionEquality().equals(other.label, label)&&const DeepCollectionEquality().equals(other.data, data)&&(identical(other.paddingRight, paddingRight) || other.paddingRight == paddingRight)&&(identical(other.paddingLeft, paddingLeft) || other.paddingLeft == paddingLeft)&&const DeepCollectionEquality().equals(other.tooltip, tooltip)&&const DeepCollectionEquality().equals(other._textEdits, _textEdits)&&(identical(other.kind, kind) || other.kind == kind));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,position,const DeepCollectionEquality().hash(label),const DeepCollectionEquality().hash(data),paddingRight,paddingLeft,const DeepCollectionEquality().hash(tooltip),const DeepCollectionEquality().hash(_textEdits),kind);

@override
String toString() {
  return 'InlayHint(position: $position, label: $label, data: $data, paddingRight: $paddingRight, paddingLeft: $paddingLeft, tooltip: $tooltip, textEdits: $textEdits, kind: $kind)';
}


}

/// @nodoc
abstract mixin class _$InlayHintCopyWith<$Res> implements $InlayHintCopyWith<$Res> {
  factory _$InlayHintCopyWith(_InlayHint value, $Res Function(_InlayHint) _then) = __$InlayHintCopyWithImpl;
@override @useResult
$Res call({
 Position position, dynamic label, LSPAny? data, bool? paddingRight, bool? paddingLeft, dynamic? tooltip, List<TextEdit>? textEdits, InlayHintKind? kind
});


@override $PositionCopyWith<$Res> get position;

}
/// @nodoc
class __$InlayHintCopyWithImpl<$Res>
    implements _$InlayHintCopyWith<$Res> {
  __$InlayHintCopyWithImpl(this._self, this._then);

  final _InlayHint _self;
  final $Res Function(_InlayHint) _then;

/// Create a copy of InlayHint
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? position = null,Object? label = freezed,Object? data = freezed,Object? paddingRight = freezed,Object? paddingLeft = freezed,Object? tooltip = freezed,Object? textEdits = freezed,Object? kind = freezed,}) {
  return _then(_InlayHint(
position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,label: freezed == label ? _self.label : label // ignore: cast_nullable_to_non_nullable
as dynamic,data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LSPAny?,paddingRight: freezed == paddingRight ? _self.paddingRight : paddingRight // ignore: cast_nullable_to_non_nullable
as bool?,paddingLeft: freezed == paddingLeft ? _self.paddingLeft : paddingLeft // ignore: cast_nullable_to_non_nullable
as bool?,tooltip: freezed == tooltip ? _self.tooltip : tooltip // ignore: cast_nullable_to_non_nullable
as dynamic?,textEdits: freezed == textEdits ? _self._textEdits : textEdits // ignore: cast_nullable_to_non_nullable
as List<TextEdit>?,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as InlayHintKind?,
  ));
}

/// Create a copy of InlayHint
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}
}


/// @nodoc
mixin _$InlayHintRegistrationOptions {

 dynamic get documentSelector; String? get id; bool? get resolveProvider; bool? get workDoneProgress;
/// Create a copy of InlayHintRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlayHintRegistrationOptionsCopyWith<InlayHintRegistrationOptions> get copyWith => _$InlayHintRegistrationOptionsCopyWithImpl<InlayHintRegistrationOptions>(this as InlayHintRegistrationOptions, _$identity);

  /// Serializes this InlayHintRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlayHintRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.id, id) || other.id == id)&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),id,resolveProvider,workDoneProgress);

@override
String toString() {
  return 'InlayHintRegistrationOptions(documentSelector: $documentSelector, id: $id, resolveProvider: $resolveProvider, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $InlayHintRegistrationOptionsCopyWith<$Res>  {
  factory $InlayHintRegistrationOptionsCopyWith(InlayHintRegistrationOptions value, $Res Function(InlayHintRegistrationOptions) _then) = _$InlayHintRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 dynamic documentSelector, String? id, bool? resolveProvider, bool? workDoneProgress
});




}
/// @nodoc
class _$InlayHintRegistrationOptionsCopyWithImpl<$Res>
    implements $InlayHintRegistrationOptionsCopyWith<$Res> {
  _$InlayHintRegistrationOptionsCopyWithImpl(this._self, this._then);

  final InlayHintRegistrationOptions _self;
  final $Res Function(InlayHintRegistrationOptions) _then;

/// Create a copy of InlayHintRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = freezed,Object? id = freezed,Object? resolveProvider = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _InlayHintRegistrationOptions implements InlayHintRegistrationOptions {
  const _InlayHintRegistrationOptions({required this.documentSelector, this.id, this.resolveProvider, this.workDoneProgress});
  factory _InlayHintRegistrationOptions.fromJson(Map<String, dynamic> json) => _$InlayHintRegistrationOptionsFromJson(json);

@override final  dynamic documentSelector;
@override final  String? id;
@override final  bool? resolveProvider;
@override final  bool? workDoneProgress;

/// Create a copy of InlayHintRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlayHintRegistrationOptionsCopyWith<_InlayHintRegistrationOptions> get copyWith => __$InlayHintRegistrationOptionsCopyWithImpl<_InlayHintRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlayHintRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlayHintRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.id, id) || other.id == id)&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),id,resolveProvider,workDoneProgress);

@override
String toString() {
  return 'InlayHintRegistrationOptions(documentSelector: $documentSelector, id: $id, resolveProvider: $resolveProvider, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$InlayHintRegistrationOptionsCopyWith<$Res> implements $InlayHintRegistrationOptionsCopyWith<$Res> {
  factory _$InlayHintRegistrationOptionsCopyWith(_InlayHintRegistrationOptions value, $Res Function(_InlayHintRegistrationOptions) _then) = __$InlayHintRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 dynamic documentSelector, String? id, bool? resolveProvider, bool? workDoneProgress
});




}
/// @nodoc
class __$InlayHintRegistrationOptionsCopyWithImpl<$Res>
    implements _$InlayHintRegistrationOptionsCopyWith<$Res> {
  __$InlayHintRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _InlayHintRegistrationOptions _self;
  final $Res Function(_InlayHintRegistrationOptions) _then;

/// Create a copy of InlayHintRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = freezed,Object? id = freezed,Object? resolveProvider = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_InlayHintRegistrationOptions(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DocumentDiagnosticParams {

 TextDocumentIdentifier get textDocument; String? get previousResultId; String? get identifier; ProgressToken? get partialResultToken; ProgressToken? get workDoneToken;
/// Create a copy of DocumentDiagnosticParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentDiagnosticParamsCopyWith<DocumentDiagnosticParams> get copyWith => _$DocumentDiagnosticParamsCopyWithImpl<DocumentDiagnosticParams>(this as DocumentDiagnosticParams, _$identity);

  /// Serializes this DocumentDiagnosticParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentDiagnosticParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.previousResultId, previousResultId) || other.previousResultId == previousResultId)&&(identical(other.identifier, identifier) || other.identifier == identifier)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,previousResultId,identifier,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'DocumentDiagnosticParams(textDocument: $textDocument, previousResultId: $previousResultId, identifier: $identifier, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $DocumentDiagnosticParamsCopyWith<$Res>  {
  factory $DocumentDiagnosticParamsCopyWith(DocumentDiagnosticParams value, $Res Function(DocumentDiagnosticParams) _then) = _$DocumentDiagnosticParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument, String? previousResultId, String? identifier, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$DocumentDiagnosticParamsCopyWithImpl<$Res>
    implements $DocumentDiagnosticParamsCopyWith<$Res> {
  _$DocumentDiagnosticParamsCopyWithImpl(this._self, this._then);

  final DocumentDiagnosticParams _self;
  final $Res Function(DocumentDiagnosticParams) _then;

/// Create a copy of DocumentDiagnosticParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? previousResultId = freezed,Object? identifier = freezed,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,previousResultId: freezed == previousResultId ? _self.previousResultId : previousResultId // ignore: cast_nullable_to_non_nullable
as String?,identifier: freezed == identifier ? _self.identifier : identifier // ignore: cast_nullable_to_non_nullable
as String?,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of DocumentDiagnosticParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DocumentDiagnosticParams implements DocumentDiagnosticParams {
  const _DocumentDiagnosticParams({required this.textDocument, this.previousResultId, this.identifier, this.partialResultToken, this.workDoneToken});
  factory _DocumentDiagnosticParams.fromJson(Map<String, dynamic> json) => _$DocumentDiagnosticParamsFromJson(json);

@override final  TextDocumentIdentifier textDocument;
@override final  String? previousResultId;
@override final  String? identifier;
@override final  ProgressToken? partialResultToken;
@override final  ProgressToken? workDoneToken;

/// Create a copy of DocumentDiagnosticParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentDiagnosticParamsCopyWith<_DocumentDiagnosticParams> get copyWith => __$DocumentDiagnosticParamsCopyWithImpl<_DocumentDiagnosticParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentDiagnosticParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentDiagnosticParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.previousResultId, previousResultId) || other.previousResultId == previousResultId)&&(identical(other.identifier, identifier) || other.identifier == identifier)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,previousResultId,identifier,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'DocumentDiagnosticParams(textDocument: $textDocument, previousResultId: $previousResultId, identifier: $identifier, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$DocumentDiagnosticParamsCopyWith<$Res> implements $DocumentDiagnosticParamsCopyWith<$Res> {
  factory _$DocumentDiagnosticParamsCopyWith(_DocumentDiagnosticParams value, $Res Function(_DocumentDiagnosticParams) _then) = __$DocumentDiagnosticParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument, String? previousResultId, String? identifier, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$DocumentDiagnosticParamsCopyWithImpl<$Res>
    implements _$DocumentDiagnosticParamsCopyWith<$Res> {
  __$DocumentDiagnosticParamsCopyWithImpl(this._self, this._then);

  final _DocumentDiagnosticParams _self;
  final $Res Function(_DocumentDiagnosticParams) _then;

/// Create a copy of DocumentDiagnosticParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? previousResultId = freezed,Object? identifier = freezed,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_DocumentDiagnosticParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,previousResultId: freezed == previousResultId ? _self.previousResultId : previousResultId // ignore: cast_nullable_to_non_nullable
as String?,identifier: freezed == identifier ? _self.identifier : identifier // ignore: cast_nullable_to_non_nullable
as String?,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of DocumentDiagnosticParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$DocumentDiagnosticReportPartialResult {

 Map<String, dynamic> get relatedDocuments;
/// Create a copy of DocumentDiagnosticReportPartialResult
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentDiagnosticReportPartialResultCopyWith<DocumentDiagnosticReportPartialResult> get copyWith => _$DocumentDiagnosticReportPartialResultCopyWithImpl<DocumentDiagnosticReportPartialResult>(this as DocumentDiagnosticReportPartialResult, _$identity);

  /// Serializes this DocumentDiagnosticReportPartialResult to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentDiagnosticReportPartialResult&&const DeepCollectionEquality().equals(other.relatedDocuments, relatedDocuments));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(relatedDocuments));

@override
String toString() {
  return 'DocumentDiagnosticReportPartialResult(relatedDocuments: $relatedDocuments)';
}


}

/// @nodoc
abstract mixin class $DocumentDiagnosticReportPartialResultCopyWith<$Res>  {
  factory $DocumentDiagnosticReportPartialResultCopyWith(DocumentDiagnosticReportPartialResult value, $Res Function(DocumentDiagnosticReportPartialResult) _then) = _$DocumentDiagnosticReportPartialResultCopyWithImpl;
@useResult
$Res call({
 Map<String, dynamic> relatedDocuments
});




}
/// @nodoc
class _$DocumentDiagnosticReportPartialResultCopyWithImpl<$Res>
    implements $DocumentDiagnosticReportPartialResultCopyWith<$Res> {
  _$DocumentDiagnosticReportPartialResultCopyWithImpl(this._self, this._then);

  final DocumentDiagnosticReportPartialResult _self;
  final $Res Function(DocumentDiagnosticReportPartialResult) _then;

/// Create a copy of DocumentDiagnosticReportPartialResult
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? relatedDocuments = null,}) {
  return _then(_self.copyWith(
relatedDocuments: null == relatedDocuments ? _self.relatedDocuments : relatedDocuments // ignore: cast_nullable_to_non_nullable
as Map<String, dynamic>,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DocumentDiagnosticReportPartialResult implements DocumentDiagnosticReportPartialResult {
  const _DocumentDiagnosticReportPartialResult({required final  Map<String, dynamic> relatedDocuments}): _relatedDocuments = relatedDocuments;
  factory _DocumentDiagnosticReportPartialResult.fromJson(Map<String, dynamic> json) => _$DocumentDiagnosticReportPartialResultFromJson(json);

 final  Map<String, dynamic> _relatedDocuments;
@override Map<String, dynamic> get relatedDocuments {
  if (_relatedDocuments is EqualUnmodifiableMapView) return _relatedDocuments;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(_relatedDocuments);
}


/// Create a copy of DocumentDiagnosticReportPartialResult
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentDiagnosticReportPartialResultCopyWith<_DocumentDiagnosticReportPartialResult> get copyWith => __$DocumentDiagnosticReportPartialResultCopyWithImpl<_DocumentDiagnosticReportPartialResult>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentDiagnosticReportPartialResultToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentDiagnosticReportPartialResult&&const DeepCollectionEquality().equals(other._relatedDocuments, _relatedDocuments));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_relatedDocuments));

@override
String toString() {
  return 'DocumentDiagnosticReportPartialResult(relatedDocuments: $relatedDocuments)';
}


}

/// @nodoc
abstract mixin class _$DocumentDiagnosticReportPartialResultCopyWith<$Res> implements $DocumentDiagnosticReportPartialResultCopyWith<$Res> {
  factory _$DocumentDiagnosticReportPartialResultCopyWith(_DocumentDiagnosticReportPartialResult value, $Res Function(_DocumentDiagnosticReportPartialResult) _then) = __$DocumentDiagnosticReportPartialResultCopyWithImpl;
@override @useResult
$Res call({
 Map<String, dynamic> relatedDocuments
});




}
/// @nodoc
class __$DocumentDiagnosticReportPartialResultCopyWithImpl<$Res>
    implements _$DocumentDiagnosticReportPartialResultCopyWith<$Res> {
  __$DocumentDiagnosticReportPartialResultCopyWithImpl(this._self, this._then);

  final _DocumentDiagnosticReportPartialResult _self;
  final $Res Function(_DocumentDiagnosticReportPartialResult) _then;

/// Create a copy of DocumentDiagnosticReportPartialResult
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? relatedDocuments = null,}) {
  return _then(_DocumentDiagnosticReportPartialResult(
relatedDocuments: null == relatedDocuments ? _self._relatedDocuments : relatedDocuments // ignore: cast_nullable_to_non_nullable
as Map<String, dynamic>,
  ));
}


}


/// @nodoc
mixin _$DiagnosticServerCancellationData {

 bool get retriggerRequest;
/// Create a copy of DiagnosticServerCancellationData
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DiagnosticServerCancellationDataCopyWith<DiagnosticServerCancellationData> get copyWith => _$DiagnosticServerCancellationDataCopyWithImpl<DiagnosticServerCancellationData>(this as DiagnosticServerCancellationData, _$identity);

  /// Serializes this DiagnosticServerCancellationData to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DiagnosticServerCancellationData&&(identical(other.retriggerRequest, retriggerRequest) || other.retriggerRequest == retriggerRequest));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,retriggerRequest);

@override
String toString() {
  return 'DiagnosticServerCancellationData(retriggerRequest: $retriggerRequest)';
}


}

/// @nodoc
abstract mixin class $DiagnosticServerCancellationDataCopyWith<$Res>  {
  factory $DiagnosticServerCancellationDataCopyWith(DiagnosticServerCancellationData value, $Res Function(DiagnosticServerCancellationData) _then) = _$DiagnosticServerCancellationDataCopyWithImpl;
@useResult
$Res call({
 bool retriggerRequest
});




}
/// @nodoc
class _$DiagnosticServerCancellationDataCopyWithImpl<$Res>
    implements $DiagnosticServerCancellationDataCopyWith<$Res> {
  _$DiagnosticServerCancellationDataCopyWithImpl(this._self, this._then);

  final DiagnosticServerCancellationData _self;
  final $Res Function(DiagnosticServerCancellationData) _then;

/// Create a copy of DiagnosticServerCancellationData
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? retriggerRequest = null,}) {
  return _then(_self.copyWith(
retriggerRequest: null == retriggerRequest ? _self.retriggerRequest : retriggerRequest // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DiagnosticServerCancellationData implements DiagnosticServerCancellationData {
  const _DiagnosticServerCancellationData({required this.retriggerRequest});
  factory _DiagnosticServerCancellationData.fromJson(Map<String, dynamic> json) => _$DiagnosticServerCancellationDataFromJson(json);

@override final  bool retriggerRequest;

/// Create a copy of DiagnosticServerCancellationData
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DiagnosticServerCancellationDataCopyWith<_DiagnosticServerCancellationData> get copyWith => __$DiagnosticServerCancellationDataCopyWithImpl<_DiagnosticServerCancellationData>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DiagnosticServerCancellationDataToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DiagnosticServerCancellationData&&(identical(other.retriggerRequest, retriggerRequest) || other.retriggerRequest == retriggerRequest));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,retriggerRequest);

@override
String toString() {
  return 'DiagnosticServerCancellationData(retriggerRequest: $retriggerRequest)';
}


}

/// @nodoc
abstract mixin class _$DiagnosticServerCancellationDataCopyWith<$Res> implements $DiagnosticServerCancellationDataCopyWith<$Res> {
  factory _$DiagnosticServerCancellationDataCopyWith(_DiagnosticServerCancellationData value, $Res Function(_DiagnosticServerCancellationData) _then) = __$DiagnosticServerCancellationDataCopyWithImpl;
@override @useResult
$Res call({
 bool retriggerRequest
});




}
/// @nodoc
class __$DiagnosticServerCancellationDataCopyWithImpl<$Res>
    implements _$DiagnosticServerCancellationDataCopyWith<$Res> {
  __$DiagnosticServerCancellationDataCopyWithImpl(this._self, this._then);

  final _DiagnosticServerCancellationData _self;
  final $Res Function(_DiagnosticServerCancellationData) _then;

/// Create a copy of DiagnosticServerCancellationData
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? retriggerRequest = null,}) {
  return _then(_DiagnosticServerCancellationData(
retriggerRequest: null == retriggerRequest ? _self.retriggerRequest : retriggerRequest // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}


}


/// @nodoc
mixin _$DiagnosticRegistrationOptions {

 dynamic get documentSelector; bool get interFileDependencies; bool get workspaceDiagnostics; String? get id; String? get identifier; bool? get workDoneProgress;
/// Create a copy of DiagnosticRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DiagnosticRegistrationOptionsCopyWith<DiagnosticRegistrationOptions> get copyWith => _$DiagnosticRegistrationOptionsCopyWithImpl<DiagnosticRegistrationOptions>(this as DiagnosticRegistrationOptions, _$identity);

  /// Serializes this DiagnosticRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DiagnosticRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.interFileDependencies, interFileDependencies) || other.interFileDependencies == interFileDependencies)&&(identical(other.workspaceDiagnostics, workspaceDiagnostics) || other.workspaceDiagnostics == workspaceDiagnostics)&&(identical(other.id, id) || other.id == id)&&(identical(other.identifier, identifier) || other.identifier == identifier)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),interFileDependencies,workspaceDiagnostics,id,identifier,workDoneProgress);

@override
String toString() {
  return 'DiagnosticRegistrationOptions(documentSelector: $documentSelector, interFileDependencies: $interFileDependencies, workspaceDiagnostics: $workspaceDiagnostics, id: $id, identifier: $identifier, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $DiagnosticRegistrationOptionsCopyWith<$Res>  {
  factory $DiagnosticRegistrationOptionsCopyWith(DiagnosticRegistrationOptions value, $Res Function(DiagnosticRegistrationOptions) _then) = _$DiagnosticRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 dynamic documentSelector, bool interFileDependencies, bool workspaceDiagnostics, String? id, String? identifier, bool? workDoneProgress
});




}
/// @nodoc
class _$DiagnosticRegistrationOptionsCopyWithImpl<$Res>
    implements $DiagnosticRegistrationOptionsCopyWith<$Res> {
  _$DiagnosticRegistrationOptionsCopyWithImpl(this._self, this._then);

  final DiagnosticRegistrationOptions _self;
  final $Res Function(DiagnosticRegistrationOptions) _then;

/// Create a copy of DiagnosticRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = freezed,Object? interFileDependencies = null,Object? workspaceDiagnostics = null,Object? id = freezed,Object? identifier = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,interFileDependencies: null == interFileDependencies ? _self.interFileDependencies : interFileDependencies // ignore: cast_nullable_to_non_nullable
as bool,workspaceDiagnostics: null == workspaceDiagnostics ? _self.workspaceDiagnostics : workspaceDiagnostics // ignore: cast_nullable_to_non_nullable
as bool,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,identifier: freezed == identifier ? _self.identifier : identifier // ignore: cast_nullable_to_non_nullable
as String?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DiagnosticRegistrationOptions implements DiagnosticRegistrationOptions {
  const _DiagnosticRegistrationOptions({required this.documentSelector, required this.interFileDependencies, required this.workspaceDiagnostics, this.id, this.identifier, this.workDoneProgress});
  factory _DiagnosticRegistrationOptions.fromJson(Map<String, dynamic> json) => _$DiagnosticRegistrationOptionsFromJson(json);

@override final  dynamic documentSelector;
@override final  bool interFileDependencies;
@override final  bool workspaceDiagnostics;
@override final  String? id;
@override final  String? identifier;
@override final  bool? workDoneProgress;

/// Create a copy of DiagnosticRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DiagnosticRegistrationOptionsCopyWith<_DiagnosticRegistrationOptions> get copyWith => __$DiagnosticRegistrationOptionsCopyWithImpl<_DiagnosticRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DiagnosticRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DiagnosticRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.interFileDependencies, interFileDependencies) || other.interFileDependencies == interFileDependencies)&&(identical(other.workspaceDiagnostics, workspaceDiagnostics) || other.workspaceDiagnostics == workspaceDiagnostics)&&(identical(other.id, id) || other.id == id)&&(identical(other.identifier, identifier) || other.identifier == identifier)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),interFileDependencies,workspaceDiagnostics,id,identifier,workDoneProgress);

@override
String toString() {
  return 'DiagnosticRegistrationOptions(documentSelector: $documentSelector, interFileDependencies: $interFileDependencies, workspaceDiagnostics: $workspaceDiagnostics, id: $id, identifier: $identifier, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$DiagnosticRegistrationOptionsCopyWith<$Res> implements $DiagnosticRegistrationOptionsCopyWith<$Res> {
  factory _$DiagnosticRegistrationOptionsCopyWith(_DiagnosticRegistrationOptions value, $Res Function(_DiagnosticRegistrationOptions) _then) = __$DiagnosticRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 dynamic documentSelector, bool interFileDependencies, bool workspaceDiagnostics, String? id, String? identifier, bool? workDoneProgress
});




}
/// @nodoc
class __$DiagnosticRegistrationOptionsCopyWithImpl<$Res>
    implements _$DiagnosticRegistrationOptionsCopyWith<$Res> {
  __$DiagnosticRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _DiagnosticRegistrationOptions _self;
  final $Res Function(_DiagnosticRegistrationOptions) _then;

/// Create a copy of DiagnosticRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = freezed,Object? interFileDependencies = null,Object? workspaceDiagnostics = null,Object? id = freezed,Object? identifier = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_DiagnosticRegistrationOptions(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,interFileDependencies: null == interFileDependencies ? _self.interFileDependencies : interFileDependencies // ignore: cast_nullable_to_non_nullable
as bool,workspaceDiagnostics: null == workspaceDiagnostics ? _self.workspaceDiagnostics : workspaceDiagnostics // ignore: cast_nullable_to_non_nullable
as bool,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,identifier: freezed == identifier ? _self.identifier : identifier // ignore: cast_nullable_to_non_nullable
as String?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$WorkspaceDiagnosticParams {

 List<PreviousResultId> get previousResultIds; String? get identifier; ProgressToken? get partialResultToken; ProgressToken? get workDoneToken;
/// Create a copy of WorkspaceDiagnosticParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkspaceDiagnosticParamsCopyWith<WorkspaceDiagnosticParams> get copyWith => _$WorkspaceDiagnosticParamsCopyWithImpl<WorkspaceDiagnosticParams>(this as WorkspaceDiagnosticParams, _$identity);

  /// Serializes this WorkspaceDiagnosticParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkspaceDiagnosticParams&&const DeepCollectionEquality().equals(other.previousResultIds, previousResultIds)&&(identical(other.identifier, identifier) || other.identifier == identifier)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(previousResultIds),identifier,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'WorkspaceDiagnosticParams(previousResultIds: $previousResultIds, identifier: $identifier, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $WorkspaceDiagnosticParamsCopyWith<$Res>  {
  factory $WorkspaceDiagnosticParamsCopyWith(WorkspaceDiagnosticParams value, $Res Function(WorkspaceDiagnosticParams) _then) = _$WorkspaceDiagnosticParamsCopyWithImpl;
@useResult
$Res call({
 List<PreviousResultId> previousResultIds, String? identifier, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});




}
/// @nodoc
class _$WorkspaceDiagnosticParamsCopyWithImpl<$Res>
    implements $WorkspaceDiagnosticParamsCopyWith<$Res> {
  _$WorkspaceDiagnosticParamsCopyWithImpl(this._self, this._then);

  final WorkspaceDiagnosticParams _self;
  final $Res Function(WorkspaceDiagnosticParams) _then;

/// Create a copy of WorkspaceDiagnosticParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? previousResultIds = null,Object? identifier = freezed,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
previousResultIds: null == previousResultIds ? _self.previousResultIds : previousResultIds // ignore: cast_nullable_to_non_nullable
as List<PreviousResultId>,identifier: freezed == identifier ? _self.identifier : identifier // ignore: cast_nullable_to_non_nullable
as String?,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _WorkspaceDiagnosticParams implements WorkspaceDiagnosticParams {
  const _WorkspaceDiagnosticParams({required final  List<PreviousResultId> previousResultIds, this.identifier, this.partialResultToken, this.workDoneToken}): _previousResultIds = previousResultIds;
  factory _WorkspaceDiagnosticParams.fromJson(Map<String, dynamic> json) => _$WorkspaceDiagnosticParamsFromJson(json);

 final  List<PreviousResultId> _previousResultIds;
@override List<PreviousResultId> get previousResultIds {
  if (_previousResultIds is EqualUnmodifiableListView) return _previousResultIds;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_previousResultIds);
}

@override final  String? identifier;
@override final  ProgressToken? partialResultToken;
@override final  ProgressToken? workDoneToken;

/// Create a copy of WorkspaceDiagnosticParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkspaceDiagnosticParamsCopyWith<_WorkspaceDiagnosticParams> get copyWith => __$WorkspaceDiagnosticParamsCopyWithImpl<_WorkspaceDiagnosticParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkspaceDiagnosticParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkspaceDiagnosticParams&&const DeepCollectionEquality().equals(other._previousResultIds, _previousResultIds)&&(identical(other.identifier, identifier) || other.identifier == identifier)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_previousResultIds),identifier,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'WorkspaceDiagnosticParams(previousResultIds: $previousResultIds, identifier: $identifier, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$WorkspaceDiagnosticParamsCopyWith<$Res> implements $WorkspaceDiagnosticParamsCopyWith<$Res> {
  factory _$WorkspaceDiagnosticParamsCopyWith(_WorkspaceDiagnosticParams value, $Res Function(_WorkspaceDiagnosticParams) _then) = __$WorkspaceDiagnosticParamsCopyWithImpl;
@override @useResult
$Res call({
 List<PreviousResultId> previousResultIds, String? identifier, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});




}
/// @nodoc
class __$WorkspaceDiagnosticParamsCopyWithImpl<$Res>
    implements _$WorkspaceDiagnosticParamsCopyWith<$Res> {
  __$WorkspaceDiagnosticParamsCopyWithImpl(this._self, this._then);

  final _WorkspaceDiagnosticParams _self;
  final $Res Function(_WorkspaceDiagnosticParams) _then;

/// Create a copy of WorkspaceDiagnosticParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? previousResultIds = null,Object? identifier = freezed,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_WorkspaceDiagnosticParams(
previousResultIds: null == previousResultIds ? _self._previousResultIds : previousResultIds // ignore: cast_nullable_to_non_nullable
as List<PreviousResultId>,identifier: freezed == identifier ? _self.identifier : identifier // ignore: cast_nullable_to_non_nullable
as String?,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}


}


/// @nodoc
mixin _$WorkspaceDiagnosticReport {

 List<WorkspaceDocumentDiagnosticReport> get items;
/// Create a copy of WorkspaceDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkspaceDiagnosticReportCopyWith<WorkspaceDiagnosticReport> get copyWith => _$WorkspaceDiagnosticReportCopyWithImpl<WorkspaceDiagnosticReport>(this as WorkspaceDiagnosticReport, _$identity);

  /// Serializes this WorkspaceDiagnosticReport to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkspaceDiagnosticReport&&const DeepCollectionEquality().equals(other.items, items));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(items));

@override
String toString() {
  return 'WorkspaceDiagnosticReport(items: $items)';
}


}

/// @nodoc
abstract mixin class $WorkspaceDiagnosticReportCopyWith<$Res>  {
  factory $WorkspaceDiagnosticReportCopyWith(WorkspaceDiagnosticReport value, $Res Function(WorkspaceDiagnosticReport) _then) = _$WorkspaceDiagnosticReportCopyWithImpl;
@useResult
$Res call({
 List<WorkspaceDocumentDiagnosticReport> items
});




}
/// @nodoc
class _$WorkspaceDiagnosticReportCopyWithImpl<$Res>
    implements $WorkspaceDiagnosticReportCopyWith<$Res> {
  _$WorkspaceDiagnosticReportCopyWithImpl(this._self, this._then);

  final WorkspaceDiagnosticReport _self;
  final $Res Function(WorkspaceDiagnosticReport) _then;

/// Create a copy of WorkspaceDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? items = null,}) {
  return _then(_self.copyWith(
items: null == items ? _self.items : items // ignore: cast_nullable_to_non_nullable
as List<WorkspaceDocumentDiagnosticReport>,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _WorkspaceDiagnosticReport implements WorkspaceDiagnosticReport {
  const _WorkspaceDiagnosticReport({required final  List<WorkspaceDocumentDiagnosticReport> items}): _items = items;
  factory _WorkspaceDiagnosticReport.fromJson(Map<String, dynamic> json) => _$WorkspaceDiagnosticReportFromJson(json);

 final  List<WorkspaceDocumentDiagnosticReport> _items;
@override List<WorkspaceDocumentDiagnosticReport> get items {
  if (_items is EqualUnmodifiableListView) return _items;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_items);
}


/// Create a copy of WorkspaceDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkspaceDiagnosticReportCopyWith<_WorkspaceDiagnosticReport> get copyWith => __$WorkspaceDiagnosticReportCopyWithImpl<_WorkspaceDiagnosticReport>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkspaceDiagnosticReportToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkspaceDiagnosticReport&&const DeepCollectionEquality().equals(other._items, _items));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_items));

@override
String toString() {
  return 'WorkspaceDiagnosticReport(items: $items)';
}


}

/// @nodoc
abstract mixin class _$WorkspaceDiagnosticReportCopyWith<$Res> implements $WorkspaceDiagnosticReportCopyWith<$Res> {
  factory _$WorkspaceDiagnosticReportCopyWith(_WorkspaceDiagnosticReport value, $Res Function(_WorkspaceDiagnosticReport) _then) = __$WorkspaceDiagnosticReportCopyWithImpl;
@override @useResult
$Res call({
 List<WorkspaceDocumentDiagnosticReport> items
});




}
/// @nodoc
class __$WorkspaceDiagnosticReportCopyWithImpl<$Res>
    implements _$WorkspaceDiagnosticReportCopyWith<$Res> {
  __$WorkspaceDiagnosticReportCopyWithImpl(this._self, this._then);

  final _WorkspaceDiagnosticReport _self;
  final $Res Function(_WorkspaceDiagnosticReport) _then;

/// Create a copy of WorkspaceDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? items = null,}) {
  return _then(_WorkspaceDiagnosticReport(
items: null == items ? _self._items : items // ignore: cast_nullable_to_non_nullable
as List<WorkspaceDocumentDiagnosticReport>,
  ));
}


}


/// @nodoc
mixin _$WorkspaceDiagnosticReportPartialResult {

 List<WorkspaceDocumentDiagnosticReport> get items;
/// Create a copy of WorkspaceDiagnosticReportPartialResult
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkspaceDiagnosticReportPartialResultCopyWith<WorkspaceDiagnosticReportPartialResult> get copyWith => _$WorkspaceDiagnosticReportPartialResultCopyWithImpl<WorkspaceDiagnosticReportPartialResult>(this as WorkspaceDiagnosticReportPartialResult, _$identity);

  /// Serializes this WorkspaceDiagnosticReportPartialResult to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkspaceDiagnosticReportPartialResult&&const DeepCollectionEquality().equals(other.items, items));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(items));

@override
String toString() {
  return 'WorkspaceDiagnosticReportPartialResult(items: $items)';
}


}

/// @nodoc
abstract mixin class $WorkspaceDiagnosticReportPartialResultCopyWith<$Res>  {
  factory $WorkspaceDiagnosticReportPartialResultCopyWith(WorkspaceDiagnosticReportPartialResult value, $Res Function(WorkspaceDiagnosticReportPartialResult) _then) = _$WorkspaceDiagnosticReportPartialResultCopyWithImpl;
@useResult
$Res call({
 List<WorkspaceDocumentDiagnosticReport> items
});




}
/// @nodoc
class _$WorkspaceDiagnosticReportPartialResultCopyWithImpl<$Res>
    implements $WorkspaceDiagnosticReportPartialResultCopyWith<$Res> {
  _$WorkspaceDiagnosticReportPartialResultCopyWithImpl(this._self, this._then);

  final WorkspaceDiagnosticReportPartialResult _self;
  final $Res Function(WorkspaceDiagnosticReportPartialResult) _then;

/// Create a copy of WorkspaceDiagnosticReportPartialResult
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? items = null,}) {
  return _then(_self.copyWith(
items: null == items ? _self.items : items // ignore: cast_nullable_to_non_nullable
as List<WorkspaceDocumentDiagnosticReport>,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _WorkspaceDiagnosticReportPartialResult implements WorkspaceDiagnosticReportPartialResult {
  const _WorkspaceDiagnosticReportPartialResult({required final  List<WorkspaceDocumentDiagnosticReport> items}): _items = items;
  factory _WorkspaceDiagnosticReportPartialResult.fromJson(Map<String, dynamic> json) => _$WorkspaceDiagnosticReportPartialResultFromJson(json);

 final  List<WorkspaceDocumentDiagnosticReport> _items;
@override List<WorkspaceDocumentDiagnosticReport> get items {
  if (_items is EqualUnmodifiableListView) return _items;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_items);
}


/// Create a copy of WorkspaceDiagnosticReportPartialResult
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkspaceDiagnosticReportPartialResultCopyWith<_WorkspaceDiagnosticReportPartialResult> get copyWith => __$WorkspaceDiagnosticReportPartialResultCopyWithImpl<_WorkspaceDiagnosticReportPartialResult>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkspaceDiagnosticReportPartialResultToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkspaceDiagnosticReportPartialResult&&const DeepCollectionEquality().equals(other._items, _items));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_items));

@override
String toString() {
  return 'WorkspaceDiagnosticReportPartialResult(items: $items)';
}


}

/// @nodoc
abstract mixin class _$WorkspaceDiagnosticReportPartialResultCopyWith<$Res> implements $WorkspaceDiagnosticReportPartialResultCopyWith<$Res> {
  factory _$WorkspaceDiagnosticReportPartialResultCopyWith(_WorkspaceDiagnosticReportPartialResult value, $Res Function(_WorkspaceDiagnosticReportPartialResult) _then) = __$WorkspaceDiagnosticReportPartialResultCopyWithImpl;
@override @useResult
$Res call({
 List<WorkspaceDocumentDiagnosticReport> items
});




}
/// @nodoc
class __$WorkspaceDiagnosticReportPartialResultCopyWithImpl<$Res>
    implements _$WorkspaceDiagnosticReportPartialResultCopyWith<$Res> {
  __$WorkspaceDiagnosticReportPartialResultCopyWithImpl(this._self, this._then);

  final _WorkspaceDiagnosticReportPartialResult _self;
  final $Res Function(_WorkspaceDiagnosticReportPartialResult) _then;

/// Create a copy of WorkspaceDiagnosticReportPartialResult
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? items = null,}) {
  return _then(_WorkspaceDiagnosticReportPartialResult(
items: null == items ? _self._items : items // ignore: cast_nullable_to_non_nullable
as List<WorkspaceDocumentDiagnosticReport>,
  ));
}


}


/// @nodoc
mixin _$DidOpenNotebookDocumentParams {

 NotebookDocument get notebookDocument; List<TextDocumentItem> get cellTextDocuments;
/// Create a copy of DidOpenNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DidOpenNotebookDocumentParamsCopyWith<DidOpenNotebookDocumentParams> get copyWith => _$DidOpenNotebookDocumentParamsCopyWithImpl<DidOpenNotebookDocumentParams>(this as DidOpenNotebookDocumentParams, _$identity);

  /// Serializes this DidOpenNotebookDocumentParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DidOpenNotebookDocumentParams&&(identical(other.notebookDocument, notebookDocument) || other.notebookDocument == notebookDocument)&&const DeepCollectionEquality().equals(other.cellTextDocuments, cellTextDocuments));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,notebookDocument,const DeepCollectionEquality().hash(cellTextDocuments));

@override
String toString() {
  return 'DidOpenNotebookDocumentParams(notebookDocument: $notebookDocument, cellTextDocuments: $cellTextDocuments)';
}


}

/// @nodoc
abstract mixin class $DidOpenNotebookDocumentParamsCopyWith<$Res>  {
  factory $DidOpenNotebookDocumentParamsCopyWith(DidOpenNotebookDocumentParams value, $Res Function(DidOpenNotebookDocumentParams) _then) = _$DidOpenNotebookDocumentParamsCopyWithImpl;
@useResult
$Res call({
 NotebookDocument notebookDocument, List<TextDocumentItem> cellTextDocuments
});


$NotebookDocumentCopyWith<$Res> get notebookDocument;

}
/// @nodoc
class _$DidOpenNotebookDocumentParamsCopyWithImpl<$Res>
    implements $DidOpenNotebookDocumentParamsCopyWith<$Res> {
  _$DidOpenNotebookDocumentParamsCopyWithImpl(this._self, this._then);

  final DidOpenNotebookDocumentParams _self;
  final $Res Function(DidOpenNotebookDocumentParams) _then;

/// Create a copy of DidOpenNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? notebookDocument = null,Object? cellTextDocuments = null,}) {
  return _then(_self.copyWith(
notebookDocument: null == notebookDocument ? _self.notebookDocument : notebookDocument // ignore: cast_nullable_to_non_nullable
as NotebookDocument,cellTextDocuments: null == cellTextDocuments ? _self.cellTextDocuments : cellTextDocuments // ignore: cast_nullable_to_non_nullable
as List<TextDocumentItem>,
  ));
}
/// Create a copy of DidOpenNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$NotebookDocumentCopyWith<$Res> get notebookDocument {
  
  return $NotebookDocumentCopyWith<$Res>(_self.notebookDocument, (value) {
    return _then(_self.copyWith(notebookDocument: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DidOpenNotebookDocumentParams implements DidOpenNotebookDocumentParams {
  const _DidOpenNotebookDocumentParams({required this.notebookDocument, required final  List<TextDocumentItem> cellTextDocuments}): _cellTextDocuments = cellTextDocuments;
  factory _DidOpenNotebookDocumentParams.fromJson(Map<String, dynamic> json) => _$DidOpenNotebookDocumentParamsFromJson(json);

@override final  NotebookDocument notebookDocument;
 final  List<TextDocumentItem> _cellTextDocuments;
@override List<TextDocumentItem> get cellTextDocuments {
  if (_cellTextDocuments is EqualUnmodifiableListView) return _cellTextDocuments;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_cellTextDocuments);
}


/// Create a copy of DidOpenNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DidOpenNotebookDocumentParamsCopyWith<_DidOpenNotebookDocumentParams> get copyWith => __$DidOpenNotebookDocumentParamsCopyWithImpl<_DidOpenNotebookDocumentParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DidOpenNotebookDocumentParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DidOpenNotebookDocumentParams&&(identical(other.notebookDocument, notebookDocument) || other.notebookDocument == notebookDocument)&&const DeepCollectionEquality().equals(other._cellTextDocuments, _cellTextDocuments));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,notebookDocument,const DeepCollectionEquality().hash(_cellTextDocuments));

@override
String toString() {
  return 'DidOpenNotebookDocumentParams(notebookDocument: $notebookDocument, cellTextDocuments: $cellTextDocuments)';
}


}

/// @nodoc
abstract mixin class _$DidOpenNotebookDocumentParamsCopyWith<$Res> implements $DidOpenNotebookDocumentParamsCopyWith<$Res> {
  factory _$DidOpenNotebookDocumentParamsCopyWith(_DidOpenNotebookDocumentParams value, $Res Function(_DidOpenNotebookDocumentParams) _then) = __$DidOpenNotebookDocumentParamsCopyWithImpl;
@override @useResult
$Res call({
 NotebookDocument notebookDocument, List<TextDocumentItem> cellTextDocuments
});


@override $NotebookDocumentCopyWith<$Res> get notebookDocument;

}
/// @nodoc
class __$DidOpenNotebookDocumentParamsCopyWithImpl<$Res>
    implements _$DidOpenNotebookDocumentParamsCopyWith<$Res> {
  __$DidOpenNotebookDocumentParamsCopyWithImpl(this._self, this._then);

  final _DidOpenNotebookDocumentParams _self;
  final $Res Function(_DidOpenNotebookDocumentParams) _then;

/// Create a copy of DidOpenNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? notebookDocument = null,Object? cellTextDocuments = null,}) {
  return _then(_DidOpenNotebookDocumentParams(
notebookDocument: null == notebookDocument ? _self.notebookDocument : notebookDocument // ignore: cast_nullable_to_non_nullable
as NotebookDocument,cellTextDocuments: null == cellTextDocuments ? _self._cellTextDocuments : cellTextDocuments // ignore: cast_nullable_to_non_nullable
as List<TextDocumentItem>,
  ));
}

/// Create a copy of DidOpenNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$NotebookDocumentCopyWith<$Res> get notebookDocument {
  
  return $NotebookDocumentCopyWith<$Res>(_self.notebookDocument, (value) {
    return _then(_self.copyWith(notebookDocument: value));
  });
}
}


/// @nodoc
mixin _$DidChangeNotebookDocumentParams {

 VersionedNotebookDocumentIdentifier get notebookDocument; NotebookDocumentChangeEvent get change;
/// Create a copy of DidChangeNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DidChangeNotebookDocumentParamsCopyWith<DidChangeNotebookDocumentParams> get copyWith => _$DidChangeNotebookDocumentParamsCopyWithImpl<DidChangeNotebookDocumentParams>(this as DidChangeNotebookDocumentParams, _$identity);

  /// Serializes this DidChangeNotebookDocumentParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DidChangeNotebookDocumentParams&&(identical(other.notebookDocument, notebookDocument) || other.notebookDocument == notebookDocument)&&(identical(other.change, change) || other.change == change));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,notebookDocument,change);

@override
String toString() {
  return 'DidChangeNotebookDocumentParams(notebookDocument: $notebookDocument, change: $change)';
}


}

/// @nodoc
abstract mixin class $DidChangeNotebookDocumentParamsCopyWith<$Res>  {
  factory $DidChangeNotebookDocumentParamsCopyWith(DidChangeNotebookDocumentParams value, $Res Function(DidChangeNotebookDocumentParams) _then) = _$DidChangeNotebookDocumentParamsCopyWithImpl;
@useResult
$Res call({
 VersionedNotebookDocumentIdentifier notebookDocument, NotebookDocumentChangeEvent change
});


$VersionedNotebookDocumentIdentifierCopyWith<$Res> get notebookDocument;$NotebookDocumentChangeEventCopyWith<$Res> get change;

}
/// @nodoc
class _$DidChangeNotebookDocumentParamsCopyWithImpl<$Res>
    implements $DidChangeNotebookDocumentParamsCopyWith<$Res> {
  _$DidChangeNotebookDocumentParamsCopyWithImpl(this._self, this._then);

  final DidChangeNotebookDocumentParams _self;
  final $Res Function(DidChangeNotebookDocumentParams) _then;

/// Create a copy of DidChangeNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? notebookDocument = null,Object? change = null,}) {
  return _then(_self.copyWith(
notebookDocument: null == notebookDocument ? _self.notebookDocument : notebookDocument // ignore: cast_nullable_to_non_nullable
as VersionedNotebookDocumentIdentifier,change: null == change ? _self.change : change // ignore: cast_nullable_to_non_nullable
as NotebookDocumentChangeEvent,
  ));
}
/// Create a copy of DidChangeNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$VersionedNotebookDocumentIdentifierCopyWith<$Res> get notebookDocument {
  
  return $VersionedNotebookDocumentIdentifierCopyWith<$Res>(_self.notebookDocument, (value) {
    return _then(_self.copyWith(notebookDocument: value));
  });
}/// Create a copy of DidChangeNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$NotebookDocumentChangeEventCopyWith<$Res> get change {
  
  return $NotebookDocumentChangeEventCopyWith<$Res>(_self.change, (value) {
    return _then(_self.copyWith(change: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DidChangeNotebookDocumentParams implements DidChangeNotebookDocumentParams {
  const _DidChangeNotebookDocumentParams({required this.notebookDocument, required this.change});
  factory _DidChangeNotebookDocumentParams.fromJson(Map<String, dynamic> json) => _$DidChangeNotebookDocumentParamsFromJson(json);

@override final  VersionedNotebookDocumentIdentifier notebookDocument;
@override final  NotebookDocumentChangeEvent change;

/// Create a copy of DidChangeNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DidChangeNotebookDocumentParamsCopyWith<_DidChangeNotebookDocumentParams> get copyWith => __$DidChangeNotebookDocumentParamsCopyWithImpl<_DidChangeNotebookDocumentParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DidChangeNotebookDocumentParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DidChangeNotebookDocumentParams&&(identical(other.notebookDocument, notebookDocument) || other.notebookDocument == notebookDocument)&&(identical(other.change, change) || other.change == change));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,notebookDocument,change);

@override
String toString() {
  return 'DidChangeNotebookDocumentParams(notebookDocument: $notebookDocument, change: $change)';
}


}

/// @nodoc
abstract mixin class _$DidChangeNotebookDocumentParamsCopyWith<$Res> implements $DidChangeNotebookDocumentParamsCopyWith<$Res> {
  factory _$DidChangeNotebookDocumentParamsCopyWith(_DidChangeNotebookDocumentParams value, $Res Function(_DidChangeNotebookDocumentParams) _then) = __$DidChangeNotebookDocumentParamsCopyWithImpl;
@override @useResult
$Res call({
 VersionedNotebookDocumentIdentifier notebookDocument, NotebookDocumentChangeEvent change
});


@override $VersionedNotebookDocumentIdentifierCopyWith<$Res> get notebookDocument;@override $NotebookDocumentChangeEventCopyWith<$Res> get change;

}
/// @nodoc
class __$DidChangeNotebookDocumentParamsCopyWithImpl<$Res>
    implements _$DidChangeNotebookDocumentParamsCopyWith<$Res> {
  __$DidChangeNotebookDocumentParamsCopyWithImpl(this._self, this._then);

  final _DidChangeNotebookDocumentParams _self;
  final $Res Function(_DidChangeNotebookDocumentParams) _then;

/// Create a copy of DidChangeNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? notebookDocument = null,Object? change = null,}) {
  return _then(_DidChangeNotebookDocumentParams(
notebookDocument: null == notebookDocument ? _self.notebookDocument : notebookDocument // ignore: cast_nullable_to_non_nullable
as VersionedNotebookDocumentIdentifier,change: null == change ? _self.change : change // ignore: cast_nullable_to_non_nullable
as NotebookDocumentChangeEvent,
  ));
}

/// Create a copy of DidChangeNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$VersionedNotebookDocumentIdentifierCopyWith<$Res> get notebookDocument {
  
  return $VersionedNotebookDocumentIdentifierCopyWith<$Res>(_self.notebookDocument, (value) {
    return _then(_self.copyWith(notebookDocument: value));
  });
}/// Create a copy of DidChangeNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$NotebookDocumentChangeEventCopyWith<$Res> get change {
  
  return $NotebookDocumentChangeEventCopyWith<$Res>(_self.change, (value) {
    return _then(_self.copyWith(change: value));
  });
}
}


/// @nodoc
mixin _$DidSaveNotebookDocumentParams {

 NotebookDocumentIdentifier get notebookDocument;
/// Create a copy of DidSaveNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DidSaveNotebookDocumentParamsCopyWith<DidSaveNotebookDocumentParams> get copyWith => _$DidSaveNotebookDocumentParamsCopyWithImpl<DidSaveNotebookDocumentParams>(this as DidSaveNotebookDocumentParams, _$identity);

  /// Serializes this DidSaveNotebookDocumentParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DidSaveNotebookDocumentParams&&(identical(other.notebookDocument, notebookDocument) || other.notebookDocument == notebookDocument));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,notebookDocument);

@override
String toString() {
  return 'DidSaveNotebookDocumentParams(notebookDocument: $notebookDocument)';
}


}

/// @nodoc
abstract mixin class $DidSaveNotebookDocumentParamsCopyWith<$Res>  {
  factory $DidSaveNotebookDocumentParamsCopyWith(DidSaveNotebookDocumentParams value, $Res Function(DidSaveNotebookDocumentParams) _then) = _$DidSaveNotebookDocumentParamsCopyWithImpl;
@useResult
$Res call({
 NotebookDocumentIdentifier notebookDocument
});


$NotebookDocumentIdentifierCopyWith<$Res> get notebookDocument;

}
/// @nodoc
class _$DidSaveNotebookDocumentParamsCopyWithImpl<$Res>
    implements $DidSaveNotebookDocumentParamsCopyWith<$Res> {
  _$DidSaveNotebookDocumentParamsCopyWithImpl(this._self, this._then);

  final DidSaveNotebookDocumentParams _self;
  final $Res Function(DidSaveNotebookDocumentParams) _then;

/// Create a copy of DidSaveNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? notebookDocument = null,}) {
  return _then(_self.copyWith(
notebookDocument: null == notebookDocument ? _self.notebookDocument : notebookDocument // ignore: cast_nullable_to_non_nullable
as NotebookDocumentIdentifier,
  ));
}
/// Create a copy of DidSaveNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$NotebookDocumentIdentifierCopyWith<$Res> get notebookDocument {
  
  return $NotebookDocumentIdentifierCopyWith<$Res>(_self.notebookDocument, (value) {
    return _then(_self.copyWith(notebookDocument: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DidSaveNotebookDocumentParams implements DidSaveNotebookDocumentParams {
  const _DidSaveNotebookDocumentParams({required this.notebookDocument});
  factory _DidSaveNotebookDocumentParams.fromJson(Map<String, dynamic> json) => _$DidSaveNotebookDocumentParamsFromJson(json);

@override final  NotebookDocumentIdentifier notebookDocument;

/// Create a copy of DidSaveNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DidSaveNotebookDocumentParamsCopyWith<_DidSaveNotebookDocumentParams> get copyWith => __$DidSaveNotebookDocumentParamsCopyWithImpl<_DidSaveNotebookDocumentParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DidSaveNotebookDocumentParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DidSaveNotebookDocumentParams&&(identical(other.notebookDocument, notebookDocument) || other.notebookDocument == notebookDocument));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,notebookDocument);

@override
String toString() {
  return 'DidSaveNotebookDocumentParams(notebookDocument: $notebookDocument)';
}


}

/// @nodoc
abstract mixin class _$DidSaveNotebookDocumentParamsCopyWith<$Res> implements $DidSaveNotebookDocumentParamsCopyWith<$Res> {
  factory _$DidSaveNotebookDocumentParamsCopyWith(_DidSaveNotebookDocumentParams value, $Res Function(_DidSaveNotebookDocumentParams) _then) = __$DidSaveNotebookDocumentParamsCopyWithImpl;
@override @useResult
$Res call({
 NotebookDocumentIdentifier notebookDocument
});


@override $NotebookDocumentIdentifierCopyWith<$Res> get notebookDocument;

}
/// @nodoc
class __$DidSaveNotebookDocumentParamsCopyWithImpl<$Res>
    implements _$DidSaveNotebookDocumentParamsCopyWith<$Res> {
  __$DidSaveNotebookDocumentParamsCopyWithImpl(this._self, this._then);

  final _DidSaveNotebookDocumentParams _self;
  final $Res Function(_DidSaveNotebookDocumentParams) _then;

/// Create a copy of DidSaveNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? notebookDocument = null,}) {
  return _then(_DidSaveNotebookDocumentParams(
notebookDocument: null == notebookDocument ? _self.notebookDocument : notebookDocument // ignore: cast_nullable_to_non_nullable
as NotebookDocumentIdentifier,
  ));
}

/// Create a copy of DidSaveNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$NotebookDocumentIdentifierCopyWith<$Res> get notebookDocument {
  
  return $NotebookDocumentIdentifierCopyWith<$Res>(_self.notebookDocument, (value) {
    return _then(_self.copyWith(notebookDocument: value));
  });
}
}


/// @nodoc
mixin _$DidCloseNotebookDocumentParams {

 NotebookDocumentIdentifier get notebookDocument; List<TextDocumentIdentifier> get cellTextDocuments;
/// Create a copy of DidCloseNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DidCloseNotebookDocumentParamsCopyWith<DidCloseNotebookDocumentParams> get copyWith => _$DidCloseNotebookDocumentParamsCopyWithImpl<DidCloseNotebookDocumentParams>(this as DidCloseNotebookDocumentParams, _$identity);

  /// Serializes this DidCloseNotebookDocumentParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DidCloseNotebookDocumentParams&&(identical(other.notebookDocument, notebookDocument) || other.notebookDocument == notebookDocument)&&const DeepCollectionEquality().equals(other.cellTextDocuments, cellTextDocuments));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,notebookDocument,const DeepCollectionEquality().hash(cellTextDocuments));

@override
String toString() {
  return 'DidCloseNotebookDocumentParams(notebookDocument: $notebookDocument, cellTextDocuments: $cellTextDocuments)';
}


}

/// @nodoc
abstract mixin class $DidCloseNotebookDocumentParamsCopyWith<$Res>  {
  factory $DidCloseNotebookDocumentParamsCopyWith(DidCloseNotebookDocumentParams value, $Res Function(DidCloseNotebookDocumentParams) _then) = _$DidCloseNotebookDocumentParamsCopyWithImpl;
@useResult
$Res call({
 NotebookDocumentIdentifier notebookDocument, List<TextDocumentIdentifier> cellTextDocuments
});


$NotebookDocumentIdentifierCopyWith<$Res> get notebookDocument;

}
/// @nodoc
class _$DidCloseNotebookDocumentParamsCopyWithImpl<$Res>
    implements $DidCloseNotebookDocumentParamsCopyWith<$Res> {
  _$DidCloseNotebookDocumentParamsCopyWithImpl(this._self, this._then);

  final DidCloseNotebookDocumentParams _self;
  final $Res Function(DidCloseNotebookDocumentParams) _then;

/// Create a copy of DidCloseNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? notebookDocument = null,Object? cellTextDocuments = null,}) {
  return _then(_self.copyWith(
notebookDocument: null == notebookDocument ? _self.notebookDocument : notebookDocument // ignore: cast_nullable_to_non_nullable
as NotebookDocumentIdentifier,cellTextDocuments: null == cellTextDocuments ? _self.cellTextDocuments : cellTextDocuments // ignore: cast_nullable_to_non_nullable
as List<TextDocumentIdentifier>,
  ));
}
/// Create a copy of DidCloseNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$NotebookDocumentIdentifierCopyWith<$Res> get notebookDocument {
  
  return $NotebookDocumentIdentifierCopyWith<$Res>(_self.notebookDocument, (value) {
    return _then(_self.copyWith(notebookDocument: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DidCloseNotebookDocumentParams implements DidCloseNotebookDocumentParams {
  const _DidCloseNotebookDocumentParams({required this.notebookDocument, required final  List<TextDocumentIdentifier> cellTextDocuments}): _cellTextDocuments = cellTextDocuments;
  factory _DidCloseNotebookDocumentParams.fromJson(Map<String, dynamic> json) => _$DidCloseNotebookDocumentParamsFromJson(json);

@override final  NotebookDocumentIdentifier notebookDocument;
 final  List<TextDocumentIdentifier> _cellTextDocuments;
@override List<TextDocumentIdentifier> get cellTextDocuments {
  if (_cellTextDocuments is EqualUnmodifiableListView) return _cellTextDocuments;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_cellTextDocuments);
}


/// Create a copy of DidCloseNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DidCloseNotebookDocumentParamsCopyWith<_DidCloseNotebookDocumentParams> get copyWith => __$DidCloseNotebookDocumentParamsCopyWithImpl<_DidCloseNotebookDocumentParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DidCloseNotebookDocumentParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DidCloseNotebookDocumentParams&&(identical(other.notebookDocument, notebookDocument) || other.notebookDocument == notebookDocument)&&const DeepCollectionEquality().equals(other._cellTextDocuments, _cellTextDocuments));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,notebookDocument,const DeepCollectionEquality().hash(_cellTextDocuments));

@override
String toString() {
  return 'DidCloseNotebookDocumentParams(notebookDocument: $notebookDocument, cellTextDocuments: $cellTextDocuments)';
}


}

/// @nodoc
abstract mixin class _$DidCloseNotebookDocumentParamsCopyWith<$Res> implements $DidCloseNotebookDocumentParamsCopyWith<$Res> {
  factory _$DidCloseNotebookDocumentParamsCopyWith(_DidCloseNotebookDocumentParams value, $Res Function(_DidCloseNotebookDocumentParams) _then) = __$DidCloseNotebookDocumentParamsCopyWithImpl;
@override @useResult
$Res call({
 NotebookDocumentIdentifier notebookDocument, List<TextDocumentIdentifier> cellTextDocuments
});


@override $NotebookDocumentIdentifierCopyWith<$Res> get notebookDocument;

}
/// @nodoc
class __$DidCloseNotebookDocumentParamsCopyWithImpl<$Res>
    implements _$DidCloseNotebookDocumentParamsCopyWith<$Res> {
  __$DidCloseNotebookDocumentParamsCopyWithImpl(this._self, this._then);

  final _DidCloseNotebookDocumentParams _self;
  final $Res Function(_DidCloseNotebookDocumentParams) _then;

/// Create a copy of DidCloseNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? notebookDocument = null,Object? cellTextDocuments = null,}) {
  return _then(_DidCloseNotebookDocumentParams(
notebookDocument: null == notebookDocument ? _self.notebookDocument : notebookDocument // ignore: cast_nullable_to_non_nullable
as NotebookDocumentIdentifier,cellTextDocuments: null == cellTextDocuments ? _self._cellTextDocuments : cellTextDocuments // ignore: cast_nullable_to_non_nullable
as List<TextDocumentIdentifier>,
  ));
}

/// Create a copy of DidCloseNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$NotebookDocumentIdentifierCopyWith<$Res> get notebookDocument {
  
  return $NotebookDocumentIdentifierCopyWith<$Res>(_self.notebookDocument, (value) {
    return _then(_self.copyWith(notebookDocument: value));
  });
}
}


/// @nodoc
mixin _$InlineCompletionParams {

 TextDocumentIdentifier get textDocument; Position get position; InlineCompletionContext get context; ProgressToken? get workDoneToken;
/// Create a copy of InlineCompletionParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlineCompletionParamsCopyWith<InlineCompletionParams> get copyWith => _$InlineCompletionParamsCopyWithImpl<InlineCompletionParams>(this as InlineCompletionParams, _$identity);

  /// Serializes this InlineCompletionParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlineCompletionParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.position, position) || other.position == position)&&(identical(other.context, context) || other.context == context)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,position,context,const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'InlineCompletionParams(textDocument: $textDocument, position: $position, context: $context, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $InlineCompletionParamsCopyWith<$Res>  {
  factory $InlineCompletionParamsCopyWith(InlineCompletionParams value, $Res Function(InlineCompletionParams) _then) = _$InlineCompletionParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument, Position position, InlineCompletionContext context, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;$PositionCopyWith<$Res> get position;$InlineCompletionContextCopyWith<$Res> get context;

}
/// @nodoc
class _$InlineCompletionParamsCopyWithImpl<$Res>
    implements $InlineCompletionParamsCopyWith<$Res> {
  _$InlineCompletionParamsCopyWithImpl(this._self, this._then);

  final InlineCompletionParams _self;
  final $Res Function(InlineCompletionParams) _then;

/// Create a copy of InlineCompletionParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? position = null,Object? context = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,context: null == context ? _self.context : context // ignore: cast_nullable_to_non_nullable
as InlineCompletionContext,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of InlineCompletionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of InlineCompletionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of InlineCompletionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$InlineCompletionContextCopyWith<$Res> get context {
  
  return $InlineCompletionContextCopyWith<$Res>(_self.context, (value) {
    return _then(_self.copyWith(context: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _InlineCompletionParams implements InlineCompletionParams {
  const _InlineCompletionParams({required this.textDocument, required this.position, required this.context, this.workDoneToken});
  factory _InlineCompletionParams.fromJson(Map<String, dynamic> json) => _$InlineCompletionParamsFromJson(json);

@override final  TextDocumentIdentifier textDocument;
@override final  Position position;
@override final  InlineCompletionContext context;
@override final  ProgressToken? workDoneToken;

/// Create a copy of InlineCompletionParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlineCompletionParamsCopyWith<_InlineCompletionParams> get copyWith => __$InlineCompletionParamsCopyWithImpl<_InlineCompletionParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlineCompletionParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlineCompletionParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.position, position) || other.position == position)&&(identical(other.context, context) || other.context == context)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,position,context,const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'InlineCompletionParams(textDocument: $textDocument, position: $position, context: $context, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$InlineCompletionParamsCopyWith<$Res> implements $InlineCompletionParamsCopyWith<$Res> {
  factory _$InlineCompletionParamsCopyWith(_InlineCompletionParams value, $Res Function(_InlineCompletionParams) _then) = __$InlineCompletionParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument, Position position, InlineCompletionContext context, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;@override $PositionCopyWith<$Res> get position;@override $InlineCompletionContextCopyWith<$Res> get context;

}
/// @nodoc
class __$InlineCompletionParamsCopyWithImpl<$Res>
    implements _$InlineCompletionParamsCopyWith<$Res> {
  __$InlineCompletionParamsCopyWithImpl(this._self, this._then);

  final _InlineCompletionParams _self;
  final $Res Function(_InlineCompletionParams) _then;

/// Create a copy of InlineCompletionParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? position = null,Object? context = null,Object? workDoneToken = freezed,}) {
  return _then(_InlineCompletionParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,context: null == context ? _self.context : context // ignore: cast_nullable_to_non_nullable
as InlineCompletionContext,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of InlineCompletionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of InlineCompletionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of InlineCompletionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$InlineCompletionContextCopyWith<$Res> get context {
  
  return $InlineCompletionContextCopyWith<$Res>(_self.context, (value) {
    return _then(_self.copyWith(context: value));
  });
}
}


/// @nodoc
mixin _$InlineCompletionList {

 List<InlineCompletionItem> get items;
/// Create a copy of InlineCompletionList
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlineCompletionListCopyWith<InlineCompletionList> get copyWith => _$InlineCompletionListCopyWithImpl<InlineCompletionList>(this as InlineCompletionList, _$identity);

  /// Serializes this InlineCompletionList to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlineCompletionList&&const DeepCollectionEquality().equals(other.items, items));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(items));

@override
String toString() {
  return 'InlineCompletionList(items: $items)';
}


}

/// @nodoc
abstract mixin class $InlineCompletionListCopyWith<$Res>  {
  factory $InlineCompletionListCopyWith(InlineCompletionList value, $Res Function(InlineCompletionList) _then) = _$InlineCompletionListCopyWithImpl;
@useResult
$Res call({
 List<InlineCompletionItem> items
});




}
/// @nodoc
class _$InlineCompletionListCopyWithImpl<$Res>
    implements $InlineCompletionListCopyWith<$Res> {
  _$InlineCompletionListCopyWithImpl(this._self, this._then);

  final InlineCompletionList _self;
  final $Res Function(InlineCompletionList) _then;

/// Create a copy of InlineCompletionList
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? items = null,}) {
  return _then(_self.copyWith(
items: null == items ? _self.items : items // ignore: cast_nullable_to_non_nullable
as List<InlineCompletionItem>,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _InlineCompletionList implements InlineCompletionList {
  const _InlineCompletionList({required final  List<InlineCompletionItem> items}): _items = items;
  factory _InlineCompletionList.fromJson(Map<String, dynamic> json) => _$InlineCompletionListFromJson(json);

 final  List<InlineCompletionItem> _items;
@override List<InlineCompletionItem> get items {
  if (_items is EqualUnmodifiableListView) return _items;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_items);
}


/// Create a copy of InlineCompletionList
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlineCompletionListCopyWith<_InlineCompletionList> get copyWith => __$InlineCompletionListCopyWithImpl<_InlineCompletionList>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlineCompletionListToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlineCompletionList&&const DeepCollectionEquality().equals(other._items, _items));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_items));

@override
String toString() {
  return 'InlineCompletionList(items: $items)';
}


}

/// @nodoc
abstract mixin class _$InlineCompletionListCopyWith<$Res> implements $InlineCompletionListCopyWith<$Res> {
  factory _$InlineCompletionListCopyWith(_InlineCompletionList value, $Res Function(_InlineCompletionList) _then) = __$InlineCompletionListCopyWithImpl;
@override @useResult
$Res call({
 List<InlineCompletionItem> items
});




}
/// @nodoc
class __$InlineCompletionListCopyWithImpl<$Res>
    implements _$InlineCompletionListCopyWith<$Res> {
  __$InlineCompletionListCopyWithImpl(this._self, this._then);

  final _InlineCompletionList _self;
  final $Res Function(_InlineCompletionList) _then;

/// Create a copy of InlineCompletionList
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? items = null,}) {
  return _then(_InlineCompletionList(
items: null == items ? _self._items : items // ignore: cast_nullable_to_non_nullable
as List<InlineCompletionItem>,
  ));
}


}


/// @nodoc
mixin _$InlineCompletionItem {

 dynamic get insertText; Command? get command; Range? get range; String? get filterText;
/// Create a copy of InlineCompletionItem
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlineCompletionItemCopyWith<InlineCompletionItem> get copyWith => _$InlineCompletionItemCopyWithImpl<InlineCompletionItem>(this as InlineCompletionItem, _$identity);

  /// Serializes this InlineCompletionItem to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlineCompletionItem&&const DeepCollectionEquality().equals(other.insertText, insertText)&&(identical(other.command, command) || other.command == command)&&(identical(other.range, range) || other.range == range)&&(identical(other.filterText, filterText) || other.filterText == filterText));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(insertText),command,range,filterText);

@override
String toString() {
  return 'InlineCompletionItem(insertText: $insertText, command: $command, range: $range, filterText: $filterText)';
}


}

/// @nodoc
abstract mixin class $InlineCompletionItemCopyWith<$Res>  {
  factory $InlineCompletionItemCopyWith(InlineCompletionItem value, $Res Function(InlineCompletionItem) _then) = _$InlineCompletionItemCopyWithImpl;
@useResult
$Res call({
 dynamic insertText, Command? command, Range? range, String? filterText
});


$CommandCopyWith<$Res>? get command;$RangeCopyWith<$Res>? get range;

}
/// @nodoc
class _$InlineCompletionItemCopyWithImpl<$Res>
    implements $InlineCompletionItemCopyWith<$Res> {
  _$InlineCompletionItemCopyWithImpl(this._self, this._then);

  final InlineCompletionItem _self;
  final $Res Function(InlineCompletionItem) _then;

/// Create a copy of InlineCompletionItem
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? insertText = freezed,Object? command = freezed,Object? range = freezed,Object? filterText = freezed,}) {
  return _then(_self.copyWith(
insertText: freezed == insertText ? _self.insertText : insertText // ignore: cast_nullable_to_non_nullable
as dynamic,command: freezed == command ? _self.command : command // ignore: cast_nullable_to_non_nullable
as Command?,range: freezed == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range?,filterText: freezed == filterText ? _self.filterText : filterText // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}
/// Create a copy of InlineCompletionItem
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CommandCopyWith<$Res>? get command {
    if (_self.command == null) {
    return null;
  }

  return $CommandCopyWith<$Res>(_self.command!, (value) {
    return _then(_self.copyWith(command: value));
  });
}/// Create a copy of InlineCompletionItem
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res>? get range {
    if (_self.range == null) {
    return null;
  }

  return $RangeCopyWith<$Res>(_self.range!, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _InlineCompletionItem implements InlineCompletionItem {
  const _InlineCompletionItem({required this.insertText, this.command, this.range, this.filterText});
  factory _InlineCompletionItem.fromJson(Map<String, dynamic> json) => _$InlineCompletionItemFromJson(json);

@override final  dynamic insertText;
@override final  Command? command;
@override final  Range? range;
@override final  String? filterText;

/// Create a copy of InlineCompletionItem
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlineCompletionItemCopyWith<_InlineCompletionItem> get copyWith => __$InlineCompletionItemCopyWithImpl<_InlineCompletionItem>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlineCompletionItemToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlineCompletionItem&&const DeepCollectionEquality().equals(other.insertText, insertText)&&(identical(other.command, command) || other.command == command)&&(identical(other.range, range) || other.range == range)&&(identical(other.filterText, filterText) || other.filterText == filterText));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(insertText),command,range,filterText);

@override
String toString() {
  return 'InlineCompletionItem(insertText: $insertText, command: $command, range: $range, filterText: $filterText)';
}


}

/// @nodoc
abstract mixin class _$InlineCompletionItemCopyWith<$Res> implements $InlineCompletionItemCopyWith<$Res> {
  factory _$InlineCompletionItemCopyWith(_InlineCompletionItem value, $Res Function(_InlineCompletionItem) _then) = __$InlineCompletionItemCopyWithImpl;
@override @useResult
$Res call({
 dynamic insertText, Command? command, Range? range, String? filterText
});


@override $CommandCopyWith<$Res>? get command;@override $RangeCopyWith<$Res>? get range;

}
/// @nodoc
class __$InlineCompletionItemCopyWithImpl<$Res>
    implements _$InlineCompletionItemCopyWith<$Res> {
  __$InlineCompletionItemCopyWithImpl(this._self, this._then);

  final _InlineCompletionItem _self;
  final $Res Function(_InlineCompletionItem) _then;

/// Create a copy of InlineCompletionItem
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? insertText = freezed,Object? command = freezed,Object? range = freezed,Object? filterText = freezed,}) {
  return _then(_InlineCompletionItem(
insertText: freezed == insertText ? _self.insertText : insertText // ignore: cast_nullable_to_non_nullable
as dynamic,command: freezed == command ? _self.command : command // ignore: cast_nullable_to_non_nullable
as Command?,range: freezed == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range?,filterText: freezed == filterText ? _self.filterText : filterText // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

/// Create a copy of InlineCompletionItem
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CommandCopyWith<$Res>? get command {
    if (_self.command == null) {
    return null;
  }

  return $CommandCopyWith<$Res>(_self.command!, (value) {
    return _then(_self.copyWith(command: value));
  });
}/// Create a copy of InlineCompletionItem
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res>? get range {
    if (_self.range == null) {
    return null;
  }

  return $RangeCopyWith<$Res>(_self.range!, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}


/// @nodoc
mixin _$InlineCompletionRegistrationOptions {

 dynamic get documentSelector; String? get id; bool? get workDoneProgress;
/// Create a copy of InlineCompletionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlineCompletionRegistrationOptionsCopyWith<InlineCompletionRegistrationOptions> get copyWith => _$InlineCompletionRegistrationOptionsCopyWithImpl<InlineCompletionRegistrationOptions>(this as InlineCompletionRegistrationOptions, _$identity);

  /// Serializes this InlineCompletionRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlineCompletionRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.id, id) || other.id == id)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),id,workDoneProgress);

@override
String toString() {
  return 'InlineCompletionRegistrationOptions(documentSelector: $documentSelector, id: $id, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $InlineCompletionRegistrationOptionsCopyWith<$Res>  {
  factory $InlineCompletionRegistrationOptionsCopyWith(InlineCompletionRegistrationOptions value, $Res Function(InlineCompletionRegistrationOptions) _then) = _$InlineCompletionRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 dynamic documentSelector, String? id, bool? workDoneProgress
});




}
/// @nodoc
class _$InlineCompletionRegistrationOptionsCopyWithImpl<$Res>
    implements $InlineCompletionRegistrationOptionsCopyWith<$Res> {
  _$InlineCompletionRegistrationOptionsCopyWithImpl(this._self, this._then);

  final InlineCompletionRegistrationOptions _self;
  final $Res Function(InlineCompletionRegistrationOptions) _then;

/// Create a copy of InlineCompletionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = freezed,Object? id = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _InlineCompletionRegistrationOptions implements InlineCompletionRegistrationOptions {
  const _InlineCompletionRegistrationOptions({required this.documentSelector, this.id, this.workDoneProgress});
  factory _InlineCompletionRegistrationOptions.fromJson(Map<String, dynamic> json) => _$InlineCompletionRegistrationOptionsFromJson(json);

@override final  dynamic documentSelector;
@override final  String? id;
@override final  bool? workDoneProgress;

/// Create a copy of InlineCompletionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlineCompletionRegistrationOptionsCopyWith<_InlineCompletionRegistrationOptions> get copyWith => __$InlineCompletionRegistrationOptionsCopyWithImpl<_InlineCompletionRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlineCompletionRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlineCompletionRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.id, id) || other.id == id)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),id,workDoneProgress);

@override
String toString() {
  return 'InlineCompletionRegistrationOptions(documentSelector: $documentSelector, id: $id, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$InlineCompletionRegistrationOptionsCopyWith<$Res> implements $InlineCompletionRegistrationOptionsCopyWith<$Res> {
  factory _$InlineCompletionRegistrationOptionsCopyWith(_InlineCompletionRegistrationOptions value, $Res Function(_InlineCompletionRegistrationOptions) _then) = __$InlineCompletionRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 dynamic documentSelector, String? id, bool? workDoneProgress
});




}
/// @nodoc
class __$InlineCompletionRegistrationOptionsCopyWithImpl<$Res>
    implements _$InlineCompletionRegistrationOptionsCopyWith<$Res> {
  __$InlineCompletionRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _InlineCompletionRegistrationOptions _self;
  final $Res Function(_InlineCompletionRegistrationOptions) _then;

/// Create a copy of InlineCompletionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = freezed,Object? id = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_InlineCompletionRegistrationOptions(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$RegistrationParams {

 List<Registration> get registrations;
/// Create a copy of RegistrationParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RegistrationParamsCopyWith<RegistrationParams> get copyWith => _$RegistrationParamsCopyWithImpl<RegistrationParams>(this as RegistrationParams, _$identity);

  /// Serializes this RegistrationParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RegistrationParams&&const DeepCollectionEquality().equals(other.registrations, registrations));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(registrations));

@override
String toString() {
  return 'RegistrationParams(registrations: $registrations)';
}


}

/// @nodoc
abstract mixin class $RegistrationParamsCopyWith<$Res>  {
  factory $RegistrationParamsCopyWith(RegistrationParams value, $Res Function(RegistrationParams) _then) = _$RegistrationParamsCopyWithImpl;
@useResult
$Res call({
 List<Registration> registrations
});




}
/// @nodoc
class _$RegistrationParamsCopyWithImpl<$Res>
    implements $RegistrationParamsCopyWith<$Res> {
  _$RegistrationParamsCopyWithImpl(this._self, this._then);

  final RegistrationParams _self;
  final $Res Function(RegistrationParams) _then;

/// Create a copy of RegistrationParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? registrations = null,}) {
  return _then(_self.copyWith(
registrations: null == registrations ? _self.registrations : registrations // ignore: cast_nullable_to_non_nullable
as List<Registration>,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _RegistrationParams implements RegistrationParams {
  const _RegistrationParams({required final  List<Registration> registrations}): _registrations = registrations;
  factory _RegistrationParams.fromJson(Map<String, dynamic> json) => _$RegistrationParamsFromJson(json);

 final  List<Registration> _registrations;
@override List<Registration> get registrations {
  if (_registrations is EqualUnmodifiableListView) return _registrations;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_registrations);
}


/// Create a copy of RegistrationParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RegistrationParamsCopyWith<_RegistrationParams> get copyWith => __$RegistrationParamsCopyWithImpl<_RegistrationParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$RegistrationParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _RegistrationParams&&const DeepCollectionEquality().equals(other._registrations, _registrations));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_registrations));

@override
String toString() {
  return 'RegistrationParams(registrations: $registrations)';
}


}

/// @nodoc
abstract mixin class _$RegistrationParamsCopyWith<$Res> implements $RegistrationParamsCopyWith<$Res> {
  factory _$RegistrationParamsCopyWith(_RegistrationParams value, $Res Function(_RegistrationParams) _then) = __$RegistrationParamsCopyWithImpl;
@override @useResult
$Res call({
 List<Registration> registrations
});




}
/// @nodoc
class __$RegistrationParamsCopyWithImpl<$Res>
    implements _$RegistrationParamsCopyWith<$Res> {
  __$RegistrationParamsCopyWithImpl(this._self, this._then);

  final _RegistrationParams _self;
  final $Res Function(_RegistrationParams) _then;

/// Create a copy of RegistrationParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? registrations = null,}) {
  return _then(_RegistrationParams(
registrations: null == registrations ? _self._registrations : registrations // ignore: cast_nullable_to_non_nullable
as List<Registration>,
  ));
}


}


/// @nodoc
mixin _$UnregistrationParams {

 List<Unregistration> get unregisterations;
/// Create a copy of UnregistrationParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UnregistrationParamsCopyWith<UnregistrationParams> get copyWith => _$UnregistrationParamsCopyWithImpl<UnregistrationParams>(this as UnregistrationParams, _$identity);

  /// Serializes this UnregistrationParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UnregistrationParams&&const DeepCollectionEquality().equals(other.unregisterations, unregisterations));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(unregisterations));

@override
String toString() {
  return 'UnregistrationParams(unregisterations: $unregisterations)';
}


}

/// @nodoc
abstract mixin class $UnregistrationParamsCopyWith<$Res>  {
  factory $UnregistrationParamsCopyWith(UnregistrationParams value, $Res Function(UnregistrationParams) _then) = _$UnregistrationParamsCopyWithImpl;
@useResult
$Res call({
 List<Unregistration> unregisterations
});




}
/// @nodoc
class _$UnregistrationParamsCopyWithImpl<$Res>
    implements $UnregistrationParamsCopyWith<$Res> {
  _$UnregistrationParamsCopyWithImpl(this._self, this._then);

  final UnregistrationParams _self;
  final $Res Function(UnregistrationParams) _then;

/// Create a copy of UnregistrationParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? unregisterations = null,}) {
  return _then(_self.copyWith(
unregisterations: null == unregisterations ? _self.unregisterations : unregisterations // ignore: cast_nullable_to_non_nullable
as List<Unregistration>,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _UnregistrationParams implements UnregistrationParams {
  const _UnregistrationParams({required final  List<Unregistration> unregisterations}): _unregisterations = unregisterations;
  factory _UnregistrationParams.fromJson(Map<String, dynamic> json) => _$UnregistrationParamsFromJson(json);

 final  List<Unregistration> _unregisterations;
@override List<Unregistration> get unregisterations {
  if (_unregisterations is EqualUnmodifiableListView) return _unregisterations;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_unregisterations);
}


/// Create a copy of UnregistrationParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$UnregistrationParamsCopyWith<_UnregistrationParams> get copyWith => __$UnregistrationParamsCopyWithImpl<_UnregistrationParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$UnregistrationParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _UnregistrationParams&&const DeepCollectionEquality().equals(other._unregisterations, _unregisterations));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_unregisterations));

@override
String toString() {
  return 'UnregistrationParams(unregisterations: $unregisterations)';
}


}

/// @nodoc
abstract mixin class _$UnregistrationParamsCopyWith<$Res> implements $UnregistrationParamsCopyWith<$Res> {
  factory _$UnregistrationParamsCopyWith(_UnregistrationParams value, $Res Function(_UnregistrationParams) _then) = __$UnregistrationParamsCopyWithImpl;
@override @useResult
$Res call({
 List<Unregistration> unregisterations
});




}
/// @nodoc
class __$UnregistrationParamsCopyWithImpl<$Res>
    implements _$UnregistrationParamsCopyWith<$Res> {
  __$UnregistrationParamsCopyWithImpl(this._self, this._then);

  final _UnregistrationParams _self;
  final $Res Function(_UnregistrationParams) _then;

/// Create a copy of UnregistrationParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? unregisterations = null,}) {
  return _then(_UnregistrationParams(
unregisterations: null == unregisterations ? _self._unregisterations : unregisterations // ignore: cast_nullable_to_non_nullable
as List<Unregistration>,
  ));
}


}


/// @nodoc
mixin _$InitializeParams {

 dynamic get processId; dynamic get rootUri; ClientCapabilities get capabilities; dynamic? get workspaceFolders; TraceValues? get trace; LSPAny? get initializationOptions; dynamic? get rootPath; String? get locale; ({String name, String? version})? get clientInfo; ProgressToken? get workDoneToken;
/// Create a copy of InitializeParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InitializeParamsCopyWith<InitializeParams> get copyWith => _$InitializeParamsCopyWithImpl<InitializeParams>(this as InitializeParams, _$identity);

  /// Serializes this InitializeParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InitializeParams&&const DeepCollectionEquality().equals(other.processId, processId)&&const DeepCollectionEquality().equals(other.rootUri, rootUri)&&(identical(other.capabilities, capabilities) || other.capabilities == capabilities)&&const DeepCollectionEquality().equals(other.workspaceFolders, workspaceFolders)&&(identical(other.trace, trace) || other.trace == trace)&&const DeepCollectionEquality().equals(other.initializationOptions, initializationOptions)&&const DeepCollectionEquality().equals(other.rootPath, rootPath)&&(identical(other.locale, locale) || other.locale == locale)&&(identical(other.clientInfo, clientInfo) || other.clientInfo == clientInfo)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(processId),const DeepCollectionEquality().hash(rootUri),capabilities,const DeepCollectionEquality().hash(workspaceFolders),trace,const DeepCollectionEquality().hash(initializationOptions),const DeepCollectionEquality().hash(rootPath),locale,clientInfo,const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'InitializeParams(processId: $processId, rootUri: $rootUri, capabilities: $capabilities, workspaceFolders: $workspaceFolders, trace: $trace, initializationOptions: $initializationOptions, rootPath: $rootPath, locale: $locale, clientInfo: $clientInfo, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $InitializeParamsCopyWith<$Res>  {
  factory $InitializeParamsCopyWith(InitializeParams value, $Res Function(InitializeParams) _then) = _$InitializeParamsCopyWithImpl;
@useResult
$Res call({
 dynamic processId, dynamic rootUri, ClientCapabilities capabilities, dynamic? workspaceFolders, TraceValues? trace, LSPAny? initializationOptions, dynamic? rootPath, String? locale, ({String name, String? version})? clientInfo, ProgressToken? workDoneToken
});


$ClientCapabilitiesCopyWith<$Res> get capabilities;

}
/// @nodoc
class _$InitializeParamsCopyWithImpl<$Res>
    implements $InitializeParamsCopyWith<$Res> {
  _$InitializeParamsCopyWithImpl(this._self, this._then);

  final InitializeParams _self;
  final $Res Function(InitializeParams) _then;

/// Create a copy of InitializeParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? processId = freezed,Object? rootUri = freezed,Object? capabilities = null,Object? workspaceFolders = freezed,Object? trace = freezed,Object? initializationOptions = freezed,Object? rootPath = freezed,Object? locale = freezed,Object? clientInfo = freezed,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
processId: freezed == processId ? _self.processId : processId // ignore: cast_nullable_to_non_nullable
as dynamic,rootUri: freezed == rootUri ? _self.rootUri : rootUri // ignore: cast_nullable_to_non_nullable
as dynamic,capabilities: null == capabilities ? _self.capabilities : capabilities // ignore: cast_nullable_to_non_nullable
as ClientCapabilities,workspaceFolders: freezed == workspaceFolders ? _self.workspaceFolders : workspaceFolders // ignore: cast_nullable_to_non_nullable
as dynamic?,trace: freezed == trace ? _self.trace : trace // ignore: cast_nullable_to_non_nullable
as TraceValues?,initializationOptions: freezed == initializationOptions ? _self.initializationOptions : initializationOptions // ignore: cast_nullable_to_non_nullable
as LSPAny?,rootPath: freezed == rootPath ? _self.rootPath : rootPath // ignore: cast_nullable_to_non_nullable
as dynamic?,locale: freezed == locale ? _self.locale : locale // ignore: cast_nullable_to_non_nullable
as String?,clientInfo: freezed == clientInfo ? _self.clientInfo : clientInfo // ignore: cast_nullable_to_non_nullable
as ({String name, String? version})?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of InitializeParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ClientCapabilitiesCopyWith<$Res> get capabilities {
  
  return $ClientCapabilitiesCopyWith<$Res>(_self.capabilities, (value) {
    return _then(_self.copyWith(capabilities: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _InitializeParams implements InitializeParams {
  const _InitializeParams({required this.processId, required this.rootUri, required this.capabilities, this.workspaceFolders, this.trace, this.initializationOptions, this.rootPath, this.locale, this.clientInfo, this.workDoneToken});
  factory _InitializeParams.fromJson(Map<String, dynamic> json) => _$InitializeParamsFromJson(json);

@override final  dynamic processId;
@override final  dynamic rootUri;
@override final  ClientCapabilities capabilities;
@override final  dynamic? workspaceFolders;
@override final  TraceValues? trace;
@override final  LSPAny? initializationOptions;
@override final  dynamic? rootPath;
@override final  String? locale;
@override final  ({String name, String? version})? clientInfo;
@override final  ProgressToken? workDoneToken;

/// Create a copy of InitializeParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InitializeParamsCopyWith<_InitializeParams> get copyWith => __$InitializeParamsCopyWithImpl<_InitializeParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InitializeParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InitializeParams&&const DeepCollectionEquality().equals(other.processId, processId)&&const DeepCollectionEquality().equals(other.rootUri, rootUri)&&(identical(other.capabilities, capabilities) || other.capabilities == capabilities)&&const DeepCollectionEquality().equals(other.workspaceFolders, workspaceFolders)&&(identical(other.trace, trace) || other.trace == trace)&&const DeepCollectionEquality().equals(other.initializationOptions, initializationOptions)&&const DeepCollectionEquality().equals(other.rootPath, rootPath)&&(identical(other.locale, locale) || other.locale == locale)&&(identical(other.clientInfo, clientInfo) || other.clientInfo == clientInfo)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(processId),const DeepCollectionEquality().hash(rootUri),capabilities,const DeepCollectionEquality().hash(workspaceFolders),trace,const DeepCollectionEquality().hash(initializationOptions),const DeepCollectionEquality().hash(rootPath),locale,clientInfo,const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'InitializeParams(processId: $processId, rootUri: $rootUri, capabilities: $capabilities, workspaceFolders: $workspaceFolders, trace: $trace, initializationOptions: $initializationOptions, rootPath: $rootPath, locale: $locale, clientInfo: $clientInfo, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$InitializeParamsCopyWith<$Res> implements $InitializeParamsCopyWith<$Res> {
  factory _$InitializeParamsCopyWith(_InitializeParams value, $Res Function(_InitializeParams) _then) = __$InitializeParamsCopyWithImpl;
@override @useResult
$Res call({
 dynamic processId, dynamic rootUri, ClientCapabilities capabilities, dynamic? workspaceFolders, TraceValues? trace, LSPAny? initializationOptions, dynamic? rootPath, String? locale, ({String name, String? version})? clientInfo, ProgressToken? workDoneToken
});


@override $ClientCapabilitiesCopyWith<$Res> get capabilities;

}
/// @nodoc
class __$InitializeParamsCopyWithImpl<$Res>
    implements _$InitializeParamsCopyWith<$Res> {
  __$InitializeParamsCopyWithImpl(this._self, this._then);

  final _InitializeParams _self;
  final $Res Function(_InitializeParams) _then;

/// Create a copy of InitializeParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? processId = freezed,Object? rootUri = freezed,Object? capabilities = null,Object? workspaceFolders = freezed,Object? trace = freezed,Object? initializationOptions = freezed,Object? rootPath = freezed,Object? locale = freezed,Object? clientInfo = freezed,Object? workDoneToken = freezed,}) {
  return _then(_InitializeParams(
processId: freezed == processId ? _self.processId : processId // ignore: cast_nullable_to_non_nullable
as dynamic,rootUri: freezed == rootUri ? _self.rootUri : rootUri // ignore: cast_nullable_to_non_nullable
as dynamic,capabilities: null == capabilities ? _self.capabilities : capabilities // ignore: cast_nullable_to_non_nullable
as ClientCapabilities,workspaceFolders: freezed == workspaceFolders ? _self.workspaceFolders : workspaceFolders // ignore: cast_nullable_to_non_nullable
as dynamic?,trace: freezed == trace ? _self.trace : trace // ignore: cast_nullable_to_non_nullable
as TraceValues?,initializationOptions: freezed == initializationOptions ? _self.initializationOptions : initializationOptions // ignore: cast_nullable_to_non_nullable
as LSPAny?,rootPath: freezed == rootPath ? _self.rootPath : rootPath // ignore: cast_nullable_to_non_nullable
as dynamic?,locale: freezed == locale ? _self.locale : locale // ignore: cast_nullable_to_non_nullable
as String?,clientInfo: freezed == clientInfo ? _self.clientInfo : clientInfo // ignore: cast_nullable_to_non_nullable
as ({String name, String? version})?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of InitializeParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ClientCapabilitiesCopyWith<$Res> get capabilities {
  
  return $ClientCapabilitiesCopyWith<$Res>(_self.capabilities, (value) {
    return _then(_self.copyWith(capabilities: value));
  });
}
}


/// @nodoc
mixin _$InitializeResult {

 ServerCapabilities get capabilities; ({String name, String? version})? get serverInfo;
/// Create a copy of InitializeResult
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InitializeResultCopyWith<InitializeResult> get copyWith => _$InitializeResultCopyWithImpl<InitializeResult>(this as InitializeResult, _$identity);

  /// Serializes this InitializeResult to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InitializeResult&&(identical(other.capabilities, capabilities) || other.capabilities == capabilities)&&(identical(other.serverInfo, serverInfo) || other.serverInfo == serverInfo));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,capabilities,serverInfo);

@override
String toString() {
  return 'InitializeResult(capabilities: $capabilities, serverInfo: $serverInfo)';
}


}

/// @nodoc
abstract mixin class $InitializeResultCopyWith<$Res>  {
  factory $InitializeResultCopyWith(InitializeResult value, $Res Function(InitializeResult) _then) = _$InitializeResultCopyWithImpl;
@useResult
$Res call({
 ServerCapabilities capabilities, ({String name, String? version})? serverInfo
});


$ServerCapabilitiesCopyWith<$Res> get capabilities;

}
/// @nodoc
class _$InitializeResultCopyWithImpl<$Res>
    implements $InitializeResultCopyWith<$Res> {
  _$InitializeResultCopyWithImpl(this._self, this._then);

  final InitializeResult _self;
  final $Res Function(InitializeResult) _then;

/// Create a copy of InitializeResult
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? capabilities = null,Object? serverInfo = freezed,}) {
  return _then(_self.copyWith(
capabilities: null == capabilities ? _self.capabilities : capabilities // ignore: cast_nullable_to_non_nullable
as ServerCapabilities,serverInfo: freezed == serverInfo ? _self.serverInfo : serverInfo // ignore: cast_nullable_to_non_nullable
as ({String name, String? version})?,
  ));
}
/// Create a copy of InitializeResult
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ServerCapabilitiesCopyWith<$Res> get capabilities {
  
  return $ServerCapabilitiesCopyWith<$Res>(_self.capabilities, (value) {
    return _then(_self.copyWith(capabilities: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _InitializeResult implements InitializeResult {
  const _InitializeResult({required this.capabilities, this.serverInfo});
  factory _InitializeResult.fromJson(Map<String, dynamic> json) => _$InitializeResultFromJson(json);

@override final  ServerCapabilities capabilities;
@override final  ({String name, String? version})? serverInfo;

/// Create a copy of InitializeResult
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InitializeResultCopyWith<_InitializeResult> get copyWith => __$InitializeResultCopyWithImpl<_InitializeResult>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InitializeResultToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InitializeResult&&(identical(other.capabilities, capabilities) || other.capabilities == capabilities)&&(identical(other.serverInfo, serverInfo) || other.serverInfo == serverInfo));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,capabilities,serverInfo);

@override
String toString() {
  return 'InitializeResult(capabilities: $capabilities, serverInfo: $serverInfo)';
}


}

/// @nodoc
abstract mixin class _$InitializeResultCopyWith<$Res> implements $InitializeResultCopyWith<$Res> {
  factory _$InitializeResultCopyWith(_InitializeResult value, $Res Function(_InitializeResult) _then) = __$InitializeResultCopyWithImpl;
@override @useResult
$Res call({
 ServerCapabilities capabilities, ({String name, String? version})? serverInfo
});


@override $ServerCapabilitiesCopyWith<$Res> get capabilities;

}
/// @nodoc
class __$InitializeResultCopyWithImpl<$Res>
    implements _$InitializeResultCopyWith<$Res> {
  __$InitializeResultCopyWithImpl(this._self, this._then);

  final _InitializeResult _self;
  final $Res Function(_InitializeResult) _then;

/// Create a copy of InitializeResult
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? capabilities = null,Object? serverInfo = freezed,}) {
  return _then(_InitializeResult(
capabilities: null == capabilities ? _self.capabilities : capabilities // ignore: cast_nullable_to_non_nullable
as ServerCapabilities,serverInfo: freezed == serverInfo ? _self.serverInfo : serverInfo // ignore: cast_nullable_to_non_nullable
as ({String name, String? version})?,
  ));
}

/// Create a copy of InitializeResult
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ServerCapabilitiesCopyWith<$Res> get capabilities {
  
  return $ServerCapabilitiesCopyWith<$Res>(_self.capabilities, (value) {
    return _then(_self.copyWith(capabilities: value));
  });
}
}


/// @nodoc
mixin _$InitializeError {

 bool get retry;
/// Create a copy of InitializeError
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InitializeErrorCopyWith<InitializeError> get copyWith => _$InitializeErrorCopyWithImpl<InitializeError>(this as InitializeError, _$identity);

  /// Serializes this InitializeError to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InitializeError&&(identical(other.retry, retry) || other.retry == retry));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,retry);

@override
String toString() {
  return 'InitializeError(retry: $retry)';
}


}

/// @nodoc
abstract mixin class $InitializeErrorCopyWith<$Res>  {
  factory $InitializeErrorCopyWith(InitializeError value, $Res Function(InitializeError) _then) = _$InitializeErrorCopyWithImpl;
@useResult
$Res call({
 bool retry
});




}
/// @nodoc
class _$InitializeErrorCopyWithImpl<$Res>
    implements $InitializeErrorCopyWith<$Res> {
  _$InitializeErrorCopyWithImpl(this._self, this._then);

  final InitializeError _self;
  final $Res Function(InitializeError) _then;

/// Create a copy of InitializeError
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? retry = null,}) {
  return _then(_self.copyWith(
retry: null == retry ? _self.retry : retry // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _InitializeError implements InitializeError {
  const _InitializeError({required this.retry});
  factory _InitializeError.fromJson(Map<String, dynamic> json) => _$InitializeErrorFromJson(json);

@override final  bool retry;

/// Create a copy of InitializeError
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InitializeErrorCopyWith<_InitializeError> get copyWith => __$InitializeErrorCopyWithImpl<_InitializeError>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InitializeErrorToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InitializeError&&(identical(other.retry, retry) || other.retry == retry));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,retry);

@override
String toString() {
  return 'InitializeError(retry: $retry)';
}


}

/// @nodoc
abstract mixin class _$InitializeErrorCopyWith<$Res> implements $InitializeErrorCopyWith<$Res> {
  factory _$InitializeErrorCopyWith(_InitializeError value, $Res Function(_InitializeError) _then) = __$InitializeErrorCopyWithImpl;
@override @useResult
$Res call({
 bool retry
});




}
/// @nodoc
class __$InitializeErrorCopyWithImpl<$Res>
    implements _$InitializeErrorCopyWith<$Res> {
  __$InitializeErrorCopyWithImpl(this._self, this._then);

  final _InitializeError _self;
  final $Res Function(_InitializeError) _then;

/// Create a copy of InitializeError
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? retry = null,}) {
  return _then(_InitializeError(
retry: null == retry ? _self.retry : retry // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}


}


/// @nodoc
mixin _$InitializedParams {



  /// Serializes this InitializedParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InitializedParams);
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'InitializedParams()';
}


}

/// @nodoc
class $InitializedParamsCopyWith<$Res>  {
$InitializedParamsCopyWith(InitializedParams _, $Res Function(InitializedParams) __);
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _InitializedParams implements InitializedParams {
  const _InitializedParams();
  factory _InitializedParams.fromJson(Map<String, dynamic> json) => _$InitializedParamsFromJson(json);




@override
Map<String, dynamic> toJson() {
  return _$InitializedParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InitializedParams);
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'InitializedParams()';
}


}





/// @nodoc
mixin _$DidChangeConfigurationParams {

 LSPAny get settings;
/// Create a copy of DidChangeConfigurationParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DidChangeConfigurationParamsCopyWith<DidChangeConfigurationParams> get copyWith => _$DidChangeConfigurationParamsCopyWithImpl<DidChangeConfigurationParams>(this as DidChangeConfigurationParams, _$identity);

  /// Serializes this DidChangeConfigurationParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DidChangeConfigurationParams&&const DeepCollectionEquality().equals(other.settings, settings));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(settings));

@override
String toString() {
  return 'DidChangeConfigurationParams(settings: $settings)';
}


}

/// @nodoc
abstract mixin class $DidChangeConfigurationParamsCopyWith<$Res>  {
  factory $DidChangeConfigurationParamsCopyWith(DidChangeConfigurationParams value, $Res Function(DidChangeConfigurationParams) _then) = _$DidChangeConfigurationParamsCopyWithImpl;
@useResult
$Res call({
 LSPAny settings
});




}
/// @nodoc
class _$DidChangeConfigurationParamsCopyWithImpl<$Res>
    implements $DidChangeConfigurationParamsCopyWith<$Res> {
  _$DidChangeConfigurationParamsCopyWithImpl(this._self, this._then);

  final DidChangeConfigurationParams _self;
  final $Res Function(DidChangeConfigurationParams) _then;

/// Create a copy of DidChangeConfigurationParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? settings = freezed,}) {
  return _then(_self.copyWith(
settings: freezed == settings ? _self.settings : settings // ignore: cast_nullable_to_non_nullable
as LSPAny,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DidChangeConfigurationParams implements DidChangeConfigurationParams {
  const _DidChangeConfigurationParams({required this.settings});
  factory _DidChangeConfigurationParams.fromJson(Map<String, dynamic> json) => _$DidChangeConfigurationParamsFromJson(json);

@override final  LSPAny settings;

/// Create a copy of DidChangeConfigurationParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DidChangeConfigurationParamsCopyWith<_DidChangeConfigurationParams> get copyWith => __$DidChangeConfigurationParamsCopyWithImpl<_DidChangeConfigurationParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DidChangeConfigurationParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DidChangeConfigurationParams&&const DeepCollectionEquality().equals(other.settings, settings));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(settings));

@override
String toString() {
  return 'DidChangeConfigurationParams(settings: $settings)';
}


}

/// @nodoc
abstract mixin class _$DidChangeConfigurationParamsCopyWith<$Res> implements $DidChangeConfigurationParamsCopyWith<$Res> {
  factory _$DidChangeConfigurationParamsCopyWith(_DidChangeConfigurationParams value, $Res Function(_DidChangeConfigurationParams) _then) = __$DidChangeConfigurationParamsCopyWithImpl;
@override @useResult
$Res call({
 LSPAny settings
});




}
/// @nodoc
class __$DidChangeConfigurationParamsCopyWithImpl<$Res>
    implements _$DidChangeConfigurationParamsCopyWith<$Res> {
  __$DidChangeConfigurationParamsCopyWithImpl(this._self, this._then);

  final _DidChangeConfigurationParams _self;
  final $Res Function(_DidChangeConfigurationParams) _then;

/// Create a copy of DidChangeConfigurationParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? settings = freezed,}) {
  return _then(_DidChangeConfigurationParams(
settings: freezed == settings ? _self.settings : settings // ignore: cast_nullable_to_non_nullable
as LSPAny,
  ));
}


}


/// @nodoc
mixin _$DidChangeConfigurationRegistrationOptions {

 dynamic? get section;
/// Create a copy of DidChangeConfigurationRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DidChangeConfigurationRegistrationOptionsCopyWith<DidChangeConfigurationRegistrationOptions> get copyWith => _$DidChangeConfigurationRegistrationOptionsCopyWithImpl<DidChangeConfigurationRegistrationOptions>(this as DidChangeConfigurationRegistrationOptions, _$identity);

  /// Serializes this DidChangeConfigurationRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DidChangeConfigurationRegistrationOptions&&const DeepCollectionEquality().equals(other.section, section));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(section));

@override
String toString() {
  return 'DidChangeConfigurationRegistrationOptions(section: $section)';
}


}

/// @nodoc
abstract mixin class $DidChangeConfigurationRegistrationOptionsCopyWith<$Res>  {
  factory $DidChangeConfigurationRegistrationOptionsCopyWith(DidChangeConfigurationRegistrationOptions value, $Res Function(DidChangeConfigurationRegistrationOptions) _then) = _$DidChangeConfigurationRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 dynamic? section
});




}
/// @nodoc
class _$DidChangeConfigurationRegistrationOptionsCopyWithImpl<$Res>
    implements $DidChangeConfigurationRegistrationOptionsCopyWith<$Res> {
  _$DidChangeConfigurationRegistrationOptionsCopyWithImpl(this._self, this._then);

  final DidChangeConfigurationRegistrationOptions _self;
  final $Res Function(DidChangeConfigurationRegistrationOptions) _then;

/// Create a copy of DidChangeConfigurationRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? section = freezed,}) {
  return _then(_self.copyWith(
section: freezed == section ? _self.section : section // ignore: cast_nullable_to_non_nullable
as dynamic?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DidChangeConfigurationRegistrationOptions implements DidChangeConfigurationRegistrationOptions {
  const _DidChangeConfigurationRegistrationOptions({this.section});
  factory _DidChangeConfigurationRegistrationOptions.fromJson(Map<String, dynamic> json) => _$DidChangeConfigurationRegistrationOptionsFromJson(json);

@override final  dynamic? section;

/// Create a copy of DidChangeConfigurationRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DidChangeConfigurationRegistrationOptionsCopyWith<_DidChangeConfigurationRegistrationOptions> get copyWith => __$DidChangeConfigurationRegistrationOptionsCopyWithImpl<_DidChangeConfigurationRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DidChangeConfigurationRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DidChangeConfigurationRegistrationOptions&&const DeepCollectionEquality().equals(other.section, section));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(section));

@override
String toString() {
  return 'DidChangeConfigurationRegistrationOptions(section: $section)';
}


}

/// @nodoc
abstract mixin class _$DidChangeConfigurationRegistrationOptionsCopyWith<$Res> implements $DidChangeConfigurationRegistrationOptionsCopyWith<$Res> {
  factory _$DidChangeConfigurationRegistrationOptionsCopyWith(_DidChangeConfigurationRegistrationOptions value, $Res Function(_DidChangeConfigurationRegistrationOptions) _then) = __$DidChangeConfigurationRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 dynamic? section
});




}
/// @nodoc
class __$DidChangeConfigurationRegistrationOptionsCopyWithImpl<$Res>
    implements _$DidChangeConfigurationRegistrationOptionsCopyWith<$Res> {
  __$DidChangeConfigurationRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _DidChangeConfigurationRegistrationOptions _self;
  final $Res Function(_DidChangeConfigurationRegistrationOptions) _then;

/// Create a copy of DidChangeConfigurationRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? section = freezed,}) {
  return _then(_DidChangeConfigurationRegistrationOptions(
section: freezed == section ? _self.section : section // ignore: cast_nullable_to_non_nullable
as dynamic?,
  ));
}


}


/// @nodoc
mixin _$ShowMessageParams {

 MessageType get type; String get message;
/// Create a copy of ShowMessageParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ShowMessageParamsCopyWith<ShowMessageParams> get copyWith => _$ShowMessageParamsCopyWithImpl<ShowMessageParams>(this as ShowMessageParams, _$identity);

  /// Serializes this ShowMessageParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ShowMessageParams&&(identical(other.type, type) || other.type == type)&&(identical(other.message, message) || other.message == message));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,type,message);

@override
String toString() {
  return 'ShowMessageParams(type: $type, message: $message)';
}


}

/// @nodoc
abstract mixin class $ShowMessageParamsCopyWith<$Res>  {
  factory $ShowMessageParamsCopyWith(ShowMessageParams value, $Res Function(ShowMessageParams) _then) = _$ShowMessageParamsCopyWithImpl;
@useResult
$Res call({
 MessageType type, String message
});




}
/// @nodoc
class _$ShowMessageParamsCopyWithImpl<$Res>
    implements $ShowMessageParamsCopyWith<$Res> {
  _$ShowMessageParamsCopyWithImpl(this._self, this._then);

  final ShowMessageParams _self;
  final $Res Function(ShowMessageParams) _then;

/// Create a copy of ShowMessageParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? type = null,Object? message = null,}) {
  return _then(_self.copyWith(
type: null == type ? _self.type : type // ignore: cast_nullable_to_non_nullable
as MessageType,message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _ShowMessageParams implements ShowMessageParams {
  const _ShowMessageParams({required this.type, required this.message});
  factory _ShowMessageParams.fromJson(Map<String, dynamic> json) => _$ShowMessageParamsFromJson(json);

@override final  MessageType type;
@override final  String message;

/// Create a copy of ShowMessageParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ShowMessageParamsCopyWith<_ShowMessageParams> get copyWith => __$ShowMessageParamsCopyWithImpl<_ShowMessageParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ShowMessageParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ShowMessageParams&&(identical(other.type, type) || other.type == type)&&(identical(other.message, message) || other.message == message));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,type,message);

@override
String toString() {
  return 'ShowMessageParams(type: $type, message: $message)';
}


}

/// @nodoc
abstract mixin class _$ShowMessageParamsCopyWith<$Res> implements $ShowMessageParamsCopyWith<$Res> {
  factory _$ShowMessageParamsCopyWith(_ShowMessageParams value, $Res Function(_ShowMessageParams) _then) = __$ShowMessageParamsCopyWithImpl;
@override @useResult
$Res call({
 MessageType type, String message
});




}
/// @nodoc
class __$ShowMessageParamsCopyWithImpl<$Res>
    implements _$ShowMessageParamsCopyWith<$Res> {
  __$ShowMessageParamsCopyWithImpl(this._self, this._then);

  final _ShowMessageParams _self;
  final $Res Function(_ShowMessageParams) _then;

/// Create a copy of ShowMessageParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? type = null,Object? message = null,}) {
  return _then(_ShowMessageParams(
type: null == type ? _self.type : type // ignore: cast_nullable_to_non_nullable
as MessageType,message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}


/// @nodoc
mixin _$ShowMessageRequestParams {

 MessageType get type; String get message; List<MessageActionItem>? get actions;
/// Create a copy of ShowMessageRequestParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ShowMessageRequestParamsCopyWith<ShowMessageRequestParams> get copyWith => _$ShowMessageRequestParamsCopyWithImpl<ShowMessageRequestParams>(this as ShowMessageRequestParams, _$identity);

  /// Serializes this ShowMessageRequestParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ShowMessageRequestParams&&(identical(other.type, type) || other.type == type)&&(identical(other.message, message) || other.message == message)&&const DeepCollectionEquality().equals(other.actions, actions));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,type,message,const DeepCollectionEquality().hash(actions));

@override
String toString() {
  return 'ShowMessageRequestParams(type: $type, message: $message, actions: $actions)';
}


}

/// @nodoc
abstract mixin class $ShowMessageRequestParamsCopyWith<$Res>  {
  factory $ShowMessageRequestParamsCopyWith(ShowMessageRequestParams value, $Res Function(ShowMessageRequestParams) _then) = _$ShowMessageRequestParamsCopyWithImpl;
@useResult
$Res call({
 MessageType type, String message, List<MessageActionItem>? actions
});




}
/// @nodoc
class _$ShowMessageRequestParamsCopyWithImpl<$Res>
    implements $ShowMessageRequestParamsCopyWith<$Res> {
  _$ShowMessageRequestParamsCopyWithImpl(this._self, this._then);

  final ShowMessageRequestParams _self;
  final $Res Function(ShowMessageRequestParams) _then;

/// Create a copy of ShowMessageRequestParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? type = null,Object? message = null,Object? actions = freezed,}) {
  return _then(_self.copyWith(
type: null == type ? _self.type : type // ignore: cast_nullable_to_non_nullable
as MessageType,message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,actions: freezed == actions ? _self.actions : actions // ignore: cast_nullable_to_non_nullable
as List<MessageActionItem>?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _ShowMessageRequestParams implements ShowMessageRequestParams {
  const _ShowMessageRequestParams({required this.type, required this.message, final  List<MessageActionItem>? actions}): _actions = actions;
  factory _ShowMessageRequestParams.fromJson(Map<String, dynamic> json) => _$ShowMessageRequestParamsFromJson(json);

@override final  MessageType type;
@override final  String message;
 final  List<MessageActionItem>? _actions;
@override List<MessageActionItem>? get actions {
  final value = _actions;
  if (value == null) return null;
  if (_actions is EqualUnmodifiableListView) return _actions;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}


/// Create a copy of ShowMessageRequestParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ShowMessageRequestParamsCopyWith<_ShowMessageRequestParams> get copyWith => __$ShowMessageRequestParamsCopyWithImpl<_ShowMessageRequestParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ShowMessageRequestParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ShowMessageRequestParams&&(identical(other.type, type) || other.type == type)&&(identical(other.message, message) || other.message == message)&&const DeepCollectionEquality().equals(other._actions, _actions));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,type,message,const DeepCollectionEquality().hash(_actions));

@override
String toString() {
  return 'ShowMessageRequestParams(type: $type, message: $message, actions: $actions)';
}


}

/// @nodoc
abstract mixin class _$ShowMessageRequestParamsCopyWith<$Res> implements $ShowMessageRequestParamsCopyWith<$Res> {
  factory _$ShowMessageRequestParamsCopyWith(_ShowMessageRequestParams value, $Res Function(_ShowMessageRequestParams) _then) = __$ShowMessageRequestParamsCopyWithImpl;
@override @useResult
$Res call({
 MessageType type, String message, List<MessageActionItem>? actions
});




}
/// @nodoc
class __$ShowMessageRequestParamsCopyWithImpl<$Res>
    implements _$ShowMessageRequestParamsCopyWith<$Res> {
  __$ShowMessageRequestParamsCopyWithImpl(this._self, this._then);

  final _ShowMessageRequestParams _self;
  final $Res Function(_ShowMessageRequestParams) _then;

/// Create a copy of ShowMessageRequestParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? type = null,Object? message = null,Object? actions = freezed,}) {
  return _then(_ShowMessageRequestParams(
type: null == type ? _self.type : type // ignore: cast_nullable_to_non_nullable
as MessageType,message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,actions: freezed == actions ? _self._actions : actions // ignore: cast_nullable_to_non_nullable
as List<MessageActionItem>?,
  ));
}


}


/// @nodoc
mixin _$MessageActionItem {

 String get title;
/// Create a copy of MessageActionItem
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$MessageActionItemCopyWith<MessageActionItem> get copyWith => _$MessageActionItemCopyWithImpl<MessageActionItem>(this as MessageActionItem, _$identity);

  /// Serializes this MessageActionItem to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is MessageActionItem&&(identical(other.title, title) || other.title == title));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,title);

@override
String toString() {
  return 'MessageActionItem(title: $title)';
}


}

/// @nodoc
abstract mixin class $MessageActionItemCopyWith<$Res>  {
  factory $MessageActionItemCopyWith(MessageActionItem value, $Res Function(MessageActionItem) _then) = _$MessageActionItemCopyWithImpl;
@useResult
$Res call({
 String title
});




}
/// @nodoc
class _$MessageActionItemCopyWithImpl<$Res>
    implements $MessageActionItemCopyWith<$Res> {
  _$MessageActionItemCopyWithImpl(this._self, this._then);

  final MessageActionItem _self;
  final $Res Function(MessageActionItem) _then;

/// Create a copy of MessageActionItem
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? title = null,}) {
  return _then(_self.copyWith(
title: null == title ? _self.title : title // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _MessageActionItem implements MessageActionItem {
  const _MessageActionItem({required this.title});
  factory _MessageActionItem.fromJson(Map<String, dynamic> json) => _$MessageActionItemFromJson(json);

@override final  String title;

/// Create a copy of MessageActionItem
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$MessageActionItemCopyWith<_MessageActionItem> get copyWith => __$MessageActionItemCopyWithImpl<_MessageActionItem>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$MessageActionItemToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _MessageActionItem&&(identical(other.title, title) || other.title == title));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,title);

@override
String toString() {
  return 'MessageActionItem(title: $title)';
}


}

/// @nodoc
abstract mixin class _$MessageActionItemCopyWith<$Res> implements $MessageActionItemCopyWith<$Res> {
  factory _$MessageActionItemCopyWith(_MessageActionItem value, $Res Function(_MessageActionItem) _then) = __$MessageActionItemCopyWithImpl;
@override @useResult
$Res call({
 String title
});




}
/// @nodoc
class __$MessageActionItemCopyWithImpl<$Res>
    implements _$MessageActionItemCopyWith<$Res> {
  __$MessageActionItemCopyWithImpl(this._self, this._then);

  final _MessageActionItem _self;
  final $Res Function(_MessageActionItem) _then;

/// Create a copy of MessageActionItem
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? title = null,}) {
  return _then(_MessageActionItem(
title: null == title ? _self.title : title // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}


/// @nodoc
mixin _$LogMessageParams {

 MessageType get type; String get message;
/// Create a copy of LogMessageParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LogMessageParamsCopyWith<LogMessageParams> get copyWith => _$LogMessageParamsCopyWithImpl<LogMessageParams>(this as LogMessageParams, _$identity);

  /// Serializes this LogMessageParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LogMessageParams&&(identical(other.type, type) || other.type == type)&&(identical(other.message, message) || other.message == message));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,type,message);

@override
String toString() {
  return 'LogMessageParams(type: $type, message: $message)';
}


}

/// @nodoc
abstract mixin class $LogMessageParamsCopyWith<$Res>  {
  factory $LogMessageParamsCopyWith(LogMessageParams value, $Res Function(LogMessageParams) _then) = _$LogMessageParamsCopyWithImpl;
@useResult
$Res call({
 MessageType type, String message
});




}
/// @nodoc
class _$LogMessageParamsCopyWithImpl<$Res>
    implements $LogMessageParamsCopyWith<$Res> {
  _$LogMessageParamsCopyWithImpl(this._self, this._then);

  final LogMessageParams _self;
  final $Res Function(LogMessageParams) _then;

/// Create a copy of LogMessageParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? type = null,Object? message = null,}) {
  return _then(_self.copyWith(
type: null == type ? _self.type : type // ignore: cast_nullable_to_non_nullable
as MessageType,message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _LogMessageParams implements LogMessageParams {
  const _LogMessageParams({required this.type, required this.message});
  factory _LogMessageParams.fromJson(Map<String, dynamic> json) => _$LogMessageParamsFromJson(json);

@override final  MessageType type;
@override final  String message;

/// Create a copy of LogMessageParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$LogMessageParamsCopyWith<_LogMessageParams> get copyWith => __$LogMessageParamsCopyWithImpl<_LogMessageParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$LogMessageParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _LogMessageParams&&(identical(other.type, type) || other.type == type)&&(identical(other.message, message) || other.message == message));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,type,message);

@override
String toString() {
  return 'LogMessageParams(type: $type, message: $message)';
}


}

/// @nodoc
abstract mixin class _$LogMessageParamsCopyWith<$Res> implements $LogMessageParamsCopyWith<$Res> {
  factory _$LogMessageParamsCopyWith(_LogMessageParams value, $Res Function(_LogMessageParams) _then) = __$LogMessageParamsCopyWithImpl;
@override @useResult
$Res call({
 MessageType type, String message
});




}
/// @nodoc
class __$LogMessageParamsCopyWithImpl<$Res>
    implements _$LogMessageParamsCopyWith<$Res> {
  __$LogMessageParamsCopyWithImpl(this._self, this._then);

  final _LogMessageParams _self;
  final $Res Function(_LogMessageParams) _then;

/// Create a copy of LogMessageParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? type = null,Object? message = null,}) {
  return _then(_LogMessageParams(
type: null == type ? _self.type : type // ignore: cast_nullable_to_non_nullable
as MessageType,message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}


/// @nodoc
mixin _$DidOpenTextDocumentParams {

 TextDocumentItem get textDocument;
/// Create a copy of DidOpenTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DidOpenTextDocumentParamsCopyWith<DidOpenTextDocumentParams> get copyWith => _$DidOpenTextDocumentParamsCopyWithImpl<DidOpenTextDocumentParams>(this as DidOpenTextDocumentParams, _$identity);

  /// Serializes this DidOpenTextDocumentParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DidOpenTextDocumentParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument);

@override
String toString() {
  return 'DidOpenTextDocumentParams(textDocument: $textDocument)';
}


}

/// @nodoc
abstract mixin class $DidOpenTextDocumentParamsCopyWith<$Res>  {
  factory $DidOpenTextDocumentParamsCopyWith(DidOpenTextDocumentParams value, $Res Function(DidOpenTextDocumentParams) _then) = _$DidOpenTextDocumentParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentItem textDocument
});


$TextDocumentItemCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$DidOpenTextDocumentParamsCopyWithImpl<$Res>
    implements $DidOpenTextDocumentParamsCopyWith<$Res> {
  _$DidOpenTextDocumentParamsCopyWithImpl(this._self, this._then);

  final DidOpenTextDocumentParams _self;
  final $Res Function(DidOpenTextDocumentParams) _then;

/// Create a copy of DidOpenTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentItem,
  ));
}
/// Create a copy of DidOpenTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentItemCopyWith<$Res> get textDocument {
  
  return $TextDocumentItemCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DidOpenTextDocumentParams implements DidOpenTextDocumentParams {
  const _DidOpenTextDocumentParams({required this.textDocument});
  factory _DidOpenTextDocumentParams.fromJson(Map<String, dynamic> json) => _$DidOpenTextDocumentParamsFromJson(json);

@override final  TextDocumentItem textDocument;

/// Create a copy of DidOpenTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DidOpenTextDocumentParamsCopyWith<_DidOpenTextDocumentParams> get copyWith => __$DidOpenTextDocumentParamsCopyWithImpl<_DidOpenTextDocumentParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DidOpenTextDocumentParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DidOpenTextDocumentParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument);

@override
String toString() {
  return 'DidOpenTextDocumentParams(textDocument: $textDocument)';
}


}

/// @nodoc
abstract mixin class _$DidOpenTextDocumentParamsCopyWith<$Res> implements $DidOpenTextDocumentParamsCopyWith<$Res> {
  factory _$DidOpenTextDocumentParamsCopyWith(_DidOpenTextDocumentParams value, $Res Function(_DidOpenTextDocumentParams) _then) = __$DidOpenTextDocumentParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentItem textDocument
});


@override $TextDocumentItemCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$DidOpenTextDocumentParamsCopyWithImpl<$Res>
    implements _$DidOpenTextDocumentParamsCopyWith<$Res> {
  __$DidOpenTextDocumentParamsCopyWithImpl(this._self, this._then);

  final _DidOpenTextDocumentParams _self;
  final $Res Function(_DidOpenTextDocumentParams) _then;

/// Create a copy of DidOpenTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,}) {
  return _then(_DidOpenTextDocumentParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentItem,
  ));
}

/// Create a copy of DidOpenTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentItemCopyWith<$Res> get textDocument {
  
  return $TextDocumentItemCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$DidChangeTextDocumentParams {

 VersionedTextDocumentIdentifier get textDocument; List<TextDocumentContentChangeEvent> get contentChanges;
/// Create a copy of DidChangeTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DidChangeTextDocumentParamsCopyWith<DidChangeTextDocumentParams> get copyWith => _$DidChangeTextDocumentParamsCopyWithImpl<DidChangeTextDocumentParams>(this as DidChangeTextDocumentParams, _$identity);

  /// Serializes this DidChangeTextDocumentParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DidChangeTextDocumentParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&const DeepCollectionEquality().equals(other.contentChanges, contentChanges));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,const DeepCollectionEquality().hash(contentChanges));

@override
String toString() {
  return 'DidChangeTextDocumentParams(textDocument: $textDocument, contentChanges: $contentChanges)';
}


}

/// @nodoc
abstract mixin class $DidChangeTextDocumentParamsCopyWith<$Res>  {
  factory $DidChangeTextDocumentParamsCopyWith(DidChangeTextDocumentParams value, $Res Function(DidChangeTextDocumentParams) _then) = _$DidChangeTextDocumentParamsCopyWithImpl;
@useResult
$Res call({
 VersionedTextDocumentIdentifier textDocument, List<TextDocumentContentChangeEvent> contentChanges
});


$VersionedTextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$DidChangeTextDocumentParamsCopyWithImpl<$Res>
    implements $DidChangeTextDocumentParamsCopyWith<$Res> {
  _$DidChangeTextDocumentParamsCopyWithImpl(this._self, this._then);

  final DidChangeTextDocumentParams _self;
  final $Res Function(DidChangeTextDocumentParams) _then;

/// Create a copy of DidChangeTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? contentChanges = null,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as VersionedTextDocumentIdentifier,contentChanges: null == contentChanges ? _self.contentChanges : contentChanges // ignore: cast_nullable_to_non_nullable
as List<TextDocumentContentChangeEvent>,
  ));
}
/// Create a copy of DidChangeTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$VersionedTextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $VersionedTextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DidChangeTextDocumentParams implements DidChangeTextDocumentParams {
  const _DidChangeTextDocumentParams({required this.textDocument, required final  List<TextDocumentContentChangeEvent> contentChanges}): _contentChanges = contentChanges;
  factory _DidChangeTextDocumentParams.fromJson(Map<String, dynamic> json) => _$DidChangeTextDocumentParamsFromJson(json);

@override final  VersionedTextDocumentIdentifier textDocument;
 final  List<TextDocumentContentChangeEvent> _contentChanges;
@override List<TextDocumentContentChangeEvent> get contentChanges {
  if (_contentChanges is EqualUnmodifiableListView) return _contentChanges;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_contentChanges);
}


/// Create a copy of DidChangeTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DidChangeTextDocumentParamsCopyWith<_DidChangeTextDocumentParams> get copyWith => __$DidChangeTextDocumentParamsCopyWithImpl<_DidChangeTextDocumentParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DidChangeTextDocumentParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DidChangeTextDocumentParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&const DeepCollectionEquality().equals(other._contentChanges, _contentChanges));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,const DeepCollectionEquality().hash(_contentChanges));

@override
String toString() {
  return 'DidChangeTextDocumentParams(textDocument: $textDocument, contentChanges: $contentChanges)';
}


}

/// @nodoc
abstract mixin class _$DidChangeTextDocumentParamsCopyWith<$Res> implements $DidChangeTextDocumentParamsCopyWith<$Res> {
  factory _$DidChangeTextDocumentParamsCopyWith(_DidChangeTextDocumentParams value, $Res Function(_DidChangeTextDocumentParams) _then) = __$DidChangeTextDocumentParamsCopyWithImpl;
@override @useResult
$Res call({
 VersionedTextDocumentIdentifier textDocument, List<TextDocumentContentChangeEvent> contentChanges
});


@override $VersionedTextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$DidChangeTextDocumentParamsCopyWithImpl<$Res>
    implements _$DidChangeTextDocumentParamsCopyWith<$Res> {
  __$DidChangeTextDocumentParamsCopyWithImpl(this._self, this._then);

  final _DidChangeTextDocumentParams _self;
  final $Res Function(_DidChangeTextDocumentParams) _then;

/// Create a copy of DidChangeTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? contentChanges = null,}) {
  return _then(_DidChangeTextDocumentParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as VersionedTextDocumentIdentifier,contentChanges: null == contentChanges ? _self._contentChanges : contentChanges // ignore: cast_nullable_to_non_nullable
as List<TextDocumentContentChangeEvent>,
  ));
}

/// Create a copy of DidChangeTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$VersionedTextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $VersionedTextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$TextDocumentChangeRegistrationOptions {

 dynamic get documentSelector; TextDocumentSyncKind get syncKind;
/// Create a copy of TextDocumentChangeRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TextDocumentChangeRegistrationOptionsCopyWith<TextDocumentChangeRegistrationOptions> get copyWith => _$TextDocumentChangeRegistrationOptionsCopyWithImpl<TextDocumentChangeRegistrationOptions>(this as TextDocumentChangeRegistrationOptions, _$identity);

  /// Serializes this TextDocumentChangeRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TextDocumentChangeRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.syncKind, syncKind) || other.syncKind == syncKind));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),syncKind);

@override
String toString() {
  return 'TextDocumentChangeRegistrationOptions(documentSelector: $documentSelector, syncKind: $syncKind)';
}


}

/// @nodoc
abstract mixin class $TextDocumentChangeRegistrationOptionsCopyWith<$Res>  {
  factory $TextDocumentChangeRegistrationOptionsCopyWith(TextDocumentChangeRegistrationOptions value, $Res Function(TextDocumentChangeRegistrationOptions) _then) = _$TextDocumentChangeRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 dynamic documentSelector, TextDocumentSyncKind syncKind
});




}
/// @nodoc
class _$TextDocumentChangeRegistrationOptionsCopyWithImpl<$Res>
    implements $TextDocumentChangeRegistrationOptionsCopyWith<$Res> {
  _$TextDocumentChangeRegistrationOptionsCopyWithImpl(this._self, this._then);

  final TextDocumentChangeRegistrationOptions _self;
  final $Res Function(TextDocumentChangeRegistrationOptions) _then;

/// Create a copy of TextDocumentChangeRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = freezed,Object? syncKind = null,}) {
  return _then(_self.copyWith(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,syncKind: null == syncKind ? _self.syncKind : syncKind // ignore: cast_nullable_to_non_nullable
as TextDocumentSyncKind,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _TextDocumentChangeRegistrationOptions implements TextDocumentChangeRegistrationOptions {
  const _TextDocumentChangeRegistrationOptions({required this.documentSelector, required this.syncKind});
  factory _TextDocumentChangeRegistrationOptions.fromJson(Map<String, dynamic> json) => _$TextDocumentChangeRegistrationOptionsFromJson(json);

@override final  dynamic documentSelector;
@override final  TextDocumentSyncKind syncKind;

/// Create a copy of TextDocumentChangeRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TextDocumentChangeRegistrationOptionsCopyWith<_TextDocumentChangeRegistrationOptions> get copyWith => __$TextDocumentChangeRegistrationOptionsCopyWithImpl<_TextDocumentChangeRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TextDocumentChangeRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TextDocumentChangeRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.syncKind, syncKind) || other.syncKind == syncKind));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),syncKind);

@override
String toString() {
  return 'TextDocumentChangeRegistrationOptions(documentSelector: $documentSelector, syncKind: $syncKind)';
}


}

/// @nodoc
abstract mixin class _$TextDocumentChangeRegistrationOptionsCopyWith<$Res> implements $TextDocumentChangeRegistrationOptionsCopyWith<$Res> {
  factory _$TextDocumentChangeRegistrationOptionsCopyWith(_TextDocumentChangeRegistrationOptions value, $Res Function(_TextDocumentChangeRegistrationOptions) _then) = __$TextDocumentChangeRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 dynamic documentSelector, TextDocumentSyncKind syncKind
});




}
/// @nodoc
class __$TextDocumentChangeRegistrationOptionsCopyWithImpl<$Res>
    implements _$TextDocumentChangeRegistrationOptionsCopyWith<$Res> {
  __$TextDocumentChangeRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _TextDocumentChangeRegistrationOptions _self;
  final $Res Function(_TextDocumentChangeRegistrationOptions) _then;

/// Create a copy of TextDocumentChangeRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = freezed,Object? syncKind = null,}) {
  return _then(_TextDocumentChangeRegistrationOptions(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,syncKind: null == syncKind ? _self.syncKind : syncKind // ignore: cast_nullable_to_non_nullable
as TextDocumentSyncKind,
  ));
}


}


/// @nodoc
mixin _$DidCloseTextDocumentParams {

 TextDocumentIdentifier get textDocument;
/// Create a copy of DidCloseTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DidCloseTextDocumentParamsCopyWith<DidCloseTextDocumentParams> get copyWith => _$DidCloseTextDocumentParamsCopyWithImpl<DidCloseTextDocumentParams>(this as DidCloseTextDocumentParams, _$identity);

  /// Serializes this DidCloseTextDocumentParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DidCloseTextDocumentParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument);

@override
String toString() {
  return 'DidCloseTextDocumentParams(textDocument: $textDocument)';
}


}

/// @nodoc
abstract mixin class $DidCloseTextDocumentParamsCopyWith<$Res>  {
  factory $DidCloseTextDocumentParamsCopyWith(DidCloseTextDocumentParams value, $Res Function(DidCloseTextDocumentParams) _then) = _$DidCloseTextDocumentParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$DidCloseTextDocumentParamsCopyWithImpl<$Res>
    implements $DidCloseTextDocumentParamsCopyWith<$Res> {
  _$DidCloseTextDocumentParamsCopyWithImpl(this._self, this._then);

  final DidCloseTextDocumentParams _self;
  final $Res Function(DidCloseTextDocumentParams) _then;

/// Create a copy of DidCloseTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,
  ));
}
/// Create a copy of DidCloseTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DidCloseTextDocumentParams implements DidCloseTextDocumentParams {
  const _DidCloseTextDocumentParams({required this.textDocument});
  factory _DidCloseTextDocumentParams.fromJson(Map<String, dynamic> json) => _$DidCloseTextDocumentParamsFromJson(json);

@override final  TextDocumentIdentifier textDocument;

/// Create a copy of DidCloseTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DidCloseTextDocumentParamsCopyWith<_DidCloseTextDocumentParams> get copyWith => __$DidCloseTextDocumentParamsCopyWithImpl<_DidCloseTextDocumentParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DidCloseTextDocumentParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DidCloseTextDocumentParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument);

@override
String toString() {
  return 'DidCloseTextDocumentParams(textDocument: $textDocument)';
}


}

/// @nodoc
abstract mixin class _$DidCloseTextDocumentParamsCopyWith<$Res> implements $DidCloseTextDocumentParamsCopyWith<$Res> {
  factory _$DidCloseTextDocumentParamsCopyWith(_DidCloseTextDocumentParams value, $Res Function(_DidCloseTextDocumentParams) _then) = __$DidCloseTextDocumentParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$DidCloseTextDocumentParamsCopyWithImpl<$Res>
    implements _$DidCloseTextDocumentParamsCopyWith<$Res> {
  __$DidCloseTextDocumentParamsCopyWithImpl(this._self, this._then);

  final _DidCloseTextDocumentParams _self;
  final $Res Function(_DidCloseTextDocumentParams) _then;

/// Create a copy of DidCloseTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,}) {
  return _then(_DidCloseTextDocumentParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,
  ));
}

/// Create a copy of DidCloseTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$DidSaveTextDocumentParams {

 TextDocumentIdentifier get textDocument; String? get text;
/// Create a copy of DidSaveTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DidSaveTextDocumentParamsCopyWith<DidSaveTextDocumentParams> get copyWith => _$DidSaveTextDocumentParamsCopyWithImpl<DidSaveTextDocumentParams>(this as DidSaveTextDocumentParams, _$identity);

  /// Serializes this DidSaveTextDocumentParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DidSaveTextDocumentParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.text, text) || other.text == text));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,text);

@override
String toString() {
  return 'DidSaveTextDocumentParams(textDocument: $textDocument, text: $text)';
}


}

/// @nodoc
abstract mixin class $DidSaveTextDocumentParamsCopyWith<$Res>  {
  factory $DidSaveTextDocumentParamsCopyWith(DidSaveTextDocumentParams value, $Res Function(DidSaveTextDocumentParams) _then) = _$DidSaveTextDocumentParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument, String? text
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$DidSaveTextDocumentParamsCopyWithImpl<$Res>
    implements $DidSaveTextDocumentParamsCopyWith<$Res> {
  _$DidSaveTextDocumentParamsCopyWithImpl(this._self, this._then);

  final DidSaveTextDocumentParams _self;
  final $Res Function(DidSaveTextDocumentParams) _then;

/// Create a copy of DidSaveTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? text = freezed,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,text: freezed == text ? _self.text : text // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}
/// Create a copy of DidSaveTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DidSaveTextDocumentParams implements DidSaveTextDocumentParams {
  const _DidSaveTextDocumentParams({required this.textDocument, this.text});
  factory _DidSaveTextDocumentParams.fromJson(Map<String, dynamic> json) => _$DidSaveTextDocumentParamsFromJson(json);

@override final  TextDocumentIdentifier textDocument;
@override final  String? text;

/// Create a copy of DidSaveTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DidSaveTextDocumentParamsCopyWith<_DidSaveTextDocumentParams> get copyWith => __$DidSaveTextDocumentParamsCopyWithImpl<_DidSaveTextDocumentParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DidSaveTextDocumentParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DidSaveTextDocumentParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.text, text) || other.text == text));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,text);

@override
String toString() {
  return 'DidSaveTextDocumentParams(textDocument: $textDocument, text: $text)';
}


}

/// @nodoc
abstract mixin class _$DidSaveTextDocumentParamsCopyWith<$Res> implements $DidSaveTextDocumentParamsCopyWith<$Res> {
  factory _$DidSaveTextDocumentParamsCopyWith(_DidSaveTextDocumentParams value, $Res Function(_DidSaveTextDocumentParams) _then) = __$DidSaveTextDocumentParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument, String? text
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$DidSaveTextDocumentParamsCopyWithImpl<$Res>
    implements _$DidSaveTextDocumentParamsCopyWith<$Res> {
  __$DidSaveTextDocumentParamsCopyWithImpl(this._self, this._then);

  final _DidSaveTextDocumentParams _self;
  final $Res Function(_DidSaveTextDocumentParams) _then;

/// Create a copy of DidSaveTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? text = freezed,}) {
  return _then(_DidSaveTextDocumentParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,text: freezed == text ? _self.text : text // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

/// Create a copy of DidSaveTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$TextDocumentSaveRegistrationOptions {

 dynamic get documentSelector; bool? get includeText;
/// Create a copy of TextDocumentSaveRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TextDocumentSaveRegistrationOptionsCopyWith<TextDocumentSaveRegistrationOptions> get copyWith => _$TextDocumentSaveRegistrationOptionsCopyWithImpl<TextDocumentSaveRegistrationOptions>(this as TextDocumentSaveRegistrationOptions, _$identity);

  /// Serializes this TextDocumentSaveRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TextDocumentSaveRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.includeText, includeText) || other.includeText == includeText));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),includeText);

@override
String toString() {
  return 'TextDocumentSaveRegistrationOptions(documentSelector: $documentSelector, includeText: $includeText)';
}


}

/// @nodoc
abstract mixin class $TextDocumentSaveRegistrationOptionsCopyWith<$Res>  {
  factory $TextDocumentSaveRegistrationOptionsCopyWith(TextDocumentSaveRegistrationOptions value, $Res Function(TextDocumentSaveRegistrationOptions) _then) = _$TextDocumentSaveRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 dynamic documentSelector, bool? includeText
});




}
/// @nodoc
class _$TextDocumentSaveRegistrationOptionsCopyWithImpl<$Res>
    implements $TextDocumentSaveRegistrationOptionsCopyWith<$Res> {
  _$TextDocumentSaveRegistrationOptionsCopyWithImpl(this._self, this._then);

  final TextDocumentSaveRegistrationOptions _self;
  final $Res Function(TextDocumentSaveRegistrationOptions) _then;

/// Create a copy of TextDocumentSaveRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = freezed,Object? includeText = freezed,}) {
  return _then(_self.copyWith(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,includeText: freezed == includeText ? _self.includeText : includeText // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _TextDocumentSaveRegistrationOptions implements TextDocumentSaveRegistrationOptions {
  const _TextDocumentSaveRegistrationOptions({required this.documentSelector, this.includeText});
  factory _TextDocumentSaveRegistrationOptions.fromJson(Map<String, dynamic> json) => _$TextDocumentSaveRegistrationOptionsFromJson(json);

@override final  dynamic documentSelector;
@override final  bool? includeText;

/// Create a copy of TextDocumentSaveRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TextDocumentSaveRegistrationOptionsCopyWith<_TextDocumentSaveRegistrationOptions> get copyWith => __$TextDocumentSaveRegistrationOptionsCopyWithImpl<_TextDocumentSaveRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TextDocumentSaveRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TextDocumentSaveRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.includeText, includeText) || other.includeText == includeText));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),includeText);

@override
String toString() {
  return 'TextDocumentSaveRegistrationOptions(documentSelector: $documentSelector, includeText: $includeText)';
}


}

/// @nodoc
abstract mixin class _$TextDocumentSaveRegistrationOptionsCopyWith<$Res> implements $TextDocumentSaveRegistrationOptionsCopyWith<$Res> {
  factory _$TextDocumentSaveRegistrationOptionsCopyWith(_TextDocumentSaveRegistrationOptions value, $Res Function(_TextDocumentSaveRegistrationOptions) _then) = __$TextDocumentSaveRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 dynamic documentSelector, bool? includeText
});




}
/// @nodoc
class __$TextDocumentSaveRegistrationOptionsCopyWithImpl<$Res>
    implements _$TextDocumentSaveRegistrationOptionsCopyWith<$Res> {
  __$TextDocumentSaveRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _TextDocumentSaveRegistrationOptions _self;
  final $Res Function(_TextDocumentSaveRegistrationOptions) _then;

/// Create a copy of TextDocumentSaveRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = freezed,Object? includeText = freezed,}) {
  return _then(_TextDocumentSaveRegistrationOptions(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,includeText: freezed == includeText ? _self.includeText : includeText // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$WillSaveTextDocumentParams {

 TextDocumentIdentifier get textDocument; TextDocumentSaveReason get reason;
/// Create a copy of WillSaveTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WillSaveTextDocumentParamsCopyWith<WillSaveTextDocumentParams> get copyWith => _$WillSaveTextDocumentParamsCopyWithImpl<WillSaveTextDocumentParams>(this as WillSaveTextDocumentParams, _$identity);

  /// Serializes this WillSaveTextDocumentParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WillSaveTextDocumentParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.reason, reason) || other.reason == reason));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,reason);

@override
String toString() {
  return 'WillSaveTextDocumentParams(textDocument: $textDocument, reason: $reason)';
}


}

/// @nodoc
abstract mixin class $WillSaveTextDocumentParamsCopyWith<$Res>  {
  factory $WillSaveTextDocumentParamsCopyWith(WillSaveTextDocumentParams value, $Res Function(WillSaveTextDocumentParams) _then) = _$WillSaveTextDocumentParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument, TextDocumentSaveReason reason
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$WillSaveTextDocumentParamsCopyWithImpl<$Res>
    implements $WillSaveTextDocumentParamsCopyWith<$Res> {
  _$WillSaveTextDocumentParamsCopyWithImpl(this._self, this._then);

  final WillSaveTextDocumentParams _self;
  final $Res Function(WillSaveTextDocumentParams) _then;

/// Create a copy of WillSaveTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? reason = null,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,reason: null == reason ? _self.reason : reason // ignore: cast_nullable_to_non_nullable
as TextDocumentSaveReason,
  ));
}
/// Create a copy of WillSaveTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _WillSaveTextDocumentParams implements WillSaveTextDocumentParams {
  const _WillSaveTextDocumentParams({required this.textDocument, required this.reason});
  factory _WillSaveTextDocumentParams.fromJson(Map<String, dynamic> json) => _$WillSaveTextDocumentParamsFromJson(json);

@override final  TextDocumentIdentifier textDocument;
@override final  TextDocumentSaveReason reason;

/// Create a copy of WillSaveTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WillSaveTextDocumentParamsCopyWith<_WillSaveTextDocumentParams> get copyWith => __$WillSaveTextDocumentParamsCopyWithImpl<_WillSaveTextDocumentParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WillSaveTextDocumentParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WillSaveTextDocumentParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.reason, reason) || other.reason == reason));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,reason);

@override
String toString() {
  return 'WillSaveTextDocumentParams(textDocument: $textDocument, reason: $reason)';
}


}

/// @nodoc
abstract mixin class _$WillSaveTextDocumentParamsCopyWith<$Res> implements $WillSaveTextDocumentParamsCopyWith<$Res> {
  factory _$WillSaveTextDocumentParamsCopyWith(_WillSaveTextDocumentParams value, $Res Function(_WillSaveTextDocumentParams) _then) = __$WillSaveTextDocumentParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument, TextDocumentSaveReason reason
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$WillSaveTextDocumentParamsCopyWithImpl<$Res>
    implements _$WillSaveTextDocumentParamsCopyWith<$Res> {
  __$WillSaveTextDocumentParamsCopyWithImpl(this._self, this._then);

  final _WillSaveTextDocumentParams _self;
  final $Res Function(_WillSaveTextDocumentParams) _then;

/// Create a copy of WillSaveTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? reason = null,}) {
  return _then(_WillSaveTextDocumentParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,reason: null == reason ? _self.reason : reason // ignore: cast_nullable_to_non_nullable
as TextDocumentSaveReason,
  ));
}

/// Create a copy of WillSaveTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$TextEdit {

 Range get range; String get newText;
/// Create a copy of TextEdit
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TextEditCopyWith<TextEdit> get copyWith => _$TextEditCopyWithImpl<TextEdit>(this as TextEdit, _$identity);

  /// Serializes this TextEdit to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TextEdit&&(identical(other.range, range) || other.range == range)&&(identical(other.newText, newText) || other.newText == newText));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,range,newText);

@override
String toString() {
  return 'TextEdit(range: $range, newText: $newText)';
}


}

/// @nodoc
abstract mixin class $TextEditCopyWith<$Res>  {
  factory $TextEditCopyWith(TextEdit value, $Res Function(TextEdit) _then) = _$TextEditCopyWithImpl;
@useResult
$Res call({
 Range range, String newText
});


$RangeCopyWith<$Res> get range;

}
/// @nodoc
class _$TextEditCopyWithImpl<$Res>
    implements $TextEditCopyWith<$Res> {
  _$TextEditCopyWithImpl(this._self, this._then);

  final TextEdit _self;
  final $Res Function(TextEdit) _then;

/// Create a copy of TextEdit
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? range = null,Object? newText = null,}) {
  return _then(_self.copyWith(
range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,newText: null == newText ? _self.newText : newText // ignore: cast_nullable_to_non_nullable
as String,
  ));
}
/// Create a copy of TextEdit
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _TextEdit implements TextEdit {
  const _TextEdit({required this.range, required this.newText});
  factory _TextEdit.fromJson(Map<String, dynamic> json) => _$TextEditFromJson(json);

@override final  Range range;
@override final  String newText;

/// Create a copy of TextEdit
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TextEditCopyWith<_TextEdit> get copyWith => __$TextEditCopyWithImpl<_TextEdit>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TextEditToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TextEdit&&(identical(other.range, range) || other.range == range)&&(identical(other.newText, newText) || other.newText == newText));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,range,newText);

@override
String toString() {
  return 'TextEdit(range: $range, newText: $newText)';
}


}

/// @nodoc
abstract mixin class _$TextEditCopyWith<$Res> implements $TextEditCopyWith<$Res> {
  factory _$TextEditCopyWith(_TextEdit value, $Res Function(_TextEdit) _then) = __$TextEditCopyWithImpl;
@override @useResult
$Res call({
 Range range, String newText
});


@override $RangeCopyWith<$Res> get range;

}
/// @nodoc
class __$TextEditCopyWithImpl<$Res>
    implements _$TextEditCopyWith<$Res> {
  __$TextEditCopyWithImpl(this._self, this._then);

  final _TextEdit _self;
  final $Res Function(_TextEdit) _then;

/// Create a copy of TextEdit
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? range = null,Object? newText = null,}) {
  return _then(_TextEdit(
range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,newText: null == newText ? _self.newText : newText // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

/// Create a copy of TextEdit
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}


/// @nodoc
mixin _$DidChangeWatchedFilesParams {

 List<FileEvent> get changes;
/// Create a copy of DidChangeWatchedFilesParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DidChangeWatchedFilesParamsCopyWith<DidChangeWatchedFilesParams> get copyWith => _$DidChangeWatchedFilesParamsCopyWithImpl<DidChangeWatchedFilesParams>(this as DidChangeWatchedFilesParams, _$identity);

  /// Serializes this DidChangeWatchedFilesParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DidChangeWatchedFilesParams&&const DeepCollectionEquality().equals(other.changes, changes));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(changes));

@override
String toString() {
  return 'DidChangeWatchedFilesParams(changes: $changes)';
}


}

/// @nodoc
abstract mixin class $DidChangeWatchedFilesParamsCopyWith<$Res>  {
  factory $DidChangeWatchedFilesParamsCopyWith(DidChangeWatchedFilesParams value, $Res Function(DidChangeWatchedFilesParams) _then) = _$DidChangeWatchedFilesParamsCopyWithImpl;
@useResult
$Res call({
 List<FileEvent> changes
});




}
/// @nodoc
class _$DidChangeWatchedFilesParamsCopyWithImpl<$Res>
    implements $DidChangeWatchedFilesParamsCopyWith<$Res> {
  _$DidChangeWatchedFilesParamsCopyWithImpl(this._self, this._then);

  final DidChangeWatchedFilesParams _self;
  final $Res Function(DidChangeWatchedFilesParams) _then;

/// Create a copy of DidChangeWatchedFilesParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? changes = null,}) {
  return _then(_self.copyWith(
changes: null == changes ? _self.changes : changes // ignore: cast_nullable_to_non_nullable
as List<FileEvent>,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DidChangeWatchedFilesParams implements DidChangeWatchedFilesParams {
  const _DidChangeWatchedFilesParams({required final  List<FileEvent> changes}): _changes = changes;
  factory _DidChangeWatchedFilesParams.fromJson(Map<String, dynamic> json) => _$DidChangeWatchedFilesParamsFromJson(json);

 final  List<FileEvent> _changes;
@override List<FileEvent> get changes {
  if (_changes is EqualUnmodifiableListView) return _changes;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_changes);
}


/// Create a copy of DidChangeWatchedFilesParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DidChangeWatchedFilesParamsCopyWith<_DidChangeWatchedFilesParams> get copyWith => __$DidChangeWatchedFilesParamsCopyWithImpl<_DidChangeWatchedFilesParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DidChangeWatchedFilesParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DidChangeWatchedFilesParams&&const DeepCollectionEquality().equals(other._changes, _changes));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_changes));

@override
String toString() {
  return 'DidChangeWatchedFilesParams(changes: $changes)';
}


}

/// @nodoc
abstract mixin class _$DidChangeWatchedFilesParamsCopyWith<$Res> implements $DidChangeWatchedFilesParamsCopyWith<$Res> {
  factory _$DidChangeWatchedFilesParamsCopyWith(_DidChangeWatchedFilesParams value, $Res Function(_DidChangeWatchedFilesParams) _then) = __$DidChangeWatchedFilesParamsCopyWithImpl;
@override @useResult
$Res call({
 List<FileEvent> changes
});




}
/// @nodoc
class __$DidChangeWatchedFilesParamsCopyWithImpl<$Res>
    implements _$DidChangeWatchedFilesParamsCopyWith<$Res> {
  __$DidChangeWatchedFilesParamsCopyWithImpl(this._self, this._then);

  final _DidChangeWatchedFilesParams _self;
  final $Res Function(_DidChangeWatchedFilesParams) _then;

/// Create a copy of DidChangeWatchedFilesParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? changes = null,}) {
  return _then(_DidChangeWatchedFilesParams(
changes: null == changes ? _self._changes : changes // ignore: cast_nullable_to_non_nullable
as List<FileEvent>,
  ));
}


}


/// @nodoc
mixin _$DidChangeWatchedFilesRegistrationOptions {

 List<FileSystemWatcher> get watchers;
/// Create a copy of DidChangeWatchedFilesRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DidChangeWatchedFilesRegistrationOptionsCopyWith<DidChangeWatchedFilesRegistrationOptions> get copyWith => _$DidChangeWatchedFilesRegistrationOptionsCopyWithImpl<DidChangeWatchedFilesRegistrationOptions>(this as DidChangeWatchedFilesRegistrationOptions, _$identity);

  /// Serializes this DidChangeWatchedFilesRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DidChangeWatchedFilesRegistrationOptions&&const DeepCollectionEquality().equals(other.watchers, watchers));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(watchers));

@override
String toString() {
  return 'DidChangeWatchedFilesRegistrationOptions(watchers: $watchers)';
}


}

/// @nodoc
abstract mixin class $DidChangeWatchedFilesRegistrationOptionsCopyWith<$Res>  {
  factory $DidChangeWatchedFilesRegistrationOptionsCopyWith(DidChangeWatchedFilesRegistrationOptions value, $Res Function(DidChangeWatchedFilesRegistrationOptions) _then) = _$DidChangeWatchedFilesRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 List<FileSystemWatcher> watchers
});




}
/// @nodoc
class _$DidChangeWatchedFilesRegistrationOptionsCopyWithImpl<$Res>
    implements $DidChangeWatchedFilesRegistrationOptionsCopyWith<$Res> {
  _$DidChangeWatchedFilesRegistrationOptionsCopyWithImpl(this._self, this._then);

  final DidChangeWatchedFilesRegistrationOptions _self;
  final $Res Function(DidChangeWatchedFilesRegistrationOptions) _then;

/// Create a copy of DidChangeWatchedFilesRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? watchers = null,}) {
  return _then(_self.copyWith(
watchers: null == watchers ? _self.watchers : watchers // ignore: cast_nullable_to_non_nullable
as List<FileSystemWatcher>,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DidChangeWatchedFilesRegistrationOptions implements DidChangeWatchedFilesRegistrationOptions {
  const _DidChangeWatchedFilesRegistrationOptions({required final  List<FileSystemWatcher> watchers}): _watchers = watchers;
  factory _DidChangeWatchedFilesRegistrationOptions.fromJson(Map<String, dynamic> json) => _$DidChangeWatchedFilesRegistrationOptionsFromJson(json);

 final  List<FileSystemWatcher> _watchers;
@override List<FileSystemWatcher> get watchers {
  if (_watchers is EqualUnmodifiableListView) return _watchers;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_watchers);
}


/// Create a copy of DidChangeWatchedFilesRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DidChangeWatchedFilesRegistrationOptionsCopyWith<_DidChangeWatchedFilesRegistrationOptions> get copyWith => __$DidChangeWatchedFilesRegistrationOptionsCopyWithImpl<_DidChangeWatchedFilesRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DidChangeWatchedFilesRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DidChangeWatchedFilesRegistrationOptions&&const DeepCollectionEquality().equals(other._watchers, _watchers));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_watchers));

@override
String toString() {
  return 'DidChangeWatchedFilesRegistrationOptions(watchers: $watchers)';
}


}

/// @nodoc
abstract mixin class _$DidChangeWatchedFilesRegistrationOptionsCopyWith<$Res> implements $DidChangeWatchedFilesRegistrationOptionsCopyWith<$Res> {
  factory _$DidChangeWatchedFilesRegistrationOptionsCopyWith(_DidChangeWatchedFilesRegistrationOptions value, $Res Function(_DidChangeWatchedFilesRegistrationOptions) _then) = __$DidChangeWatchedFilesRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 List<FileSystemWatcher> watchers
});




}
/// @nodoc
class __$DidChangeWatchedFilesRegistrationOptionsCopyWithImpl<$Res>
    implements _$DidChangeWatchedFilesRegistrationOptionsCopyWith<$Res> {
  __$DidChangeWatchedFilesRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _DidChangeWatchedFilesRegistrationOptions _self;
  final $Res Function(_DidChangeWatchedFilesRegistrationOptions) _then;

/// Create a copy of DidChangeWatchedFilesRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? watchers = null,}) {
  return _then(_DidChangeWatchedFilesRegistrationOptions(
watchers: null == watchers ? _self._watchers : watchers // ignore: cast_nullable_to_non_nullable
as List<FileSystemWatcher>,
  ));
}


}


/// @nodoc
mixin _$PublishDiagnosticsParams {

 String get uri; List<Diagnostic> get diagnostics; int? get version;
/// Create a copy of PublishDiagnosticsParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$PublishDiagnosticsParamsCopyWith<PublishDiagnosticsParams> get copyWith => _$PublishDiagnosticsParamsCopyWithImpl<PublishDiagnosticsParams>(this as PublishDiagnosticsParams, _$identity);

  /// Serializes this PublishDiagnosticsParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is PublishDiagnosticsParams&&(identical(other.uri, uri) || other.uri == uri)&&const DeepCollectionEquality().equals(other.diagnostics, diagnostics)&&(identical(other.version, version) || other.version == version));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri,const DeepCollectionEquality().hash(diagnostics),version);

@override
String toString() {
  return 'PublishDiagnosticsParams(uri: $uri, diagnostics: $diagnostics, version: $version)';
}


}

/// @nodoc
abstract mixin class $PublishDiagnosticsParamsCopyWith<$Res>  {
  factory $PublishDiagnosticsParamsCopyWith(PublishDiagnosticsParams value, $Res Function(PublishDiagnosticsParams) _then) = _$PublishDiagnosticsParamsCopyWithImpl;
@useResult
$Res call({
 String uri, List<Diagnostic> diagnostics, int? version
});




}
/// @nodoc
class _$PublishDiagnosticsParamsCopyWithImpl<$Res>
    implements $PublishDiagnosticsParamsCopyWith<$Res> {
  _$PublishDiagnosticsParamsCopyWithImpl(this._self, this._then);

  final PublishDiagnosticsParams _self;
  final $Res Function(PublishDiagnosticsParams) _then;

/// Create a copy of PublishDiagnosticsParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? uri = null,Object? diagnostics = null,Object? version = freezed,}) {
  return _then(_self.copyWith(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,diagnostics: null == diagnostics ? _self.diagnostics : diagnostics // ignore: cast_nullable_to_non_nullable
as List<Diagnostic>,version: freezed == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as int?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _PublishDiagnosticsParams implements PublishDiagnosticsParams {
  const _PublishDiagnosticsParams({required this.uri, required final  List<Diagnostic> diagnostics, this.version}): _diagnostics = diagnostics;
  factory _PublishDiagnosticsParams.fromJson(Map<String, dynamic> json) => _$PublishDiagnosticsParamsFromJson(json);

@override final  String uri;
 final  List<Diagnostic> _diagnostics;
@override List<Diagnostic> get diagnostics {
  if (_diagnostics is EqualUnmodifiableListView) return _diagnostics;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_diagnostics);
}

@override final  int? version;

/// Create a copy of PublishDiagnosticsParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$PublishDiagnosticsParamsCopyWith<_PublishDiagnosticsParams> get copyWith => __$PublishDiagnosticsParamsCopyWithImpl<_PublishDiagnosticsParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$PublishDiagnosticsParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _PublishDiagnosticsParams&&(identical(other.uri, uri) || other.uri == uri)&&const DeepCollectionEquality().equals(other._diagnostics, _diagnostics)&&(identical(other.version, version) || other.version == version));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri,const DeepCollectionEquality().hash(_diagnostics),version);

@override
String toString() {
  return 'PublishDiagnosticsParams(uri: $uri, diagnostics: $diagnostics, version: $version)';
}


}

/// @nodoc
abstract mixin class _$PublishDiagnosticsParamsCopyWith<$Res> implements $PublishDiagnosticsParamsCopyWith<$Res> {
  factory _$PublishDiagnosticsParamsCopyWith(_PublishDiagnosticsParams value, $Res Function(_PublishDiagnosticsParams) _then) = __$PublishDiagnosticsParamsCopyWithImpl;
@override @useResult
$Res call({
 String uri, List<Diagnostic> diagnostics, int? version
});




}
/// @nodoc
class __$PublishDiagnosticsParamsCopyWithImpl<$Res>
    implements _$PublishDiagnosticsParamsCopyWith<$Res> {
  __$PublishDiagnosticsParamsCopyWithImpl(this._self, this._then);

  final _PublishDiagnosticsParams _self;
  final $Res Function(_PublishDiagnosticsParams) _then;

/// Create a copy of PublishDiagnosticsParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? uri = null,Object? diagnostics = null,Object? version = freezed,}) {
  return _then(_PublishDiagnosticsParams(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,diagnostics: null == diagnostics ? _self._diagnostics : diagnostics // ignore: cast_nullable_to_non_nullable
as List<Diagnostic>,version: freezed == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as int?,
  ));
}


}


/// @nodoc
mixin _$CompletionParams {

 TextDocumentIdentifier get textDocument; Position get position; CompletionContext? get context; ProgressToken? get partialResultToken; ProgressToken? get workDoneToken;
/// Create a copy of CompletionParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CompletionParamsCopyWith<CompletionParams> get copyWith => _$CompletionParamsCopyWithImpl<CompletionParams>(this as CompletionParams, _$identity);

  /// Serializes this CompletionParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CompletionParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.position, position) || other.position == position)&&(identical(other.context, context) || other.context == context)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,position,context,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'CompletionParams(textDocument: $textDocument, position: $position, context: $context, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $CompletionParamsCopyWith<$Res>  {
  factory $CompletionParamsCopyWith(CompletionParams value, $Res Function(CompletionParams) _then) = _$CompletionParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument, Position position, CompletionContext? context, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;$PositionCopyWith<$Res> get position;$CompletionContextCopyWith<$Res>? get context;

}
/// @nodoc
class _$CompletionParamsCopyWithImpl<$Res>
    implements $CompletionParamsCopyWith<$Res> {
  _$CompletionParamsCopyWithImpl(this._self, this._then);

  final CompletionParams _self;
  final $Res Function(CompletionParams) _then;

/// Create a copy of CompletionParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? position = null,Object? context = freezed,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,context: freezed == context ? _self.context : context // ignore: cast_nullable_to_non_nullable
as CompletionContext?,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of CompletionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of CompletionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of CompletionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CompletionContextCopyWith<$Res>? get context {
    if (_self.context == null) {
    return null;
  }

  return $CompletionContextCopyWith<$Res>(_self.context!, (value) {
    return _then(_self.copyWith(context: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _CompletionParams implements CompletionParams {
  const _CompletionParams({required this.textDocument, required this.position, this.context, this.partialResultToken, this.workDoneToken});
  factory _CompletionParams.fromJson(Map<String, dynamic> json) => _$CompletionParamsFromJson(json);

@override final  TextDocumentIdentifier textDocument;
@override final  Position position;
@override final  CompletionContext? context;
@override final  ProgressToken? partialResultToken;
@override final  ProgressToken? workDoneToken;

/// Create a copy of CompletionParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CompletionParamsCopyWith<_CompletionParams> get copyWith => __$CompletionParamsCopyWithImpl<_CompletionParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CompletionParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CompletionParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.position, position) || other.position == position)&&(identical(other.context, context) || other.context == context)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,position,context,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'CompletionParams(textDocument: $textDocument, position: $position, context: $context, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$CompletionParamsCopyWith<$Res> implements $CompletionParamsCopyWith<$Res> {
  factory _$CompletionParamsCopyWith(_CompletionParams value, $Res Function(_CompletionParams) _then) = __$CompletionParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument, Position position, CompletionContext? context, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;@override $PositionCopyWith<$Res> get position;@override $CompletionContextCopyWith<$Res>? get context;

}
/// @nodoc
class __$CompletionParamsCopyWithImpl<$Res>
    implements _$CompletionParamsCopyWith<$Res> {
  __$CompletionParamsCopyWithImpl(this._self, this._then);

  final _CompletionParams _self;
  final $Res Function(_CompletionParams) _then;

/// Create a copy of CompletionParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? position = null,Object? context = freezed,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_CompletionParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,context: freezed == context ? _self.context : context // ignore: cast_nullable_to_non_nullable
as CompletionContext?,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of CompletionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of CompletionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of CompletionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CompletionContextCopyWith<$Res>? get context {
    if (_self.context == null) {
    return null;
  }

  return $CompletionContextCopyWith<$Res>(_self.context!, (value) {
    return _then(_self.copyWith(context: value));
  });
}
}


/// @nodoc
mixin _$CompletionItem {

 String get label; LSPAny? get data; Command? get command; List<String>? get commitCharacters; List<TextEdit>? get additionalTextEdits; String? get textEditText; dynamic? get textEdit; InsertTextMode? get insertTextMode; InsertTextFormat? get insertTextFormat; String? get insertText; String? get filterText; String? get sortText; bool? get preselect; bool? get deprecated; dynamic? get documentation; String? get detail; List<CompletionItemTag>? get tags; CompletionItemKind? get kind; CompletionItemLabelDetails? get labelDetails;
/// Create a copy of CompletionItem
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CompletionItemCopyWith<CompletionItem> get copyWith => _$CompletionItemCopyWithImpl<CompletionItem>(this as CompletionItem, _$identity);

  /// Serializes this CompletionItem to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CompletionItem&&(identical(other.label, label) || other.label == label)&&const DeepCollectionEquality().equals(other.data, data)&&(identical(other.command, command) || other.command == command)&&const DeepCollectionEquality().equals(other.commitCharacters, commitCharacters)&&const DeepCollectionEquality().equals(other.additionalTextEdits, additionalTextEdits)&&(identical(other.textEditText, textEditText) || other.textEditText == textEditText)&&const DeepCollectionEquality().equals(other.textEdit, textEdit)&&(identical(other.insertTextMode, insertTextMode) || other.insertTextMode == insertTextMode)&&(identical(other.insertTextFormat, insertTextFormat) || other.insertTextFormat == insertTextFormat)&&(identical(other.insertText, insertText) || other.insertText == insertText)&&(identical(other.filterText, filterText) || other.filterText == filterText)&&(identical(other.sortText, sortText) || other.sortText == sortText)&&(identical(other.preselect, preselect) || other.preselect == preselect)&&(identical(other.deprecated, deprecated) || other.deprecated == deprecated)&&const DeepCollectionEquality().equals(other.documentation, documentation)&&(identical(other.detail, detail) || other.detail == detail)&&const DeepCollectionEquality().equals(other.tags, tags)&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.labelDetails, labelDetails) || other.labelDetails == labelDetails));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hashAll([runtimeType,label,const DeepCollectionEquality().hash(data),command,const DeepCollectionEquality().hash(commitCharacters),const DeepCollectionEquality().hash(additionalTextEdits),textEditText,const DeepCollectionEquality().hash(textEdit),insertTextMode,insertTextFormat,insertText,filterText,sortText,preselect,deprecated,const DeepCollectionEquality().hash(documentation),detail,const DeepCollectionEquality().hash(tags),kind,labelDetails]);

@override
String toString() {
  return 'CompletionItem(label: $label, data: $data, command: $command, commitCharacters: $commitCharacters, additionalTextEdits: $additionalTextEdits, textEditText: $textEditText, textEdit: $textEdit, insertTextMode: $insertTextMode, insertTextFormat: $insertTextFormat, insertText: $insertText, filterText: $filterText, sortText: $sortText, preselect: $preselect, deprecated: $deprecated, documentation: $documentation, detail: $detail, tags: $tags, kind: $kind, labelDetails: $labelDetails)';
}


}

/// @nodoc
abstract mixin class $CompletionItemCopyWith<$Res>  {
  factory $CompletionItemCopyWith(CompletionItem value, $Res Function(CompletionItem) _then) = _$CompletionItemCopyWithImpl;
@useResult
$Res call({
 String label, LSPAny? data, Command? command, List<String>? commitCharacters, List<TextEdit>? additionalTextEdits, String? textEditText, dynamic? textEdit, InsertTextMode? insertTextMode, InsertTextFormat? insertTextFormat, String? insertText, String? filterText, String? sortText, bool? preselect, bool? deprecated, dynamic? documentation, String? detail, List<CompletionItemTag>? tags, CompletionItemKind? kind, CompletionItemLabelDetails? labelDetails
});


$CommandCopyWith<$Res>? get command;$CompletionItemLabelDetailsCopyWith<$Res>? get labelDetails;

}
/// @nodoc
class _$CompletionItemCopyWithImpl<$Res>
    implements $CompletionItemCopyWith<$Res> {
  _$CompletionItemCopyWithImpl(this._self, this._then);

  final CompletionItem _self;
  final $Res Function(CompletionItem) _then;

/// Create a copy of CompletionItem
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? label = null,Object? data = freezed,Object? command = freezed,Object? commitCharacters = freezed,Object? additionalTextEdits = freezed,Object? textEditText = freezed,Object? textEdit = freezed,Object? insertTextMode = freezed,Object? insertTextFormat = freezed,Object? insertText = freezed,Object? filterText = freezed,Object? sortText = freezed,Object? preselect = freezed,Object? deprecated = freezed,Object? documentation = freezed,Object? detail = freezed,Object? tags = freezed,Object? kind = freezed,Object? labelDetails = freezed,}) {
  return _then(_self.copyWith(
label: null == label ? _self.label : label // ignore: cast_nullable_to_non_nullable
as String,data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LSPAny?,command: freezed == command ? _self.command : command // ignore: cast_nullable_to_non_nullable
as Command?,commitCharacters: freezed == commitCharacters ? _self.commitCharacters : commitCharacters // ignore: cast_nullable_to_non_nullable
as List<String>?,additionalTextEdits: freezed == additionalTextEdits ? _self.additionalTextEdits : additionalTextEdits // ignore: cast_nullable_to_non_nullable
as List<TextEdit>?,textEditText: freezed == textEditText ? _self.textEditText : textEditText // ignore: cast_nullable_to_non_nullable
as String?,textEdit: freezed == textEdit ? _self.textEdit : textEdit // ignore: cast_nullable_to_non_nullable
as dynamic?,insertTextMode: freezed == insertTextMode ? _self.insertTextMode : insertTextMode // ignore: cast_nullable_to_non_nullable
as InsertTextMode?,insertTextFormat: freezed == insertTextFormat ? _self.insertTextFormat : insertTextFormat // ignore: cast_nullable_to_non_nullable
as InsertTextFormat?,insertText: freezed == insertText ? _self.insertText : insertText // ignore: cast_nullable_to_non_nullable
as String?,filterText: freezed == filterText ? _self.filterText : filterText // ignore: cast_nullable_to_non_nullable
as String?,sortText: freezed == sortText ? _self.sortText : sortText // ignore: cast_nullable_to_non_nullable
as String?,preselect: freezed == preselect ? _self.preselect : preselect // ignore: cast_nullable_to_non_nullable
as bool?,deprecated: freezed == deprecated ? _self.deprecated : deprecated // ignore: cast_nullable_to_non_nullable
as bool?,documentation: freezed == documentation ? _self.documentation : documentation // ignore: cast_nullable_to_non_nullable
as dynamic?,detail: freezed == detail ? _self.detail : detail // ignore: cast_nullable_to_non_nullable
as String?,tags: freezed == tags ? _self.tags : tags // ignore: cast_nullable_to_non_nullable
as List<CompletionItemTag>?,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as CompletionItemKind?,labelDetails: freezed == labelDetails ? _self.labelDetails : labelDetails // ignore: cast_nullable_to_non_nullable
as CompletionItemLabelDetails?,
  ));
}
/// Create a copy of CompletionItem
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CommandCopyWith<$Res>? get command {
    if (_self.command == null) {
    return null;
  }

  return $CommandCopyWith<$Res>(_self.command!, (value) {
    return _then(_self.copyWith(command: value));
  });
}/// Create a copy of CompletionItem
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CompletionItemLabelDetailsCopyWith<$Res>? get labelDetails {
    if (_self.labelDetails == null) {
    return null;
  }

  return $CompletionItemLabelDetailsCopyWith<$Res>(_self.labelDetails!, (value) {
    return _then(_self.copyWith(labelDetails: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _CompletionItem implements CompletionItem {
  const _CompletionItem({required this.label, this.data, this.command, final  List<String>? commitCharacters, final  List<TextEdit>? additionalTextEdits, this.textEditText, this.textEdit, this.insertTextMode, this.insertTextFormat, this.insertText, this.filterText, this.sortText, this.preselect, this.deprecated, this.documentation, this.detail, final  List<CompletionItemTag>? tags, this.kind, this.labelDetails}): _commitCharacters = commitCharacters,_additionalTextEdits = additionalTextEdits,_tags = tags;
  factory _CompletionItem.fromJson(Map<String, dynamic> json) => _$CompletionItemFromJson(json);

@override final  String label;
@override final  LSPAny? data;
@override final  Command? command;
 final  List<String>? _commitCharacters;
@override List<String>? get commitCharacters {
  final value = _commitCharacters;
  if (value == null) return null;
  if (_commitCharacters is EqualUnmodifiableListView) return _commitCharacters;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

 final  List<TextEdit>? _additionalTextEdits;
@override List<TextEdit>? get additionalTextEdits {
  final value = _additionalTextEdits;
  if (value == null) return null;
  if (_additionalTextEdits is EqualUnmodifiableListView) return _additionalTextEdits;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

@override final  String? textEditText;
@override final  dynamic? textEdit;
@override final  InsertTextMode? insertTextMode;
@override final  InsertTextFormat? insertTextFormat;
@override final  String? insertText;
@override final  String? filterText;
@override final  String? sortText;
@override final  bool? preselect;
@override final  bool? deprecated;
@override final  dynamic? documentation;
@override final  String? detail;
 final  List<CompletionItemTag>? _tags;
@override List<CompletionItemTag>? get tags {
  final value = _tags;
  if (value == null) return null;
  if (_tags is EqualUnmodifiableListView) return _tags;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

@override final  CompletionItemKind? kind;
@override final  CompletionItemLabelDetails? labelDetails;

/// Create a copy of CompletionItem
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CompletionItemCopyWith<_CompletionItem> get copyWith => __$CompletionItemCopyWithImpl<_CompletionItem>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CompletionItemToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CompletionItem&&(identical(other.label, label) || other.label == label)&&const DeepCollectionEquality().equals(other.data, data)&&(identical(other.command, command) || other.command == command)&&const DeepCollectionEquality().equals(other._commitCharacters, _commitCharacters)&&const DeepCollectionEquality().equals(other._additionalTextEdits, _additionalTextEdits)&&(identical(other.textEditText, textEditText) || other.textEditText == textEditText)&&const DeepCollectionEquality().equals(other.textEdit, textEdit)&&(identical(other.insertTextMode, insertTextMode) || other.insertTextMode == insertTextMode)&&(identical(other.insertTextFormat, insertTextFormat) || other.insertTextFormat == insertTextFormat)&&(identical(other.insertText, insertText) || other.insertText == insertText)&&(identical(other.filterText, filterText) || other.filterText == filterText)&&(identical(other.sortText, sortText) || other.sortText == sortText)&&(identical(other.preselect, preselect) || other.preselect == preselect)&&(identical(other.deprecated, deprecated) || other.deprecated == deprecated)&&const DeepCollectionEquality().equals(other.documentation, documentation)&&(identical(other.detail, detail) || other.detail == detail)&&const DeepCollectionEquality().equals(other._tags, _tags)&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.labelDetails, labelDetails) || other.labelDetails == labelDetails));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hashAll([runtimeType,label,const DeepCollectionEquality().hash(data),command,const DeepCollectionEquality().hash(_commitCharacters),const DeepCollectionEquality().hash(_additionalTextEdits),textEditText,const DeepCollectionEquality().hash(textEdit),insertTextMode,insertTextFormat,insertText,filterText,sortText,preselect,deprecated,const DeepCollectionEquality().hash(documentation),detail,const DeepCollectionEquality().hash(_tags),kind,labelDetails]);

@override
String toString() {
  return 'CompletionItem(label: $label, data: $data, command: $command, commitCharacters: $commitCharacters, additionalTextEdits: $additionalTextEdits, textEditText: $textEditText, textEdit: $textEdit, insertTextMode: $insertTextMode, insertTextFormat: $insertTextFormat, insertText: $insertText, filterText: $filterText, sortText: $sortText, preselect: $preselect, deprecated: $deprecated, documentation: $documentation, detail: $detail, tags: $tags, kind: $kind, labelDetails: $labelDetails)';
}


}

/// @nodoc
abstract mixin class _$CompletionItemCopyWith<$Res> implements $CompletionItemCopyWith<$Res> {
  factory _$CompletionItemCopyWith(_CompletionItem value, $Res Function(_CompletionItem) _then) = __$CompletionItemCopyWithImpl;
@override @useResult
$Res call({
 String label, LSPAny? data, Command? command, List<String>? commitCharacters, List<TextEdit>? additionalTextEdits, String? textEditText, dynamic? textEdit, InsertTextMode? insertTextMode, InsertTextFormat? insertTextFormat, String? insertText, String? filterText, String? sortText, bool? preselect, bool? deprecated, dynamic? documentation, String? detail, List<CompletionItemTag>? tags, CompletionItemKind? kind, CompletionItemLabelDetails? labelDetails
});


@override $CommandCopyWith<$Res>? get command;@override $CompletionItemLabelDetailsCopyWith<$Res>? get labelDetails;

}
/// @nodoc
class __$CompletionItemCopyWithImpl<$Res>
    implements _$CompletionItemCopyWith<$Res> {
  __$CompletionItemCopyWithImpl(this._self, this._then);

  final _CompletionItem _self;
  final $Res Function(_CompletionItem) _then;

/// Create a copy of CompletionItem
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? label = null,Object? data = freezed,Object? command = freezed,Object? commitCharacters = freezed,Object? additionalTextEdits = freezed,Object? textEditText = freezed,Object? textEdit = freezed,Object? insertTextMode = freezed,Object? insertTextFormat = freezed,Object? insertText = freezed,Object? filterText = freezed,Object? sortText = freezed,Object? preselect = freezed,Object? deprecated = freezed,Object? documentation = freezed,Object? detail = freezed,Object? tags = freezed,Object? kind = freezed,Object? labelDetails = freezed,}) {
  return _then(_CompletionItem(
label: null == label ? _self.label : label // ignore: cast_nullable_to_non_nullable
as String,data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LSPAny?,command: freezed == command ? _self.command : command // ignore: cast_nullable_to_non_nullable
as Command?,commitCharacters: freezed == commitCharacters ? _self._commitCharacters : commitCharacters // ignore: cast_nullable_to_non_nullable
as List<String>?,additionalTextEdits: freezed == additionalTextEdits ? _self._additionalTextEdits : additionalTextEdits // ignore: cast_nullable_to_non_nullable
as List<TextEdit>?,textEditText: freezed == textEditText ? _self.textEditText : textEditText // ignore: cast_nullable_to_non_nullable
as String?,textEdit: freezed == textEdit ? _self.textEdit : textEdit // ignore: cast_nullable_to_non_nullable
as dynamic?,insertTextMode: freezed == insertTextMode ? _self.insertTextMode : insertTextMode // ignore: cast_nullable_to_non_nullable
as InsertTextMode?,insertTextFormat: freezed == insertTextFormat ? _self.insertTextFormat : insertTextFormat // ignore: cast_nullable_to_non_nullable
as InsertTextFormat?,insertText: freezed == insertText ? _self.insertText : insertText // ignore: cast_nullable_to_non_nullable
as String?,filterText: freezed == filterText ? _self.filterText : filterText // ignore: cast_nullable_to_non_nullable
as String?,sortText: freezed == sortText ? _self.sortText : sortText // ignore: cast_nullable_to_non_nullable
as String?,preselect: freezed == preselect ? _self.preselect : preselect // ignore: cast_nullable_to_non_nullable
as bool?,deprecated: freezed == deprecated ? _self.deprecated : deprecated // ignore: cast_nullable_to_non_nullable
as bool?,documentation: freezed == documentation ? _self.documentation : documentation // ignore: cast_nullable_to_non_nullable
as dynamic?,detail: freezed == detail ? _self.detail : detail // ignore: cast_nullable_to_non_nullable
as String?,tags: freezed == tags ? _self._tags : tags // ignore: cast_nullable_to_non_nullable
as List<CompletionItemTag>?,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as CompletionItemKind?,labelDetails: freezed == labelDetails ? _self.labelDetails : labelDetails // ignore: cast_nullable_to_non_nullable
as CompletionItemLabelDetails?,
  ));
}

/// Create a copy of CompletionItem
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CommandCopyWith<$Res>? get command {
    if (_self.command == null) {
    return null;
  }

  return $CommandCopyWith<$Res>(_self.command!, (value) {
    return _then(_self.copyWith(command: value));
  });
}/// Create a copy of CompletionItem
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CompletionItemLabelDetailsCopyWith<$Res>? get labelDetails {
    if (_self.labelDetails == null) {
    return null;
  }

  return $CompletionItemLabelDetailsCopyWith<$Res>(_self.labelDetails!, (value) {
    return _then(_self.copyWith(labelDetails: value));
  });
}
}


/// @nodoc
mixin _$CompletionList {

 bool get isIncomplete; List<CompletionItem> get items; ({List<String>? commitCharacters, dynamic? editRange, InsertTextFormat? insertTextFormat, InsertTextMode? insertTextMode, LSPAny? data})? get itemDefaults;
/// Create a copy of CompletionList
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CompletionListCopyWith<CompletionList> get copyWith => _$CompletionListCopyWithImpl<CompletionList>(this as CompletionList, _$identity);

  /// Serializes this CompletionList to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CompletionList&&(identical(other.isIncomplete, isIncomplete) || other.isIncomplete == isIncomplete)&&const DeepCollectionEquality().equals(other.items, items)&&(identical(other.itemDefaults, itemDefaults) || other.itemDefaults == itemDefaults));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,isIncomplete,const DeepCollectionEquality().hash(items),itemDefaults);

@override
String toString() {
  return 'CompletionList(isIncomplete: $isIncomplete, items: $items, itemDefaults: $itemDefaults)';
}


}

/// @nodoc
abstract mixin class $CompletionListCopyWith<$Res>  {
  factory $CompletionListCopyWith(CompletionList value, $Res Function(CompletionList) _then) = _$CompletionListCopyWithImpl;
@useResult
$Res call({
 bool isIncomplete, List<CompletionItem> items, ({List<String>? commitCharacters, dynamic? editRange, InsertTextFormat? insertTextFormat, InsertTextMode? insertTextMode, LSPAny? data})? itemDefaults
});




}
/// @nodoc
class _$CompletionListCopyWithImpl<$Res>
    implements $CompletionListCopyWith<$Res> {
  _$CompletionListCopyWithImpl(this._self, this._then);

  final CompletionList _self;
  final $Res Function(CompletionList) _then;

/// Create a copy of CompletionList
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? isIncomplete = null,Object? items = null,Object? itemDefaults = freezed,}) {
  return _then(_self.copyWith(
isIncomplete: null == isIncomplete ? _self.isIncomplete : isIncomplete // ignore: cast_nullable_to_non_nullable
as bool,items: null == items ? _self.items : items // ignore: cast_nullable_to_non_nullable
as List<CompletionItem>,itemDefaults: freezed == itemDefaults ? _self.itemDefaults : itemDefaults // ignore: cast_nullable_to_non_nullable
as ({List<String>? commitCharacters, dynamic? editRange, InsertTextFormat? insertTextFormat, InsertTextMode? insertTextMode, LSPAny? data})?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _CompletionList implements CompletionList {
  const _CompletionList({required this.isIncomplete, required final  List<CompletionItem> items, this.itemDefaults}): _items = items;
  factory _CompletionList.fromJson(Map<String, dynamic> json) => _$CompletionListFromJson(json);

@override final  bool isIncomplete;
 final  List<CompletionItem> _items;
@override List<CompletionItem> get items {
  if (_items is EqualUnmodifiableListView) return _items;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_items);
}

@override final  ({List<String>? commitCharacters, dynamic? editRange, InsertTextFormat? insertTextFormat, InsertTextMode? insertTextMode, LSPAny? data})? itemDefaults;

/// Create a copy of CompletionList
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CompletionListCopyWith<_CompletionList> get copyWith => __$CompletionListCopyWithImpl<_CompletionList>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CompletionListToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CompletionList&&(identical(other.isIncomplete, isIncomplete) || other.isIncomplete == isIncomplete)&&const DeepCollectionEquality().equals(other._items, _items)&&(identical(other.itemDefaults, itemDefaults) || other.itemDefaults == itemDefaults));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,isIncomplete,const DeepCollectionEquality().hash(_items),itemDefaults);

@override
String toString() {
  return 'CompletionList(isIncomplete: $isIncomplete, items: $items, itemDefaults: $itemDefaults)';
}


}

/// @nodoc
abstract mixin class _$CompletionListCopyWith<$Res> implements $CompletionListCopyWith<$Res> {
  factory _$CompletionListCopyWith(_CompletionList value, $Res Function(_CompletionList) _then) = __$CompletionListCopyWithImpl;
@override @useResult
$Res call({
 bool isIncomplete, List<CompletionItem> items, ({List<String>? commitCharacters, dynamic? editRange, InsertTextFormat? insertTextFormat, InsertTextMode? insertTextMode, LSPAny? data})? itemDefaults
});




}
/// @nodoc
class __$CompletionListCopyWithImpl<$Res>
    implements _$CompletionListCopyWith<$Res> {
  __$CompletionListCopyWithImpl(this._self, this._then);

  final _CompletionList _self;
  final $Res Function(_CompletionList) _then;

/// Create a copy of CompletionList
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? isIncomplete = null,Object? items = null,Object? itemDefaults = freezed,}) {
  return _then(_CompletionList(
isIncomplete: null == isIncomplete ? _self.isIncomplete : isIncomplete // ignore: cast_nullable_to_non_nullable
as bool,items: null == items ? _self._items : items // ignore: cast_nullable_to_non_nullable
as List<CompletionItem>,itemDefaults: freezed == itemDefaults ? _self.itemDefaults : itemDefaults // ignore: cast_nullable_to_non_nullable
as ({List<String>? commitCharacters, dynamic? editRange, InsertTextFormat? insertTextFormat, InsertTextMode? insertTextMode, LSPAny? data})?,
  ));
}


}


/// @nodoc
mixin _$CompletionRegistrationOptions {

 dynamic get documentSelector; ({bool? labelDetailsSupport})? get completionItem; bool? get resolveProvider; List<String>? get allCommitCharacters; List<String>? get triggerCharacters; bool? get workDoneProgress;
/// Create a copy of CompletionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CompletionRegistrationOptionsCopyWith<CompletionRegistrationOptions> get copyWith => _$CompletionRegistrationOptionsCopyWithImpl<CompletionRegistrationOptions>(this as CompletionRegistrationOptions, _$identity);

  /// Serializes this CompletionRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CompletionRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.completionItem, completionItem) || other.completionItem == completionItem)&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider)&&const DeepCollectionEquality().equals(other.allCommitCharacters, allCommitCharacters)&&const DeepCollectionEquality().equals(other.triggerCharacters, triggerCharacters)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),completionItem,resolveProvider,const DeepCollectionEquality().hash(allCommitCharacters),const DeepCollectionEquality().hash(triggerCharacters),workDoneProgress);

@override
String toString() {
  return 'CompletionRegistrationOptions(documentSelector: $documentSelector, completionItem: $completionItem, resolveProvider: $resolveProvider, allCommitCharacters: $allCommitCharacters, triggerCharacters: $triggerCharacters, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $CompletionRegistrationOptionsCopyWith<$Res>  {
  factory $CompletionRegistrationOptionsCopyWith(CompletionRegistrationOptions value, $Res Function(CompletionRegistrationOptions) _then) = _$CompletionRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 dynamic documentSelector, ({bool? labelDetailsSupport})? completionItem, bool? resolveProvider, List<String>? allCommitCharacters, List<String>? triggerCharacters, bool? workDoneProgress
});




}
/// @nodoc
class _$CompletionRegistrationOptionsCopyWithImpl<$Res>
    implements $CompletionRegistrationOptionsCopyWith<$Res> {
  _$CompletionRegistrationOptionsCopyWithImpl(this._self, this._then);

  final CompletionRegistrationOptions _self;
  final $Res Function(CompletionRegistrationOptions) _then;

/// Create a copy of CompletionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = freezed,Object? completionItem = freezed,Object? resolveProvider = freezed,Object? allCommitCharacters = freezed,Object? triggerCharacters = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,completionItem: freezed == completionItem ? _self.completionItem : completionItem // ignore: cast_nullable_to_non_nullable
as ({bool? labelDetailsSupport})?,resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,allCommitCharacters: freezed == allCommitCharacters ? _self.allCommitCharacters : allCommitCharacters // ignore: cast_nullable_to_non_nullable
as List<String>?,triggerCharacters: freezed == triggerCharacters ? _self.triggerCharacters : triggerCharacters // ignore: cast_nullable_to_non_nullable
as List<String>?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _CompletionRegistrationOptions implements CompletionRegistrationOptions {
  const _CompletionRegistrationOptions({required this.documentSelector, this.completionItem, this.resolveProvider, final  List<String>? allCommitCharacters, final  List<String>? triggerCharacters, this.workDoneProgress}): _allCommitCharacters = allCommitCharacters,_triggerCharacters = triggerCharacters;
  factory _CompletionRegistrationOptions.fromJson(Map<String, dynamic> json) => _$CompletionRegistrationOptionsFromJson(json);

@override final  dynamic documentSelector;
@override final  ({bool? labelDetailsSupport})? completionItem;
@override final  bool? resolveProvider;
 final  List<String>? _allCommitCharacters;
@override List<String>? get allCommitCharacters {
  final value = _allCommitCharacters;
  if (value == null) return null;
  if (_allCommitCharacters is EqualUnmodifiableListView) return _allCommitCharacters;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

 final  List<String>? _triggerCharacters;
@override List<String>? get triggerCharacters {
  final value = _triggerCharacters;
  if (value == null) return null;
  if (_triggerCharacters is EqualUnmodifiableListView) return _triggerCharacters;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

@override final  bool? workDoneProgress;

/// Create a copy of CompletionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CompletionRegistrationOptionsCopyWith<_CompletionRegistrationOptions> get copyWith => __$CompletionRegistrationOptionsCopyWithImpl<_CompletionRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CompletionRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CompletionRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.completionItem, completionItem) || other.completionItem == completionItem)&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider)&&const DeepCollectionEquality().equals(other._allCommitCharacters, _allCommitCharacters)&&const DeepCollectionEquality().equals(other._triggerCharacters, _triggerCharacters)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),completionItem,resolveProvider,const DeepCollectionEquality().hash(_allCommitCharacters),const DeepCollectionEquality().hash(_triggerCharacters),workDoneProgress);

@override
String toString() {
  return 'CompletionRegistrationOptions(documentSelector: $documentSelector, completionItem: $completionItem, resolveProvider: $resolveProvider, allCommitCharacters: $allCommitCharacters, triggerCharacters: $triggerCharacters, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$CompletionRegistrationOptionsCopyWith<$Res> implements $CompletionRegistrationOptionsCopyWith<$Res> {
  factory _$CompletionRegistrationOptionsCopyWith(_CompletionRegistrationOptions value, $Res Function(_CompletionRegistrationOptions) _then) = __$CompletionRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 dynamic documentSelector, ({bool? labelDetailsSupport})? completionItem, bool? resolveProvider, List<String>? allCommitCharacters, List<String>? triggerCharacters, bool? workDoneProgress
});




}
/// @nodoc
class __$CompletionRegistrationOptionsCopyWithImpl<$Res>
    implements _$CompletionRegistrationOptionsCopyWith<$Res> {
  __$CompletionRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _CompletionRegistrationOptions _self;
  final $Res Function(_CompletionRegistrationOptions) _then;

/// Create a copy of CompletionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = freezed,Object? completionItem = freezed,Object? resolveProvider = freezed,Object? allCommitCharacters = freezed,Object? triggerCharacters = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_CompletionRegistrationOptions(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,completionItem: freezed == completionItem ? _self.completionItem : completionItem // ignore: cast_nullable_to_non_nullable
as ({bool? labelDetailsSupport})?,resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,allCommitCharacters: freezed == allCommitCharacters ? _self._allCommitCharacters : allCommitCharacters // ignore: cast_nullable_to_non_nullable
as List<String>?,triggerCharacters: freezed == triggerCharacters ? _self._triggerCharacters : triggerCharacters // ignore: cast_nullable_to_non_nullable
as List<String>?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$HoverParams {

 TextDocumentIdentifier get textDocument; Position get position; ProgressToken? get workDoneToken;
/// Create a copy of HoverParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$HoverParamsCopyWith<HoverParams> get copyWith => _$HoverParamsCopyWithImpl<HoverParams>(this as HoverParams, _$identity);

  /// Serializes this HoverParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is HoverParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.position, position) || other.position == position)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,position,const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'HoverParams(textDocument: $textDocument, position: $position, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $HoverParamsCopyWith<$Res>  {
  factory $HoverParamsCopyWith(HoverParams value, $Res Function(HoverParams) _then) = _$HoverParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument, Position position, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;$PositionCopyWith<$Res> get position;

}
/// @nodoc
class _$HoverParamsCopyWithImpl<$Res>
    implements $HoverParamsCopyWith<$Res> {
  _$HoverParamsCopyWithImpl(this._self, this._then);

  final HoverParams _self;
  final $Res Function(HoverParams) _then;

/// Create a copy of HoverParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? position = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of HoverParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of HoverParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _HoverParams implements HoverParams {
  const _HoverParams({required this.textDocument, required this.position, this.workDoneToken});
  factory _HoverParams.fromJson(Map<String, dynamic> json) => _$HoverParamsFromJson(json);

@override final  TextDocumentIdentifier textDocument;
@override final  Position position;
@override final  ProgressToken? workDoneToken;

/// Create a copy of HoverParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$HoverParamsCopyWith<_HoverParams> get copyWith => __$HoverParamsCopyWithImpl<_HoverParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$HoverParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _HoverParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.position, position) || other.position == position)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,position,const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'HoverParams(textDocument: $textDocument, position: $position, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$HoverParamsCopyWith<$Res> implements $HoverParamsCopyWith<$Res> {
  factory _$HoverParamsCopyWith(_HoverParams value, $Res Function(_HoverParams) _then) = __$HoverParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument, Position position, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;@override $PositionCopyWith<$Res> get position;

}
/// @nodoc
class __$HoverParamsCopyWithImpl<$Res>
    implements _$HoverParamsCopyWith<$Res> {
  __$HoverParamsCopyWithImpl(this._self, this._then);

  final _HoverParams _self;
  final $Res Function(_HoverParams) _then;

/// Create a copy of HoverParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? position = null,Object? workDoneToken = freezed,}) {
  return _then(_HoverParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of HoverParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of HoverParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}
}


/// @nodoc
mixin _$Hover {

 dynamic get contents; Range? get range;
/// Create a copy of Hover
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$HoverCopyWith<Hover> get copyWith => _$HoverCopyWithImpl<Hover>(this as Hover, _$identity);

  /// Serializes this Hover to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Hover&&const DeepCollectionEquality().equals(other.contents, contents)&&(identical(other.range, range) || other.range == range));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(contents),range);

@override
String toString() {
  return 'Hover(contents: $contents, range: $range)';
}


}

/// @nodoc
abstract mixin class $HoverCopyWith<$Res>  {
  factory $HoverCopyWith(Hover value, $Res Function(Hover) _then) = _$HoverCopyWithImpl;
@useResult
$Res call({
 dynamic contents, Range? range
});


$RangeCopyWith<$Res>? get range;

}
/// @nodoc
class _$HoverCopyWithImpl<$Res>
    implements $HoverCopyWith<$Res> {
  _$HoverCopyWithImpl(this._self, this._then);

  final Hover _self;
  final $Res Function(Hover) _then;

/// Create a copy of Hover
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? contents = freezed,Object? range = freezed,}) {
  return _then(_self.copyWith(
contents: freezed == contents ? _self.contents : contents // ignore: cast_nullable_to_non_nullable
as dynamic,range: freezed == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range?,
  ));
}
/// Create a copy of Hover
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res>? get range {
    if (_self.range == null) {
    return null;
  }

  return $RangeCopyWith<$Res>(_self.range!, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _Hover implements Hover {
  const _Hover({required this.contents, this.range});
  factory _Hover.fromJson(Map<String, dynamic> json) => _$HoverFromJson(json);

@override final  dynamic contents;
@override final  Range? range;

/// Create a copy of Hover
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$HoverCopyWith<_Hover> get copyWith => __$HoverCopyWithImpl<_Hover>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$HoverToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _Hover&&const DeepCollectionEquality().equals(other.contents, contents)&&(identical(other.range, range) || other.range == range));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(contents),range);

@override
String toString() {
  return 'Hover(contents: $contents, range: $range)';
}


}

/// @nodoc
abstract mixin class _$HoverCopyWith<$Res> implements $HoverCopyWith<$Res> {
  factory _$HoverCopyWith(_Hover value, $Res Function(_Hover) _then) = __$HoverCopyWithImpl;
@override @useResult
$Res call({
 dynamic contents, Range? range
});


@override $RangeCopyWith<$Res>? get range;

}
/// @nodoc
class __$HoverCopyWithImpl<$Res>
    implements _$HoverCopyWith<$Res> {
  __$HoverCopyWithImpl(this._self, this._then);

  final _Hover _self;
  final $Res Function(_Hover) _then;

/// Create a copy of Hover
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? contents = freezed,Object? range = freezed,}) {
  return _then(_Hover(
contents: freezed == contents ? _self.contents : contents // ignore: cast_nullable_to_non_nullable
as dynamic,range: freezed == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range?,
  ));
}

/// Create a copy of Hover
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res>? get range {
    if (_self.range == null) {
    return null;
  }

  return $RangeCopyWith<$Res>(_self.range!, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}


/// @nodoc
mixin _$HoverRegistrationOptions {

 dynamic get documentSelector; bool? get workDoneProgress;
/// Create a copy of HoverRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$HoverRegistrationOptionsCopyWith<HoverRegistrationOptions> get copyWith => _$HoverRegistrationOptionsCopyWithImpl<HoverRegistrationOptions>(this as HoverRegistrationOptions, _$identity);

  /// Serializes this HoverRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is HoverRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),workDoneProgress);

@override
String toString() {
  return 'HoverRegistrationOptions(documentSelector: $documentSelector, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $HoverRegistrationOptionsCopyWith<$Res>  {
  factory $HoverRegistrationOptionsCopyWith(HoverRegistrationOptions value, $Res Function(HoverRegistrationOptions) _then) = _$HoverRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 dynamic documentSelector, bool? workDoneProgress
});




}
/// @nodoc
class _$HoverRegistrationOptionsCopyWithImpl<$Res>
    implements $HoverRegistrationOptionsCopyWith<$Res> {
  _$HoverRegistrationOptionsCopyWithImpl(this._self, this._then);

  final HoverRegistrationOptions _self;
  final $Res Function(HoverRegistrationOptions) _then;

/// Create a copy of HoverRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _HoverRegistrationOptions implements HoverRegistrationOptions {
  const _HoverRegistrationOptions({required this.documentSelector, this.workDoneProgress});
  factory _HoverRegistrationOptions.fromJson(Map<String, dynamic> json) => _$HoverRegistrationOptionsFromJson(json);

@override final  dynamic documentSelector;
@override final  bool? workDoneProgress;

/// Create a copy of HoverRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$HoverRegistrationOptionsCopyWith<_HoverRegistrationOptions> get copyWith => __$HoverRegistrationOptionsCopyWithImpl<_HoverRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$HoverRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _HoverRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),workDoneProgress);

@override
String toString() {
  return 'HoverRegistrationOptions(documentSelector: $documentSelector, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$HoverRegistrationOptionsCopyWith<$Res> implements $HoverRegistrationOptionsCopyWith<$Res> {
  factory _$HoverRegistrationOptionsCopyWith(_HoverRegistrationOptions value, $Res Function(_HoverRegistrationOptions) _then) = __$HoverRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 dynamic documentSelector, bool? workDoneProgress
});




}
/// @nodoc
class __$HoverRegistrationOptionsCopyWithImpl<$Res>
    implements _$HoverRegistrationOptionsCopyWith<$Res> {
  __$HoverRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _HoverRegistrationOptions _self;
  final $Res Function(_HoverRegistrationOptions) _then;

/// Create a copy of HoverRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_HoverRegistrationOptions(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$SignatureHelpParams {

 TextDocumentIdentifier get textDocument; Position get position; SignatureHelpContext? get context; ProgressToken? get workDoneToken;
/// Create a copy of SignatureHelpParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SignatureHelpParamsCopyWith<SignatureHelpParams> get copyWith => _$SignatureHelpParamsCopyWithImpl<SignatureHelpParams>(this as SignatureHelpParams, _$identity);

  /// Serializes this SignatureHelpParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SignatureHelpParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.position, position) || other.position == position)&&(identical(other.context, context) || other.context == context)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,position,context,const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'SignatureHelpParams(textDocument: $textDocument, position: $position, context: $context, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $SignatureHelpParamsCopyWith<$Res>  {
  factory $SignatureHelpParamsCopyWith(SignatureHelpParams value, $Res Function(SignatureHelpParams) _then) = _$SignatureHelpParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument, Position position, SignatureHelpContext? context, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;$PositionCopyWith<$Res> get position;$SignatureHelpContextCopyWith<$Res>? get context;

}
/// @nodoc
class _$SignatureHelpParamsCopyWithImpl<$Res>
    implements $SignatureHelpParamsCopyWith<$Res> {
  _$SignatureHelpParamsCopyWithImpl(this._self, this._then);

  final SignatureHelpParams _self;
  final $Res Function(SignatureHelpParams) _then;

/// Create a copy of SignatureHelpParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? position = null,Object? context = freezed,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,context: freezed == context ? _self.context : context // ignore: cast_nullable_to_non_nullable
as SignatureHelpContext?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of SignatureHelpParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of SignatureHelpParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of SignatureHelpParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SignatureHelpContextCopyWith<$Res>? get context {
    if (_self.context == null) {
    return null;
  }

  return $SignatureHelpContextCopyWith<$Res>(_self.context!, (value) {
    return _then(_self.copyWith(context: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _SignatureHelpParams implements SignatureHelpParams {
  const _SignatureHelpParams({required this.textDocument, required this.position, this.context, this.workDoneToken});
  factory _SignatureHelpParams.fromJson(Map<String, dynamic> json) => _$SignatureHelpParamsFromJson(json);

@override final  TextDocumentIdentifier textDocument;
@override final  Position position;
@override final  SignatureHelpContext? context;
@override final  ProgressToken? workDoneToken;

/// Create a copy of SignatureHelpParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SignatureHelpParamsCopyWith<_SignatureHelpParams> get copyWith => __$SignatureHelpParamsCopyWithImpl<_SignatureHelpParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SignatureHelpParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SignatureHelpParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.position, position) || other.position == position)&&(identical(other.context, context) || other.context == context)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,position,context,const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'SignatureHelpParams(textDocument: $textDocument, position: $position, context: $context, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$SignatureHelpParamsCopyWith<$Res> implements $SignatureHelpParamsCopyWith<$Res> {
  factory _$SignatureHelpParamsCopyWith(_SignatureHelpParams value, $Res Function(_SignatureHelpParams) _then) = __$SignatureHelpParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument, Position position, SignatureHelpContext? context, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;@override $PositionCopyWith<$Res> get position;@override $SignatureHelpContextCopyWith<$Res>? get context;

}
/// @nodoc
class __$SignatureHelpParamsCopyWithImpl<$Res>
    implements _$SignatureHelpParamsCopyWith<$Res> {
  __$SignatureHelpParamsCopyWithImpl(this._self, this._then);

  final _SignatureHelpParams _self;
  final $Res Function(_SignatureHelpParams) _then;

/// Create a copy of SignatureHelpParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? position = null,Object? context = freezed,Object? workDoneToken = freezed,}) {
  return _then(_SignatureHelpParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,context: freezed == context ? _self.context : context // ignore: cast_nullable_to_non_nullable
as SignatureHelpContext?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of SignatureHelpParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of SignatureHelpParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of SignatureHelpParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SignatureHelpContextCopyWith<$Res>? get context {
    if (_self.context == null) {
    return null;
  }

  return $SignatureHelpContextCopyWith<$Res>(_self.context!, (value) {
    return _then(_self.copyWith(context: value));
  });
}
}


/// @nodoc
mixin _$SignatureHelp {

 List<SignatureInformation> get signatures; int? get activeParameter; int? get activeSignature;
/// Create a copy of SignatureHelp
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SignatureHelpCopyWith<SignatureHelp> get copyWith => _$SignatureHelpCopyWithImpl<SignatureHelp>(this as SignatureHelp, _$identity);

  /// Serializes this SignatureHelp to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SignatureHelp&&const DeepCollectionEquality().equals(other.signatures, signatures)&&(identical(other.activeParameter, activeParameter) || other.activeParameter == activeParameter)&&(identical(other.activeSignature, activeSignature) || other.activeSignature == activeSignature));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(signatures),activeParameter,activeSignature);

@override
String toString() {
  return 'SignatureHelp(signatures: $signatures, activeParameter: $activeParameter, activeSignature: $activeSignature)';
}


}

/// @nodoc
abstract mixin class $SignatureHelpCopyWith<$Res>  {
  factory $SignatureHelpCopyWith(SignatureHelp value, $Res Function(SignatureHelp) _then) = _$SignatureHelpCopyWithImpl;
@useResult
$Res call({
 List<SignatureInformation> signatures, int? activeParameter, int? activeSignature
});




}
/// @nodoc
class _$SignatureHelpCopyWithImpl<$Res>
    implements $SignatureHelpCopyWith<$Res> {
  _$SignatureHelpCopyWithImpl(this._self, this._then);

  final SignatureHelp _self;
  final $Res Function(SignatureHelp) _then;

/// Create a copy of SignatureHelp
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? signatures = null,Object? activeParameter = freezed,Object? activeSignature = freezed,}) {
  return _then(_self.copyWith(
signatures: null == signatures ? _self.signatures : signatures // ignore: cast_nullable_to_non_nullable
as List<SignatureInformation>,activeParameter: freezed == activeParameter ? _self.activeParameter : activeParameter // ignore: cast_nullable_to_non_nullable
as int?,activeSignature: freezed == activeSignature ? _self.activeSignature : activeSignature // ignore: cast_nullable_to_non_nullable
as int?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _SignatureHelp implements SignatureHelp {
  const _SignatureHelp({required final  List<SignatureInformation> signatures, this.activeParameter, this.activeSignature}): _signatures = signatures;
  factory _SignatureHelp.fromJson(Map<String, dynamic> json) => _$SignatureHelpFromJson(json);

 final  List<SignatureInformation> _signatures;
@override List<SignatureInformation> get signatures {
  if (_signatures is EqualUnmodifiableListView) return _signatures;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_signatures);
}

@override final  int? activeParameter;
@override final  int? activeSignature;

/// Create a copy of SignatureHelp
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SignatureHelpCopyWith<_SignatureHelp> get copyWith => __$SignatureHelpCopyWithImpl<_SignatureHelp>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SignatureHelpToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SignatureHelp&&const DeepCollectionEquality().equals(other._signatures, _signatures)&&(identical(other.activeParameter, activeParameter) || other.activeParameter == activeParameter)&&(identical(other.activeSignature, activeSignature) || other.activeSignature == activeSignature));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_signatures),activeParameter,activeSignature);

@override
String toString() {
  return 'SignatureHelp(signatures: $signatures, activeParameter: $activeParameter, activeSignature: $activeSignature)';
}


}

/// @nodoc
abstract mixin class _$SignatureHelpCopyWith<$Res> implements $SignatureHelpCopyWith<$Res> {
  factory _$SignatureHelpCopyWith(_SignatureHelp value, $Res Function(_SignatureHelp) _then) = __$SignatureHelpCopyWithImpl;
@override @useResult
$Res call({
 List<SignatureInformation> signatures, int? activeParameter, int? activeSignature
});




}
/// @nodoc
class __$SignatureHelpCopyWithImpl<$Res>
    implements _$SignatureHelpCopyWith<$Res> {
  __$SignatureHelpCopyWithImpl(this._self, this._then);

  final _SignatureHelp _self;
  final $Res Function(_SignatureHelp) _then;

/// Create a copy of SignatureHelp
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? signatures = null,Object? activeParameter = freezed,Object? activeSignature = freezed,}) {
  return _then(_SignatureHelp(
signatures: null == signatures ? _self._signatures : signatures // ignore: cast_nullable_to_non_nullable
as List<SignatureInformation>,activeParameter: freezed == activeParameter ? _self.activeParameter : activeParameter // ignore: cast_nullable_to_non_nullable
as int?,activeSignature: freezed == activeSignature ? _self.activeSignature : activeSignature // ignore: cast_nullable_to_non_nullable
as int?,
  ));
}


}


/// @nodoc
mixin _$SignatureHelpRegistrationOptions {

 dynamic get documentSelector; List<String>? get retriggerCharacters; List<String>? get triggerCharacters; bool? get workDoneProgress;
/// Create a copy of SignatureHelpRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SignatureHelpRegistrationOptionsCopyWith<SignatureHelpRegistrationOptions> get copyWith => _$SignatureHelpRegistrationOptionsCopyWithImpl<SignatureHelpRegistrationOptions>(this as SignatureHelpRegistrationOptions, _$identity);

  /// Serializes this SignatureHelpRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SignatureHelpRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&const DeepCollectionEquality().equals(other.retriggerCharacters, retriggerCharacters)&&const DeepCollectionEquality().equals(other.triggerCharacters, triggerCharacters)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),const DeepCollectionEquality().hash(retriggerCharacters),const DeepCollectionEquality().hash(triggerCharacters),workDoneProgress);

@override
String toString() {
  return 'SignatureHelpRegistrationOptions(documentSelector: $documentSelector, retriggerCharacters: $retriggerCharacters, triggerCharacters: $triggerCharacters, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $SignatureHelpRegistrationOptionsCopyWith<$Res>  {
  factory $SignatureHelpRegistrationOptionsCopyWith(SignatureHelpRegistrationOptions value, $Res Function(SignatureHelpRegistrationOptions) _then) = _$SignatureHelpRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 dynamic documentSelector, List<String>? retriggerCharacters, List<String>? triggerCharacters, bool? workDoneProgress
});




}
/// @nodoc
class _$SignatureHelpRegistrationOptionsCopyWithImpl<$Res>
    implements $SignatureHelpRegistrationOptionsCopyWith<$Res> {
  _$SignatureHelpRegistrationOptionsCopyWithImpl(this._self, this._then);

  final SignatureHelpRegistrationOptions _self;
  final $Res Function(SignatureHelpRegistrationOptions) _then;

/// Create a copy of SignatureHelpRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = freezed,Object? retriggerCharacters = freezed,Object? triggerCharacters = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,retriggerCharacters: freezed == retriggerCharacters ? _self.retriggerCharacters : retriggerCharacters // ignore: cast_nullable_to_non_nullable
as List<String>?,triggerCharacters: freezed == triggerCharacters ? _self.triggerCharacters : triggerCharacters // ignore: cast_nullable_to_non_nullable
as List<String>?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _SignatureHelpRegistrationOptions implements SignatureHelpRegistrationOptions {
  const _SignatureHelpRegistrationOptions({required this.documentSelector, final  List<String>? retriggerCharacters, final  List<String>? triggerCharacters, this.workDoneProgress}): _retriggerCharacters = retriggerCharacters,_triggerCharacters = triggerCharacters;
  factory _SignatureHelpRegistrationOptions.fromJson(Map<String, dynamic> json) => _$SignatureHelpRegistrationOptionsFromJson(json);

@override final  dynamic documentSelector;
 final  List<String>? _retriggerCharacters;
@override List<String>? get retriggerCharacters {
  final value = _retriggerCharacters;
  if (value == null) return null;
  if (_retriggerCharacters is EqualUnmodifiableListView) return _retriggerCharacters;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

 final  List<String>? _triggerCharacters;
@override List<String>? get triggerCharacters {
  final value = _triggerCharacters;
  if (value == null) return null;
  if (_triggerCharacters is EqualUnmodifiableListView) return _triggerCharacters;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

@override final  bool? workDoneProgress;

/// Create a copy of SignatureHelpRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SignatureHelpRegistrationOptionsCopyWith<_SignatureHelpRegistrationOptions> get copyWith => __$SignatureHelpRegistrationOptionsCopyWithImpl<_SignatureHelpRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SignatureHelpRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SignatureHelpRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&const DeepCollectionEquality().equals(other._retriggerCharacters, _retriggerCharacters)&&const DeepCollectionEquality().equals(other._triggerCharacters, _triggerCharacters)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),const DeepCollectionEquality().hash(_retriggerCharacters),const DeepCollectionEquality().hash(_triggerCharacters),workDoneProgress);

@override
String toString() {
  return 'SignatureHelpRegistrationOptions(documentSelector: $documentSelector, retriggerCharacters: $retriggerCharacters, triggerCharacters: $triggerCharacters, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$SignatureHelpRegistrationOptionsCopyWith<$Res> implements $SignatureHelpRegistrationOptionsCopyWith<$Res> {
  factory _$SignatureHelpRegistrationOptionsCopyWith(_SignatureHelpRegistrationOptions value, $Res Function(_SignatureHelpRegistrationOptions) _then) = __$SignatureHelpRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 dynamic documentSelector, List<String>? retriggerCharacters, List<String>? triggerCharacters, bool? workDoneProgress
});




}
/// @nodoc
class __$SignatureHelpRegistrationOptionsCopyWithImpl<$Res>
    implements _$SignatureHelpRegistrationOptionsCopyWith<$Res> {
  __$SignatureHelpRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _SignatureHelpRegistrationOptions _self;
  final $Res Function(_SignatureHelpRegistrationOptions) _then;

/// Create a copy of SignatureHelpRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = freezed,Object? retriggerCharacters = freezed,Object? triggerCharacters = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_SignatureHelpRegistrationOptions(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,retriggerCharacters: freezed == retriggerCharacters ? _self._retriggerCharacters : retriggerCharacters // ignore: cast_nullable_to_non_nullable
as List<String>?,triggerCharacters: freezed == triggerCharacters ? _self._triggerCharacters : triggerCharacters // ignore: cast_nullable_to_non_nullable
as List<String>?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DefinitionParams {

 TextDocumentIdentifier get textDocument; Position get position; ProgressToken? get partialResultToken; ProgressToken? get workDoneToken;
/// Create a copy of DefinitionParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DefinitionParamsCopyWith<DefinitionParams> get copyWith => _$DefinitionParamsCopyWithImpl<DefinitionParams>(this as DefinitionParams, _$identity);

  /// Serializes this DefinitionParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DefinitionParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.position, position) || other.position == position)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,position,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'DefinitionParams(textDocument: $textDocument, position: $position, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $DefinitionParamsCopyWith<$Res>  {
  factory $DefinitionParamsCopyWith(DefinitionParams value, $Res Function(DefinitionParams) _then) = _$DefinitionParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument, Position position, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;$PositionCopyWith<$Res> get position;

}
/// @nodoc
class _$DefinitionParamsCopyWithImpl<$Res>
    implements $DefinitionParamsCopyWith<$Res> {
  _$DefinitionParamsCopyWithImpl(this._self, this._then);

  final DefinitionParams _self;
  final $Res Function(DefinitionParams) _then;

/// Create a copy of DefinitionParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? position = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of DefinitionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of DefinitionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DefinitionParams implements DefinitionParams {
  const _DefinitionParams({required this.textDocument, required this.position, this.partialResultToken, this.workDoneToken});
  factory _DefinitionParams.fromJson(Map<String, dynamic> json) => _$DefinitionParamsFromJson(json);

@override final  TextDocumentIdentifier textDocument;
@override final  Position position;
@override final  ProgressToken? partialResultToken;
@override final  ProgressToken? workDoneToken;

/// Create a copy of DefinitionParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DefinitionParamsCopyWith<_DefinitionParams> get copyWith => __$DefinitionParamsCopyWithImpl<_DefinitionParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DefinitionParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DefinitionParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.position, position) || other.position == position)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,position,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'DefinitionParams(textDocument: $textDocument, position: $position, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$DefinitionParamsCopyWith<$Res> implements $DefinitionParamsCopyWith<$Res> {
  factory _$DefinitionParamsCopyWith(_DefinitionParams value, $Res Function(_DefinitionParams) _then) = __$DefinitionParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument, Position position, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;@override $PositionCopyWith<$Res> get position;

}
/// @nodoc
class __$DefinitionParamsCopyWithImpl<$Res>
    implements _$DefinitionParamsCopyWith<$Res> {
  __$DefinitionParamsCopyWithImpl(this._self, this._then);

  final _DefinitionParams _self;
  final $Res Function(_DefinitionParams) _then;

/// Create a copy of DefinitionParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? position = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_DefinitionParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of DefinitionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of DefinitionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}
}


/// @nodoc
mixin _$DefinitionRegistrationOptions {

 dynamic get documentSelector; bool? get workDoneProgress;
/// Create a copy of DefinitionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DefinitionRegistrationOptionsCopyWith<DefinitionRegistrationOptions> get copyWith => _$DefinitionRegistrationOptionsCopyWithImpl<DefinitionRegistrationOptions>(this as DefinitionRegistrationOptions, _$identity);

  /// Serializes this DefinitionRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DefinitionRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),workDoneProgress);

@override
String toString() {
  return 'DefinitionRegistrationOptions(documentSelector: $documentSelector, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $DefinitionRegistrationOptionsCopyWith<$Res>  {
  factory $DefinitionRegistrationOptionsCopyWith(DefinitionRegistrationOptions value, $Res Function(DefinitionRegistrationOptions) _then) = _$DefinitionRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 dynamic documentSelector, bool? workDoneProgress
});




}
/// @nodoc
class _$DefinitionRegistrationOptionsCopyWithImpl<$Res>
    implements $DefinitionRegistrationOptionsCopyWith<$Res> {
  _$DefinitionRegistrationOptionsCopyWithImpl(this._self, this._then);

  final DefinitionRegistrationOptions _self;
  final $Res Function(DefinitionRegistrationOptions) _then;

/// Create a copy of DefinitionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DefinitionRegistrationOptions implements DefinitionRegistrationOptions {
  const _DefinitionRegistrationOptions({required this.documentSelector, this.workDoneProgress});
  factory _DefinitionRegistrationOptions.fromJson(Map<String, dynamic> json) => _$DefinitionRegistrationOptionsFromJson(json);

@override final  dynamic documentSelector;
@override final  bool? workDoneProgress;

/// Create a copy of DefinitionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DefinitionRegistrationOptionsCopyWith<_DefinitionRegistrationOptions> get copyWith => __$DefinitionRegistrationOptionsCopyWithImpl<_DefinitionRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DefinitionRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DefinitionRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),workDoneProgress);

@override
String toString() {
  return 'DefinitionRegistrationOptions(documentSelector: $documentSelector, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$DefinitionRegistrationOptionsCopyWith<$Res> implements $DefinitionRegistrationOptionsCopyWith<$Res> {
  factory _$DefinitionRegistrationOptionsCopyWith(_DefinitionRegistrationOptions value, $Res Function(_DefinitionRegistrationOptions) _then) = __$DefinitionRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 dynamic documentSelector, bool? workDoneProgress
});




}
/// @nodoc
class __$DefinitionRegistrationOptionsCopyWithImpl<$Res>
    implements _$DefinitionRegistrationOptionsCopyWith<$Res> {
  __$DefinitionRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _DefinitionRegistrationOptions _self;
  final $Res Function(_DefinitionRegistrationOptions) _then;

/// Create a copy of DefinitionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_DefinitionRegistrationOptions(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$ReferenceParams {

 TextDocumentIdentifier get textDocument; Position get position; ReferenceContext get context; ProgressToken? get partialResultToken; ProgressToken? get workDoneToken;
/// Create a copy of ReferenceParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ReferenceParamsCopyWith<ReferenceParams> get copyWith => _$ReferenceParamsCopyWithImpl<ReferenceParams>(this as ReferenceParams, _$identity);

  /// Serializes this ReferenceParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ReferenceParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.position, position) || other.position == position)&&(identical(other.context, context) || other.context == context)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,position,context,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'ReferenceParams(textDocument: $textDocument, position: $position, context: $context, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $ReferenceParamsCopyWith<$Res>  {
  factory $ReferenceParamsCopyWith(ReferenceParams value, $Res Function(ReferenceParams) _then) = _$ReferenceParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument, Position position, ReferenceContext context, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;$PositionCopyWith<$Res> get position;$ReferenceContextCopyWith<$Res> get context;

}
/// @nodoc
class _$ReferenceParamsCopyWithImpl<$Res>
    implements $ReferenceParamsCopyWith<$Res> {
  _$ReferenceParamsCopyWithImpl(this._self, this._then);

  final ReferenceParams _self;
  final $Res Function(ReferenceParams) _then;

/// Create a copy of ReferenceParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? position = null,Object? context = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,context: null == context ? _self.context : context // ignore: cast_nullable_to_non_nullable
as ReferenceContext,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of ReferenceParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of ReferenceParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of ReferenceParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ReferenceContextCopyWith<$Res> get context {
  
  return $ReferenceContextCopyWith<$Res>(_self.context, (value) {
    return _then(_self.copyWith(context: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _ReferenceParams implements ReferenceParams {
  const _ReferenceParams({required this.textDocument, required this.position, required this.context, this.partialResultToken, this.workDoneToken});
  factory _ReferenceParams.fromJson(Map<String, dynamic> json) => _$ReferenceParamsFromJson(json);

@override final  TextDocumentIdentifier textDocument;
@override final  Position position;
@override final  ReferenceContext context;
@override final  ProgressToken? partialResultToken;
@override final  ProgressToken? workDoneToken;

/// Create a copy of ReferenceParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ReferenceParamsCopyWith<_ReferenceParams> get copyWith => __$ReferenceParamsCopyWithImpl<_ReferenceParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ReferenceParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ReferenceParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.position, position) || other.position == position)&&(identical(other.context, context) || other.context == context)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,position,context,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'ReferenceParams(textDocument: $textDocument, position: $position, context: $context, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$ReferenceParamsCopyWith<$Res> implements $ReferenceParamsCopyWith<$Res> {
  factory _$ReferenceParamsCopyWith(_ReferenceParams value, $Res Function(_ReferenceParams) _then) = __$ReferenceParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument, Position position, ReferenceContext context, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;@override $PositionCopyWith<$Res> get position;@override $ReferenceContextCopyWith<$Res> get context;

}
/// @nodoc
class __$ReferenceParamsCopyWithImpl<$Res>
    implements _$ReferenceParamsCopyWith<$Res> {
  __$ReferenceParamsCopyWithImpl(this._self, this._then);

  final _ReferenceParams _self;
  final $Res Function(_ReferenceParams) _then;

/// Create a copy of ReferenceParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? position = null,Object? context = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_ReferenceParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,context: null == context ? _self.context : context // ignore: cast_nullable_to_non_nullable
as ReferenceContext,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of ReferenceParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of ReferenceParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of ReferenceParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ReferenceContextCopyWith<$Res> get context {
  
  return $ReferenceContextCopyWith<$Res>(_self.context, (value) {
    return _then(_self.copyWith(context: value));
  });
}
}


/// @nodoc
mixin _$ReferenceRegistrationOptions {

 dynamic get documentSelector; bool? get workDoneProgress;
/// Create a copy of ReferenceRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ReferenceRegistrationOptionsCopyWith<ReferenceRegistrationOptions> get copyWith => _$ReferenceRegistrationOptionsCopyWithImpl<ReferenceRegistrationOptions>(this as ReferenceRegistrationOptions, _$identity);

  /// Serializes this ReferenceRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ReferenceRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),workDoneProgress);

@override
String toString() {
  return 'ReferenceRegistrationOptions(documentSelector: $documentSelector, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $ReferenceRegistrationOptionsCopyWith<$Res>  {
  factory $ReferenceRegistrationOptionsCopyWith(ReferenceRegistrationOptions value, $Res Function(ReferenceRegistrationOptions) _then) = _$ReferenceRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 dynamic documentSelector, bool? workDoneProgress
});




}
/// @nodoc
class _$ReferenceRegistrationOptionsCopyWithImpl<$Res>
    implements $ReferenceRegistrationOptionsCopyWith<$Res> {
  _$ReferenceRegistrationOptionsCopyWithImpl(this._self, this._then);

  final ReferenceRegistrationOptions _self;
  final $Res Function(ReferenceRegistrationOptions) _then;

/// Create a copy of ReferenceRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _ReferenceRegistrationOptions implements ReferenceRegistrationOptions {
  const _ReferenceRegistrationOptions({required this.documentSelector, this.workDoneProgress});
  factory _ReferenceRegistrationOptions.fromJson(Map<String, dynamic> json) => _$ReferenceRegistrationOptionsFromJson(json);

@override final  dynamic documentSelector;
@override final  bool? workDoneProgress;

/// Create a copy of ReferenceRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ReferenceRegistrationOptionsCopyWith<_ReferenceRegistrationOptions> get copyWith => __$ReferenceRegistrationOptionsCopyWithImpl<_ReferenceRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ReferenceRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ReferenceRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),workDoneProgress);

@override
String toString() {
  return 'ReferenceRegistrationOptions(documentSelector: $documentSelector, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$ReferenceRegistrationOptionsCopyWith<$Res> implements $ReferenceRegistrationOptionsCopyWith<$Res> {
  factory _$ReferenceRegistrationOptionsCopyWith(_ReferenceRegistrationOptions value, $Res Function(_ReferenceRegistrationOptions) _then) = __$ReferenceRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 dynamic documentSelector, bool? workDoneProgress
});




}
/// @nodoc
class __$ReferenceRegistrationOptionsCopyWithImpl<$Res>
    implements _$ReferenceRegistrationOptionsCopyWith<$Res> {
  __$ReferenceRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _ReferenceRegistrationOptions _self;
  final $Res Function(_ReferenceRegistrationOptions) _then;

/// Create a copy of ReferenceRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_ReferenceRegistrationOptions(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DocumentHighlightParams {

 TextDocumentIdentifier get textDocument; Position get position; ProgressToken? get partialResultToken; ProgressToken? get workDoneToken;
/// Create a copy of DocumentHighlightParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentHighlightParamsCopyWith<DocumentHighlightParams> get copyWith => _$DocumentHighlightParamsCopyWithImpl<DocumentHighlightParams>(this as DocumentHighlightParams, _$identity);

  /// Serializes this DocumentHighlightParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentHighlightParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.position, position) || other.position == position)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,position,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'DocumentHighlightParams(textDocument: $textDocument, position: $position, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $DocumentHighlightParamsCopyWith<$Res>  {
  factory $DocumentHighlightParamsCopyWith(DocumentHighlightParams value, $Res Function(DocumentHighlightParams) _then) = _$DocumentHighlightParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument, Position position, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;$PositionCopyWith<$Res> get position;

}
/// @nodoc
class _$DocumentHighlightParamsCopyWithImpl<$Res>
    implements $DocumentHighlightParamsCopyWith<$Res> {
  _$DocumentHighlightParamsCopyWithImpl(this._self, this._then);

  final DocumentHighlightParams _self;
  final $Res Function(DocumentHighlightParams) _then;

/// Create a copy of DocumentHighlightParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? position = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of DocumentHighlightParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of DocumentHighlightParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DocumentHighlightParams implements DocumentHighlightParams {
  const _DocumentHighlightParams({required this.textDocument, required this.position, this.partialResultToken, this.workDoneToken});
  factory _DocumentHighlightParams.fromJson(Map<String, dynamic> json) => _$DocumentHighlightParamsFromJson(json);

@override final  TextDocumentIdentifier textDocument;
@override final  Position position;
@override final  ProgressToken? partialResultToken;
@override final  ProgressToken? workDoneToken;

/// Create a copy of DocumentHighlightParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentHighlightParamsCopyWith<_DocumentHighlightParams> get copyWith => __$DocumentHighlightParamsCopyWithImpl<_DocumentHighlightParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentHighlightParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentHighlightParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.position, position) || other.position == position)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,position,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'DocumentHighlightParams(textDocument: $textDocument, position: $position, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$DocumentHighlightParamsCopyWith<$Res> implements $DocumentHighlightParamsCopyWith<$Res> {
  factory _$DocumentHighlightParamsCopyWith(_DocumentHighlightParams value, $Res Function(_DocumentHighlightParams) _then) = __$DocumentHighlightParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument, Position position, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;@override $PositionCopyWith<$Res> get position;

}
/// @nodoc
class __$DocumentHighlightParamsCopyWithImpl<$Res>
    implements _$DocumentHighlightParamsCopyWith<$Res> {
  __$DocumentHighlightParamsCopyWithImpl(this._self, this._then);

  final _DocumentHighlightParams _self;
  final $Res Function(_DocumentHighlightParams) _then;

/// Create a copy of DocumentHighlightParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? position = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_DocumentHighlightParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of DocumentHighlightParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of DocumentHighlightParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}
}


/// @nodoc
mixin _$DocumentHighlight {

 Range get range; DocumentHighlightKind? get kind;
/// Create a copy of DocumentHighlight
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentHighlightCopyWith<DocumentHighlight> get copyWith => _$DocumentHighlightCopyWithImpl<DocumentHighlight>(this as DocumentHighlight, _$identity);

  /// Serializes this DocumentHighlight to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentHighlight&&(identical(other.range, range) || other.range == range)&&(identical(other.kind, kind) || other.kind == kind));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,range,kind);

@override
String toString() {
  return 'DocumentHighlight(range: $range, kind: $kind)';
}


}

/// @nodoc
abstract mixin class $DocumentHighlightCopyWith<$Res>  {
  factory $DocumentHighlightCopyWith(DocumentHighlight value, $Res Function(DocumentHighlight) _then) = _$DocumentHighlightCopyWithImpl;
@useResult
$Res call({
 Range range, DocumentHighlightKind? kind
});


$RangeCopyWith<$Res> get range;

}
/// @nodoc
class _$DocumentHighlightCopyWithImpl<$Res>
    implements $DocumentHighlightCopyWith<$Res> {
  _$DocumentHighlightCopyWithImpl(this._self, this._then);

  final DocumentHighlight _self;
  final $Res Function(DocumentHighlight) _then;

/// Create a copy of DocumentHighlight
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? range = null,Object? kind = freezed,}) {
  return _then(_self.copyWith(
range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as DocumentHighlightKind?,
  ));
}
/// Create a copy of DocumentHighlight
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DocumentHighlight implements DocumentHighlight {
  const _DocumentHighlight({required this.range, this.kind});
  factory _DocumentHighlight.fromJson(Map<String, dynamic> json) => _$DocumentHighlightFromJson(json);

@override final  Range range;
@override final  DocumentHighlightKind? kind;

/// Create a copy of DocumentHighlight
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentHighlightCopyWith<_DocumentHighlight> get copyWith => __$DocumentHighlightCopyWithImpl<_DocumentHighlight>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentHighlightToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentHighlight&&(identical(other.range, range) || other.range == range)&&(identical(other.kind, kind) || other.kind == kind));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,range,kind);

@override
String toString() {
  return 'DocumentHighlight(range: $range, kind: $kind)';
}


}

/// @nodoc
abstract mixin class _$DocumentHighlightCopyWith<$Res> implements $DocumentHighlightCopyWith<$Res> {
  factory _$DocumentHighlightCopyWith(_DocumentHighlight value, $Res Function(_DocumentHighlight) _then) = __$DocumentHighlightCopyWithImpl;
@override @useResult
$Res call({
 Range range, DocumentHighlightKind? kind
});


@override $RangeCopyWith<$Res> get range;

}
/// @nodoc
class __$DocumentHighlightCopyWithImpl<$Res>
    implements _$DocumentHighlightCopyWith<$Res> {
  __$DocumentHighlightCopyWithImpl(this._self, this._then);

  final _DocumentHighlight _self;
  final $Res Function(_DocumentHighlight) _then;

/// Create a copy of DocumentHighlight
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? range = null,Object? kind = freezed,}) {
  return _then(_DocumentHighlight(
range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as DocumentHighlightKind?,
  ));
}

/// Create a copy of DocumentHighlight
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}


/// @nodoc
mixin _$DocumentHighlightRegistrationOptions {

 dynamic get documentSelector; bool? get workDoneProgress;
/// Create a copy of DocumentHighlightRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentHighlightRegistrationOptionsCopyWith<DocumentHighlightRegistrationOptions> get copyWith => _$DocumentHighlightRegistrationOptionsCopyWithImpl<DocumentHighlightRegistrationOptions>(this as DocumentHighlightRegistrationOptions, _$identity);

  /// Serializes this DocumentHighlightRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentHighlightRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),workDoneProgress);

@override
String toString() {
  return 'DocumentHighlightRegistrationOptions(documentSelector: $documentSelector, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $DocumentHighlightRegistrationOptionsCopyWith<$Res>  {
  factory $DocumentHighlightRegistrationOptionsCopyWith(DocumentHighlightRegistrationOptions value, $Res Function(DocumentHighlightRegistrationOptions) _then) = _$DocumentHighlightRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 dynamic documentSelector, bool? workDoneProgress
});




}
/// @nodoc
class _$DocumentHighlightRegistrationOptionsCopyWithImpl<$Res>
    implements $DocumentHighlightRegistrationOptionsCopyWith<$Res> {
  _$DocumentHighlightRegistrationOptionsCopyWithImpl(this._self, this._then);

  final DocumentHighlightRegistrationOptions _self;
  final $Res Function(DocumentHighlightRegistrationOptions) _then;

/// Create a copy of DocumentHighlightRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DocumentHighlightRegistrationOptions implements DocumentHighlightRegistrationOptions {
  const _DocumentHighlightRegistrationOptions({required this.documentSelector, this.workDoneProgress});
  factory _DocumentHighlightRegistrationOptions.fromJson(Map<String, dynamic> json) => _$DocumentHighlightRegistrationOptionsFromJson(json);

@override final  dynamic documentSelector;
@override final  bool? workDoneProgress;

/// Create a copy of DocumentHighlightRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentHighlightRegistrationOptionsCopyWith<_DocumentHighlightRegistrationOptions> get copyWith => __$DocumentHighlightRegistrationOptionsCopyWithImpl<_DocumentHighlightRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentHighlightRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentHighlightRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),workDoneProgress);

@override
String toString() {
  return 'DocumentHighlightRegistrationOptions(documentSelector: $documentSelector, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$DocumentHighlightRegistrationOptionsCopyWith<$Res> implements $DocumentHighlightRegistrationOptionsCopyWith<$Res> {
  factory _$DocumentHighlightRegistrationOptionsCopyWith(_DocumentHighlightRegistrationOptions value, $Res Function(_DocumentHighlightRegistrationOptions) _then) = __$DocumentHighlightRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 dynamic documentSelector, bool? workDoneProgress
});




}
/// @nodoc
class __$DocumentHighlightRegistrationOptionsCopyWithImpl<$Res>
    implements _$DocumentHighlightRegistrationOptionsCopyWith<$Res> {
  __$DocumentHighlightRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _DocumentHighlightRegistrationOptions _self;
  final $Res Function(_DocumentHighlightRegistrationOptions) _then;

/// Create a copy of DocumentHighlightRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_DocumentHighlightRegistrationOptions(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DocumentSymbolParams {

 TextDocumentIdentifier get textDocument; ProgressToken? get partialResultToken; ProgressToken? get workDoneToken;
/// Create a copy of DocumentSymbolParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentSymbolParamsCopyWith<DocumentSymbolParams> get copyWith => _$DocumentSymbolParamsCopyWithImpl<DocumentSymbolParams>(this as DocumentSymbolParams, _$identity);

  /// Serializes this DocumentSymbolParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentSymbolParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'DocumentSymbolParams(textDocument: $textDocument, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $DocumentSymbolParamsCopyWith<$Res>  {
  factory $DocumentSymbolParamsCopyWith(DocumentSymbolParams value, $Res Function(DocumentSymbolParams) _then) = _$DocumentSymbolParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$DocumentSymbolParamsCopyWithImpl<$Res>
    implements $DocumentSymbolParamsCopyWith<$Res> {
  _$DocumentSymbolParamsCopyWithImpl(this._self, this._then);

  final DocumentSymbolParams _self;
  final $Res Function(DocumentSymbolParams) _then;

/// Create a copy of DocumentSymbolParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of DocumentSymbolParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DocumentSymbolParams implements DocumentSymbolParams {
  const _DocumentSymbolParams({required this.textDocument, this.partialResultToken, this.workDoneToken});
  factory _DocumentSymbolParams.fromJson(Map<String, dynamic> json) => _$DocumentSymbolParamsFromJson(json);

@override final  TextDocumentIdentifier textDocument;
@override final  ProgressToken? partialResultToken;
@override final  ProgressToken? workDoneToken;

/// Create a copy of DocumentSymbolParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentSymbolParamsCopyWith<_DocumentSymbolParams> get copyWith => __$DocumentSymbolParamsCopyWithImpl<_DocumentSymbolParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentSymbolParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentSymbolParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'DocumentSymbolParams(textDocument: $textDocument, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$DocumentSymbolParamsCopyWith<$Res> implements $DocumentSymbolParamsCopyWith<$Res> {
  factory _$DocumentSymbolParamsCopyWith(_DocumentSymbolParams value, $Res Function(_DocumentSymbolParams) _then) = __$DocumentSymbolParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$DocumentSymbolParamsCopyWithImpl<$Res>
    implements _$DocumentSymbolParamsCopyWith<$Res> {
  __$DocumentSymbolParamsCopyWithImpl(this._self, this._then);

  final _DocumentSymbolParams _self;
  final $Res Function(_DocumentSymbolParams) _then;

/// Create a copy of DocumentSymbolParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_DocumentSymbolParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of DocumentSymbolParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$SymbolInformation {

 String get name; SymbolKind get kind; Location get location; bool? get deprecated; String? get containerName; List<SymbolTag>? get tags;
/// Create a copy of SymbolInformation
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SymbolInformationCopyWith<SymbolInformation> get copyWith => _$SymbolInformationCopyWithImpl<SymbolInformation>(this as SymbolInformation, _$identity);

  /// Serializes this SymbolInformation to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SymbolInformation&&(identical(other.name, name) || other.name == name)&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.location, location) || other.location == location)&&(identical(other.deprecated, deprecated) || other.deprecated == deprecated)&&(identical(other.containerName, containerName) || other.containerName == containerName)&&const DeepCollectionEquality().equals(other.tags, tags));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,name,kind,location,deprecated,containerName,const DeepCollectionEquality().hash(tags));

@override
String toString() {
  return 'SymbolInformation(name: $name, kind: $kind, location: $location, deprecated: $deprecated, containerName: $containerName, tags: $tags)';
}


}

/// @nodoc
abstract mixin class $SymbolInformationCopyWith<$Res>  {
  factory $SymbolInformationCopyWith(SymbolInformation value, $Res Function(SymbolInformation) _then) = _$SymbolInformationCopyWithImpl;
@useResult
$Res call({
 String name, SymbolKind kind, Location location, bool? deprecated, String? containerName, List<SymbolTag>? tags
});


$LocationCopyWith<$Res> get location;

}
/// @nodoc
class _$SymbolInformationCopyWithImpl<$Res>
    implements $SymbolInformationCopyWith<$Res> {
  _$SymbolInformationCopyWithImpl(this._self, this._then);

  final SymbolInformation _self;
  final $Res Function(SymbolInformation) _then;

/// Create a copy of SymbolInformation
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? name = null,Object? kind = null,Object? location = null,Object? deprecated = freezed,Object? containerName = freezed,Object? tags = freezed,}) {
  return _then(_self.copyWith(
name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as SymbolKind,location: null == location ? _self.location : location // ignore: cast_nullable_to_non_nullable
as Location,deprecated: freezed == deprecated ? _self.deprecated : deprecated // ignore: cast_nullable_to_non_nullable
as bool?,containerName: freezed == containerName ? _self.containerName : containerName // ignore: cast_nullable_to_non_nullable
as String?,tags: freezed == tags ? _self.tags : tags // ignore: cast_nullable_to_non_nullable
as List<SymbolTag>?,
  ));
}
/// Create a copy of SymbolInformation
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$LocationCopyWith<$Res> get location {
  
  return $LocationCopyWith<$Res>(_self.location, (value) {
    return _then(_self.copyWith(location: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _SymbolInformation implements SymbolInformation {
  const _SymbolInformation({required this.name, required this.kind, required this.location, this.deprecated, this.containerName, final  List<SymbolTag>? tags}): _tags = tags;
  factory _SymbolInformation.fromJson(Map<String, dynamic> json) => _$SymbolInformationFromJson(json);

@override final  String name;
@override final  SymbolKind kind;
@override final  Location location;
@override final  bool? deprecated;
@override final  String? containerName;
 final  List<SymbolTag>? _tags;
@override List<SymbolTag>? get tags {
  final value = _tags;
  if (value == null) return null;
  if (_tags is EqualUnmodifiableListView) return _tags;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}


/// Create a copy of SymbolInformation
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SymbolInformationCopyWith<_SymbolInformation> get copyWith => __$SymbolInformationCopyWithImpl<_SymbolInformation>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SymbolInformationToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SymbolInformation&&(identical(other.name, name) || other.name == name)&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.location, location) || other.location == location)&&(identical(other.deprecated, deprecated) || other.deprecated == deprecated)&&(identical(other.containerName, containerName) || other.containerName == containerName)&&const DeepCollectionEquality().equals(other._tags, _tags));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,name,kind,location,deprecated,containerName,const DeepCollectionEquality().hash(_tags));

@override
String toString() {
  return 'SymbolInformation(name: $name, kind: $kind, location: $location, deprecated: $deprecated, containerName: $containerName, tags: $tags)';
}


}

/// @nodoc
abstract mixin class _$SymbolInformationCopyWith<$Res> implements $SymbolInformationCopyWith<$Res> {
  factory _$SymbolInformationCopyWith(_SymbolInformation value, $Res Function(_SymbolInformation) _then) = __$SymbolInformationCopyWithImpl;
@override @useResult
$Res call({
 String name, SymbolKind kind, Location location, bool? deprecated, String? containerName, List<SymbolTag>? tags
});


@override $LocationCopyWith<$Res> get location;

}
/// @nodoc
class __$SymbolInformationCopyWithImpl<$Res>
    implements _$SymbolInformationCopyWith<$Res> {
  __$SymbolInformationCopyWithImpl(this._self, this._then);

  final _SymbolInformation _self;
  final $Res Function(_SymbolInformation) _then;

/// Create a copy of SymbolInformation
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? name = null,Object? kind = null,Object? location = null,Object? deprecated = freezed,Object? containerName = freezed,Object? tags = freezed,}) {
  return _then(_SymbolInformation(
name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as SymbolKind,location: null == location ? _self.location : location // ignore: cast_nullable_to_non_nullable
as Location,deprecated: freezed == deprecated ? _self.deprecated : deprecated // ignore: cast_nullable_to_non_nullable
as bool?,containerName: freezed == containerName ? _self.containerName : containerName // ignore: cast_nullable_to_non_nullable
as String?,tags: freezed == tags ? _self._tags : tags // ignore: cast_nullable_to_non_nullable
as List<SymbolTag>?,
  ));
}

/// Create a copy of SymbolInformation
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$LocationCopyWith<$Res> get location {
  
  return $LocationCopyWith<$Res>(_self.location, (value) {
    return _then(_self.copyWith(location: value));
  });
}
}


/// @nodoc
mixin _$DocumentSymbol {

 String get name; SymbolKind get kind; Range get range; Range get selectionRange; List<DocumentSymbol>? get children; bool? get deprecated; List<SymbolTag>? get tags; String? get detail;
/// Create a copy of DocumentSymbol
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentSymbolCopyWith<DocumentSymbol> get copyWith => _$DocumentSymbolCopyWithImpl<DocumentSymbol>(this as DocumentSymbol, _$identity);

  /// Serializes this DocumentSymbol to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentSymbol&&(identical(other.name, name) || other.name == name)&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.range, range) || other.range == range)&&(identical(other.selectionRange, selectionRange) || other.selectionRange == selectionRange)&&const DeepCollectionEquality().equals(other.children, children)&&(identical(other.deprecated, deprecated) || other.deprecated == deprecated)&&const DeepCollectionEquality().equals(other.tags, tags)&&(identical(other.detail, detail) || other.detail == detail));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,name,kind,range,selectionRange,const DeepCollectionEquality().hash(children),deprecated,const DeepCollectionEquality().hash(tags),detail);

@override
String toString() {
  return 'DocumentSymbol(name: $name, kind: $kind, range: $range, selectionRange: $selectionRange, children: $children, deprecated: $deprecated, tags: $tags, detail: $detail)';
}


}

/// @nodoc
abstract mixin class $DocumentSymbolCopyWith<$Res>  {
  factory $DocumentSymbolCopyWith(DocumentSymbol value, $Res Function(DocumentSymbol) _then) = _$DocumentSymbolCopyWithImpl;
@useResult
$Res call({
 String name, SymbolKind kind, Range range, Range selectionRange, List<DocumentSymbol>? children, bool? deprecated, List<SymbolTag>? tags, String? detail
});


$RangeCopyWith<$Res> get range;$RangeCopyWith<$Res> get selectionRange;

}
/// @nodoc
class _$DocumentSymbolCopyWithImpl<$Res>
    implements $DocumentSymbolCopyWith<$Res> {
  _$DocumentSymbolCopyWithImpl(this._self, this._then);

  final DocumentSymbol _self;
  final $Res Function(DocumentSymbol) _then;

/// Create a copy of DocumentSymbol
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? name = null,Object? kind = null,Object? range = null,Object? selectionRange = null,Object? children = freezed,Object? deprecated = freezed,Object? tags = freezed,Object? detail = freezed,}) {
  return _then(_self.copyWith(
name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as SymbolKind,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,selectionRange: null == selectionRange ? _self.selectionRange : selectionRange // ignore: cast_nullable_to_non_nullable
as Range,children: freezed == children ? _self.children : children // ignore: cast_nullable_to_non_nullable
as List<DocumentSymbol>?,deprecated: freezed == deprecated ? _self.deprecated : deprecated // ignore: cast_nullable_to_non_nullable
as bool?,tags: freezed == tags ? _self.tags : tags // ignore: cast_nullable_to_non_nullable
as List<SymbolTag>?,detail: freezed == detail ? _self.detail : detail // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}
/// Create a copy of DocumentSymbol
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}/// Create a copy of DocumentSymbol
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get selectionRange {
  
  return $RangeCopyWith<$Res>(_self.selectionRange, (value) {
    return _then(_self.copyWith(selectionRange: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DocumentSymbol implements DocumentSymbol {
  const _DocumentSymbol({required this.name, required this.kind, required this.range, required this.selectionRange, final  List<DocumentSymbol>? children, this.deprecated, final  List<SymbolTag>? tags, this.detail}): _children = children,_tags = tags;
  factory _DocumentSymbol.fromJson(Map<String, dynamic> json) => _$DocumentSymbolFromJson(json);

@override final  String name;
@override final  SymbolKind kind;
@override final  Range range;
@override final  Range selectionRange;
 final  List<DocumentSymbol>? _children;
@override List<DocumentSymbol>? get children {
  final value = _children;
  if (value == null) return null;
  if (_children is EqualUnmodifiableListView) return _children;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

@override final  bool? deprecated;
 final  List<SymbolTag>? _tags;
@override List<SymbolTag>? get tags {
  final value = _tags;
  if (value == null) return null;
  if (_tags is EqualUnmodifiableListView) return _tags;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

@override final  String? detail;

/// Create a copy of DocumentSymbol
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentSymbolCopyWith<_DocumentSymbol> get copyWith => __$DocumentSymbolCopyWithImpl<_DocumentSymbol>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentSymbolToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentSymbol&&(identical(other.name, name) || other.name == name)&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.range, range) || other.range == range)&&(identical(other.selectionRange, selectionRange) || other.selectionRange == selectionRange)&&const DeepCollectionEquality().equals(other._children, _children)&&(identical(other.deprecated, deprecated) || other.deprecated == deprecated)&&const DeepCollectionEquality().equals(other._tags, _tags)&&(identical(other.detail, detail) || other.detail == detail));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,name,kind,range,selectionRange,const DeepCollectionEquality().hash(_children),deprecated,const DeepCollectionEquality().hash(_tags),detail);

@override
String toString() {
  return 'DocumentSymbol(name: $name, kind: $kind, range: $range, selectionRange: $selectionRange, children: $children, deprecated: $deprecated, tags: $tags, detail: $detail)';
}


}

/// @nodoc
abstract mixin class _$DocumentSymbolCopyWith<$Res> implements $DocumentSymbolCopyWith<$Res> {
  factory _$DocumentSymbolCopyWith(_DocumentSymbol value, $Res Function(_DocumentSymbol) _then) = __$DocumentSymbolCopyWithImpl;
@override @useResult
$Res call({
 String name, SymbolKind kind, Range range, Range selectionRange, List<DocumentSymbol>? children, bool? deprecated, List<SymbolTag>? tags, String? detail
});


@override $RangeCopyWith<$Res> get range;@override $RangeCopyWith<$Res> get selectionRange;

}
/// @nodoc
class __$DocumentSymbolCopyWithImpl<$Res>
    implements _$DocumentSymbolCopyWith<$Res> {
  __$DocumentSymbolCopyWithImpl(this._self, this._then);

  final _DocumentSymbol _self;
  final $Res Function(_DocumentSymbol) _then;

/// Create a copy of DocumentSymbol
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? name = null,Object? kind = null,Object? range = null,Object? selectionRange = null,Object? children = freezed,Object? deprecated = freezed,Object? tags = freezed,Object? detail = freezed,}) {
  return _then(_DocumentSymbol(
name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as SymbolKind,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,selectionRange: null == selectionRange ? _self.selectionRange : selectionRange // ignore: cast_nullable_to_non_nullable
as Range,children: freezed == children ? _self._children : children // ignore: cast_nullable_to_non_nullable
as List<DocumentSymbol>?,deprecated: freezed == deprecated ? _self.deprecated : deprecated // ignore: cast_nullable_to_non_nullable
as bool?,tags: freezed == tags ? _self._tags : tags // ignore: cast_nullable_to_non_nullable
as List<SymbolTag>?,detail: freezed == detail ? _self.detail : detail // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

/// Create a copy of DocumentSymbol
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}/// Create a copy of DocumentSymbol
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get selectionRange {
  
  return $RangeCopyWith<$Res>(_self.selectionRange, (value) {
    return _then(_self.copyWith(selectionRange: value));
  });
}
}


/// @nodoc
mixin _$DocumentSymbolRegistrationOptions {

 dynamic get documentSelector; String? get label; bool? get workDoneProgress;
/// Create a copy of DocumentSymbolRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentSymbolRegistrationOptionsCopyWith<DocumentSymbolRegistrationOptions> get copyWith => _$DocumentSymbolRegistrationOptionsCopyWithImpl<DocumentSymbolRegistrationOptions>(this as DocumentSymbolRegistrationOptions, _$identity);

  /// Serializes this DocumentSymbolRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentSymbolRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.label, label) || other.label == label)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),label,workDoneProgress);

@override
String toString() {
  return 'DocumentSymbolRegistrationOptions(documentSelector: $documentSelector, label: $label, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $DocumentSymbolRegistrationOptionsCopyWith<$Res>  {
  factory $DocumentSymbolRegistrationOptionsCopyWith(DocumentSymbolRegistrationOptions value, $Res Function(DocumentSymbolRegistrationOptions) _then) = _$DocumentSymbolRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 dynamic documentSelector, String? label, bool? workDoneProgress
});




}
/// @nodoc
class _$DocumentSymbolRegistrationOptionsCopyWithImpl<$Res>
    implements $DocumentSymbolRegistrationOptionsCopyWith<$Res> {
  _$DocumentSymbolRegistrationOptionsCopyWithImpl(this._self, this._then);

  final DocumentSymbolRegistrationOptions _self;
  final $Res Function(DocumentSymbolRegistrationOptions) _then;

/// Create a copy of DocumentSymbolRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = freezed,Object? label = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,label: freezed == label ? _self.label : label // ignore: cast_nullable_to_non_nullable
as String?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DocumentSymbolRegistrationOptions implements DocumentSymbolRegistrationOptions {
  const _DocumentSymbolRegistrationOptions({required this.documentSelector, this.label, this.workDoneProgress});
  factory _DocumentSymbolRegistrationOptions.fromJson(Map<String, dynamic> json) => _$DocumentSymbolRegistrationOptionsFromJson(json);

@override final  dynamic documentSelector;
@override final  String? label;
@override final  bool? workDoneProgress;

/// Create a copy of DocumentSymbolRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentSymbolRegistrationOptionsCopyWith<_DocumentSymbolRegistrationOptions> get copyWith => __$DocumentSymbolRegistrationOptionsCopyWithImpl<_DocumentSymbolRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentSymbolRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentSymbolRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.label, label) || other.label == label)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),label,workDoneProgress);

@override
String toString() {
  return 'DocumentSymbolRegistrationOptions(documentSelector: $documentSelector, label: $label, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$DocumentSymbolRegistrationOptionsCopyWith<$Res> implements $DocumentSymbolRegistrationOptionsCopyWith<$Res> {
  factory _$DocumentSymbolRegistrationOptionsCopyWith(_DocumentSymbolRegistrationOptions value, $Res Function(_DocumentSymbolRegistrationOptions) _then) = __$DocumentSymbolRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 dynamic documentSelector, String? label, bool? workDoneProgress
});




}
/// @nodoc
class __$DocumentSymbolRegistrationOptionsCopyWithImpl<$Res>
    implements _$DocumentSymbolRegistrationOptionsCopyWith<$Res> {
  __$DocumentSymbolRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _DocumentSymbolRegistrationOptions _self;
  final $Res Function(_DocumentSymbolRegistrationOptions) _then;

/// Create a copy of DocumentSymbolRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = freezed,Object? label = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_DocumentSymbolRegistrationOptions(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,label: freezed == label ? _self.label : label // ignore: cast_nullable_to_non_nullable
as String?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$CodeActionParams {

 TextDocumentIdentifier get textDocument; Range get range; CodeActionContext get context; ProgressToken? get partialResultToken; ProgressToken? get workDoneToken;
/// Create a copy of CodeActionParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CodeActionParamsCopyWith<CodeActionParams> get copyWith => _$CodeActionParamsCopyWithImpl<CodeActionParams>(this as CodeActionParams, _$identity);

  /// Serializes this CodeActionParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CodeActionParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.range, range) || other.range == range)&&(identical(other.context, context) || other.context == context)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,range,context,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'CodeActionParams(textDocument: $textDocument, range: $range, context: $context, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $CodeActionParamsCopyWith<$Res>  {
  factory $CodeActionParamsCopyWith(CodeActionParams value, $Res Function(CodeActionParams) _then) = _$CodeActionParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument, Range range, CodeActionContext context, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;$RangeCopyWith<$Res> get range;$CodeActionContextCopyWith<$Res> get context;

}
/// @nodoc
class _$CodeActionParamsCopyWithImpl<$Res>
    implements $CodeActionParamsCopyWith<$Res> {
  _$CodeActionParamsCopyWithImpl(this._self, this._then);

  final CodeActionParams _self;
  final $Res Function(CodeActionParams) _then;

/// Create a copy of CodeActionParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? range = null,Object? context = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,context: null == context ? _self.context : context // ignore: cast_nullable_to_non_nullable
as CodeActionContext,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of CodeActionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of CodeActionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}/// Create a copy of CodeActionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CodeActionContextCopyWith<$Res> get context {
  
  return $CodeActionContextCopyWith<$Res>(_self.context, (value) {
    return _then(_self.copyWith(context: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _CodeActionParams implements CodeActionParams {
  const _CodeActionParams({required this.textDocument, required this.range, required this.context, this.partialResultToken, this.workDoneToken});
  factory _CodeActionParams.fromJson(Map<String, dynamic> json) => _$CodeActionParamsFromJson(json);

@override final  TextDocumentIdentifier textDocument;
@override final  Range range;
@override final  CodeActionContext context;
@override final  ProgressToken? partialResultToken;
@override final  ProgressToken? workDoneToken;

/// Create a copy of CodeActionParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CodeActionParamsCopyWith<_CodeActionParams> get copyWith => __$CodeActionParamsCopyWithImpl<_CodeActionParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CodeActionParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CodeActionParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.range, range) || other.range == range)&&(identical(other.context, context) || other.context == context)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,range,context,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'CodeActionParams(textDocument: $textDocument, range: $range, context: $context, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$CodeActionParamsCopyWith<$Res> implements $CodeActionParamsCopyWith<$Res> {
  factory _$CodeActionParamsCopyWith(_CodeActionParams value, $Res Function(_CodeActionParams) _then) = __$CodeActionParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument, Range range, CodeActionContext context, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;@override $RangeCopyWith<$Res> get range;@override $CodeActionContextCopyWith<$Res> get context;

}
/// @nodoc
class __$CodeActionParamsCopyWithImpl<$Res>
    implements _$CodeActionParamsCopyWith<$Res> {
  __$CodeActionParamsCopyWithImpl(this._self, this._then);

  final _CodeActionParams _self;
  final $Res Function(_CodeActionParams) _then;

/// Create a copy of CodeActionParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? range = null,Object? context = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_CodeActionParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,context: null == context ? _self.context : context // ignore: cast_nullable_to_non_nullable
as CodeActionContext,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of CodeActionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of CodeActionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}/// Create a copy of CodeActionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CodeActionContextCopyWith<$Res> get context {
  
  return $CodeActionContextCopyWith<$Res>(_self.context, (value) {
    return _then(_self.copyWith(context: value));
  });
}
}


/// @nodoc
mixin _$Command {

 String get title; String get command; List<LSPAny>? get arguments;
/// Create a copy of Command
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CommandCopyWith<Command> get copyWith => _$CommandCopyWithImpl<Command>(this as Command, _$identity);

  /// Serializes this Command to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Command&&(identical(other.title, title) || other.title == title)&&(identical(other.command, command) || other.command == command)&&const DeepCollectionEquality().equals(other.arguments, arguments));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,title,command,const DeepCollectionEquality().hash(arguments));

@override
String toString() {
  return 'Command(title: $title, command: $command, arguments: $arguments)';
}


}

/// @nodoc
abstract mixin class $CommandCopyWith<$Res>  {
  factory $CommandCopyWith(Command value, $Res Function(Command) _then) = _$CommandCopyWithImpl;
@useResult
$Res call({
 String title, String command, List<LSPAny>? arguments
});




}
/// @nodoc
class _$CommandCopyWithImpl<$Res>
    implements $CommandCopyWith<$Res> {
  _$CommandCopyWithImpl(this._self, this._then);

  final Command _self;
  final $Res Function(Command) _then;

/// Create a copy of Command
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? title = null,Object? command = null,Object? arguments = freezed,}) {
  return _then(_self.copyWith(
title: null == title ? _self.title : title // ignore: cast_nullable_to_non_nullable
as String,command: null == command ? _self.command : command // ignore: cast_nullable_to_non_nullable
as String,arguments: freezed == arguments ? _self.arguments : arguments // ignore: cast_nullable_to_non_nullable
as List<LSPAny>?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _Command implements Command {
  const _Command({required this.title, required this.command, final  List<LSPAny>? arguments}): _arguments = arguments;
  factory _Command.fromJson(Map<String, dynamic> json) => _$CommandFromJson(json);

@override final  String title;
@override final  String command;
 final  List<LSPAny>? _arguments;
@override List<LSPAny>? get arguments {
  final value = _arguments;
  if (value == null) return null;
  if (_arguments is EqualUnmodifiableListView) return _arguments;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}


/// Create a copy of Command
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CommandCopyWith<_Command> get copyWith => __$CommandCopyWithImpl<_Command>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CommandToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _Command&&(identical(other.title, title) || other.title == title)&&(identical(other.command, command) || other.command == command)&&const DeepCollectionEquality().equals(other._arguments, _arguments));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,title,command,const DeepCollectionEquality().hash(_arguments));

@override
String toString() {
  return 'Command(title: $title, command: $command, arguments: $arguments)';
}


}

/// @nodoc
abstract mixin class _$CommandCopyWith<$Res> implements $CommandCopyWith<$Res> {
  factory _$CommandCopyWith(_Command value, $Res Function(_Command) _then) = __$CommandCopyWithImpl;
@override @useResult
$Res call({
 String title, String command, List<LSPAny>? arguments
});




}
/// @nodoc
class __$CommandCopyWithImpl<$Res>
    implements _$CommandCopyWith<$Res> {
  __$CommandCopyWithImpl(this._self, this._then);

  final _Command _self;
  final $Res Function(_Command) _then;

/// Create a copy of Command
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? title = null,Object? command = null,Object? arguments = freezed,}) {
  return _then(_Command(
title: null == title ? _self.title : title // ignore: cast_nullable_to_non_nullable
as String,command: null == command ? _self.command : command // ignore: cast_nullable_to_non_nullable
as String,arguments: freezed == arguments ? _self._arguments : arguments // ignore: cast_nullable_to_non_nullable
as List<LSPAny>?,
  ));
}


}


/// @nodoc
mixin _$CodeAction {

 String get title; LSPAny? get data; Command? get command; WorkspaceEdit? get edit; ({String reason})? get disabled; bool? get isPreferred; List<Diagnostic>? get diagnostics; CodeActionKind? get kind;
/// Create a copy of CodeAction
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CodeActionCopyWith<CodeAction> get copyWith => _$CodeActionCopyWithImpl<CodeAction>(this as CodeAction, _$identity);

  /// Serializes this CodeAction to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CodeAction&&(identical(other.title, title) || other.title == title)&&const DeepCollectionEquality().equals(other.data, data)&&(identical(other.command, command) || other.command == command)&&(identical(other.edit, edit) || other.edit == edit)&&(identical(other.disabled, disabled) || other.disabled == disabled)&&(identical(other.isPreferred, isPreferred) || other.isPreferred == isPreferred)&&const DeepCollectionEquality().equals(other.diagnostics, diagnostics)&&(identical(other.kind, kind) || other.kind == kind));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,title,const DeepCollectionEquality().hash(data),command,edit,disabled,isPreferred,const DeepCollectionEquality().hash(diagnostics),kind);

@override
String toString() {
  return 'CodeAction(title: $title, data: $data, command: $command, edit: $edit, disabled: $disabled, isPreferred: $isPreferred, diagnostics: $diagnostics, kind: $kind)';
}


}

/// @nodoc
abstract mixin class $CodeActionCopyWith<$Res>  {
  factory $CodeActionCopyWith(CodeAction value, $Res Function(CodeAction) _then) = _$CodeActionCopyWithImpl;
@useResult
$Res call({
 String title, LSPAny? data, Command? command, WorkspaceEdit? edit, ({String reason})? disabled, bool? isPreferred, List<Diagnostic>? diagnostics, CodeActionKind? kind
});


$CommandCopyWith<$Res>? get command;$WorkspaceEditCopyWith<$Res>? get edit;

}
/// @nodoc
class _$CodeActionCopyWithImpl<$Res>
    implements $CodeActionCopyWith<$Res> {
  _$CodeActionCopyWithImpl(this._self, this._then);

  final CodeAction _self;
  final $Res Function(CodeAction) _then;

/// Create a copy of CodeAction
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? title = null,Object? data = freezed,Object? command = freezed,Object? edit = freezed,Object? disabled = freezed,Object? isPreferred = freezed,Object? diagnostics = freezed,Object? kind = freezed,}) {
  return _then(_self.copyWith(
title: null == title ? _self.title : title // ignore: cast_nullable_to_non_nullable
as String,data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LSPAny?,command: freezed == command ? _self.command : command // ignore: cast_nullable_to_non_nullable
as Command?,edit: freezed == edit ? _self.edit : edit // ignore: cast_nullable_to_non_nullable
as WorkspaceEdit?,disabled: freezed == disabled ? _self.disabled : disabled // ignore: cast_nullable_to_non_nullable
as ({String reason})?,isPreferred: freezed == isPreferred ? _self.isPreferred : isPreferred // ignore: cast_nullable_to_non_nullable
as bool?,diagnostics: freezed == diagnostics ? _self.diagnostics : diagnostics // ignore: cast_nullable_to_non_nullable
as List<Diagnostic>?,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as CodeActionKind?,
  ));
}
/// Create a copy of CodeAction
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CommandCopyWith<$Res>? get command {
    if (_self.command == null) {
    return null;
  }

  return $CommandCopyWith<$Res>(_self.command!, (value) {
    return _then(_self.copyWith(command: value));
  });
}/// Create a copy of CodeAction
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$WorkspaceEditCopyWith<$Res>? get edit {
    if (_self.edit == null) {
    return null;
  }

  return $WorkspaceEditCopyWith<$Res>(_self.edit!, (value) {
    return _then(_self.copyWith(edit: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _CodeAction implements CodeAction {
  const _CodeAction({required this.title, this.data, this.command, this.edit, this.disabled, this.isPreferred, final  List<Diagnostic>? diagnostics, this.kind}): _diagnostics = diagnostics;
  factory _CodeAction.fromJson(Map<String, dynamic> json) => _$CodeActionFromJson(json);

@override final  String title;
@override final  LSPAny? data;
@override final  Command? command;
@override final  WorkspaceEdit? edit;
@override final  ({String reason})? disabled;
@override final  bool? isPreferred;
 final  List<Diagnostic>? _diagnostics;
@override List<Diagnostic>? get diagnostics {
  final value = _diagnostics;
  if (value == null) return null;
  if (_diagnostics is EqualUnmodifiableListView) return _diagnostics;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

@override final  CodeActionKind? kind;

/// Create a copy of CodeAction
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CodeActionCopyWith<_CodeAction> get copyWith => __$CodeActionCopyWithImpl<_CodeAction>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CodeActionToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CodeAction&&(identical(other.title, title) || other.title == title)&&const DeepCollectionEquality().equals(other.data, data)&&(identical(other.command, command) || other.command == command)&&(identical(other.edit, edit) || other.edit == edit)&&(identical(other.disabled, disabled) || other.disabled == disabled)&&(identical(other.isPreferred, isPreferred) || other.isPreferred == isPreferred)&&const DeepCollectionEquality().equals(other._diagnostics, _diagnostics)&&(identical(other.kind, kind) || other.kind == kind));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,title,const DeepCollectionEquality().hash(data),command,edit,disabled,isPreferred,const DeepCollectionEquality().hash(_diagnostics),kind);

@override
String toString() {
  return 'CodeAction(title: $title, data: $data, command: $command, edit: $edit, disabled: $disabled, isPreferred: $isPreferred, diagnostics: $diagnostics, kind: $kind)';
}


}

/// @nodoc
abstract mixin class _$CodeActionCopyWith<$Res> implements $CodeActionCopyWith<$Res> {
  factory _$CodeActionCopyWith(_CodeAction value, $Res Function(_CodeAction) _then) = __$CodeActionCopyWithImpl;
@override @useResult
$Res call({
 String title, LSPAny? data, Command? command, WorkspaceEdit? edit, ({String reason})? disabled, bool? isPreferred, List<Diagnostic>? diagnostics, CodeActionKind? kind
});


@override $CommandCopyWith<$Res>? get command;@override $WorkspaceEditCopyWith<$Res>? get edit;

}
/// @nodoc
class __$CodeActionCopyWithImpl<$Res>
    implements _$CodeActionCopyWith<$Res> {
  __$CodeActionCopyWithImpl(this._self, this._then);

  final _CodeAction _self;
  final $Res Function(_CodeAction) _then;

/// Create a copy of CodeAction
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? title = null,Object? data = freezed,Object? command = freezed,Object? edit = freezed,Object? disabled = freezed,Object? isPreferred = freezed,Object? diagnostics = freezed,Object? kind = freezed,}) {
  return _then(_CodeAction(
title: null == title ? _self.title : title // ignore: cast_nullable_to_non_nullable
as String,data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LSPAny?,command: freezed == command ? _self.command : command // ignore: cast_nullable_to_non_nullable
as Command?,edit: freezed == edit ? _self.edit : edit // ignore: cast_nullable_to_non_nullable
as WorkspaceEdit?,disabled: freezed == disabled ? _self.disabled : disabled // ignore: cast_nullable_to_non_nullable
as ({String reason})?,isPreferred: freezed == isPreferred ? _self.isPreferred : isPreferred // ignore: cast_nullable_to_non_nullable
as bool?,diagnostics: freezed == diagnostics ? _self._diagnostics : diagnostics // ignore: cast_nullable_to_non_nullable
as List<Diagnostic>?,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as CodeActionKind?,
  ));
}

/// Create a copy of CodeAction
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CommandCopyWith<$Res>? get command {
    if (_self.command == null) {
    return null;
  }

  return $CommandCopyWith<$Res>(_self.command!, (value) {
    return _then(_self.copyWith(command: value));
  });
}/// Create a copy of CodeAction
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$WorkspaceEditCopyWith<$Res>? get edit {
    if (_self.edit == null) {
    return null;
  }

  return $WorkspaceEditCopyWith<$Res>(_self.edit!, (value) {
    return _then(_self.copyWith(edit: value));
  });
}
}


/// @nodoc
mixin _$CodeActionRegistrationOptions {

 dynamic get documentSelector; bool? get resolveProvider; List<CodeActionKind>? get codeActionKinds; bool? get workDoneProgress;
/// Create a copy of CodeActionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CodeActionRegistrationOptionsCopyWith<CodeActionRegistrationOptions> get copyWith => _$CodeActionRegistrationOptionsCopyWithImpl<CodeActionRegistrationOptions>(this as CodeActionRegistrationOptions, _$identity);

  /// Serializes this CodeActionRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CodeActionRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider)&&const DeepCollectionEquality().equals(other.codeActionKinds, codeActionKinds)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),resolveProvider,const DeepCollectionEquality().hash(codeActionKinds),workDoneProgress);

@override
String toString() {
  return 'CodeActionRegistrationOptions(documentSelector: $documentSelector, resolveProvider: $resolveProvider, codeActionKinds: $codeActionKinds, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $CodeActionRegistrationOptionsCopyWith<$Res>  {
  factory $CodeActionRegistrationOptionsCopyWith(CodeActionRegistrationOptions value, $Res Function(CodeActionRegistrationOptions) _then) = _$CodeActionRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 dynamic documentSelector, bool? resolveProvider, List<CodeActionKind>? codeActionKinds, bool? workDoneProgress
});




}
/// @nodoc
class _$CodeActionRegistrationOptionsCopyWithImpl<$Res>
    implements $CodeActionRegistrationOptionsCopyWith<$Res> {
  _$CodeActionRegistrationOptionsCopyWithImpl(this._self, this._then);

  final CodeActionRegistrationOptions _self;
  final $Res Function(CodeActionRegistrationOptions) _then;

/// Create a copy of CodeActionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = freezed,Object? resolveProvider = freezed,Object? codeActionKinds = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,codeActionKinds: freezed == codeActionKinds ? _self.codeActionKinds : codeActionKinds // ignore: cast_nullable_to_non_nullable
as List<CodeActionKind>?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _CodeActionRegistrationOptions implements CodeActionRegistrationOptions {
  const _CodeActionRegistrationOptions({required this.documentSelector, this.resolveProvider, final  List<CodeActionKind>? codeActionKinds, this.workDoneProgress}): _codeActionKinds = codeActionKinds;
  factory _CodeActionRegistrationOptions.fromJson(Map<String, dynamic> json) => _$CodeActionRegistrationOptionsFromJson(json);

@override final  dynamic documentSelector;
@override final  bool? resolveProvider;
 final  List<CodeActionKind>? _codeActionKinds;
@override List<CodeActionKind>? get codeActionKinds {
  final value = _codeActionKinds;
  if (value == null) return null;
  if (_codeActionKinds is EqualUnmodifiableListView) return _codeActionKinds;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

@override final  bool? workDoneProgress;

/// Create a copy of CodeActionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CodeActionRegistrationOptionsCopyWith<_CodeActionRegistrationOptions> get copyWith => __$CodeActionRegistrationOptionsCopyWithImpl<_CodeActionRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CodeActionRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CodeActionRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider)&&const DeepCollectionEquality().equals(other._codeActionKinds, _codeActionKinds)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),resolveProvider,const DeepCollectionEquality().hash(_codeActionKinds),workDoneProgress);

@override
String toString() {
  return 'CodeActionRegistrationOptions(documentSelector: $documentSelector, resolveProvider: $resolveProvider, codeActionKinds: $codeActionKinds, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$CodeActionRegistrationOptionsCopyWith<$Res> implements $CodeActionRegistrationOptionsCopyWith<$Res> {
  factory _$CodeActionRegistrationOptionsCopyWith(_CodeActionRegistrationOptions value, $Res Function(_CodeActionRegistrationOptions) _then) = __$CodeActionRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 dynamic documentSelector, bool? resolveProvider, List<CodeActionKind>? codeActionKinds, bool? workDoneProgress
});




}
/// @nodoc
class __$CodeActionRegistrationOptionsCopyWithImpl<$Res>
    implements _$CodeActionRegistrationOptionsCopyWith<$Res> {
  __$CodeActionRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _CodeActionRegistrationOptions _self;
  final $Res Function(_CodeActionRegistrationOptions) _then;

/// Create a copy of CodeActionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = freezed,Object? resolveProvider = freezed,Object? codeActionKinds = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_CodeActionRegistrationOptions(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,codeActionKinds: freezed == codeActionKinds ? _self._codeActionKinds : codeActionKinds // ignore: cast_nullable_to_non_nullable
as List<CodeActionKind>?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$WorkspaceSymbolParams {

 String get query; ProgressToken? get partialResultToken; ProgressToken? get workDoneToken;
/// Create a copy of WorkspaceSymbolParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkspaceSymbolParamsCopyWith<WorkspaceSymbolParams> get copyWith => _$WorkspaceSymbolParamsCopyWithImpl<WorkspaceSymbolParams>(this as WorkspaceSymbolParams, _$identity);

  /// Serializes this WorkspaceSymbolParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkspaceSymbolParams&&(identical(other.query, query) || other.query == query)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,query,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'WorkspaceSymbolParams(query: $query, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $WorkspaceSymbolParamsCopyWith<$Res>  {
  factory $WorkspaceSymbolParamsCopyWith(WorkspaceSymbolParams value, $Res Function(WorkspaceSymbolParams) _then) = _$WorkspaceSymbolParamsCopyWithImpl;
@useResult
$Res call({
 String query, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});




}
/// @nodoc
class _$WorkspaceSymbolParamsCopyWithImpl<$Res>
    implements $WorkspaceSymbolParamsCopyWith<$Res> {
  _$WorkspaceSymbolParamsCopyWithImpl(this._self, this._then);

  final WorkspaceSymbolParams _self;
  final $Res Function(WorkspaceSymbolParams) _then;

/// Create a copy of WorkspaceSymbolParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? query = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
query: null == query ? _self.query : query // ignore: cast_nullable_to_non_nullable
as String,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _WorkspaceSymbolParams implements WorkspaceSymbolParams {
  const _WorkspaceSymbolParams({required this.query, this.partialResultToken, this.workDoneToken});
  factory _WorkspaceSymbolParams.fromJson(Map<String, dynamic> json) => _$WorkspaceSymbolParamsFromJson(json);

@override final  String query;
@override final  ProgressToken? partialResultToken;
@override final  ProgressToken? workDoneToken;

/// Create a copy of WorkspaceSymbolParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkspaceSymbolParamsCopyWith<_WorkspaceSymbolParams> get copyWith => __$WorkspaceSymbolParamsCopyWithImpl<_WorkspaceSymbolParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkspaceSymbolParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkspaceSymbolParams&&(identical(other.query, query) || other.query == query)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,query,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'WorkspaceSymbolParams(query: $query, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$WorkspaceSymbolParamsCopyWith<$Res> implements $WorkspaceSymbolParamsCopyWith<$Res> {
  factory _$WorkspaceSymbolParamsCopyWith(_WorkspaceSymbolParams value, $Res Function(_WorkspaceSymbolParams) _then) = __$WorkspaceSymbolParamsCopyWithImpl;
@override @useResult
$Res call({
 String query, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});




}
/// @nodoc
class __$WorkspaceSymbolParamsCopyWithImpl<$Res>
    implements _$WorkspaceSymbolParamsCopyWith<$Res> {
  __$WorkspaceSymbolParamsCopyWithImpl(this._self, this._then);

  final _WorkspaceSymbolParams _self;
  final $Res Function(_WorkspaceSymbolParams) _then;

/// Create a copy of WorkspaceSymbolParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? query = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_WorkspaceSymbolParams(
query: null == query ? _self.query : query // ignore: cast_nullable_to_non_nullable
as String,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}


}


/// @nodoc
mixin _$WorkspaceSymbol {

 String get name; SymbolKind get kind; dynamic get location; LSPAny? get data; String? get containerName; List<SymbolTag>? get tags;
/// Create a copy of WorkspaceSymbol
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkspaceSymbolCopyWith<WorkspaceSymbol> get copyWith => _$WorkspaceSymbolCopyWithImpl<WorkspaceSymbol>(this as WorkspaceSymbol, _$identity);

  /// Serializes this WorkspaceSymbol to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkspaceSymbol&&(identical(other.name, name) || other.name == name)&&(identical(other.kind, kind) || other.kind == kind)&&const DeepCollectionEquality().equals(other.location, location)&&const DeepCollectionEquality().equals(other.data, data)&&(identical(other.containerName, containerName) || other.containerName == containerName)&&const DeepCollectionEquality().equals(other.tags, tags));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,name,kind,const DeepCollectionEquality().hash(location),const DeepCollectionEquality().hash(data),containerName,const DeepCollectionEquality().hash(tags));

@override
String toString() {
  return 'WorkspaceSymbol(name: $name, kind: $kind, location: $location, data: $data, containerName: $containerName, tags: $tags)';
}


}

/// @nodoc
abstract mixin class $WorkspaceSymbolCopyWith<$Res>  {
  factory $WorkspaceSymbolCopyWith(WorkspaceSymbol value, $Res Function(WorkspaceSymbol) _then) = _$WorkspaceSymbolCopyWithImpl;
@useResult
$Res call({
 String name, SymbolKind kind, dynamic location, LSPAny? data, String? containerName, List<SymbolTag>? tags
});




}
/// @nodoc
class _$WorkspaceSymbolCopyWithImpl<$Res>
    implements $WorkspaceSymbolCopyWith<$Res> {
  _$WorkspaceSymbolCopyWithImpl(this._self, this._then);

  final WorkspaceSymbol _self;
  final $Res Function(WorkspaceSymbol) _then;

/// Create a copy of WorkspaceSymbol
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? name = null,Object? kind = null,Object? location = freezed,Object? data = freezed,Object? containerName = freezed,Object? tags = freezed,}) {
  return _then(_self.copyWith(
name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as SymbolKind,location: freezed == location ? _self.location : location // ignore: cast_nullable_to_non_nullable
as dynamic,data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LSPAny?,containerName: freezed == containerName ? _self.containerName : containerName // ignore: cast_nullable_to_non_nullable
as String?,tags: freezed == tags ? _self.tags : tags // ignore: cast_nullable_to_non_nullable
as List<SymbolTag>?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _WorkspaceSymbol implements WorkspaceSymbol {
  const _WorkspaceSymbol({required this.name, required this.kind, required this.location, this.data, this.containerName, final  List<SymbolTag>? tags}): _tags = tags;
  factory _WorkspaceSymbol.fromJson(Map<String, dynamic> json) => _$WorkspaceSymbolFromJson(json);

@override final  String name;
@override final  SymbolKind kind;
@override final  dynamic location;
@override final  LSPAny? data;
@override final  String? containerName;
 final  List<SymbolTag>? _tags;
@override List<SymbolTag>? get tags {
  final value = _tags;
  if (value == null) return null;
  if (_tags is EqualUnmodifiableListView) return _tags;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}


/// Create a copy of WorkspaceSymbol
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkspaceSymbolCopyWith<_WorkspaceSymbol> get copyWith => __$WorkspaceSymbolCopyWithImpl<_WorkspaceSymbol>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkspaceSymbolToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkspaceSymbol&&(identical(other.name, name) || other.name == name)&&(identical(other.kind, kind) || other.kind == kind)&&const DeepCollectionEquality().equals(other.location, location)&&const DeepCollectionEquality().equals(other.data, data)&&(identical(other.containerName, containerName) || other.containerName == containerName)&&const DeepCollectionEquality().equals(other._tags, _tags));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,name,kind,const DeepCollectionEquality().hash(location),const DeepCollectionEquality().hash(data),containerName,const DeepCollectionEquality().hash(_tags));

@override
String toString() {
  return 'WorkspaceSymbol(name: $name, kind: $kind, location: $location, data: $data, containerName: $containerName, tags: $tags)';
}


}

/// @nodoc
abstract mixin class _$WorkspaceSymbolCopyWith<$Res> implements $WorkspaceSymbolCopyWith<$Res> {
  factory _$WorkspaceSymbolCopyWith(_WorkspaceSymbol value, $Res Function(_WorkspaceSymbol) _then) = __$WorkspaceSymbolCopyWithImpl;
@override @useResult
$Res call({
 String name, SymbolKind kind, dynamic location, LSPAny? data, String? containerName, List<SymbolTag>? tags
});




}
/// @nodoc
class __$WorkspaceSymbolCopyWithImpl<$Res>
    implements _$WorkspaceSymbolCopyWith<$Res> {
  __$WorkspaceSymbolCopyWithImpl(this._self, this._then);

  final _WorkspaceSymbol _self;
  final $Res Function(_WorkspaceSymbol) _then;

/// Create a copy of WorkspaceSymbol
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? name = null,Object? kind = null,Object? location = freezed,Object? data = freezed,Object? containerName = freezed,Object? tags = freezed,}) {
  return _then(_WorkspaceSymbol(
name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as SymbolKind,location: freezed == location ? _self.location : location // ignore: cast_nullable_to_non_nullable
as dynamic,data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LSPAny?,containerName: freezed == containerName ? _self.containerName : containerName // ignore: cast_nullable_to_non_nullable
as String?,tags: freezed == tags ? _self._tags : tags // ignore: cast_nullable_to_non_nullable
as List<SymbolTag>?,
  ));
}


}


/// @nodoc
mixin _$WorkspaceSymbolRegistrationOptions {

 bool? get resolveProvider; bool? get workDoneProgress;
/// Create a copy of WorkspaceSymbolRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkspaceSymbolRegistrationOptionsCopyWith<WorkspaceSymbolRegistrationOptions> get copyWith => _$WorkspaceSymbolRegistrationOptionsCopyWithImpl<WorkspaceSymbolRegistrationOptions>(this as WorkspaceSymbolRegistrationOptions, _$identity);

  /// Serializes this WorkspaceSymbolRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkspaceSymbolRegistrationOptions&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,resolveProvider,workDoneProgress);

@override
String toString() {
  return 'WorkspaceSymbolRegistrationOptions(resolveProvider: $resolveProvider, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $WorkspaceSymbolRegistrationOptionsCopyWith<$Res>  {
  factory $WorkspaceSymbolRegistrationOptionsCopyWith(WorkspaceSymbolRegistrationOptions value, $Res Function(WorkspaceSymbolRegistrationOptions) _then) = _$WorkspaceSymbolRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 bool? resolveProvider, bool? workDoneProgress
});




}
/// @nodoc
class _$WorkspaceSymbolRegistrationOptionsCopyWithImpl<$Res>
    implements $WorkspaceSymbolRegistrationOptionsCopyWith<$Res> {
  _$WorkspaceSymbolRegistrationOptionsCopyWithImpl(this._self, this._then);

  final WorkspaceSymbolRegistrationOptions _self;
  final $Res Function(WorkspaceSymbolRegistrationOptions) _then;

/// Create a copy of WorkspaceSymbolRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? resolveProvider = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _WorkspaceSymbolRegistrationOptions implements WorkspaceSymbolRegistrationOptions {
  const _WorkspaceSymbolRegistrationOptions({this.resolveProvider, this.workDoneProgress});
  factory _WorkspaceSymbolRegistrationOptions.fromJson(Map<String, dynamic> json) => _$WorkspaceSymbolRegistrationOptionsFromJson(json);

@override final  bool? resolveProvider;
@override final  bool? workDoneProgress;

/// Create a copy of WorkspaceSymbolRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkspaceSymbolRegistrationOptionsCopyWith<_WorkspaceSymbolRegistrationOptions> get copyWith => __$WorkspaceSymbolRegistrationOptionsCopyWithImpl<_WorkspaceSymbolRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkspaceSymbolRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkspaceSymbolRegistrationOptions&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,resolveProvider,workDoneProgress);

@override
String toString() {
  return 'WorkspaceSymbolRegistrationOptions(resolveProvider: $resolveProvider, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$WorkspaceSymbolRegistrationOptionsCopyWith<$Res> implements $WorkspaceSymbolRegistrationOptionsCopyWith<$Res> {
  factory _$WorkspaceSymbolRegistrationOptionsCopyWith(_WorkspaceSymbolRegistrationOptions value, $Res Function(_WorkspaceSymbolRegistrationOptions) _then) = __$WorkspaceSymbolRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? resolveProvider, bool? workDoneProgress
});




}
/// @nodoc
class __$WorkspaceSymbolRegistrationOptionsCopyWithImpl<$Res>
    implements _$WorkspaceSymbolRegistrationOptionsCopyWith<$Res> {
  __$WorkspaceSymbolRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _WorkspaceSymbolRegistrationOptions _self;
  final $Res Function(_WorkspaceSymbolRegistrationOptions) _then;

/// Create a copy of WorkspaceSymbolRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? resolveProvider = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_WorkspaceSymbolRegistrationOptions(
resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$CodeLensParams {

 TextDocumentIdentifier get textDocument; ProgressToken? get partialResultToken; ProgressToken? get workDoneToken;
/// Create a copy of CodeLensParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CodeLensParamsCopyWith<CodeLensParams> get copyWith => _$CodeLensParamsCopyWithImpl<CodeLensParams>(this as CodeLensParams, _$identity);

  /// Serializes this CodeLensParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CodeLensParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'CodeLensParams(textDocument: $textDocument, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $CodeLensParamsCopyWith<$Res>  {
  factory $CodeLensParamsCopyWith(CodeLensParams value, $Res Function(CodeLensParams) _then) = _$CodeLensParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$CodeLensParamsCopyWithImpl<$Res>
    implements $CodeLensParamsCopyWith<$Res> {
  _$CodeLensParamsCopyWithImpl(this._self, this._then);

  final CodeLensParams _self;
  final $Res Function(CodeLensParams) _then;

/// Create a copy of CodeLensParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of CodeLensParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _CodeLensParams implements CodeLensParams {
  const _CodeLensParams({required this.textDocument, this.partialResultToken, this.workDoneToken});
  factory _CodeLensParams.fromJson(Map<String, dynamic> json) => _$CodeLensParamsFromJson(json);

@override final  TextDocumentIdentifier textDocument;
@override final  ProgressToken? partialResultToken;
@override final  ProgressToken? workDoneToken;

/// Create a copy of CodeLensParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CodeLensParamsCopyWith<_CodeLensParams> get copyWith => __$CodeLensParamsCopyWithImpl<_CodeLensParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CodeLensParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CodeLensParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'CodeLensParams(textDocument: $textDocument, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$CodeLensParamsCopyWith<$Res> implements $CodeLensParamsCopyWith<$Res> {
  factory _$CodeLensParamsCopyWith(_CodeLensParams value, $Res Function(_CodeLensParams) _then) = __$CodeLensParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$CodeLensParamsCopyWithImpl<$Res>
    implements _$CodeLensParamsCopyWith<$Res> {
  __$CodeLensParamsCopyWithImpl(this._self, this._then);

  final _CodeLensParams _self;
  final $Res Function(_CodeLensParams) _then;

/// Create a copy of CodeLensParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_CodeLensParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of CodeLensParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$CodeLens {

 Range get range; LSPAny? get data; Command? get command;
/// Create a copy of CodeLens
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CodeLensCopyWith<CodeLens> get copyWith => _$CodeLensCopyWithImpl<CodeLens>(this as CodeLens, _$identity);

  /// Serializes this CodeLens to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CodeLens&&(identical(other.range, range) || other.range == range)&&const DeepCollectionEquality().equals(other.data, data)&&(identical(other.command, command) || other.command == command));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,range,const DeepCollectionEquality().hash(data),command);

@override
String toString() {
  return 'CodeLens(range: $range, data: $data, command: $command)';
}


}

/// @nodoc
abstract mixin class $CodeLensCopyWith<$Res>  {
  factory $CodeLensCopyWith(CodeLens value, $Res Function(CodeLens) _then) = _$CodeLensCopyWithImpl;
@useResult
$Res call({
 Range range, LSPAny? data, Command? command
});


$RangeCopyWith<$Res> get range;$CommandCopyWith<$Res>? get command;

}
/// @nodoc
class _$CodeLensCopyWithImpl<$Res>
    implements $CodeLensCopyWith<$Res> {
  _$CodeLensCopyWithImpl(this._self, this._then);

  final CodeLens _self;
  final $Res Function(CodeLens) _then;

/// Create a copy of CodeLens
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? range = null,Object? data = freezed,Object? command = freezed,}) {
  return _then(_self.copyWith(
range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LSPAny?,command: freezed == command ? _self.command : command // ignore: cast_nullable_to_non_nullable
as Command?,
  ));
}
/// Create a copy of CodeLens
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}/// Create a copy of CodeLens
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CommandCopyWith<$Res>? get command {
    if (_self.command == null) {
    return null;
  }

  return $CommandCopyWith<$Res>(_self.command!, (value) {
    return _then(_self.copyWith(command: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _CodeLens implements CodeLens {
  const _CodeLens({required this.range, this.data, this.command});
  factory _CodeLens.fromJson(Map<String, dynamic> json) => _$CodeLensFromJson(json);

@override final  Range range;
@override final  LSPAny? data;
@override final  Command? command;

/// Create a copy of CodeLens
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CodeLensCopyWith<_CodeLens> get copyWith => __$CodeLensCopyWithImpl<_CodeLens>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CodeLensToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CodeLens&&(identical(other.range, range) || other.range == range)&&const DeepCollectionEquality().equals(other.data, data)&&(identical(other.command, command) || other.command == command));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,range,const DeepCollectionEquality().hash(data),command);

@override
String toString() {
  return 'CodeLens(range: $range, data: $data, command: $command)';
}


}

/// @nodoc
abstract mixin class _$CodeLensCopyWith<$Res> implements $CodeLensCopyWith<$Res> {
  factory _$CodeLensCopyWith(_CodeLens value, $Res Function(_CodeLens) _then) = __$CodeLensCopyWithImpl;
@override @useResult
$Res call({
 Range range, LSPAny? data, Command? command
});


@override $RangeCopyWith<$Res> get range;@override $CommandCopyWith<$Res>? get command;

}
/// @nodoc
class __$CodeLensCopyWithImpl<$Res>
    implements _$CodeLensCopyWith<$Res> {
  __$CodeLensCopyWithImpl(this._self, this._then);

  final _CodeLens _self;
  final $Res Function(_CodeLens) _then;

/// Create a copy of CodeLens
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? range = null,Object? data = freezed,Object? command = freezed,}) {
  return _then(_CodeLens(
range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LSPAny?,command: freezed == command ? _self.command : command // ignore: cast_nullable_to_non_nullable
as Command?,
  ));
}

/// Create a copy of CodeLens
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}/// Create a copy of CodeLens
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CommandCopyWith<$Res>? get command {
    if (_self.command == null) {
    return null;
  }

  return $CommandCopyWith<$Res>(_self.command!, (value) {
    return _then(_self.copyWith(command: value));
  });
}
}


/// @nodoc
mixin _$CodeLensRegistrationOptions {

 dynamic get documentSelector; bool? get resolveProvider; bool? get workDoneProgress;
/// Create a copy of CodeLensRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CodeLensRegistrationOptionsCopyWith<CodeLensRegistrationOptions> get copyWith => _$CodeLensRegistrationOptionsCopyWithImpl<CodeLensRegistrationOptions>(this as CodeLensRegistrationOptions, _$identity);

  /// Serializes this CodeLensRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CodeLensRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),resolveProvider,workDoneProgress);

@override
String toString() {
  return 'CodeLensRegistrationOptions(documentSelector: $documentSelector, resolveProvider: $resolveProvider, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $CodeLensRegistrationOptionsCopyWith<$Res>  {
  factory $CodeLensRegistrationOptionsCopyWith(CodeLensRegistrationOptions value, $Res Function(CodeLensRegistrationOptions) _then) = _$CodeLensRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 dynamic documentSelector, bool? resolveProvider, bool? workDoneProgress
});




}
/// @nodoc
class _$CodeLensRegistrationOptionsCopyWithImpl<$Res>
    implements $CodeLensRegistrationOptionsCopyWith<$Res> {
  _$CodeLensRegistrationOptionsCopyWithImpl(this._self, this._then);

  final CodeLensRegistrationOptions _self;
  final $Res Function(CodeLensRegistrationOptions) _then;

/// Create a copy of CodeLensRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = freezed,Object? resolveProvider = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _CodeLensRegistrationOptions implements CodeLensRegistrationOptions {
  const _CodeLensRegistrationOptions({required this.documentSelector, this.resolveProvider, this.workDoneProgress});
  factory _CodeLensRegistrationOptions.fromJson(Map<String, dynamic> json) => _$CodeLensRegistrationOptionsFromJson(json);

@override final  dynamic documentSelector;
@override final  bool? resolveProvider;
@override final  bool? workDoneProgress;

/// Create a copy of CodeLensRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CodeLensRegistrationOptionsCopyWith<_CodeLensRegistrationOptions> get copyWith => __$CodeLensRegistrationOptionsCopyWithImpl<_CodeLensRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CodeLensRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CodeLensRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),resolveProvider,workDoneProgress);

@override
String toString() {
  return 'CodeLensRegistrationOptions(documentSelector: $documentSelector, resolveProvider: $resolveProvider, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$CodeLensRegistrationOptionsCopyWith<$Res> implements $CodeLensRegistrationOptionsCopyWith<$Res> {
  factory _$CodeLensRegistrationOptionsCopyWith(_CodeLensRegistrationOptions value, $Res Function(_CodeLensRegistrationOptions) _then) = __$CodeLensRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 dynamic documentSelector, bool? resolveProvider, bool? workDoneProgress
});




}
/// @nodoc
class __$CodeLensRegistrationOptionsCopyWithImpl<$Res>
    implements _$CodeLensRegistrationOptionsCopyWith<$Res> {
  __$CodeLensRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _CodeLensRegistrationOptions _self;
  final $Res Function(_CodeLensRegistrationOptions) _then;

/// Create a copy of CodeLensRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = freezed,Object? resolveProvider = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_CodeLensRegistrationOptions(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DocumentLinkParams {

 TextDocumentIdentifier get textDocument; ProgressToken? get partialResultToken; ProgressToken? get workDoneToken;
/// Create a copy of DocumentLinkParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentLinkParamsCopyWith<DocumentLinkParams> get copyWith => _$DocumentLinkParamsCopyWithImpl<DocumentLinkParams>(this as DocumentLinkParams, _$identity);

  /// Serializes this DocumentLinkParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentLinkParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'DocumentLinkParams(textDocument: $textDocument, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $DocumentLinkParamsCopyWith<$Res>  {
  factory $DocumentLinkParamsCopyWith(DocumentLinkParams value, $Res Function(DocumentLinkParams) _then) = _$DocumentLinkParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$DocumentLinkParamsCopyWithImpl<$Res>
    implements $DocumentLinkParamsCopyWith<$Res> {
  _$DocumentLinkParamsCopyWithImpl(this._self, this._then);

  final DocumentLinkParams _self;
  final $Res Function(DocumentLinkParams) _then;

/// Create a copy of DocumentLinkParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of DocumentLinkParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DocumentLinkParams implements DocumentLinkParams {
  const _DocumentLinkParams({required this.textDocument, this.partialResultToken, this.workDoneToken});
  factory _DocumentLinkParams.fromJson(Map<String, dynamic> json) => _$DocumentLinkParamsFromJson(json);

@override final  TextDocumentIdentifier textDocument;
@override final  ProgressToken? partialResultToken;
@override final  ProgressToken? workDoneToken;

/// Create a copy of DocumentLinkParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentLinkParamsCopyWith<_DocumentLinkParams> get copyWith => __$DocumentLinkParamsCopyWithImpl<_DocumentLinkParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentLinkParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentLinkParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,const DeepCollectionEquality().hash(partialResultToken),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'DocumentLinkParams(textDocument: $textDocument, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$DocumentLinkParamsCopyWith<$Res> implements $DocumentLinkParamsCopyWith<$Res> {
  factory _$DocumentLinkParamsCopyWith(_DocumentLinkParams value, $Res Function(_DocumentLinkParams) _then) = __$DocumentLinkParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$DocumentLinkParamsCopyWithImpl<$Res>
    implements _$DocumentLinkParamsCopyWith<$Res> {
  __$DocumentLinkParamsCopyWithImpl(this._self, this._then);

  final _DocumentLinkParams _self;
  final $Res Function(_DocumentLinkParams) _then;

/// Create a copy of DocumentLinkParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_DocumentLinkParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of DocumentLinkParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$DocumentLink {

 Range get range; LSPAny? get data; String? get tooltip; String? get target;
/// Create a copy of DocumentLink
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentLinkCopyWith<DocumentLink> get copyWith => _$DocumentLinkCopyWithImpl<DocumentLink>(this as DocumentLink, _$identity);

  /// Serializes this DocumentLink to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentLink&&(identical(other.range, range) || other.range == range)&&const DeepCollectionEquality().equals(other.data, data)&&(identical(other.tooltip, tooltip) || other.tooltip == tooltip)&&(identical(other.target, target) || other.target == target));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,range,const DeepCollectionEquality().hash(data),tooltip,target);

@override
String toString() {
  return 'DocumentLink(range: $range, data: $data, tooltip: $tooltip, target: $target)';
}


}

/// @nodoc
abstract mixin class $DocumentLinkCopyWith<$Res>  {
  factory $DocumentLinkCopyWith(DocumentLink value, $Res Function(DocumentLink) _then) = _$DocumentLinkCopyWithImpl;
@useResult
$Res call({
 Range range, LSPAny? data, String? tooltip, String? target
});


$RangeCopyWith<$Res> get range;

}
/// @nodoc
class _$DocumentLinkCopyWithImpl<$Res>
    implements $DocumentLinkCopyWith<$Res> {
  _$DocumentLinkCopyWithImpl(this._self, this._then);

  final DocumentLink _self;
  final $Res Function(DocumentLink) _then;

/// Create a copy of DocumentLink
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? range = null,Object? data = freezed,Object? tooltip = freezed,Object? target = freezed,}) {
  return _then(_self.copyWith(
range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LSPAny?,tooltip: freezed == tooltip ? _self.tooltip : tooltip // ignore: cast_nullable_to_non_nullable
as String?,target: freezed == target ? _self.target : target // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}
/// Create a copy of DocumentLink
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DocumentLink implements DocumentLink {
  const _DocumentLink({required this.range, this.data, this.tooltip, this.target});
  factory _DocumentLink.fromJson(Map<String, dynamic> json) => _$DocumentLinkFromJson(json);

@override final  Range range;
@override final  LSPAny? data;
@override final  String? tooltip;
@override final  String? target;

/// Create a copy of DocumentLink
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentLinkCopyWith<_DocumentLink> get copyWith => __$DocumentLinkCopyWithImpl<_DocumentLink>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentLinkToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentLink&&(identical(other.range, range) || other.range == range)&&const DeepCollectionEquality().equals(other.data, data)&&(identical(other.tooltip, tooltip) || other.tooltip == tooltip)&&(identical(other.target, target) || other.target == target));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,range,const DeepCollectionEquality().hash(data),tooltip,target);

@override
String toString() {
  return 'DocumentLink(range: $range, data: $data, tooltip: $tooltip, target: $target)';
}


}

/// @nodoc
abstract mixin class _$DocumentLinkCopyWith<$Res> implements $DocumentLinkCopyWith<$Res> {
  factory _$DocumentLinkCopyWith(_DocumentLink value, $Res Function(_DocumentLink) _then) = __$DocumentLinkCopyWithImpl;
@override @useResult
$Res call({
 Range range, LSPAny? data, String? tooltip, String? target
});


@override $RangeCopyWith<$Res> get range;

}
/// @nodoc
class __$DocumentLinkCopyWithImpl<$Res>
    implements _$DocumentLinkCopyWith<$Res> {
  __$DocumentLinkCopyWithImpl(this._self, this._then);

  final _DocumentLink _self;
  final $Res Function(_DocumentLink) _then;

/// Create a copy of DocumentLink
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? range = null,Object? data = freezed,Object? tooltip = freezed,Object? target = freezed,}) {
  return _then(_DocumentLink(
range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LSPAny?,tooltip: freezed == tooltip ? _self.tooltip : tooltip // ignore: cast_nullable_to_non_nullable
as String?,target: freezed == target ? _self.target : target // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

/// Create a copy of DocumentLink
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}


/// @nodoc
mixin _$DocumentLinkRegistrationOptions {

 dynamic get documentSelector; bool? get resolveProvider; bool? get workDoneProgress;
/// Create a copy of DocumentLinkRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentLinkRegistrationOptionsCopyWith<DocumentLinkRegistrationOptions> get copyWith => _$DocumentLinkRegistrationOptionsCopyWithImpl<DocumentLinkRegistrationOptions>(this as DocumentLinkRegistrationOptions, _$identity);

  /// Serializes this DocumentLinkRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentLinkRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),resolveProvider,workDoneProgress);

@override
String toString() {
  return 'DocumentLinkRegistrationOptions(documentSelector: $documentSelector, resolveProvider: $resolveProvider, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $DocumentLinkRegistrationOptionsCopyWith<$Res>  {
  factory $DocumentLinkRegistrationOptionsCopyWith(DocumentLinkRegistrationOptions value, $Res Function(DocumentLinkRegistrationOptions) _then) = _$DocumentLinkRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 dynamic documentSelector, bool? resolveProvider, bool? workDoneProgress
});




}
/// @nodoc
class _$DocumentLinkRegistrationOptionsCopyWithImpl<$Res>
    implements $DocumentLinkRegistrationOptionsCopyWith<$Res> {
  _$DocumentLinkRegistrationOptionsCopyWithImpl(this._self, this._then);

  final DocumentLinkRegistrationOptions _self;
  final $Res Function(DocumentLinkRegistrationOptions) _then;

/// Create a copy of DocumentLinkRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = freezed,Object? resolveProvider = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DocumentLinkRegistrationOptions implements DocumentLinkRegistrationOptions {
  const _DocumentLinkRegistrationOptions({required this.documentSelector, this.resolveProvider, this.workDoneProgress});
  factory _DocumentLinkRegistrationOptions.fromJson(Map<String, dynamic> json) => _$DocumentLinkRegistrationOptionsFromJson(json);

@override final  dynamic documentSelector;
@override final  bool? resolveProvider;
@override final  bool? workDoneProgress;

/// Create a copy of DocumentLinkRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentLinkRegistrationOptionsCopyWith<_DocumentLinkRegistrationOptions> get copyWith => __$DocumentLinkRegistrationOptionsCopyWithImpl<_DocumentLinkRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentLinkRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentLinkRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),resolveProvider,workDoneProgress);

@override
String toString() {
  return 'DocumentLinkRegistrationOptions(documentSelector: $documentSelector, resolveProvider: $resolveProvider, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$DocumentLinkRegistrationOptionsCopyWith<$Res> implements $DocumentLinkRegistrationOptionsCopyWith<$Res> {
  factory _$DocumentLinkRegistrationOptionsCopyWith(_DocumentLinkRegistrationOptions value, $Res Function(_DocumentLinkRegistrationOptions) _then) = __$DocumentLinkRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 dynamic documentSelector, bool? resolveProvider, bool? workDoneProgress
});




}
/// @nodoc
class __$DocumentLinkRegistrationOptionsCopyWithImpl<$Res>
    implements _$DocumentLinkRegistrationOptionsCopyWith<$Res> {
  __$DocumentLinkRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _DocumentLinkRegistrationOptions _self;
  final $Res Function(_DocumentLinkRegistrationOptions) _then;

/// Create a copy of DocumentLinkRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = freezed,Object? resolveProvider = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_DocumentLinkRegistrationOptions(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DocumentFormattingParams {

 TextDocumentIdentifier get textDocument; FormattingOptions get options; ProgressToken? get workDoneToken;
/// Create a copy of DocumentFormattingParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentFormattingParamsCopyWith<DocumentFormattingParams> get copyWith => _$DocumentFormattingParamsCopyWithImpl<DocumentFormattingParams>(this as DocumentFormattingParams, _$identity);

  /// Serializes this DocumentFormattingParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentFormattingParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.options, options) || other.options == options)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,options,const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'DocumentFormattingParams(textDocument: $textDocument, options: $options, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $DocumentFormattingParamsCopyWith<$Res>  {
  factory $DocumentFormattingParamsCopyWith(DocumentFormattingParams value, $Res Function(DocumentFormattingParams) _then) = _$DocumentFormattingParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument, FormattingOptions options, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;$FormattingOptionsCopyWith<$Res> get options;

}
/// @nodoc
class _$DocumentFormattingParamsCopyWithImpl<$Res>
    implements $DocumentFormattingParamsCopyWith<$Res> {
  _$DocumentFormattingParamsCopyWithImpl(this._self, this._then);

  final DocumentFormattingParams _self;
  final $Res Function(DocumentFormattingParams) _then;

/// Create a copy of DocumentFormattingParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? options = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,options: null == options ? _self.options : options // ignore: cast_nullable_to_non_nullable
as FormattingOptions,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of DocumentFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of DocumentFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FormattingOptionsCopyWith<$Res> get options {
  
  return $FormattingOptionsCopyWith<$Res>(_self.options, (value) {
    return _then(_self.copyWith(options: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DocumentFormattingParams implements DocumentFormattingParams {
  const _DocumentFormattingParams({required this.textDocument, required this.options, this.workDoneToken});
  factory _DocumentFormattingParams.fromJson(Map<String, dynamic> json) => _$DocumentFormattingParamsFromJson(json);

@override final  TextDocumentIdentifier textDocument;
@override final  FormattingOptions options;
@override final  ProgressToken? workDoneToken;

/// Create a copy of DocumentFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentFormattingParamsCopyWith<_DocumentFormattingParams> get copyWith => __$DocumentFormattingParamsCopyWithImpl<_DocumentFormattingParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentFormattingParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentFormattingParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.options, options) || other.options == options)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,options,const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'DocumentFormattingParams(textDocument: $textDocument, options: $options, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$DocumentFormattingParamsCopyWith<$Res> implements $DocumentFormattingParamsCopyWith<$Res> {
  factory _$DocumentFormattingParamsCopyWith(_DocumentFormattingParams value, $Res Function(_DocumentFormattingParams) _then) = __$DocumentFormattingParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument, FormattingOptions options, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;@override $FormattingOptionsCopyWith<$Res> get options;

}
/// @nodoc
class __$DocumentFormattingParamsCopyWithImpl<$Res>
    implements _$DocumentFormattingParamsCopyWith<$Res> {
  __$DocumentFormattingParamsCopyWithImpl(this._self, this._then);

  final _DocumentFormattingParams _self;
  final $Res Function(_DocumentFormattingParams) _then;

/// Create a copy of DocumentFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? options = null,Object? workDoneToken = freezed,}) {
  return _then(_DocumentFormattingParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,options: null == options ? _self.options : options // ignore: cast_nullable_to_non_nullable
as FormattingOptions,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of DocumentFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of DocumentFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FormattingOptionsCopyWith<$Res> get options {
  
  return $FormattingOptionsCopyWith<$Res>(_self.options, (value) {
    return _then(_self.copyWith(options: value));
  });
}
}


/// @nodoc
mixin _$DocumentFormattingRegistrationOptions {

 dynamic get documentSelector; bool? get workDoneProgress;
/// Create a copy of DocumentFormattingRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentFormattingRegistrationOptionsCopyWith<DocumentFormattingRegistrationOptions> get copyWith => _$DocumentFormattingRegistrationOptionsCopyWithImpl<DocumentFormattingRegistrationOptions>(this as DocumentFormattingRegistrationOptions, _$identity);

  /// Serializes this DocumentFormattingRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentFormattingRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),workDoneProgress);

@override
String toString() {
  return 'DocumentFormattingRegistrationOptions(documentSelector: $documentSelector, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $DocumentFormattingRegistrationOptionsCopyWith<$Res>  {
  factory $DocumentFormattingRegistrationOptionsCopyWith(DocumentFormattingRegistrationOptions value, $Res Function(DocumentFormattingRegistrationOptions) _then) = _$DocumentFormattingRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 dynamic documentSelector, bool? workDoneProgress
});




}
/// @nodoc
class _$DocumentFormattingRegistrationOptionsCopyWithImpl<$Res>
    implements $DocumentFormattingRegistrationOptionsCopyWith<$Res> {
  _$DocumentFormattingRegistrationOptionsCopyWithImpl(this._self, this._then);

  final DocumentFormattingRegistrationOptions _self;
  final $Res Function(DocumentFormattingRegistrationOptions) _then;

/// Create a copy of DocumentFormattingRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DocumentFormattingRegistrationOptions implements DocumentFormattingRegistrationOptions {
  const _DocumentFormattingRegistrationOptions({required this.documentSelector, this.workDoneProgress});
  factory _DocumentFormattingRegistrationOptions.fromJson(Map<String, dynamic> json) => _$DocumentFormattingRegistrationOptionsFromJson(json);

@override final  dynamic documentSelector;
@override final  bool? workDoneProgress;

/// Create a copy of DocumentFormattingRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentFormattingRegistrationOptionsCopyWith<_DocumentFormattingRegistrationOptions> get copyWith => __$DocumentFormattingRegistrationOptionsCopyWithImpl<_DocumentFormattingRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentFormattingRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentFormattingRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),workDoneProgress);

@override
String toString() {
  return 'DocumentFormattingRegistrationOptions(documentSelector: $documentSelector, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$DocumentFormattingRegistrationOptionsCopyWith<$Res> implements $DocumentFormattingRegistrationOptionsCopyWith<$Res> {
  factory _$DocumentFormattingRegistrationOptionsCopyWith(_DocumentFormattingRegistrationOptions value, $Res Function(_DocumentFormattingRegistrationOptions) _then) = __$DocumentFormattingRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 dynamic documentSelector, bool? workDoneProgress
});




}
/// @nodoc
class __$DocumentFormattingRegistrationOptionsCopyWithImpl<$Res>
    implements _$DocumentFormattingRegistrationOptionsCopyWith<$Res> {
  __$DocumentFormattingRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _DocumentFormattingRegistrationOptions _self;
  final $Res Function(_DocumentFormattingRegistrationOptions) _then;

/// Create a copy of DocumentFormattingRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_DocumentFormattingRegistrationOptions(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DocumentRangeFormattingParams {

 TextDocumentIdentifier get textDocument; Range get range; FormattingOptions get options; ProgressToken? get workDoneToken;
/// Create a copy of DocumentRangeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentRangeFormattingParamsCopyWith<DocumentRangeFormattingParams> get copyWith => _$DocumentRangeFormattingParamsCopyWithImpl<DocumentRangeFormattingParams>(this as DocumentRangeFormattingParams, _$identity);

  /// Serializes this DocumentRangeFormattingParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentRangeFormattingParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.range, range) || other.range == range)&&(identical(other.options, options) || other.options == options)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,range,options,const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'DocumentRangeFormattingParams(textDocument: $textDocument, range: $range, options: $options, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $DocumentRangeFormattingParamsCopyWith<$Res>  {
  factory $DocumentRangeFormattingParamsCopyWith(DocumentRangeFormattingParams value, $Res Function(DocumentRangeFormattingParams) _then) = _$DocumentRangeFormattingParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument, Range range, FormattingOptions options, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;$RangeCopyWith<$Res> get range;$FormattingOptionsCopyWith<$Res> get options;

}
/// @nodoc
class _$DocumentRangeFormattingParamsCopyWithImpl<$Res>
    implements $DocumentRangeFormattingParamsCopyWith<$Res> {
  _$DocumentRangeFormattingParamsCopyWithImpl(this._self, this._then);

  final DocumentRangeFormattingParams _self;
  final $Res Function(DocumentRangeFormattingParams) _then;

/// Create a copy of DocumentRangeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? range = null,Object? options = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,options: null == options ? _self.options : options // ignore: cast_nullable_to_non_nullable
as FormattingOptions,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of DocumentRangeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of DocumentRangeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}/// Create a copy of DocumentRangeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FormattingOptionsCopyWith<$Res> get options {
  
  return $FormattingOptionsCopyWith<$Res>(_self.options, (value) {
    return _then(_self.copyWith(options: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DocumentRangeFormattingParams implements DocumentRangeFormattingParams {
  const _DocumentRangeFormattingParams({required this.textDocument, required this.range, required this.options, this.workDoneToken});
  factory _DocumentRangeFormattingParams.fromJson(Map<String, dynamic> json) => _$DocumentRangeFormattingParamsFromJson(json);

@override final  TextDocumentIdentifier textDocument;
@override final  Range range;
@override final  FormattingOptions options;
@override final  ProgressToken? workDoneToken;

/// Create a copy of DocumentRangeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentRangeFormattingParamsCopyWith<_DocumentRangeFormattingParams> get copyWith => __$DocumentRangeFormattingParamsCopyWithImpl<_DocumentRangeFormattingParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentRangeFormattingParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentRangeFormattingParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.range, range) || other.range == range)&&(identical(other.options, options) || other.options == options)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,range,options,const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'DocumentRangeFormattingParams(textDocument: $textDocument, range: $range, options: $options, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$DocumentRangeFormattingParamsCopyWith<$Res> implements $DocumentRangeFormattingParamsCopyWith<$Res> {
  factory _$DocumentRangeFormattingParamsCopyWith(_DocumentRangeFormattingParams value, $Res Function(_DocumentRangeFormattingParams) _then) = __$DocumentRangeFormattingParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument, Range range, FormattingOptions options, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;@override $RangeCopyWith<$Res> get range;@override $FormattingOptionsCopyWith<$Res> get options;

}
/// @nodoc
class __$DocumentRangeFormattingParamsCopyWithImpl<$Res>
    implements _$DocumentRangeFormattingParamsCopyWith<$Res> {
  __$DocumentRangeFormattingParamsCopyWithImpl(this._self, this._then);

  final _DocumentRangeFormattingParams _self;
  final $Res Function(_DocumentRangeFormattingParams) _then;

/// Create a copy of DocumentRangeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? range = null,Object? options = null,Object? workDoneToken = freezed,}) {
  return _then(_DocumentRangeFormattingParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,options: null == options ? _self.options : options // ignore: cast_nullable_to_non_nullable
as FormattingOptions,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of DocumentRangeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of DocumentRangeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}/// Create a copy of DocumentRangeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FormattingOptionsCopyWith<$Res> get options {
  
  return $FormattingOptionsCopyWith<$Res>(_self.options, (value) {
    return _then(_self.copyWith(options: value));
  });
}
}


/// @nodoc
mixin _$DocumentRangeFormattingRegistrationOptions {

 dynamic get documentSelector; bool? get rangesSupport; bool? get workDoneProgress;
/// Create a copy of DocumentRangeFormattingRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentRangeFormattingRegistrationOptionsCopyWith<DocumentRangeFormattingRegistrationOptions> get copyWith => _$DocumentRangeFormattingRegistrationOptionsCopyWithImpl<DocumentRangeFormattingRegistrationOptions>(this as DocumentRangeFormattingRegistrationOptions, _$identity);

  /// Serializes this DocumentRangeFormattingRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentRangeFormattingRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.rangesSupport, rangesSupport) || other.rangesSupport == rangesSupport)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),rangesSupport,workDoneProgress);

@override
String toString() {
  return 'DocumentRangeFormattingRegistrationOptions(documentSelector: $documentSelector, rangesSupport: $rangesSupport, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $DocumentRangeFormattingRegistrationOptionsCopyWith<$Res>  {
  factory $DocumentRangeFormattingRegistrationOptionsCopyWith(DocumentRangeFormattingRegistrationOptions value, $Res Function(DocumentRangeFormattingRegistrationOptions) _then) = _$DocumentRangeFormattingRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 dynamic documentSelector, bool? rangesSupport, bool? workDoneProgress
});




}
/// @nodoc
class _$DocumentRangeFormattingRegistrationOptionsCopyWithImpl<$Res>
    implements $DocumentRangeFormattingRegistrationOptionsCopyWith<$Res> {
  _$DocumentRangeFormattingRegistrationOptionsCopyWithImpl(this._self, this._then);

  final DocumentRangeFormattingRegistrationOptions _self;
  final $Res Function(DocumentRangeFormattingRegistrationOptions) _then;

/// Create a copy of DocumentRangeFormattingRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = freezed,Object? rangesSupport = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,rangesSupport: freezed == rangesSupport ? _self.rangesSupport : rangesSupport // ignore: cast_nullable_to_non_nullable
as bool?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DocumentRangeFormattingRegistrationOptions implements DocumentRangeFormattingRegistrationOptions {
  const _DocumentRangeFormattingRegistrationOptions({required this.documentSelector, this.rangesSupport, this.workDoneProgress});
  factory _DocumentRangeFormattingRegistrationOptions.fromJson(Map<String, dynamic> json) => _$DocumentRangeFormattingRegistrationOptionsFromJson(json);

@override final  dynamic documentSelector;
@override final  bool? rangesSupport;
@override final  bool? workDoneProgress;

/// Create a copy of DocumentRangeFormattingRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentRangeFormattingRegistrationOptionsCopyWith<_DocumentRangeFormattingRegistrationOptions> get copyWith => __$DocumentRangeFormattingRegistrationOptionsCopyWithImpl<_DocumentRangeFormattingRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentRangeFormattingRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentRangeFormattingRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.rangesSupport, rangesSupport) || other.rangesSupport == rangesSupport)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),rangesSupport,workDoneProgress);

@override
String toString() {
  return 'DocumentRangeFormattingRegistrationOptions(documentSelector: $documentSelector, rangesSupport: $rangesSupport, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$DocumentRangeFormattingRegistrationOptionsCopyWith<$Res> implements $DocumentRangeFormattingRegistrationOptionsCopyWith<$Res> {
  factory _$DocumentRangeFormattingRegistrationOptionsCopyWith(_DocumentRangeFormattingRegistrationOptions value, $Res Function(_DocumentRangeFormattingRegistrationOptions) _then) = __$DocumentRangeFormattingRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 dynamic documentSelector, bool? rangesSupport, bool? workDoneProgress
});




}
/// @nodoc
class __$DocumentRangeFormattingRegistrationOptionsCopyWithImpl<$Res>
    implements _$DocumentRangeFormattingRegistrationOptionsCopyWith<$Res> {
  __$DocumentRangeFormattingRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _DocumentRangeFormattingRegistrationOptions _self;
  final $Res Function(_DocumentRangeFormattingRegistrationOptions) _then;

/// Create a copy of DocumentRangeFormattingRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = freezed,Object? rangesSupport = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_DocumentRangeFormattingRegistrationOptions(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,rangesSupport: freezed == rangesSupport ? _self.rangesSupport : rangesSupport // ignore: cast_nullable_to_non_nullable
as bool?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DocumentRangesFormattingParams {

 TextDocumentIdentifier get textDocument; List<Range> get ranges; FormattingOptions get options; ProgressToken? get workDoneToken;
/// Create a copy of DocumentRangesFormattingParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentRangesFormattingParamsCopyWith<DocumentRangesFormattingParams> get copyWith => _$DocumentRangesFormattingParamsCopyWithImpl<DocumentRangesFormattingParams>(this as DocumentRangesFormattingParams, _$identity);

  /// Serializes this DocumentRangesFormattingParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentRangesFormattingParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&const DeepCollectionEquality().equals(other.ranges, ranges)&&(identical(other.options, options) || other.options == options)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,const DeepCollectionEquality().hash(ranges),options,const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'DocumentRangesFormattingParams(textDocument: $textDocument, ranges: $ranges, options: $options, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $DocumentRangesFormattingParamsCopyWith<$Res>  {
  factory $DocumentRangesFormattingParamsCopyWith(DocumentRangesFormattingParams value, $Res Function(DocumentRangesFormattingParams) _then) = _$DocumentRangesFormattingParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument, List<Range> ranges, FormattingOptions options, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;$FormattingOptionsCopyWith<$Res> get options;

}
/// @nodoc
class _$DocumentRangesFormattingParamsCopyWithImpl<$Res>
    implements $DocumentRangesFormattingParamsCopyWith<$Res> {
  _$DocumentRangesFormattingParamsCopyWithImpl(this._self, this._then);

  final DocumentRangesFormattingParams _self;
  final $Res Function(DocumentRangesFormattingParams) _then;

/// Create a copy of DocumentRangesFormattingParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? ranges = null,Object? options = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,ranges: null == ranges ? _self.ranges : ranges // ignore: cast_nullable_to_non_nullable
as List<Range>,options: null == options ? _self.options : options // ignore: cast_nullable_to_non_nullable
as FormattingOptions,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of DocumentRangesFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of DocumentRangesFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FormattingOptionsCopyWith<$Res> get options {
  
  return $FormattingOptionsCopyWith<$Res>(_self.options, (value) {
    return _then(_self.copyWith(options: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DocumentRangesFormattingParams implements DocumentRangesFormattingParams {
  const _DocumentRangesFormattingParams({required this.textDocument, required final  List<Range> ranges, required this.options, this.workDoneToken}): _ranges = ranges;
  factory _DocumentRangesFormattingParams.fromJson(Map<String, dynamic> json) => _$DocumentRangesFormattingParamsFromJson(json);

@override final  TextDocumentIdentifier textDocument;
 final  List<Range> _ranges;
@override List<Range> get ranges {
  if (_ranges is EqualUnmodifiableListView) return _ranges;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_ranges);
}

@override final  FormattingOptions options;
@override final  ProgressToken? workDoneToken;

/// Create a copy of DocumentRangesFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentRangesFormattingParamsCopyWith<_DocumentRangesFormattingParams> get copyWith => __$DocumentRangesFormattingParamsCopyWithImpl<_DocumentRangesFormattingParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentRangesFormattingParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentRangesFormattingParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&const DeepCollectionEquality().equals(other._ranges, _ranges)&&(identical(other.options, options) || other.options == options)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,const DeepCollectionEquality().hash(_ranges),options,const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'DocumentRangesFormattingParams(textDocument: $textDocument, ranges: $ranges, options: $options, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$DocumentRangesFormattingParamsCopyWith<$Res> implements $DocumentRangesFormattingParamsCopyWith<$Res> {
  factory _$DocumentRangesFormattingParamsCopyWith(_DocumentRangesFormattingParams value, $Res Function(_DocumentRangesFormattingParams) _then) = __$DocumentRangesFormattingParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument, List<Range> ranges, FormattingOptions options, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;@override $FormattingOptionsCopyWith<$Res> get options;

}
/// @nodoc
class __$DocumentRangesFormattingParamsCopyWithImpl<$Res>
    implements _$DocumentRangesFormattingParamsCopyWith<$Res> {
  __$DocumentRangesFormattingParamsCopyWithImpl(this._self, this._then);

  final _DocumentRangesFormattingParams _self;
  final $Res Function(_DocumentRangesFormattingParams) _then;

/// Create a copy of DocumentRangesFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? ranges = null,Object? options = null,Object? workDoneToken = freezed,}) {
  return _then(_DocumentRangesFormattingParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,ranges: null == ranges ? _self._ranges : ranges // ignore: cast_nullable_to_non_nullable
as List<Range>,options: null == options ? _self.options : options // ignore: cast_nullable_to_non_nullable
as FormattingOptions,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of DocumentRangesFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of DocumentRangesFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FormattingOptionsCopyWith<$Res> get options {
  
  return $FormattingOptionsCopyWith<$Res>(_self.options, (value) {
    return _then(_self.copyWith(options: value));
  });
}
}


/// @nodoc
mixin _$DocumentOnTypeFormattingParams {

 TextDocumentIdentifier get textDocument; Position get position; String get ch; FormattingOptions get options;
/// Create a copy of DocumentOnTypeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentOnTypeFormattingParamsCopyWith<DocumentOnTypeFormattingParams> get copyWith => _$DocumentOnTypeFormattingParamsCopyWithImpl<DocumentOnTypeFormattingParams>(this as DocumentOnTypeFormattingParams, _$identity);

  /// Serializes this DocumentOnTypeFormattingParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentOnTypeFormattingParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.position, position) || other.position == position)&&(identical(other.ch, ch) || other.ch == ch)&&(identical(other.options, options) || other.options == options));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,position,ch,options);

@override
String toString() {
  return 'DocumentOnTypeFormattingParams(textDocument: $textDocument, position: $position, ch: $ch, options: $options)';
}


}

/// @nodoc
abstract mixin class $DocumentOnTypeFormattingParamsCopyWith<$Res>  {
  factory $DocumentOnTypeFormattingParamsCopyWith(DocumentOnTypeFormattingParams value, $Res Function(DocumentOnTypeFormattingParams) _then) = _$DocumentOnTypeFormattingParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument, Position position, String ch, FormattingOptions options
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;$PositionCopyWith<$Res> get position;$FormattingOptionsCopyWith<$Res> get options;

}
/// @nodoc
class _$DocumentOnTypeFormattingParamsCopyWithImpl<$Res>
    implements $DocumentOnTypeFormattingParamsCopyWith<$Res> {
  _$DocumentOnTypeFormattingParamsCopyWithImpl(this._self, this._then);

  final DocumentOnTypeFormattingParams _self;
  final $Res Function(DocumentOnTypeFormattingParams) _then;

/// Create a copy of DocumentOnTypeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? position = null,Object? ch = null,Object? options = null,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,ch: null == ch ? _self.ch : ch // ignore: cast_nullable_to_non_nullable
as String,options: null == options ? _self.options : options // ignore: cast_nullable_to_non_nullable
as FormattingOptions,
  ));
}
/// Create a copy of DocumentOnTypeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of DocumentOnTypeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of DocumentOnTypeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FormattingOptionsCopyWith<$Res> get options {
  
  return $FormattingOptionsCopyWith<$Res>(_self.options, (value) {
    return _then(_self.copyWith(options: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DocumentOnTypeFormattingParams implements DocumentOnTypeFormattingParams {
  const _DocumentOnTypeFormattingParams({required this.textDocument, required this.position, required this.ch, required this.options});
  factory _DocumentOnTypeFormattingParams.fromJson(Map<String, dynamic> json) => _$DocumentOnTypeFormattingParamsFromJson(json);

@override final  TextDocumentIdentifier textDocument;
@override final  Position position;
@override final  String ch;
@override final  FormattingOptions options;

/// Create a copy of DocumentOnTypeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentOnTypeFormattingParamsCopyWith<_DocumentOnTypeFormattingParams> get copyWith => __$DocumentOnTypeFormattingParamsCopyWithImpl<_DocumentOnTypeFormattingParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentOnTypeFormattingParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentOnTypeFormattingParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.position, position) || other.position == position)&&(identical(other.ch, ch) || other.ch == ch)&&(identical(other.options, options) || other.options == options));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,position,ch,options);

@override
String toString() {
  return 'DocumentOnTypeFormattingParams(textDocument: $textDocument, position: $position, ch: $ch, options: $options)';
}


}

/// @nodoc
abstract mixin class _$DocumentOnTypeFormattingParamsCopyWith<$Res> implements $DocumentOnTypeFormattingParamsCopyWith<$Res> {
  factory _$DocumentOnTypeFormattingParamsCopyWith(_DocumentOnTypeFormattingParams value, $Res Function(_DocumentOnTypeFormattingParams) _then) = __$DocumentOnTypeFormattingParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument, Position position, String ch, FormattingOptions options
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;@override $PositionCopyWith<$Res> get position;@override $FormattingOptionsCopyWith<$Res> get options;

}
/// @nodoc
class __$DocumentOnTypeFormattingParamsCopyWithImpl<$Res>
    implements _$DocumentOnTypeFormattingParamsCopyWith<$Res> {
  __$DocumentOnTypeFormattingParamsCopyWithImpl(this._self, this._then);

  final _DocumentOnTypeFormattingParams _self;
  final $Res Function(_DocumentOnTypeFormattingParams) _then;

/// Create a copy of DocumentOnTypeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? position = null,Object? ch = null,Object? options = null,}) {
  return _then(_DocumentOnTypeFormattingParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,ch: null == ch ? _self.ch : ch // ignore: cast_nullable_to_non_nullable
as String,options: null == options ? _self.options : options // ignore: cast_nullable_to_non_nullable
as FormattingOptions,
  ));
}

/// Create a copy of DocumentOnTypeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of DocumentOnTypeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of DocumentOnTypeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FormattingOptionsCopyWith<$Res> get options {
  
  return $FormattingOptionsCopyWith<$Res>(_self.options, (value) {
    return _then(_self.copyWith(options: value));
  });
}
}


/// @nodoc
mixin _$DocumentOnTypeFormattingRegistrationOptions {

 dynamic get documentSelector; String get firstTriggerCharacter; List<String>? get moreTriggerCharacter;
/// Create a copy of DocumentOnTypeFormattingRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentOnTypeFormattingRegistrationOptionsCopyWith<DocumentOnTypeFormattingRegistrationOptions> get copyWith => _$DocumentOnTypeFormattingRegistrationOptionsCopyWithImpl<DocumentOnTypeFormattingRegistrationOptions>(this as DocumentOnTypeFormattingRegistrationOptions, _$identity);

  /// Serializes this DocumentOnTypeFormattingRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentOnTypeFormattingRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.firstTriggerCharacter, firstTriggerCharacter) || other.firstTriggerCharacter == firstTriggerCharacter)&&const DeepCollectionEquality().equals(other.moreTriggerCharacter, moreTriggerCharacter));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),firstTriggerCharacter,const DeepCollectionEquality().hash(moreTriggerCharacter));

@override
String toString() {
  return 'DocumentOnTypeFormattingRegistrationOptions(documentSelector: $documentSelector, firstTriggerCharacter: $firstTriggerCharacter, moreTriggerCharacter: $moreTriggerCharacter)';
}


}

/// @nodoc
abstract mixin class $DocumentOnTypeFormattingRegistrationOptionsCopyWith<$Res>  {
  factory $DocumentOnTypeFormattingRegistrationOptionsCopyWith(DocumentOnTypeFormattingRegistrationOptions value, $Res Function(DocumentOnTypeFormattingRegistrationOptions) _then) = _$DocumentOnTypeFormattingRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 dynamic documentSelector, String firstTriggerCharacter, List<String>? moreTriggerCharacter
});




}
/// @nodoc
class _$DocumentOnTypeFormattingRegistrationOptionsCopyWithImpl<$Res>
    implements $DocumentOnTypeFormattingRegistrationOptionsCopyWith<$Res> {
  _$DocumentOnTypeFormattingRegistrationOptionsCopyWithImpl(this._self, this._then);

  final DocumentOnTypeFormattingRegistrationOptions _self;
  final $Res Function(DocumentOnTypeFormattingRegistrationOptions) _then;

/// Create a copy of DocumentOnTypeFormattingRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = freezed,Object? firstTriggerCharacter = null,Object? moreTriggerCharacter = freezed,}) {
  return _then(_self.copyWith(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,firstTriggerCharacter: null == firstTriggerCharacter ? _self.firstTriggerCharacter : firstTriggerCharacter // ignore: cast_nullable_to_non_nullable
as String,moreTriggerCharacter: freezed == moreTriggerCharacter ? _self.moreTriggerCharacter : moreTriggerCharacter // ignore: cast_nullable_to_non_nullable
as List<String>?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DocumentOnTypeFormattingRegistrationOptions implements DocumentOnTypeFormattingRegistrationOptions {
  const _DocumentOnTypeFormattingRegistrationOptions({required this.documentSelector, required this.firstTriggerCharacter, final  List<String>? moreTriggerCharacter}): _moreTriggerCharacter = moreTriggerCharacter;
  factory _DocumentOnTypeFormattingRegistrationOptions.fromJson(Map<String, dynamic> json) => _$DocumentOnTypeFormattingRegistrationOptionsFromJson(json);

@override final  dynamic documentSelector;
@override final  String firstTriggerCharacter;
 final  List<String>? _moreTriggerCharacter;
@override List<String>? get moreTriggerCharacter {
  final value = _moreTriggerCharacter;
  if (value == null) return null;
  if (_moreTriggerCharacter is EqualUnmodifiableListView) return _moreTriggerCharacter;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}


/// Create a copy of DocumentOnTypeFormattingRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentOnTypeFormattingRegistrationOptionsCopyWith<_DocumentOnTypeFormattingRegistrationOptions> get copyWith => __$DocumentOnTypeFormattingRegistrationOptionsCopyWithImpl<_DocumentOnTypeFormattingRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentOnTypeFormattingRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentOnTypeFormattingRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.firstTriggerCharacter, firstTriggerCharacter) || other.firstTriggerCharacter == firstTriggerCharacter)&&const DeepCollectionEquality().equals(other._moreTriggerCharacter, _moreTriggerCharacter));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),firstTriggerCharacter,const DeepCollectionEquality().hash(_moreTriggerCharacter));

@override
String toString() {
  return 'DocumentOnTypeFormattingRegistrationOptions(documentSelector: $documentSelector, firstTriggerCharacter: $firstTriggerCharacter, moreTriggerCharacter: $moreTriggerCharacter)';
}


}

/// @nodoc
abstract mixin class _$DocumentOnTypeFormattingRegistrationOptionsCopyWith<$Res> implements $DocumentOnTypeFormattingRegistrationOptionsCopyWith<$Res> {
  factory _$DocumentOnTypeFormattingRegistrationOptionsCopyWith(_DocumentOnTypeFormattingRegistrationOptions value, $Res Function(_DocumentOnTypeFormattingRegistrationOptions) _then) = __$DocumentOnTypeFormattingRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 dynamic documentSelector, String firstTriggerCharacter, List<String>? moreTriggerCharacter
});




}
/// @nodoc
class __$DocumentOnTypeFormattingRegistrationOptionsCopyWithImpl<$Res>
    implements _$DocumentOnTypeFormattingRegistrationOptionsCopyWith<$Res> {
  __$DocumentOnTypeFormattingRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _DocumentOnTypeFormattingRegistrationOptions _self;
  final $Res Function(_DocumentOnTypeFormattingRegistrationOptions) _then;

/// Create a copy of DocumentOnTypeFormattingRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = freezed,Object? firstTriggerCharacter = null,Object? moreTriggerCharacter = freezed,}) {
  return _then(_DocumentOnTypeFormattingRegistrationOptions(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,firstTriggerCharacter: null == firstTriggerCharacter ? _self.firstTriggerCharacter : firstTriggerCharacter // ignore: cast_nullable_to_non_nullable
as String,moreTriggerCharacter: freezed == moreTriggerCharacter ? _self._moreTriggerCharacter : moreTriggerCharacter // ignore: cast_nullable_to_non_nullable
as List<String>?,
  ));
}


}


/// @nodoc
mixin _$RenameParams {

 TextDocumentIdentifier get textDocument; Position get position; String get newName; ProgressToken? get workDoneToken;
/// Create a copy of RenameParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RenameParamsCopyWith<RenameParams> get copyWith => _$RenameParamsCopyWithImpl<RenameParams>(this as RenameParams, _$identity);

  /// Serializes this RenameParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RenameParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.position, position) || other.position == position)&&(identical(other.newName, newName) || other.newName == newName)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,position,newName,const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'RenameParams(textDocument: $textDocument, position: $position, newName: $newName, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $RenameParamsCopyWith<$Res>  {
  factory $RenameParamsCopyWith(RenameParams value, $Res Function(RenameParams) _then) = _$RenameParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument, Position position, String newName, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;$PositionCopyWith<$Res> get position;

}
/// @nodoc
class _$RenameParamsCopyWithImpl<$Res>
    implements $RenameParamsCopyWith<$Res> {
  _$RenameParamsCopyWithImpl(this._self, this._then);

  final RenameParams _self;
  final $Res Function(RenameParams) _then;

/// Create a copy of RenameParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? position = null,Object? newName = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,newName: null == newName ? _self.newName : newName // ignore: cast_nullable_to_non_nullable
as String,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of RenameParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of RenameParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _RenameParams implements RenameParams {
  const _RenameParams({required this.textDocument, required this.position, required this.newName, this.workDoneToken});
  factory _RenameParams.fromJson(Map<String, dynamic> json) => _$RenameParamsFromJson(json);

@override final  TextDocumentIdentifier textDocument;
@override final  Position position;
@override final  String newName;
@override final  ProgressToken? workDoneToken;

/// Create a copy of RenameParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RenameParamsCopyWith<_RenameParams> get copyWith => __$RenameParamsCopyWithImpl<_RenameParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$RenameParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _RenameParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.position, position) || other.position == position)&&(identical(other.newName, newName) || other.newName == newName)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,position,newName,const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'RenameParams(textDocument: $textDocument, position: $position, newName: $newName, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$RenameParamsCopyWith<$Res> implements $RenameParamsCopyWith<$Res> {
  factory _$RenameParamsCopyWith(_RenameParams value, $Res Function(_RenameParams) _then) = __$RenameParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument, Position position, String newName, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;@override $PositionCopyWith<$Res> get position;

}
/// @nodoc
class __$RenameParamsCopyWithImpl<$Res>
    implements _$RenameParamsCopyWith<$Res> {
  __$RenameParamsCopyWithImpl(this._self, this._then);

  final _RenameParams _self;
  final $Res Function(_RenameParams) _then;

/// Create a copy of RenameParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? position = null,Object? newName = null,Object? workDoneToken = freezed,}) {
  return _then(_RenameParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,newName: null == newName ? _self.newName : newName // ignore: cast_nullable_to_non_nullable
as String,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of RenameParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of RenameParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}
}


/// @nodoc
mixin _$RenameRegistrationOptions {

 dynamic get documentSelector; bool? get prepareProvider; bool? get workDoneProgress;
/// Create a copy of RenameRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RenameRegistrationOptionsCopyWith<RenameRegistrationOptions> get copyWith => _$RenameRegistrationOptionsCopyWithImpl<RenameRegistrationOptions>(this as RenameRegistrationOptions, _$identity);

  /// Serializes this RenameRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RenameRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.prepareProvider, prepareProvider) || other.prepareProvider == prepareProvider)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),prepareProvider,workDoneProgress);

@override
String toString() {
  return 'RenameRegistrationOptions(documentSelector: $documentSelector, prepareProvider: $prepareProvider, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $RenameRegistrationOptionsCopyWith<$Res>  {
  factory $RenameRegistrationOptionsCopyWith(RenameRegistrationOptions value, $Res Function(RenameRegistrationOptions) _then) = _$RenameRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 dynamic documentSelector, bool? prepareProvider, bool? workDoneProgress
});




}
/// @nodoc
class _$RenameRegistrationOptionsCopyWithImpl<$Res>
    implements $RenameRegistrationOptionsCopyWith<$Res> {
  _$RenameRegistrationOptionsCopyWithImpl(this._self, this._then);

  final RenameRegistrationOptions _self;
  final $Res Function(RenameRegistrationOptions) _then;

/// Create a copy of RenameRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = freezed,Object? prepareProvider = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,prepareProvider: freezed == prepareProvider ? _self.prepareProvider : prepareProvider // ignore: cast_nullable_to_non_nullable
as bool?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _RenameRegistrationOptions implements RenameRegistrationOptions {
  const _RenameRegistrationOptions({required this.documentSelector, this.prepareProvider, this.workDoneProgress});
  factory _RenameRegistrationOptions.fromJson(Map<String, dynamic> json) => _$RenameRegistrationOptionsFromJson(json);

@override final  dynamic documentSelector;
@override final  bool? prepareProvider;
@override final  bool? workDoneProgress;

/// Create a copy of RenameRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RenameRegistrationOptionsCopyWith<_RenameRegistrationOptions> get copyWith => __$RenameRegistrationOptionsCopyWithImpl<_RenameRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$RenameRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _RenameRegistrationOptions&&const DeepCollectionEquality().equals(other.documentSelector, documentSelector)&&(identical(other.prepareProvider, prepareProvider) || other.prepareProvider == prepareProvider)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(documentSelector),prepareProvider,workDoneProgress);

@override
String toString() {
  return 'RenameRegistrationOptions(documentSelector: $documentSelector, prepareProvider: $prepareProvider, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$RenameRegistrationOptionsCopyWith<$Res> implements $RenameRegistrationOptionsCopyWith<$Res> {
  factory _$RenameRegistrationOptionsCopyWith(_RenameRegistrationOptions value, $Res Function(_RenameRegistrationOptions) _then) = __$RenameRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 dynamic documentSelector, bool? prepareProvider, bool? workDoneProgress
});




}
/// @nodoc
class __$RenameRegistrationOptionsCopyWithImpl<$Res>
    implements _$RenameRegistrationOptionsCopyWith<$Res> {
  __$RenameRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _RenameRegistrationOptions _self;
  final $Res Function(_RenameRegistrationOptions) _then;

/// Create a copy of RenameRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = freezed,Object? prepareProvider = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_RenameRegistrationOptions(
documentSelector: freezed == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as dynamic,prepareProvider: freezed == prepareProvider ? _self.prepareProvider : prepareProvider // ignore: cast_nullable_to_non_nullable
as bool?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$PrepareRenameParams {

 TextDocumentIdentifier get textDocument; Position get position; ProgressToken? get workDoneToken;
/// Create a copy of PrepareRenameParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$PrepareRenameParamsCopyWith<PrepareRenameParams> get copyWith => _$PrepareRenameParamsCopyWithImpl<PrepareRenameParams>(this as PrepareRenameParams, _$identity);

  /// Serializes this PrepareRenameParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is PrepareRenameParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.position, position) || other.position == position)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,position,const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'PrepareRenameParams(textDocument: $textDocument, position: $position, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $PrepareRenameParamsCopyWith<$Res>  {
  factory $PrepareRenameParamsCopyWith(PrepareRenameParams value, $Res Function(PrepareRenameParams) _then) = _$PrepareRenameParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument, Position position, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;$PositionCopyWith<$Res> get position;

}
/// @nodoc
class _$PrepareRenameParamsCopyWithImpl<$Res>
    implements $PrepareRenameParamsCopyWith<$Res> {
  _$PrepareRenameParamsCopyWithImpl(this._self, this._then);

  final PrepareRenameParams _self;
  final $Res Function(PrepareRenameParams) _then;

/// Create a copy of PrepareRenameParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? position = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of PrepareRenameParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of PrepareRenameParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _PrepareRenameParams implements PrepareRenameParams {
  const _PrepareRenameParams({required this.textDocument, required this.position, this.workDoneToken});
  factory _PrepareRenameParams.fromJson(Map<String, dynamic> json) => _$PrepareRenameParamsFromJson(json);

@override final  TextDocumentIdentifier textDocument;
@override final  Position position;
@override final  ProgressToken? workDoneToken;

/// Create a copy of PrepareRenameParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$PrepareRenameParamsCopyWith<_PrepareRenameParams> get copyWith => __$PrepareRenameParamsCopyWithImpl<_PrepareRenameParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$PrepareRenameParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _PrepareRenameParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.position, position) || other.position == position)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,position,const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'PrepareRenameParams(textDocument: $textDocument, position: $position, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$PrepareRenameParamsCopyWith<$Res> implements $PrepareRenameParamsCopyWith<$Res> {
  factory _$PrepareRenameParamsCopyWith(_PrepareRenameParams value, $Res Function(_PrepareRenameParams) _then) = __$PrepareRenameParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument, Position position, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;@override $PositionCopyWith<$Res> get position;

}
/// @nodoc
class __$PrepareRenameParamsCopyWithImpl<$Res>
    implements _$PrepareRenameParamsCopyWith<$Res> {
  __$PrepareRenameParamsCopyWithImpl(this._self, this._then);

  final _PrepareRenameParams _self;
  final $Res Function(_PrepareRenameParams) _then;

/// Create a copy of PrepareRenameParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? position = null,Object? workDoneToken = freezed,}) {
  return _then(_PrepareRenameParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of PrepareRenameParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of PrepareRenameParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}
}


/// @nodoc
mixin _$ExecuteCommandParams {

 String get command; List<LSPAny>? get arguments; ProgressToken? get workDoneToken;
/// Create a copy of ExecuteCommandParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ExecuteCommandParamsCopyWith<ExecuteCommandParams> get copyWith => _$ExecuteCommandParamsCopyWithImpl<ExecuteCommandParams>(this as ExecuteCommandParams, _$identity);

  /// Serializes this ExecuteCommandParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ExecuteCommandParams&&(identical(other.command, command) || other.command == command)&&const DeepCollectionEquality().equals(other.arguments, arguments)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,command,const DeepCollectionEquality().hash(arguments),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'ExecuteCommandParams(command: $command, arguments: $arguments, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $ExecuteCommandParamsCopyWith<$Res>  {
  factory $ExecuteCommandParamsCopyWith(ExecuteCommandParams value, $Res Function(ExecuteCommandParams) _then) = _$ExecuteCommandParamsCopyWithImpl;
@useResult
$Res call({
 String command, List<LSPAny>? arguments, ProgressToken? workDoneToken
});




}
/// @nodoc
class _$ExecuteCommandParamsCopyWithImpl<$Res>
    implements $ExecuteCommandParamsCopyWith<$Res> {
  _$ExecuteCommandParamsCopyWithImpl(this._self, this._then);

  final ExecuteCommandParams _self;
  final $Res Function(ExecuteCommandParams) _then;

/// Create a copy of ExecuteCommandParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? command = null,Object? arguments = freezed,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
command: null == command ? _self.command : command // ignore: cast_nullable_to_non_nullable
as String,arguments: freezed == arguments ? _self.arguments : arguments // ignore: cast_nullable_to_non_nullable
as List<LSPAny>?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _ExecuteCommandParams implements ExecuteCommandParams {
  const _ExecuteCommandParams({required this.command, final  List<LSPAny>? arguments, this.workDoneToken}): _arguments = arguments;
  factory _ExecuteCommandParams.fromJson(Map<String, dynamic> json) => _$ExecuteCommandParamsFromJson(json);

@override final  String command;
 final  List<LSPAny>? _arguments;
@override List<LSPAny>? get arguments {
  final value = _arguments;
  if (value == null) return null;
  if (_arguments is EqualUnmodifiableListView) return _arguments;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

@override final  ProgressToken? workDoneToken;

/// Create a copy of ExecuteCommandParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ExecuteCommandParamsCopyWith<_ExecuteCommandParams> get copyWith => __$ExecuteCommandParamsCopyWithImpl<_ExecuteCommandParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ExecuteCommandParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ExecuteCommandParams&&(identical(other.command, command) || other.command == command)&&const DeepCollectionEquality().equals(other._arguments, _arguments)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,command,const DeepCollectionEquality().hash(_arguments),const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'ExecuteCommandParams(command: $command, arguments: $arguments, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$ExecuteCommandParamsCopyWith<$Res> implements $ExecuteCommandParamsCopyWith<$Res> {
  factory _$ExecuteCommandParamsCopyWith(_ExecuteCommandParams value, $Res Function(_ExecuteCommandParams) _then) = __$ExecuteCommandParamsCopyWithImpl;
@override @useResult
$Res call({
 String command, List<LSPAny>? arguments, ProgressToken? workDoneToken
});




}
/// @nodoc
class __$ExecuteCommandParamsCopyWithImpl<$Res>
    implements _$ExecuteCommandParamsCopyWith<$Res> {
  __$ExecuteCommandParamsCopyWithImpl(this._self, this._then);

  final _ExecuteCommandParams _self;
  final $Res Function(_ExecuteCommandParams) _then;

/// Create a copy of ExecuteCommandParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? command = null,Object? arguments = freezed,Object? workDoneToken = freezed,}) {
  return _then(_ExecuteCommandParams(
command: null == command ? _self.command : command // ignore: cast_nullable_to_non_nullable
as String,arguments: freezed == arguments ? _self._arguments : arguments // ignore: cast_nullable_to_non_nullable
as List<LSPAny>?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}


}


/// @nodoc
mixin _$ExecuteCommandRegistrationOptions {

 List<String> get commands; bool? get workDoneProgress;
/// Create a copy of ExecuteCommandRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ExecuteCommandRegistrationOptionsCopyWith<ExecuteCommandRegistrationOptions> get copyWith => _$ExecuteCommandRegistrationOptionsCopyWithImpl<ExecuteCommandRegistrationOptions>(this as ExecuteCommandRegistrationOptions, _$identity);

  /// Serializes this ExecuteCommandRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ExecuteCommandRegistrationOptions&&const DeepCollectionEquality().equals(other.commands, commands)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(commands),workDoneProgress);

@override
String toString() {
  return 'ExecuteCommandRegistrationOptions(commands: $commands, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $ExecuteCommandRegistrationOptionsCopyWith<$Res>  {
  factory $ExecuteCommandRegistrationOptionsCopyWith(ExecuteCommandRegistrationOptions value, $Res Function(ExecuteCommandRegistrationOptions) _then) = _$ExecuteCommandRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 List<String> commands, bool? workDoneProgress
});




}
/// @nodoc
class _$ExecuteCommandRegistrationOptionsCopyWithImpl<$Res>
    implements $ExecuteCommandRegistrationOptionsCopyWith<$Res> {
  _$ExecuteCommandRegistrationOptionsCopyWithImpl(this._self, this._then);

  final ExecuteCommandRegistrationOptions _self;
  final $Res Function(ExecuteCommandRegistrationOptions) _then;

/// Create a copy of ExecuteCommandRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? commands = null,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
commands: null == commands ? _self.commands : commands // ignore: cast_nullable_to_non_nullable
as List<String>,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _ExecuteCommandRegistrationOptions implements ExecuteCommandRegistrationOptions {
  const _ExecuteCommandRegistrationOptions({required final  List<String> commands, this.workDoneProgress}): _commands = commands;
  factory _ExecuteCommandRegistrationOptions.fromJson(Map<String, dynamic> json) => _$ExecuteCommandRegistrationOptionsFromJson(json);

 final  List<String> _commands;
@override List<String> get commands {
  if (_commands is EqualUnmodifiableListView) return _commands;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_commands);
}

@override final  bool? workDoneProgress;

/// Create a copy of ExecuteCommandRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ExecuteCommandRegistrationOptionsCopyWith<_ExecuteCommandRegistrationOptions> get copyWith => __$ExecuteCommandRegistrationOptionsCopyWithImpl<_ExecuteCommandRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ExecuteCommandRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ExecuteCommandRegistrationOptions&&const DeepCollectionEquality().equals(other._commands, _commands)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_commands),workDoneProgress);

@override
String toString() {
  return 'ExecuteCommandRegistrationOptions(commands: $commands, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$ExecuteCommandRegistrationOptionsCopyWith<$Res> implements $ExecuteCommandRegistrationOptionsCopyWith<$Res> {
  factory _$ExecuteCommandRegistrationOptionsCopyWith(_ExecuteCommandRegistrationOptions value, $Res Function(_ExecuteCommandRegistrationOptions) _then) = __$ExecuteCommandRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 List<String> commands, bool? workDoneProgress
});




}
/// @nodoc
class __$ExecuteCommandRegistrationOptionsCopyWithImpl<$Res>
    implements _$ExecuteCommandRegistrationOptionsCopyWith<$Res> {
  __$ExecuteCommandRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _ExecuteCommandRegistrationOptions _self;
  final $Res Function(_ExecuteCommandRegistrationOptions) _then;

/// Create a copy of ExecuteCommandRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? commands = null,Object? workDoneProgress = freezed,}) {
  return _then(_ExecuteCommandRegistrationOptions(
commands: null == commands ? _self._commands : commands // ignore: cast_nullable_to_non_nullable
as List<String>,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$ApplyWorkspaceEditParams {

 WorkspaceEdit get edit; String? get label;
/// Create a copy of ApplyWorkspaceEditParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ApplyWorkspaceEditParamsCopyWith<ApplyWorkspaceEditParams> get copyWith => _$ApplyWorkspaceEditParamsCopyWithImpl<ApplyWorkspaceEditParams>(this as ApplyWorkspaceEditParams, _$identity);

  /// Serializes this ApplyWorkspaceEditParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ApplyWorkspaceEditParams&&(identical(other.edit, edit) || other.edit == edit)&&(identical(other.label, label) || other.label == label));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,edit,label);

@override
String toString() {
  return 'ApplyWorkspaceEditParams(edit: $edit, label: $label)';
}


}

/// @nodoc
abstract mixin class $ApplyWorkspaceEditParamsCopyWith<$Res>  {
  factory $ApplyWorkspaceEditParamsCopyWith(ApplyWorkspaceEditParams value, $Res Function(ApplyWorkspaceEditParams) _then) = _$ApplyWorkspaceEditParamsCopyWithImpl;
@useResult
$Res call({
 WorkspaceEdit edit, String? label
});


$WorkspaceEditCopyWith<$Res> get edit;

}
/// @nodoc
class _$ApplyWorkspaceEditParamsCopyWithImpl<$Res>
    implements $ApplyWorkspaceEditParamsCopyWith<$Res> {
  _$ApplyWorkspaceEditParamsCopyWithImpl(this._self, this._then);

  final ApplyWorkspaceEditParams _self;
  final $Res Function(ApplyWorkspaceEditParams) _then;

/// Create a copy of ApplyWorkspaceEditParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? edit = null,Object? label = freezed,}) {
  return _then(_self.copyWith(
edit: null == edit ? _self.edit : edit // ignore: cast_nullable_to_non_nullable
as WorkspaceEdit,label: freezed == label ? _self.label : label // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}
/// Create a copy of ApplyWorkspaceEditParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$WorkspaceEditCopyWith<$Res> get edit {
  
  return $WorkspaceEditCopyWith<$Res>(_self.edit, (value) {
    return _then(_self.copyWith(edit: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _ApplyWorkspaceEditParams implements ApplyWorkspaceEditParams {
  const _ApplyWorkspaceEditParams({required this.edit, this.label});
  factory _ApplyWorkspaceEditParams.fromJson(Map<String, dynamic> json) => _$ApplyWorkspaceEditParamsFromJson(json);

@override final  WorkspaceEdit edit;
@override final  String? label;

/// Create a copy of ApplyWorkspaceEditParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ApplyWorkspaceEditParamsCopyWith<_ApplyWorkspaceEditParams> get copyWith => __$ApplyWorkspaceEditParamsCopyWithImpl<_ApplyWorkspaceEditParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ApplyWorkspaceEditParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ApplyWorkspaceEditParams&&(identical(other.edit, edit) || other.edit == edit)&&(identical(other.label, label) || other.label == label));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,edit,label);

@override
String toString() {
  return 'ApplyWorkspaceEditParams(edit: $edit, label: $label)';
}


}

/// @nodoc
abstract mixin class _$ApplyWorkspaceEditParamsCopyWith<$Res> implements $ApplyWorkspaceEditParamsCopyWith<$Res> {
  factory _$ApplyWorkspaceEditParamsCopyWith(_ApplyWorkspaceEditParams value, $Res Function(_ApplyWorkspaceEditParams) _then) = __$ApplyWorkspaceEditParamsCopyWithImpl;
@override @useResult
$Res call({
 WorkspaceEdit edit, String? label
});


@override $WorkspaceEditCopyWith<$Res> get edit;

}
/// @nodoc
class __$ApplyWorkspaceEditParamsCopyWithImpl<$Res>
    implements _$ApplyWorkspaceEditParamsCopyWith<$Res> {
  __$ApplyWorkspaceEditParamsCopyWithImpl(this._self, this._then);

  final _ApplyWorkspaceEditParams _self;
  final $Res Function(_ApplyWorkspaceEditParams) _then;

/// Create a copy of ApplyWorkspaceEditParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? edit = null,Object? label = freezed,}) {
  return _then(_ApplyWorkspaceEditParams(
edit: null == edit ? _self.edit : edit // ignore: cast_nullable_to_non_nullable
as WorkspaceEdit,label: freezed == label ? _self.label : label // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

/// Create a copy of ApplyWorkspaceEditParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$WorkspaceEditCopyWith<$Res> get edit {
  
  return $WorkspaceEditCopyWith<$Res>(_self.edit, (value) {
    return _then(_self.copyWith(edit: value));
  });
}
}


/// @nodoc
mixin _$ApplyWorkspaceEditResult {

 bool get applied; int? get failedChange; String? get failureReason;
/// Create a copy of ApplyWorkspaceEditResult
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ApplyWorkspaceEditResultCopyWith<ApplyWorkspaceEditResult> get copyWith => _$ApplyWorkspaceEditResultCopyWithImpl<ApplyWorkspaceEditResult>(this as ApplyWorkspaceEditResult, _$identity);

  /// Serializes this ApplyWorkspaceEditResult to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ApplyWorkspaceEditResult&&(identical(other.applied, applied) || other.applied == applied)&&(identical(other.failedChange, failedChange) || other.failedChange == failedChange)&&(identical(other.failureReason, failureReason) || other.failureReason == failureReason));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,applied,failedChange,failureReason);

@override
String toString() {
  return 'ApplyWorkspaceEditResult(applied: $applied, failedChange: $failedChange, failureReason: $failureReason)';
}


}

/// @nodoc
abstract mixin class $ApplyWorkspaceEditResultCopyWith<$Res>  {
  factory $ApplyWorkspaceEditResultCopyWith(ApplyWorkspaceEditResult value, $Res Function(ApplyWorkspaceEditResult) _then) = _$ApplyWorkspaceEditResultCopyWithImpl;
@useResult
$Res call({
 bool applied, int? failedChange, String? failureReason
});




}
/// @nodoc
class _$ApplyWorkspaceEditResultCopyWithImpl<$Res>
    implements $ApplyWorkspaceEditResultCopyWith<$Res> {
  _$ApplyWorkspaceEditResultCopyWithImpl(this._self, this._then);

  final ApplyWorkspaceEditResult _self;
  final $Res Function(ApplyWorkspaceEditResult) _then;

/// Create a copy of ApplyWorkspaceEditResult
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? applied = null,Object? failedChange = freezed,Object? failureReason = freezed,}) {
  return _then(_self.copyWith(
applied: null == applied ? _self.applied : applied // ignore: cast_nullable_to_non_nullable
as bool,failedChange: freezed == failedChange ? _self.failedChange : failedChange // ignore: cast_nullable_to_non_nullable
as int?,failureReason: freezed == failureReason ? _self.failureReason : failureReason // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _ApplyWorkspaceEditResult implements ApplyWorkspaceEditResult {
  const _ApplyWorkspaceEditResult({required this.applied, this.failedChange, this.failureReason});
  factory _ApplyWorkspaceEditResult.fromJson(Map<String, dynamic> json) => _$ApplyWorkspaceEditResultFromJson(json);

@override final  bool applied;
@override final  int? failedChange;
@override final  String? failureReason;

/// Create a copy of ApplyWorkspaceEditResult
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ApplyWorkspaceEditResultCopyWith<_ApplyWorkspaceEditResult> get copyWith => __$ApplyWorkspaceEditResultCopyWithImpl<_ApplyWorkspaceEditResult>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ApplyWorkspaceEditResultToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ApplyWorkspaceEditResult&&(identical(other.applied, applied) || other.applied == applied)&&(identical(other.failedChange, failedChange) || other.failedChange == failedChange)&&(identical(other.failureReason, failureReason) || other.failureReason == failureReason));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,applied,failedChange,failureReason);

@override
String toString() {
  return 'ApplyWorkspaceEditResult(applied: $applied, failedChange: $failedChange, failureReason: $failureReason)';
}


}

/// @nodoc
abstract mixin class _$ApplyWorkspaceEditResultCopyWith<$Res> implements $ApplyWorkspaceEditResultCopyWith<$Res> {
  factory _$ApplyWorkspaceEditResultCopyWith(_ApplyWorkspaceEditResult value, $Res Function(_ApplyWorkspaceEditResult) _then) = __$ApplyWorkspaceEditResultCopyWithImpl;
@override @useResult
$Res call({
 bool applied, int? failedChange, String? failureReason
});




}
/// @nodoc
class __$ApplyWorkspaceEditResultCopyWithImpl<$Res>
    implements _$ApplyWorkspaceEditResultCopyWith<$Res> {
  __$ApplyWorkspaceEditResultCopyWithImpl(this._self, this._then);

  final _ApplyWorkspaceEditResult _self;
  final $Res Function(_ApplyWorkspaceEditResult) _then;

/// Create a copy of ApplyWorkspaceEditResult
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? applied = null,Object? failedChange = freezed,Object? failureReason = freezed,}) {
  return _then(_ApplyWorkspaceEditResult(
applied: null == applied ? _self.applied : applied // ignore: cast_nullable_to_non_nullable
as bool,failedChange: freezed == failedChange ? _self.failedChange : failedChange // ignore: cast_nullable_to_non_nullable
as int?,failureReason: freezed == failureReason ? _self.failureReason : failureReason // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$WorkDoneProgressBegin {

 String get kind; String get title; int? get percentage; String? get message; bool? get cancellable;
/// Create a copy of WorkDoneProgressBegin
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkDoneProgressBeginCopyWith<WorkDoneProgressBegin> get copyWith => _$WorkDoneProgressBeginCopyWithImpl<WorkDoneProgressBegin>(this as WorkDoneProgressBegin, _$identity);

  /// Serializes this WorkDoneProgressBegin to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkDoneProgressBegin&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.title, title) || other.title == title)&&(identical(other.percentage, percentage) || other.percentage == percentage)&&(identical(other.message, message) || other.message == message)&&(identical(other.cancellable, cancellable) || other.cancellable == cancellable));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,kind,title,percentage,message,cancellable);

@override
String toString() {
  return 'WorkDoneProgressBegin(kind: $kind, title: $title, percentage: $percentage, message: $message, cancellable: $cancellable)';
}


}

/// @nodoc
abstract mixin class $WorkDoneProgressBeginCopyWith<$Res>  {
  factory $WorkDoneProgressBeginCopyWith(WorkDoneProgressBegin value, $Res Function(WorkDoneProgressBegin) _then) = _$WorkDoneProgressBeginCopyWithImpl;
@useResult
$Res call({
 String kind, String title, int? percentage, String? message, bool? cancellable
});




}
/// @nodoc
class _$WorkDoneProgressBeginCopyWithImpl<$Res>
    implements $WorkDoneProgressBeginCopyWith<$Res> {
  _$WorkDoneProgressBeginCopyWithImpl(this._self, this._then);

  final WorkDoneProgressBegin _self;
  final $Res Function(WorkDoneProgressBegin) _then;

/// Create a copy of WorkDoneProgressBegin
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? kind = null,Object? title = null,Object? percentage = freezed,Object? message = freezed,Object? cancellable = freezed,}) {
  return _then(_self.copyWith(
kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as String,title: null == title ? _self.title : title // ignore: cast_nullable_to_non_nullable
as String,percentage: freezed == percentage ? _self.percentage : percentage // ignore: cast_nullable_to_non_nullable
as int?,message: freezed == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String?,cancellable: freezed == cancellable ? _self.cancellable : cancellable // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _WorkDoneProgressBegin implements WorkDoneProgressBegin {
  const _WorkDoneProgressBegin({required this.kind, required this.title, this.percentage, this.message, this.cancellable});
  factory _WorkDoneProgressBegin.fromJson(Map<String, dynamic> json) => _$WorkDoneProgressBeginFromJson(json);

@override final  String kind;
@override final  String title;
@override final  int? percentage;
@override final  String? message;
@override final  bool? cancellable;

/// Create a copy of WorkDoneProgressBegin
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkDoneProgressBeginCopyWith<_WorkDoneProgressBegin> get copyWith => __$WorkDoneProgressBeginCopyWithImpl<_WorkDoneProgressBegin>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkDoneProgressBeginToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkDoneProgressBegin&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.title, title) || other.title == title)&&(identical(other.percentage, percentage) || other.percentage == percentage)&&(identical(other.message, message) || other.message == message)&&(identical(other.cancellable, cancellable) || other.cancellable == cancellable));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,kind,title,percentage,message,cancellable);

@override
String toString() {
  return 'WorkDoneProgressBegin(kind: $kind, title: $title, percentage: $percentage, message: $message, cancellable: $cancellable)';
}


}

/// @nodoc
abstract mixin class _$WorkDoneProgressBeginCopyWith<$Res> implements $WorkDoneProgressBeginCopyWith<$Res> {
  factory _$WorkDoneProgressBeginCopyWith(_WorkDoneProgressBegin value, $Res Function(_WorkDoneProgressBegin) _then) = __$WorkDoneProgressBeginCopyWithImpl;
@override @useResult
$Res call({
 String kind, String title, int? percentage, String? message, bool? cancellable
});




}
/// @nodoc
class __$WorkDoneProgressBeginCopyWithImpl<$Res>
    implements _$WorkDoneProgressBeginCopyWith<$Res> {
  __$WorkDoneProgressBeginCopyWithImpl(this._self, this._then);

  final _WorkDoneProgressBegin _self;
  final $Res Function(_WorkDoneProgressBegin) _then;

/// Create a copy of WorkDoneProgressBegin
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? kind = null,Object? title = null,Object? percentage = freezed,Object? message = freezed,Object? cancellable = freezed,}) {
  return _then(_WorkDoneProgressBegin(
kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as String,title: null == title ? _self.title : title // ignore: cast_nullable_to_non_nullable
as String,percentage: freezed == percentage ? _self.percentage : percentage // ignore: cast_nullable_to_non_nullable
as int?,message: freezed == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String?,cancellable: freezed == cancellable ? _self.cancellable : cancellable // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$WorkDoneProgressReport {

 String get kind; int? get percentage; String? get message; bool? get cancellable;
/// Create a copy of WorkDoneProgressReport
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkDoneProgressReportCopyWith<WorkDoneProgressReport> get copyWith => _$WorkDoneProgressReportCopyWithImpl<WorkDoneProgressReport>(this as WorkDoneProgressReport, _$identity);

  /// Serializes this WorkDoneProgressReport to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkDoneProgressReport&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.percentage, percentage) || other.percentage == percentage)&&(identical(other.message, message) || other.message == message)&&(identical(other.cancellable, cancellable) || other.cancellable == cancellable));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,kind,percentage,message,cancellable);

@override
String toString() {
  return 'WorkDoneProgressReport(kind: $kind, percentage: $percentage, message: $message, cancellable: $cancellable)';
}


}

/// @nodoc
abstract mixin class $WorkDoneProgressReportCopyWith<$Res>  {
  factory $WorkDoneProgressReportCopyWith(WorkDoneProgressReport value, $Res Function(WorkDoneProgressReport) _then) = _$WorkDoneProgressReportCopyWithImpl;
@useResult
$Res call({
 String kind, int? percentage, String? message, bool? cancellable
});




}
/// @nodoc
class _$WorkDoneProgressReportCopyWithImpl<$Res>
    implements $WorkDoneProgressReportCopyWith<$Res> {
  _$WorkDoneProgressReportCopyWithImpl(this._self, this._then);

  final WorkDoneProgressReport _self;
  final $Res Function(WorkDoneProgressReport) _then;

/// Create a copy of WorkDoneProgressReport
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? kind = null,Object? percentage = freezed,Object? message = freezed,Object? cancellable = freezed,}) {
  return _then(_self.copyWith(
kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as String,percentage: freezed == percentage ? _self.percentage : percentage // ignore: cast_nullable_to_non_nullable
as int?,message: freezed == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String?,cancellable: freezed == cancellable ? _self.cancellable : cancellable // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _WorkDoneProgressReport implements WorkDoneProgressReport {
  const _WorkDoneProgressReport({required this.kind, this.percentage, this.message, this.cancellable});
  factory _WorkDoneProgressReport.fromJson(Map<String, dynamic> json) => _$WorkDoneProgressReportFromJson(json);

@override final  String kind;
@override final  int? percentage;
@override final  String? message;
@override final  bool? cancellable;

/// Create a copy of WorkDoneProgressReport
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkDoneProgressReportCopyWith<_WorkDoneProgressReport> get copyWith => __$WorkDoneProgressReportCopyWithImpl<_WorkDoneProgressReport>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkDoneProgressReportToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkDoneProgressReport&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.percentage, percentage) || other.percentage == percentage)&&(identical(other.message, message) || other.message == message)&&(identical(other.cancellable, cancellable) || other.cancellable == cancellable));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,kind,percentage,message,cancellable);

@override
String toString() {
  return 'WorkDoneProgressReport(kind: $kind, percentage: $percentage, message: $message, cancellable: $cancellable)';
}


}

/// @nodoc
abstract mixin class _$WorkDoneProgressReportCopyWith<$Res> implements $WorkDoneProgressReportCopyWith<$Res> {
  factory _$WorkDoneProgressReportCopyWith(_WorkDoneProgressReport value, $Res Function(_WorkDoneProgressReport) _then) = __$WorkDoneProgressReportCopyWithImpl;
@override @useResult
$Res call({
 String kind, int? percentage, String? message, bool? cancellable
});




}
/// @nodoc
class __$WorkDoneProgressReportCopyWithImpl<$Res>
    implements _$WorkDoneProgressReportCopyWith<$Res> {
  __$WorkDoneProgressReportCopyWithImpl(this._self, this._then);

  final _WorkDoneProgressReport _self;
  final $Res Function(_WorkDoneProgressReport) _then;

/// Create a copy of WorkDoneProgressReport
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? kind = null,Object? percentage = freezed,Object? message = freezed,Object? cancellable = freezed,}) {
  return _then(_WorkDoneProgressReport(
kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as String,percentage: freezed == percentage ? _self.percentage : percentage // ignore: cast_nullable_to_non_nullable
as int?,message: freezed == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String?,cancellable: freezed == cancellable ? _self.cancellable : cancellable // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$WorkDoneProgressEnd {

 String get kind; String? get message;
/// Create a copy of WorkDoneProgressEnd
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkDoneProgressEndCopyWith<WorkDoneProgressEnd> get copyWith => _$WorkDoneProgressEndCopyWithImpl<WorkDoneProgressEnd>(this as WorkDoneProgressEnd, _$identity);

  /// Serializes this WorkDoneProgressEnd to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkDoneProgressEnd&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.message, message) || other.message == message));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,kind,message);

@override
String toString() {
  return 'WorkDoneProgressEnd(kind: $kind, message: $message)';
}


}

/// @nodoc
abstract mixin class $WorkDoneProgressEndCopyWith<$Res>  {
  factory $WorkDoneProgressEndCopyWith(WorkDoneProgressEnd value, $Res Function(WorkDoneProgressEnd) _then) = _$WorkDoneProgressEndCopyWithImpl;
@useResult
$Res call({
 String kind, String? message
});




}
/// @nodoc
class _$WorkDoneProgressEndCopyWithImpl<$Res>
    implements $WorkDoneProgressEndCopyWith<$Res> {
  _$WorkDoneProgressEndCopyWithImpl(this._self, this._then);

  final WorkDoneProgressEnd _self;
  final $Res Function(WorkDoneProgressEnd) _then;

/// Create a copy of WorkDoneProgressEnd
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? kind = null,Object? message = freezed,}) {
  return _then(_self.copyWith(
kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as String,message: freezed == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _WorkDoneProgressEnd implements WorkDoneProgressEnd {
  const _WorkDoneProgressEnd({required this.kind, this.message});
  factory _WorkDoneProgressEnd.fromJson(Map<String, dynamic> json) => _$WorkDoneProgressEndFromJson(json);

@override final  String kind;
@override final  String? message;

/// Create a copy of WorkDoneProgressEnd
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkDoneProgressEndCopyWith<_WorkDoneProgressEnd> get copyWith => __$WorkDoneProgressEndCopyWithImpl<_WorkDoneProgressEnd>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkDoneProgressEndToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkDoneProgressEnd&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.message, message) || other.message == message));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,kind,message);

@override
String toString() {
  return 'WorkDoneProgressEnd(kind: $kind, message: $message)';
}


}

/// @nodoc
abstract mixin class _$WorkDoneProgressEndCopyWith<$Res> implements $WorkDoneProgressEndCopyWith<$Res> {
  factory _$WorkDoneProgressEndCopyWith(_WorkDoneProgressEnd value, $Res Function(_WorkDoneProgressEnd) _then) = __$WorkDoneProgressEndCopyWithImpl;
@override @useResult
$Res call({
 String kind, String? message
});




}
/// @nodoc
class __$WorkDoneProgressEndCopyWithImpl<$Res>
    implements _$WorkDoneProgressEndCopyWith<$Res> {
  __$WorkDoneProgressEndCopyWithImpl(this._self, this._then);

  final _WorkDoneProgressEnd _self;
  final $Res Function(_WorkDoneProgressEnd) _then;

/// Create a copy of WorkDoneProgressEnd
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? kind = null,Object? message = freezed,}) {
  return _then(_WorkDoneProgressEnd(
kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as String,message: freezed == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$SetTraceParams {

 TraceValues get value;
/// Create a copy of SetTraceParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SetTraceParamsCopyWith<SetTraceParams> get copyWith => _$SetTraceParamsCopyWithImpl<SetTraceParams>(this as SetTraceParams, _$identity);

  /// Serializes this SetTraceParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SetTraceParams&&(identical(other.value, value) || other.value == value));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,value);

@override
String toString() {
  return 'SetTraceParams(value: $value)';
}


}

/// @nodoc
abstract mixin class $SetTraceParamsCopyWith<$Res>  {
  factory $SetTraceParamsCopyWith(SetTraceParams value, $Res Function(SetTraceParams) _then) = _$SetTraceParamsCopyWithImpl;
@useResult
$Res call({
 TraceValues value
});




}
/// @nodoc
class _$SetTraceParamsCopyWithImpl<$Res>
    implements $SetTraceParamsCopyWith<$Res> {
  _$SetTraceParamsCopyWithImpl(this._self, this._then);

  final SetTraceParams _self;
  final $Res Function(SetTraceParams) _then;

/// Create a copy of SetTraceParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? value = null,}) {
  return _then(_self.copyWith(
value: null == value ? _self.value : value // ignore: cast_nullable_to_non_nullable
as TraceValues,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _SetTraceParams implements SetTraceParams {
  const _SetTraceParams({required this.value});
  factory _SetTraceParams.fromJson(Map<String, dynamic> json) => _$SetTraceParamsFromJson(json);

@override final  TraceValues value;

/// Create a copy of SetTraceParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SetTraceParamsCopyWith<_SetTraceParams> get copyWith => __$SetTraceParamsCopyWithImpl<_SetTraceParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SetTraceParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SetTraceParams&&(identical(other.value, value) || other.value == value));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,value);

@override
String toString() {
  return 'SetTraceParams(value: $value)';
}


}

/// @nodoc
abstract mixin class _$SetTraceParamsCopyWith<$Res> implements $SetTraceParamsCopyWith<$Res> {
  factory _$SetTraceParamsCopyWith(_SetTraceParams value, $Res Function(_SetTraceParams) _then) = __$SetTraceParamsCopyWithImpl;
@override @useResult
$Res call({
 TraceValues value
});




}
/// @nodoc
class __$SetTraceParamsCopyWithImpl<$Res>
    implements _$SetTraceParamsCopyWith<$Res> {
  __$SetTraceParamsCopyWithImpl(this._self, this._then);

  final _SetTraceParams _self;
  final $Res Function(_SetTraceParams) _then;

/// Create a copy of SetTraceParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? value = null,}) {
  return _then(_SetTraceParams(
value: null == value ? _self.value : value // ignore: cast_nullable_to_non_nullable
as TraceValues,
  ));
}


}


/// @nodoc
mixin _$LogTraceParams {

 String get message; String? get verbose;
/// Create a copy of LogTraceParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LogTraceParamsCopyWith<LogTraceParams> get copyWith => _$LogTraceParamsCopyWithImpl<LogTraceParams>(this as LogTraceParams, _$identity);

  /// Serializes this LogTraceParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LogTraceParams&&(identical(other.message, message) || other.message == message)&&(identical(other.verbose, verbose) || other.verbose == verbose));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,message,verbose);

@override
String toString() {
  return 'LogTraceParams(message: $message, verbose: $verbose)';
}


}

/// @nodoc
abstract mixin class $LogTraceParamsCopyWith<$Res>  {
  factory $LogTraceParamsCopyWith(LogTraceParams value, $Res Function(LogTraceParams) _then) = _$LogTraceParamsCopyWithImpl;
@useResult
$Res call({
 String message, String? verbose
});




}
/// @nodoc
class _$LogTraceParamsCopyWithImpl<$Res>
    implements $LogTraceParamsCopyWith<$Res> {
  _$LogTraceParamsCopyWithImpl(this._self, this._then);

  final LogTraceParams _self;
  final $Res Function(LogTraceParams) _then;

/// Create a copy of LogTraceParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? message = null,Object? verbose = freezed,}) {
  return _then(_self.copyWith(
message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,verbose: freezed == verbose ? _self.verbose : verbose // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _LogTraceParams implements LogTraceParams {
  const _LogTraceParams({required this.message, this.verbose});
  factory _LogTraceParams.fromJson(Map<String, dynamic> json) => _$LogTraceParamsFromJson(json);

@override final  String message;
@override final  String? verbose;

/// Create a copy of LogTraceParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$LogTraceParamsCopyWith<_LogTraceParams> get copyWith => __$LogTraceParamsCopyWithImpl<_LogTraceParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$LogTraceParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _LogTraceParams&&(identical(other.message, message) || other.message == message)&&(identical(other.verbose, verbose) || other.verbose == verbose));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,message,verbose);

@override
String toString() {
  return 'LogTraceParams(message: $message, verbose: $verbose)';
}


}

/// @nodoc
abstract mixin class _$LogTraceParamsCopyWith<$Res> implements $LogTraceParamsCopyWith<$Res> {
  factory _$LogTraceParamsCopyWith(_LogTraceParams value, $Res Function(_LogTraceParams) _then) = __$LogTraceParamsCopyWithImpl;
@override @useResult
$Res call({
 String message, String? verbose
});




}
/// @nodoc
class __$LogTraceParamsCopyWithImpl<$Res>
    implements _$LogTraceParamsCopyWith<$Res> {
  __$LogTraceParamsCopyWithImpl(this._self, this._then);

  final _LogTraceParams _self;
  final $Res Function(_LogTraceParams) _then;

/// Create a copy of LogTraceParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? message = null,Object? verbose = freezed,}) {
  return _then(_LogTraceParams(
message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,verbose: freezed == verbose ? _self.verbose : verbose // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$CancelParams {

 dynamic get id;
/// Create a copy of CancelParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CancelParamsCopyWith<CancelParams> get copyWith => _$CancelParamsCopyWithImpl<CancelParams>(this as CancelParams, _$identity);

  /// Serializes this CancelParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CancelParams&&const DeepCollectionEquality().equals(other.id, id));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(id));

@override
String toString() {
  return 'CancelParams(id: $id)';
}


}

/// @nodoc
abstract mixin class $CancelParamsCopyWith<$Res>  {
  factory $CancelParamsCopyWith(CancelParams value, $Res Function(CancelParams) _then) = _$CancelParamsCopyWithImpl;
@useResult
$Res call({
 dynamic id
});




}
/// @nodoc
class _$CancelParamsCopyWithImpl<$Res>
    implements $CancelParamsCopyWith<$Res> {
  _$CancelParamsCopyWithImpl(this._self, this._then);

  final CancelParams _self;
  final $Res Function(CancelParams) _then;

/// Create a copy of CancelParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = freezed,}) {
  return _then(_self.copyWith(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as dynamic,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _CancelParams implements CancelParams {
  const _CancelParams({required this.id});
  factory _CancelParams.fromJson(Map<String, dynamic> json) => _$CancelParamsFromJson(json);

@override final  dynamic id;

/// Create a copy of CancelParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CancelParamsCopyWith<_CancelParams> get copyWith => __$CancelParamsCopyWithImpl<_CancelParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CancelParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CancelParams&&const DeepCollectionEquality().equals(other.id, id));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(id));

@override
String toString() {
  return 'CancelParams(id: $id)';
}


}

/// @nodoc
abstract mixin class _$CancelParamsCopyWith<$Res> implements $CancelParamsCopyWith<$Res> {
  factory _$CancelParamsCopyWith(_CancelParams value, $Res Function(_CancelParams) _then) = __$CancelParamsCopyWithImpl;
@override @useResult
$Res call({
 dynamic id
});




}
/// @nodoc
class __$CancelParamsCopyWithImpl<$Res>
    implements _$CancelParamsCopyWith<$Res> {
  __$CancelParamsCopyWithImpl(this._self, this._then);

  final _CancelParams _self;
  final $Res Function(_CancelParams) _then;

/// Create a copy of CancelParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = freezed,}) {
  return _then(_CancelParams(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as dynamic,
  ));
}


}


/// @nodoc
mixin _$ProgressParams {

 ProgressToken get token; LSPAny get value;
/// Create a copy of ProgressParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ProgressParamsCopyWith<ProgressParams> get copyWith => _$ProgressParamsCopyWithImpl<ProgressParams>(this as ProgressParams, _$identity);

  /// Serializes this ProgressParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ProgressParams&&const DeepCollectionEquality().equals(other.token, token)&&const DeepCollectionEquality().equals(other.value, value));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(token),const DeepCollectionEquality().hash(value));

@override
String toString() {
  return 'ProgressParams(token: $token, value: $value)';
}


}

/// @nodoc
abstract mixin class $ProgressParamsCopyWith<$Res>  {
  factory $ProgressParamsCopyWith(ProgressParams value, $Res Function(ProgressParams) _then) = _$ProgressParamsCopyWithImpl;
@useResult
$Res call({
 ProgressToken token, LSPAny value
});




}
/// @nodoc
class _$ProgressParamsCopyWithImpl<$Res>
    implements $ProgressParamsCopyWith<$Res> {
  _$ProgressParamsCopyWithImpl(this._self, this._then);

  final ProgressParams _self;
  final $Res Function(ProgressParams) _then;

/// Create a copy of ProgressParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? token = freezed,Object? value = freezed,}) {
  return _then(_self.copyWith(
token: freezed == token ? _self.token : token // ignore: cast_nullable_to_non_nullable
as ProgressToken,value: freezed == value ? _self.value : value // ignore: cast_nullable_to_non_nullable
as LSPAny,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _ProgressParams implements ProgressParams {
  const _ProgressParams({required this.token, required this.value});
  factory _ProgressParams.fromJson(Map<String, dynamic> json) => _$ProgressParamsFromJson(json);

@override final  ProgressToken token;
@override final  LSPAny value;

/// Create a copy of ProgressParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ProgressParamsCopyWith<_ProgressParams> get copyWith => __$ProgressParamsCopyWithImpl<_ProgressParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ProgressParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ProgressParams&&const DeepCollectionEquality().equals(other.token, token)&&const DeepCollectionEquality().equals(other.value, value));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(token),const DeepCollectionEquality().hash(value));

@override
String toString() {
  return 'ProgressParams(token: $token, value: $value)';
}


}

/// @nodoc
abstract mixin class _$ProgressParamsCopyWith<$Res> implements $ProgressParamsCopyWith<$Res> {
  factory _$ProgressParamsCopyWith(_ProgressParams value, $Res Function(_ProgressParams) _then) = __$ProgressParamsCopyWithImpl;
@override @useResult
$Res call({
 ProgressToken token, LSPAny value
});




}
/// @nodoc
class __$ProgressParamsCopyWithImpl<$Res>
    implements _$ProgressParamsCopyWith<$Res> {
  __$ProgressParamsCopyWithImpl(this._self, this._then);

  final _ProgressParams _self;
  final $Res Function(_ProgressParams) _then;

/// Create a copy of ProgressParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? token = freezed,Object? value = freezed,}) {
  return _then(_ProgressParams(
token: freezed == token ? _self.token : token // ignore: cast_nullable_to_non_nullable
as ProgressToken,value: freezed == value ? _self.value : value // ignore: cast_nullable_to_non_nullable
as LSPAny,
  ));
}


}


/// @nodoc
mixin _$TextDocumentPositionParams {

 TextDocumentIdentifier get textDocument; Position get position;
/// Create a copy of TextDocumentPositionParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TextDocumentPositionParamsCopyWith<TextDocumentPositionParams> get copyWith => _$TextDocumentPositionParamsCopyWithImpl<TextDocumentPositionParams>(this as TextDocumentPositionParams, _$identity);

  /// Serializes this TextDocumentPositionParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TextDocumentPositionParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.position, position) || other.position == position));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,position);

@override
String toString() {
  return 'TextDocumentPositionParams(textDocument: $textDocument, position: $position)';
}


}

/// @nodoc
abstract mixin class $TextDocumentPositionParamsCopyWith<$Res>  {
  factory $TextDocumentPositionParamsCopyWith(TextDocumentPositionParams value, $Res Function(TextDocumentPositionParams) _then) = _$TextDocumentPositionParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument, Position position
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;$PositionCopyWith<$Res> get position;

}
/// @nodoc
class _$TextDocumentPositionParamsCopyWithImpl<$Res>
    implements $TextDocumentPositionParamsCopyWith<$Res> {
  _$TextDocumentPositionParamsCopyWithImpl(this._self, this._then);

  final TextDocumentPositionParams _self;
  final $Res Function(TextDocumentPositionParams) _then;

/// Create a copy of TextDocumentPositionParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? position = null,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,
  ));
}
/// Create a copy of TextDocumentPositionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of TextDocumentPositionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _TextDocumentPositionParams implements TextDocumentPositionParams {
  const _TextDocumentPositionParams({required this.textDocument, required this.position});
  factory _TextDocumentPositionParams.fromJson(Map<String, dynamic> json) => _$TextDocumentPositionParamsFromJson(json);

@override final  TextDocumentIdentifier textDocument;
@override final  Position position;

/// Create a copy of TextDocumentPositionParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TextDocumentPositionParamsCopyWith<_TextDocumentPositionParams> get copyWith => __$TextDocumentPositionParamsCopyWithImpl<_TextDocumentPositionParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TextDocumentPositionParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TextDocumentPositionParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.position, position) || other.position == position));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,position);

@override
String toString() {
  return 'TextDocumentPositionParams(textDocument: $textDocument, position: $position)';
}


}

/// @nodoc
abstract mixin class _$TextDocumentPositionParamsCopyWith<$Res> implements $TextDocumentPositionParamsCopyWith<$Res> {
  factory _$TextDocumentPositionParamsCopyWith(_TextDocumentPositionParams value, $Res Function(_TextDocumentPositionParams) _then) = __$TextDocumentPositionParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument, Position position
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;@override $PositionCopyWith<$Res> get position;

}
/// @nodoc
class __$TextDocumentPositionParamsCopyWithImpl<$Res>
    implements _$TextDocumentPositionParamsCopyWith<$Res> {
  __$TextDocumentPositionParamsCopyWithImpl(this._self, this._then);

  final _TextDocumentPositionParams _self;
  final $Res Function(_TextDocumentPositionParams) _then;

/// Create a copy of TextDocumentPositionParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? position = null,}) {
  return _then(_TextDocumentPositionParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,
  ));
}

/// Create a copy of TextDocumentPositionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of TextDocumentPositionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}
}


/// @nodoc
mixin _$WorkDoneProgressParams {

 ProgressToken? get workDoneToken;
/// Create a copy of WorkDoneProgressParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkDoneProgressParamsCopyWith<WorkDoneProgressParams> get copyWith => _$WorkDoneProgressParamsCopyWithImpl<WorkDoneProgressParams>(this as WorkDoneProgressParams, _$identity);

  /// Serializes this WorkDoneProgressParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkDoneProgressParams&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'WorkDoneProgressParams(workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $WorkDoneProgressParamsCopyWith<$Res>  {
  factory $WorkDoneProgressParamsCopyWith(WorkDoneProgressParams value, $Res Function(WorkDoneProgressParams) _then) = _$WorkDoneProgressParamsCopyWithImpl;
@useResult
$Res call({
 ProgressToken? workDoneToken
});




}
/// @nodoc
class _$WorkDoneProgressParamsCopyWithImpl<$Res>
    implements $WorkDoneProgressParamsCopyWith<$Res> {
  _$WorkDoneProgressParamsCopyWithImpl(this._self, this._then);

  final WorkDoneProgressParams _self;
  final $Res Function(WorkDoneProgressParams) _then;

/// Create a copy of WorkDoneProgressParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _WorkDoneProgressParams implements WorkDoneProgressParams {
  const _WorkDoneProgressParams({this.workDoneToken});
  factory _WorkDoneProgressParams.fromJson(Map<String, dynamic> json) => _$WorkDoneProgressParamsFromJson(json);

@override final  ProgressToken? workDoneToken;

/// Create a copy of WorkDoneProgressParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkDoneProgressParamsCopyWith<_WorkDoneProgressParams> get copyWith => __$WorkDoneProgressParamsCopyWithImpl<_WorkDoneProgressParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkDoneProgressParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkDoneProgressParams&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'WorkDoneProgressParams(workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$WorkDoneProgressParamsCopyWith<$Res> implements $WorkDoneProgressParamsCopyWith<$Res> {
  factory _$WorkDoneProgressParamsCopyWith(_WorkDoneProgressParams value, $Res Function(_WorkDoneProgressParams) _then) = __$WorkDoneProgressParamsCopyWithImpl;
@override @useResult
$Res call({
 ProgressToken? workDoneToken
});




}
/// @nodoc
class __$WorkDoneProgressParamsCopyWithImpl<$Res>
    implements _$WorkDoneProgressParamsCopyWith<$Res> {
  __$WorkDoneProgressParamsCopyWithImpl(this._self, this._then);

  final _WorkDoneProgressParams _self;
  final $Res Function(_WorkDoneProgressParams) _then;

/// Create a copy of WorkDoneProgressParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workDoneToken = freezed,}) {
  return _then(_WorkDoneProgressParams(
workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}


}


/// @nodoc
mixin _$PartialResultParams {

 ProgressToken? get partialResultToken;
/// Create a copy of PartialResultParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$PartialResultParamsCopyWith<PartialResultParams> get copyWith => _$PartialResultParamsCopyWithImpl<PartialResultParams>(this as PartialResultParams, _$identity);

  /// Serializes this PartialResultParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is PartialResultParams&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(partialResultToken));

@override
String toString() {
  return 'PartialResultParams(partialResultToken: $partialResultToken)';
}


}

/// @nodoc
abstract mixin class $PartialResultParamsCopyWith<$Res>  {
  factory $PartialResultParamsCopyWith(PartialResultParams value, $Res Function(PartialResultParams) _then) = _$PartialResultParamsCopyWithImpl;
@useResult
$Res call({
 ProgressToken? partialResultToken
});




}
/// @nodoc
class _$PartialResultParamsCopyWithImpl<$Res>
    implements $PartialResultParamsCopyWith<$Res> {
  _$PartialResultParamsCopyWithImpl(this._self, this._then);

  final PartialResultParams _self;
  final $Res Function(PartialResultParams) _then;

/// Create a copy of PartialResultParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? partialResultToken = freezed,}) {
  return _then(_self.copyWith(
partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _PartialResultParams implements PartialResultParams {
  const _PartialResultParams({this.partialResultToken});
  factory _PartialResultParams.fromJson(Map<String, dynamic> json) => _$PartialResultParamsFromJson(json);

@override final  ProgressToken? partialResultToken;

/// Create a copy of PartialResultParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$PartialResultParamsCopyWith<_PartialResultParams> get copyWith => __$PartialResultParamsCopyWithImpl<_PartialResultParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$PartialResultParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _PartialResultParams&&const DeepCollectionEquality().equals(other.partialResultToken, partialResultToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(partialResultToken));

@override
String toString() {
  return 'PartialResultParams(partialResultToken: $partialResultToken)';
}


}

/// @nodoc
abstract mixin class _$PartialResultParamsCopyWith<$Res> implements $PartialResultParamsCopyWith<$Res> {
  factory _$PartialResultParamsCopyWith(_PartialResultParams value, $Res Function(_PartialResultParams) _then) = __$PartialResultParamsCopyWithImpl;
@override @useResult
$Res call({
 ProgressToken? partialResultToken
});




}
/// @nodoc
class __$PartialResultParamsCopyWithImpl<$Res>
    implements _$PartialResultParamsCopyWith<$Res> {
  __$PartialResultParamsCopyWithImpl(this._self, this._then);

  final _PartialResultParams _self;
  final $Res Function(_PartialResultParams) _then;

/// Create a copy of PartialResultParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? partialResultToken = freezed,}) {
  return _then(_PartialResultParams(
partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}


}


/// @nodoc
mixin _$LocationLink {

 String get targetUri; Range get targetRange; Range get targetSelectionRange; Range? get originSelectionRange;
/// Create a copy of LocationLink
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LocationLinkCopyWith<LocationLink> get copyWith => _$LocationLinkCopyWithImpl<LocationLink>(this as LocationLink, _$identity);

  /// Serializes this LocationLink to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LocationLink&&(identical(other.targetUri, targetUri) || other.targetUri == targetUri)&&(identical(other.targetRange, targetRange) || other.targetRange == targetRange)&&(identical(other.targetSelectionRange, targetSelectionRange) || other.targetSelectionRange == targetSelectionRange)&&(identical(other.originSelectionRange, originSelectionRange) || other.originSelectionRange == originSelectionRange));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,targetUri,targetRange,targetSelectionRange,originSelectionRange);

@override
String toString() {
  return 'LocationLink(targetUri: $targetUri, targetRange: $targetRange, targetSelectionRange: $targetSelectionRange, originSelectionRange: $originSelectionRange)';
}


}

/// @nodoc
abstract mixin class $LocationLinkCopyWith<$Res>  {
  factory $LocationLinkCopyWith(LocationLink value, $Res Function(LocationLink) _then) = _$LocationLinkCopyWithImpl;
@useResult
$Res call({
 String targetUri, Range targetRange, Range targetSelectionRange, Range? originSelectionRange
});


$RangeCopyWith<$Res> get targetRange;$RangeCopyWith<$Res> get targetSelectionRange;$RangeCopyWith<$Res>? get originSelectionRange;

}
/// @nodoc
class _$LocationLinkCopyWithImpl<$Res>
    implements $LocationLinkCopyWith<$Res> {
  _$LocationLinkCopyWithImpl(this._self, this._then);

  final LocationLink _self;
  final $Res Function(LocationLink) _then;

/// Create a copy of LocationLink
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? targetUri = null,Object? targetRange = null,Object? targetSelectionRange = null,Object? originSelectionRange = freezed,}) {
  return _then(_self.copyWith(
targetUri: null == targetUri ? _self.targetUri : targetUri // ignore: cast_nullable_to_non_nullable
as String,targetRange: null == targetRange ? _self.targetRange : targetRange // ignore: cast_nullable_to_non_nullable
as Range,targetSelectionRange: null == targetSelectionRange ? _self.targetSelectionRange : targetSelectionRange // ignore: cast_nullable_to_non_nullable
as Range,originSelectionRange: freezed == originSelectionRange ? _self.originSelectionRange : originSelectionRange // ignore: cast_nullable_to_non_nullable
as Range?,
  ));
}
/// Create a copy of LocationLink
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get targetRange {
  
  return $RangeCopyWith<$Res>(_self.targetRange, (value) {
    return _then(_self.copyWith(targetRange: value));
  });
}/// Create a copy of LocationLink
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get targetSelectionRange {
  
  return $RangeCopyWith<$Res>(_self.targetSelectionRange, (value) {
    return _then(_self.copyWith(targetSelectionRange: value));
  });
}/// Create a copy of LocationLink
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res>? get originSelectionRange {
    if (_self.originSelectionRange == null) {
    return null;
  }

  return $RangeCopyWith<$Res>(_self.originSelectionRange!, (value) {
    return _then(_self.copyWith(originSelectionRange: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _LocationLink implements LocationLink {
  const _LocationLink({required this.targetUri, required this.targetRange, required this.targetSelectionRange, this.originSelectionRange});
  factory _LocationLink.fromJson(Map<String, dynamic> json) => _$LocationLinkFromJson(json);

@override final  String targetUri;
@override final  Range targetRange;
@override final  Range targetSelectionRange;
@override final  Range? originSelectionRange;

/// Create a copy of LocationLink
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$LocationLinkCopyWith<_LocationLink> get copyWith => __$LocationLinkCopyWithImpl<_LocationLink>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$LocationLinkToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _LocationLink&&(identical(other.targetUri, targetUri) || other.targetUri == targetUri)&&(identical(other.targetRange, targetRange) || other.targetRange == targetRange)&&(identical(other.targetSelectionRange, targetSelectionRange) || other.targetSelectionRange == targetSelectionRange)&&(identical(other.originSelectionRange, originSelectionRange) || other.originSelectionRange == originSelectionRange));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,targetUri,targetRange,targetSelectionRange,originSelectionRange);

@override
String toString() {
  return 'LocationLink(targetUri: $targetUri, targetRange: $targetRange, targetSelectionRange: $targetSelectionRange, originSelectionRange: $originSelectionRange)';
}


}

/// @nodoc
abstract mixin class _$LocationLinkCopyWith<$Res> implements $LocationLinkCopyWith<$Res> {
  factory _$LocationLinkCopyWith(_LocationLink value, $Res Function(_LocationLink) _then) = __$LocationLinkCopyWithImpl;
@override @useResult
$Res call({
 String targetUri, Range targetRange, Range targetSelectionRange, Range? originSelectionRange
});


@override $RangeCopyWith<$Res> get targetRange;@override $RangeCopyWith<$Res> get targetSelectionRange;@override $RangeCopyWith<$Res>? get originSelectionRange;

}
/// @nodoc
class __$LocationLinkCopyWithImpl<$Res>
    implements _$LocationLinkCopyWith<$Res> {
  __$LocationLinkCopyWithImpl(this._self, this._then);

  final _LocationLink _self;
  final $Res Function(_LocationLink) _then;

/// Create a copy of LocationLink
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? targetUri = null,Object? targetRange = null,Object? targetSelectionRange = null,Object? originSelectionRange = freezed,}) {
  return _then(_LocationLink(
targetUri: null == targetUri ? _self.targetUri : targetUri // ignore: cast_nullable_to_non_nullable
as String,targetRange: null == targetRange ? _self.targetRange : targetRange // ignore: cast_nullable_to_non_nullable
as Range,targetSelectionRange: null == targetSelectionRange ? _self.targetSelectionRange : targetSelectionRange // ignore: cast_nullable_to_non_nullable
as Range,originSelectionRange: freezed == originSelectionRange ? _self.originSelectionRange : originSelectionRange // ignore: cast_nullable_to_non_nullable
as Range?,
  ));
}

/// Create a copy of LocationLink
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get targetRange {
  
  return $RangeCopyWith<$Res>(_self.targetRange, (value) {
    return _then(_self.copyWith(targetRange: value));
  });
}/// Create a copy of LocationLink
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get targetSelectionRange {
  
  return $RangeCopyWith<$Res>(_self.targetSelectionRange, (value) {
    return _then(_self.copyWith(targetSelectionRange: value));
  });
}/// Create a copy of LocationLink
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res>? get originSelectionRange {
    if (_self.originSelectionRange == null) {
    return null;
  }

  return $RangeCopyWith<$Res>(_self.originSelectionRange!, (value) {
    return _then(_self.copyWith(originSelectionRange: value));
  });
}
}


/// @nodoc
mixin _$Range {

 Position get start; Position get end;
/// Create a copy of Range
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RangeCopyWith<Range> get copyWith => _$RangeCopyWithImpl<Range>(this as Range, _$identity);

  /// Serializes this Range to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Range&&(identical(other.start, start) || other.start == start)&&(identical(other.end, end) || other.end == end));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,start,end);

@override
String toString() {
  return 'Range(start: $start, end: $end)';
}


}

/// @nodoc
abstract mixin class $RangeCopyWith<$Res>  {
  factory $RangeCopyWith(Range value, $Res Function(Range) _then) = _$RangeCopyWithImpl;
@useResult
$Res call({
 Position start, Position end
});


$PositionCopyWith<$Res> get start;$PositionCopyWith<$Res> get end;

}
/// @nodoc
class _$RangeCopyWithImpl<$Res>
    implements $RangeCopyWith<$Res> {
  _$RangeCopyWithImpl(this._self, this._then);

  final Range _self;
  final $Res Function(Range) _then;

/// Create a copy of Range
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? start = null,Object? end = null,}) {
  return _then(_self.copyWith(
start: null == start ? _self.start : start // ignore: cast_nullable_to_non_nullable
as Position,end: null == end ? _self.end : end // ignore: cast_nullable_to_non_nullable
as Position,
  ));
}
/// Create a copy of Range
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get start {
  
  return $PositionCopyWith<$Res>(_self.start, (value) {
    return _then(_self.copyWith(start: value));
  });
}/// Create a copy of Range
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get end {
  
  return $PositionCopyWith<$Res>(_self.end, (value) {
    return _then(_self.copyWith(end: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _Range implements Range {
  const _Range({required this.start, required this.end});
  factory _Range.fromJson(Map<String, dynamic> json) => _$RangeFromJson(json);

@override final  Position start;
@override final  Position end;

/// Create a copy of Range
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RangeCopyWith<_Range> get copyWith => __$RangeCopyWithImpl<_Range>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$RangeToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _Range&&(identical(other.start, start) || other.start == start)&&(identical(other.end, end) || other.end == end));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,start,end);

@override
String toString() {
  return 'Range(start: $start, end: $end)';
}


}

/// @nodoc
abstract mixin class _$RangeCopyWith<$Res> implements $RangeCopyWith<$Res> {
  factory _$RangeCopyWith(_Range value, $Res Function(_Range) _then) = __$RangeCopyWithImpl;
@override @useResult
$Res call({
 Position start, Position end
});


@override $PositionCopyWith<$Res> get start;@override $PositionCopyWith<$Res> get end;

}
/// @nodoc
class __$RangeCopyWithImpl<$Res>
    implements _$RangeCopyWith<$Res> {
  __$RangeCopyWithImpl(this._self, this._then);

  final _Range _self;
  final $Res Function(_Range) _then;

/// Create a copy of Range
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? start = null,Object? end = null,}) {
  return _then(_Range(
start: null == start ? _self.start : start // ignore: cast_nullable_to_non_nullable
as Position,end: null == end ? _self.end : end // ignore: cast_nullable_to_non_nullable
as Position,
  ));
}

/// Create a copy of Range
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get start {
  
  return $PositionCopyWith<$Res>(_self.start, (value) {
    return _then(_self.copyWith(start: value));
  });
}/// Create a copy of Range
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get end {
  
  return $PositionCopyWith<$Res>(_self.end, (value) {
    return _then(_self.copyWith(end: value));
  });
}
}


/// @nodoc
mixin _$ImplementationOptions {

 bool? get workDoneProgress;
/// Create a copy of ImplementationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ImplementationOptionsCopyWith<ImplementationOptions> get copyWith => _$ImplementationOptionsCopyWithImpl<ImplementationOptions>(this as ImplementationOptions, _$identity);

  /// Serializes this ImplementationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ImplementationOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'ImplementationOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $ImplementationOptionsCopyWith<$Res>  {
  factory $ImplementationOptionsCopyWith(ImplementationOptions value, $Res Function(ImplementationOptions) _then) = _$ImplementationOptionsCopyWithImpl;
@useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class _$ImplementationOptionsCopyWithImpl<$Res>
    implements $ImplementationOptionsCopyWith<$Res> {
  _$ImplementationOptionsCopyWithImpl(this._self, this._then);

  final ImplementationOptions _self;
  final $Res Function(ImplementationOptions) _then;

/// Create a copy of ImplementationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _ImplementationOptions implements ImplementationOptions {
  const _ImplementationOptions({this.workDoneProgress});
  factory _ImplementationOptions.fromJson(Map<String, dynamic> json) => _$ImplementationOptionsFromJson(json);

@override final  bool? workDoneProgress;

/// Create a copy of ImplementationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ImplementationOptionsCopyWith<_ImplementationOptions> get copyWith => __$ImplementationOptionsCopyWithImpl<_ImplementationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ImplementationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ImplementationOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'ImplementationOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$ImplementationOptionsCopyWith<$Res> implements $ImplementationOptionsCopyWith<$Res> {
  factory _$ImplementationOptionsCopyWith(_ImplementationOptions value, $Res Function(_ImplementationOptions) _then) = __$ImplementationOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class __$ImplementationOptionsCopyWithImpl<$Res>
    implements _$ImplementationOptionsCopyWith<$Res> {
  __$ImplementationOptionsCopyWithImpl(this._self, this._then);

  final _ImplementationOptions _self;
  final $Res Function(_ImplementationOptions) _then;

/// Create a copy of ImplementationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_ImplementationOptions(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$StaticRegistrationOptions {

 String? get id;
/// Create a copy of StaticRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$StaticRegistrationOptionsCopyWith<StaticRegistrationOptions> get copyWith => _$StaticRegistrationOptionsCopyWithImpl<StaticRegistrationOptions>(this as StaticRegistrationOptions, _$identity);

  /// Serializes this StaticRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is StaticRegistrationOptions&&(identical(other.id, id) || other.id == id));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id);

@override
String toString() {
  return 'StaticRegistrationOptions(id: $id)';
}


}

/// @nodoc
abstract mixin class $StaticRegistrationOptionsCopyWith<$Res>  {
  factory $StaticRegistrationOptionsCopyWith(StaticRegistrationOptions value, $Res Function(StaticRegistrationOptions) _then) = _$StaticRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 String? id
});




}
/// @nodoc
class _$StaticRegistrationOptionsCopyWithImpl<$Res>
    implements $StaticRegistrationOptionsCopyWith<$Res> {
  _$StaticRegistrationOptionsCopyWithImpl(this._self, this._then);

  final StaticRegistrationOptions _self;
  final $Res Function(StaticRegistrationOptions) _then;

/// Create a copy of StaticRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = freezed,}) {
  return _then(_self.copyWith(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _StaticRegistrationOptions implements StaticRegistrationOptions {
  const _StaticRegistrationOptions({this.id});
  factory _StaticRegistrationOptions.fromJson(Map<String, dynamic> json) => _$StaticRegistrationOptionsFromJson(json);

@override final  String? id;

/// Create a copy of StaticRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$StaticRegistrationOptionsCopyWith<_StaticRegistrationOptions> get copyWith => __$StaticRegistrationOptionsCopyWithImpl<_StaticRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$StaticRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _StaticRegistrationOptions&&(identical(other.id, id) || other.id == id));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id);

@override
String toString() {
  return 'StaticRegistrationOptions(id: $id)';
}


}

/// @nodoc
abstract mixin class _$StaticRegistrationOptionsCopyWith<$Res> implements $StaticRegistrationOptionsCopyWith<$Res> {
  factory _$StaticRegistrationOptionsCopyWith(_StaticRegistrationOptions value, $Res Function(_StaticRegistrationOptions) _then) = __$StaticRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 String? id
});




}
/// @nodoc
class __$StaticRegistrationOptionsCopyWithImpl<$Res>
    implements _$StaticRegistrationOptionsCopyWith<$Res> {
  __$StaticRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _StaticRegistrationOptions _self;
  final $Res Function(_StaticRegistrationOptions) _then;

/// Create a copy of StaticRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = freezed,}) {
  return _then(_StaticRegistrationOptions(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$TypeDefinitionOptions {

 bool? get workDoneProgress;
/// Create a copy of TypeDefinitionOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TypeDefinitionOptionsCopyWith<TypeDefinitionOptions> get copyWith => _$TypeDefinitionOptionsCopyWithImpl<TypeDefinitionOptions>(this as TypeDefinitionOptions, _$identity);

  /// Serializes this TypeDefinitionOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TypeDefinitionOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'TypeDefinitionOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $TypeDefinitionOptionsCopyWith<$Res>  {
  factory $TypeDefinitionOptionsCopyWith(TypeDefinitionOptions value, $Res Function(TypeDefinitionOptions) _then) = _$TypeDefinitionOptionsCopyWithImpl;
@useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class _$TypeDefinitionOptionsCopyWithImpl<$Res>
    implements $TypeDefinitionOptionsCopyWith<$Res> {
  _$TypeDefinitionOptionsCopyWithImpl(this._self, this._then);

  final TypeDefinitionOptions _self;
  final $Res Function(TypeDefinitionOptions) _then;

/// Create a copy of TypeDefinitionOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _TypeDefinitionOptions implements TypeDefinitionOptions {
  const _TypeDefinitionOptions({this.workDoneProgress});
  factory _TypeDefinitionOptions.fromJson(Map<String, dynamic> json) => _$TypeDefinitionOptionsFromJson(json);

@override final  bool? workDoneProgress;

/// Create a copy of TypeDefinitionOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TypeDefinitionOptionsCopyWith<_TypeDefinitionOptions> get copyWith => __$TypeDefinitionOptionsCopyWithImpl<_TypeDefinitionOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TypeDefinitionOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TypeDefinitionOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'TypeDefinitionOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$TypeDefinitionOptionsCopyWith<$Res> implements $TypeDefinitionOptionsCopyWith<$Res> {
  factory _$TypeDefinitionOptionsCopyWith(_TypeDefinitionOptions value, $Res Function(_TypeDefinitionOptions) _then) = __$TypeDefinitionOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class __$TypeDefinitionOptionsCopyWithImpl<$Res>
    implements _$TypeDefinitionOptionsCopyWith<$Res> {
  __$TypeDefinitionOptionsCopyWithImpl(this._self, this._then);

  final _TypeDefinitionOptions _self;
  final $Res Function(_TypeDefinitionOptions) _then;

/// Create a copy of TypeDefinitionOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_TypeDefinitionOptions(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$WorkspaceFoldersChangeEvent {

 List<WorkspaceFolder> get added; List<WorkspaceFolder> get removed;
/// Create a copy of WorkspaceFoldersChangeEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkspaceFoldersChangeEventCopyWith<WorkspaceFoldersChangeEvent> get copyWith => _$WorkspaceFoldersChangeEventCopyWithImpl<WorkspaceFoldersChangeEvent>(this as WorkspaceFoldersChangeEvent, _$identity);

  /// Serializes this WorkspaceFoldersChangeEvent to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkspaceFoldersChangeEvent&&const DeepCollectionEquality().equals(other.added, added)&&const DeepCollectionEquality().equals(other.removed, removed));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(added),const DeepCollectionEquality().hash(removed));

@override
String toString() {
  return 'WorkspaceFoldersChangeEvent(added: $added, removed: $removed)';
}


}

/// @nodoc
abstract mixin class $WorkspaceFoldersChangeEventCopyWith<$Res>  {
  factory $WorkspaceFoldersChangeEventCopyWith(WorkspaceFoldersChangeEvent value, $Res Function(WorkspaceFoldersChangeEvent) _then) = _$WorkspaceFoldersChangeEventCopyWithImpl;
@useResult
$Res call({
 List<WorkspaceFolder> added, List<WorkspaceFolder> removed
});




}
/// @nodoc
class _$WorkspaceFoldersChangeEventCopyWithImpl<$Res>
    implements $WorkspaceFoldersChangeEventCopyWith<$Res> {
  _$WorkspaceFoldersChangeEventCopyWithImpl(this._self, this._then);

  final WorkspaceFoldersChangeEvent _self;
  final $Res Function(WorkspaceFoldersChangeEvent) _then;

/// Create a copy of WorkspaceFoldersChangeEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? added = null,Object? removed = null,}) {
  return _then(_self.copyWith(
added: null == added ? _self.added : added // ignore: cast_nullable_to_non_nullable
as List<WorkspaceFolder>,removed: null == removed ? _self.removed : removed // ignore: cast_nullable_to_non_nullable
as List<WorkspaceFolder>,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _WorkspaceFoldersChangeEvent implements WorkspaceFoldersChangeEvent {
  const _WorkspaceFoldersChangeEvent({required final  List<WorkspaceFolder> added, required final  List<WorkspaceFolder> removed}): _added = added,_removed = removed;
  factory _WorkspaceFoldersChangeEvent.fromJson(Map<String, dynamic> json) => _$WorkspaceFoldersChangeEventFromJson(json);

 final  List<WorkspaceFolder> _added;
@override List<WorkspaceFolder> get added {
  if (_added is EqualUnmodifiableListView) return _added;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_added);
}

 final  List<WorkspaceFolder> _removed;
@override List<WorkspaceFolder> get removed {
  if (_removed is EqualUnmodifiableListView) return _removed;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_removed);
}


/// Create a copy of WorkspaceFoldersChangeEvent
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkspaceFoldersChangeEventCopyWith<_WorkspaceFoldersChangeEvent> get copyWith => __$WorkspaceFoldersChangeEventCopyWithImpl<_WorkspaceFoldersChangeEvent>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkspaceFoldersChangeEventToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkspaceFoldersChangeEvent&&const DeepCollectionEquality().equals(other._added, _added)&&const DeepCollectionEquality().equals(other._removed, _removed));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_added),const DeepCollectionEquality().hash(_removed));

@override
String toString() {
  return 'WorkspaceFoldersChangeEvent(added: $added, removed: $removed)';
}


}

/// @nodoc
abstract mixin class _$WorkspaceFoldersChangeEventCopyWith<$Res> implements $WorkspaceFoldersChangeEventCopyWith<$Res> {
  factory _$WorkspaceFoldersChangeEventCopyWith(_WorkspaceFoldersChangeEvent value, $Res Function(_WorkspaceFoldersChangeEvent) _then) = __$WorkspaceFoldersChangeEventCopyWithImpl;
@override @useResult
$Res call({
 List<WorkspaceFolder> added, List<WorkspaceFolder> removed
});




}
/// @nodoc
class __$WorkspaceFoldersChangeEventCopyWithImpl<$Res>
    implements _$WorkspaceFoldersChangeEventCopyWith<$Res> {
  __$WorkspaceFoldersChangeEventCopyWithImpl(this._self, this._then);

  final _WorkspaceFoldersChangeEvent _self;
  final $Res Function(_WorkspaceFoldersChangeEvent) _then;

/// Create a copy of WorkspaceFoldersChangeEvent
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? added = null,Object? removed = null,}) {
  return _then(_WorkspaceFoldersChangeEvent(
added: null == added ? _self._added : added // ignore: cast_nullable_to_non_nullable
as List<WorkspaceFolder>,removed: null == removed ? _self._removed : removed // ignore: cast_nullable_to_non_nullable
as List<WorkspaceFolder>,
  ));
}


}


/// @nodoc
mixin _$ConfigurationItem {

 String? get section; String? get scopeUri;
/// Create a copy of ConfigurationItem
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ConfigurationItemCopyWith<ConfigurationItem> get copyWith => _$ConfigurationItemCopyWithImpl<ConfigurationItem>(this as ConfigurationItem, _$identity);

  /// Serializes this ConfigurationItem to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ConfigurationItem&&(identical(other.section, section) || other.section == section)&&(identical(other.scopeUri, scopeUri) || other.scopeUri == scopeUri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,section,scopeUri);

@override
String toString() {
  return 'ConfigurationItem(section: $section, scopeUri: $scopeUri)';
}


}

/// @nodoc
abstract mixin class $ConfigurationItemCopyWith<$Res>  {
  factory $ConfigurationItemCopyWith(ConfigurationItem value, $Res Function(ConfigurationItem) _then) = _$ConfigurationItemCopyWithImpl;
@useResult
$Res call({
 String? section, String? scopeUri
});




}
/// @nodoc
class _$ConfigurationItemCopyWithImpl<$Res>
    implements $ConfigurationItemCopyWith<$Res> {
  _$ConfigurationItemCopyWithImpl(this._self, this._then);

  final ConfigurationItem _self;
  final $Res Function(ConfigurationItem) _then;

/// Create a copy of ConfigurationItem
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? section = freezed,Object? scopeUri = freezed,}) {
  return _then(_self.copyWith(
section: freezed == section ? _self.section : section // ignore: cast_nullable_to_non_nullable
as String?,scopeUri: freezed == scopeUri ? _self.scopeUri : scopeUri // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _ConfigurationItem implements ConfigurationItem {
  const _ConfigurationItem({this.section, this.scopeUri});
  factory _ConfigurationItem.fromJson(Map<String, dynamic> json) => _$ConfigurationItemFromJson(json);

@override final  String? section;
@override final  String? scopeUri;

/// Create a copy of ConfigurationItem
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ConfigurationItemCopyWith<_ConfigurationItem> get copyWith => __$ConfigurationItemCopyWithImpl<_ConfigurationItem>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ConfigurationItemToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ConfigurationItem&&(identical(other.section, section) || other.section == section)&&(identical(other.scopeUri, scopeUri) || other.scopeUri == scopeUri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,section,scopeUri);

@override
String toString() {
  return 'ConfigurationItem(section: $section, scopeUri: $scopeUri)';
}


}

/// @nodoc
abstract mixin class _$ConfigurationItemCopyWith<$Res> implements $ConfigurationItemCopyWith<$Res> {
  factory _$ConfigurationItemCopyWith(_ConfigurationItem value, $Res Function(_ConfigurationItem) _then) = __$ConfigurationItemCopyWithImpl;
@override @useResult
$Res call({
 String? section, String? scopeUri
});




}
/// @nodoc
class __$ConfigurationItemCopyWithImpl<$Res>
    implements _$ConfigurationItemCopyWith<$Res> {
  __$ConfigurationItemCopyWithImpl(this._self, this._then);

  final _ConfigurationItem _self;
  final $Res Function(_ConfigurationItem) _then;

/// Create a copy of ConfigurationItem
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? section = freezed,Object? scopeUri = freezed,}) {
  return _then(_ConfigurationItem(
section: freezed == section ? _self.section : section // ignore: cast_nullable_to_non_nullable
as String?,scopeUri: freezed == scopeUri ? _self.scopeUri : scopeUri // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$TextDocumentIdentifier {

 String get uri;
/// Create a copy of TextDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<TextDocumentIdentifier> get copyWith => _$TextDocumentIdentifierCopyWithImpl<TextDocumentIdentifier>(this as TextDocumentIdentifier, _$identity);

  /// Serializes this TextDocumentIdentifier to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TextDocumentIdentifier&&(identical(other.uri, uri) || other.uri == uri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri);

@override
String toString() {
  return 'TextDocumentIdentifier(uri: $uri)';
}


}

/// @nodoc
abstract mixin class $TextDocumentIdentifierCopyWith<$Res>  {
  factory $TextDocumentIdentifierCopyWith(TextDocumentIdentifier value, $Res Function(TextDocumentIdentifier) _then) = _$TextDocumentIdentifierCopyWithImpl;
@useResult
$Res call({
 String uri
});




}
/// @nodoc
class _$TextDocumentIdentifierCopyWithImpl<$Res>
    implements $TextDocumentIdentifierCopyWith<$Res> {
  _$TextDocumentIdentifierCopyWithImpl(this._self, this._then);

  final TextDocumentIdentifier _self;
  final $Res Function(TextDocumentIdentifier) _then;

/// Create a copy of TextDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? uri = null,}) {
  return _then(_self.copyWith(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _TextDocumentIdentifier implements TextDocumentIdentifier {
  const _TextDocumentIdentifier({required this.uri});
  factory _TextDocumentIdentifier.fromJson(Map<String, dynamic> json) => _$TextDocumentIdentifierFromJson(json);

@override final  String uri;

/// Create a copy of TextDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TextDocumentIdentifierCopyWith<_TextDocumentIdentifier> get copyWith => __$TextDocumentIdentifierCopyWithImpl<_TextDocumentIdentifier>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TextDocumentIdentifierToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TextDocumentIdentifier&&(identical(other.uri, uri) || other.uri == uri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri);

@override
String toString() {
  return 'TextDocumentIdentifier(uri: $uri)';
}


}

/// @nodoc
abstract mixin class _$TextDocumentIdentifierCopyWith<$Res> implements $TextDocumentIdentifierCopyWith<$Res> {
  factory _$TextDocumentIdentifierCopyWith(_TextDocumentIdentifier value, $Res Function(_TextDocumentIdentifier) _then) = __$TextDocumentIdentifierCopyWithImpl;
@override @useResult
$Res call({
 String uri
});




}
/// @nodoc
class __$TextDocumentIdentifierCopyWithImpl<$Res>
    implements _$TextDocumentIdentifierCopyWith<$Res> {
  __$TextDocumentIdentifierCopyWithImpl(this._self, this._then);

  final _TextDocumentIdentifier _self;
  final $Res Function(_TextDocumentIdentifier) _then;

/// Create a copy of TextDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? uri = null,}) {
  return _then(_TextDocumentIdentifier(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}


/// @nodoc
mixin _$Color {

 double get red; double get green; double get blue; double get alpha;
/// Create a copy of Color
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ColorCopyWith<Color> get copyWith => _$ColorCopyWithImpl<Color>(this as Color, _$identity);

  /// Serializes this Color to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Color&&(identical(other.red, red) || other.red == red)&&(identical(other.green, green) || other.green == green)&&(identical(other.blue, blue) || other.blue == blue)&&(identical(other.alpha, alpha) || other.alpha == alpha));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,red,green,blue,alpha);

@override
String toString() {
  return 'Color(red: $red, green: $green, blue: $blue, alpha: $alpha)';
}


}

/// @nodoc
abstract mixin class $ColorCopyWith<$Res>  {
  factory $ColorCopyWith(Color value, $Res Function(Color) _then) = _$ColorCopyWithImpl;
@useResult
$Res call({
 double red, double green, double blue, double alpha
});




}
/// @nodoc
class _$ColorCopyWithImpl<$Res>
    implements $ColorCopyWith<$Res> {
  _$ColorCopyWithImpl(this._self, this._then);

  final Color _self;
  final $Res Function(Color) _then;

/// Create a copy of Color
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? red = null,Object? green = null,Object? blue = null,Object? alpha = null,}) {
  return _then(_self.copyWith(
red: null == red ? _self.red : red // ignore: cast_nullable_to_non_nullable
as double,green: null == green ? _self.green : green // ignore: cast_nullable_to_non_nullable
as double,blue: null == blue ? _self.blue : blue // ignore: cast_nullable_to_non_nullable
as double,alpha: null == alpha ? _self.alpha : alpha // ignore: cast_nullable_to_non_nullable
as double,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _Color implements Color {
  const _Color({required this.red, required this.green, required this.blue, required this.alpha});
  factory _Color.fromJson(Map<String, dynamic> json) => _$ColorFromJson(json);

@override final  double red;
@override final  double green;
@override final  double blue;
@override final  double alpha;

/// Create a copy of Color
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ColorCopyWith<_Color> get copyWith => __$ColorCopyWithImpl<_Color>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ColorToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _Color&&(identical(other.red, red) || other.red == red)&&(identical(other.green, green) || other.green == green)&&(identical(other.blue, blue) || other.blue == blue)&&(identical(other.alpha, alpha) || other.alpha == alpha));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,red,green,blue,alpha);

@override
String toString() {
  return 'Color(red: $red, green: $green, blue: $blue, alpha: $alpha)';
}


}

/// @nodoc
abstract mixin class _$ColorCopyWith<$Res> implements $ColorCopyWith<$Res> {
  factory _$ColorCopyWith(_Color value, $Res Function(_Color) _then) = __$ColorCopyWithImpl;
@override @useResult
$Res call({
 double red, double green, double blue, double alpha
});




}
/// @nodoc
class __$ColorCopyWithImpl<$Res>
    implements _$ColorCopyWith<$Res> {
  __$ColorCopyWithImpl(this._self, this._then);

  final _Color _self;
  final $Res Function(_Color) _then;

/// Create a copy of Color
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? red = null,Object? green = null,Object? blue = null,Object? alpha = null,}) {
  return _then(_Color(
red: null == red ? _self.red : red // ignore: cast_nullable_to_non_nullable
as double,green: null == green ? _self.green : green // ignore: cast_nullable_to_non_nullable
as double,blue: null == blue ? _self.blue : blue // ignore: cast_nullable_to_non_nullable
as double,alpha: null == alpha ? _self.alpha : alpha // ignore: cast_nullable_to_non_nullable
as double,
  ));
}


}


/// @nodoc
mixin _$DocumentColorOptions {

 bool? get workDoneProgress;
/// Create a copy of DocumentColorOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentColorOptionsCopyWith<DocumentColorOptions> get copyWith => _$DocumentColorOptionsCopyWithImpl<DocumentColorOptions>(this as DocumentColorOptions, _$identity);

  /// Serializes this DocumentColorOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentColorOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'DocumentColorOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $DocumentColorOptionsCopyWith<$Res>  {
  factory $DocumentColorOptionsCopyWith(DocumentColorOptions value, $Res Function(DocumentColorOptions) _then) = _$DocumentColorOptionsCopyWithImpl;
@useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class _$DocumentColorOptionsCopyWithImpl<$Res>
    implements $DocumentColorOptionsCopyWith<$Res> {
  _$DocumentColorOptionsCopyWithImpl(this._self, this._then);

  final DocumentColorOptions _self;
  final $Res Function(DocumentColorOptions) _then;

/// Create a copy of DocumentColorOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DocumentColorOptions implements DocumentColorOptions {
  const _DocumentColorOptions({this.workDoneProgress});
  factory _DocumentColorOptions.fromJson(Map<String, dynamic> json) => _$DocumentColorOptionsFromJson(json);

@override final  bool? workDoneProgress;

/// Create a copy of DocumentColorOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentColorOptionsCopyWith<_DocumentColorOptions> get copyWith => __$DocumentColorOptionsCopyWithImpl<_DocumentColorOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentColorOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentColorOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'DocumentColorOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$DocumentColorOptionsCopyWith<$Res> implements $DocumentColorOptionsCopyWith<$Res> {
  factory _$DocumentColorOptionsCopyWith(_DocumentColorOptions value, $Res Function(_DocumentColorOptions) _then) = __$DocumentColorOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class __$DocumentColorOptionsCopyWithImpl<$Res>
    implements _$DocumentColorOptionsCopyWith<$Res> {
  __$DocumentColorOptionsCopyWithImpl(this._self, this._then);

  final _DocumentColorOptions _self;
  final $Res Function(_DocumentColorOptions) _then;

/// Create a copy of DocumentColorOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_DocumentColorOptions(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$FoldingRangeOptions {

 bool? get workDoneProgress;
/// Create a copy of FoldingRangeOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FoldingRangeOptionsCopyWith<FoldingRangeOptions> get copyWith => _$FoldingRangeOptionsCopyWithImpl<FoldingRangeOptions>(this as FoldingRangeOptions, _$identity);

  /// Serializes this FoldingRangeOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FoldingRangeOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'FoldingRangeOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $FoldingRangeOptionsCopyWith<$Res>  {
  factory $FoldingRangeOptionsCopyWith(FoldingRangeOptions value, $Res Function(FoldingRangeOptions) _then) = _$FoldingRangeOptionsCopyWithImpl;
@useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class _$FoldingRangeOptionsCopyWithImpl<$Res>
    implements $FoldingRangeOptionsCopyWith<$Res> {
  _$FoldingRangeOptionsCopyWithImpl(this._self, this._then);

  final FoldingRangeOptions _self;
  final $Res Function(FoldingRangeOptions) _then;

/// Create a copy of FoldingRangeOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _FoldingRangeOptions implements FoldingRangeOptions {
  const _FoldingRangeOptions({this.workDoneProgress});
  factory _FoldingRangeOptions.fromJson(Map<String, dynamic> json) => _$FoldingRangeOptionsFromJson(json);

@override final  bool? workDoneProgress;

/// Create a copy of FoldingRangeOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$FoldingRangeOptionsCopyWith<_FoldingRangeOptions> get copyWith => __$FoldingRangeOptionsCopyWithImpl<_FoldingRangeOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$FoldingRangeOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _FoldingRangeOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'FoldingRangeOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$FoldingRangeOptionsCopyWith<$Res> implements $FoldingRangeOptionsCopyWith<$Res> {
  factory _$FoldingRangeOptionsCopyWith(_FoldingRangeOptions value, $Res Function(_FoldingRangeOptions) _then) = __$FoldingRangeOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class __$FoldingRangeOptionsCopyWithImpl<$Res>
    implements _$FoldingRangeOptionsCopyWith<$Res> {
  __$FoldingRangeOptionsCopyWithImpl(this._self, this._then);

  final _FoldingRangeOptions _self;
  final $Res Function(_FoldingRangeOptions) _then;

/// Create a copy of FoldingRangeOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_FoldingRangeOptions(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DeclarationOptions {

 bool? get workDoneProgress;
/// Create a copy of DeclarationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DeclarationOptionsCopyWith<DeclarationOptions> get copyWith => _$DeclarationOptionsCopyWithImpl<DeclarationOptions>(this as DeclarationOptions, _$identity);

  /// Serializes this DeclarationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DeclarationOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'DeclarationOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $DeclarationOptionsCopyWith<$Res>  {
  factory $DeclarationOptionsCopyWith(DeclarationOptions value, $Res Function(DeclarationOptions) _then) = _$DeclarationOptionsCopyWithImpl;
@useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class _$DeclarationOptionsCopyWithImpl<$Res>
    implements $DeclarationOptionsCopyWith<$Res> {
  _$DeclarationOptionsCopyWithImpl(this._self, this._then);

  final DeclarationOptions _self;
  final $Res Function(DeclarationOptions) _then;

/// Create a copy of DeclarationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DeclarationOptions implements DeclarationOptions {
  const _DeclarationOptions({this.workDoneProgress});
  factory _DeclarationOptions.fromJson(Map<String, dynamic> json) => _$DeclarationOptionsFromJson(json);

@override final  bool? workDoneProgress;

/// Create a copy of DeclarationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DeclarationOptionsCopyWith<_DeclarationOptions> get copyWith => __$DeclarationOptionsCopyWithImpl<_DeclarationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DeclarationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DeclarationOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'DeclarationOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$DeclarationOptionsCopyWith<$Res> implements $DeclarationOptionsCopyWith<$Res> {
  factory _$DeclarationOptionsCopyWith(_DeclarationOptions value, $Res Function(_DeclarationOptions) _then) = __$DeclarationOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class __$DeclarationOptionsCopyWithImpl<$Res>
    implements _$DeclarationOptionsCopyWith<$Res> {
  __$DeclarationOptionsCopyWithImpl(this._self, this._then);

  final _DeclarationOptions _self;
  final $Res Function(_DeclarationOptions) _then;

/// Create a copy of DeclarationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_DeclarationOptions(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$Position {

 int get line; int get character;
/// Create a copy of Position
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$PositionCopyWith<Position> get copyWith => _$PositionCopyWithImpl<Position>(this as Position, _$identity);

  /// Serializes this Position to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Position&&(identical(other.line, line) || other.line == line)&&(identical(other.character, character) || other.character == character));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,line,character);

@override
String toString() {
  return 'Position(line: $line, character: $character)';
}


}

/// @nodoc
abstract mixin class $PositionCopyWith<$Res>  {
  factory $PositionCopyWith(Position value, $Res Function(Position) _then) = _$PositionCopyWithImpl;
@useResult
$Res call({
 int line, int character
});




}
/// @nodoc
class _$PositionCopyWithImpl<$Res>
    implements $PositionCopyWith<$Res> {
  _$PositionCopyWithImpl(this._self, this._then);

  final Position _self;
  final $Res Function(Position) _then;

/// Create a copy of Position
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? line = null,Object? character = null,}) {
  return _then(_self.copyWith(
line: null == line ? _self.line : line // ignore: cast_nullable_to_non_nullable
as int,character: null == character ? _self.character : character // ignore: cast_nullable_to_non_nullable
as int,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _Position implements Position {
  const _Position({required this.line, required this.character});
  factory _Position.fromJson(Map<String, dynamic> json) => _$PositionFromJson(json);

@override final  int line;
@override final  int character;

/// Create a copy of Position
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$PositionCopyWith<_Position> get copyWith => __$PositionCopyWithImpl<_Position>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$PositionToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _Position&&(identical(other.line, line) || other.line == line)&&(identical(other.character, character) || other.character == character));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,line,character);

@override
String toString() {
  return 'Position(line: $line, character: $character)';
}


}

/// @nodoc
abstract mixin class _$PositionCopyWith<$Res> implements $PositionCopyWith<$Res> {
  factory _$PositionCopyWith(_Position value, $Res Function(_Position) _then) = __$PositionCopyWithImpl;
@override @useResult
$Res call({
 int line, int character
});




}
/// @nodoc
class __$PositionCopyWithImpl<$Res>
    implements _$PositionCopyWith<$Res> {
  __$PositionCopyWithImpl(this._self, this._then);

  final _Position _self;
  final $Res Function(_Position) _then;

/// Create a copy of Position
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? line = null,Object? character = null,}) {
  return _then(_Position(
line: null == line ? _self.line : line // ignore: cast_nullable_to_non_nullable
as int,character: null == character ? _self.character : character // ignore: cast_nullable_to_non_nullable
as int,
  ));
}


}


/// @nodoc
mixin _$SelectionRangeOptions {

 bool? get workDoneProgress;
/// Create a copy of SelectionRangeOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SelectionRangeOptionsCopyWith<SelectionRangeOptions> get copyWith => _$SelectionRangeOptionsCopyWithImpl<SelectionRangeOptions>(this as SelectionRangeOptions, _$identity);

  /// Serializes this SelectionRangeOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SelectionRangeOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'SelectionRangeOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $SelectionRangeOptionsCopyWith<$Res>  {
  factory $SelectionRangeOptionsCopyWith(SelectionRangeOptions value, $Res Function(SelectionRangeOptions) _then) = _$SelectionRangeOptionsCopyWithImpl;
@useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class _$SelectionRangeOptionsCopyWithImpl<$Res>
    implements $SelectionRangeOptionsCopyWith<$Res> {
  _$SelectionRangeOptionsCopyWithImpl(this._self, this._then);

  final SelectionRangeOptions _self;
  final $Res Function(SelectionRangeOptions) _then;

/// Create a copy of SelectionRangeOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _SelectionRangeOptions implements SelectionRangeOptions {
  const _SelectionRangeOptions({this.workDoneProgress});
  factory _SelectionRangeOptions.fromJson(Map<String, dynamic> json) => _$SelectionRangeOptionsFromJson(json);

@override final  bool? workDoneProgress;

/// Create a copy of SelectionRangeOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SelectionRangeOptionsCopyWith<_SelectionRangeOptions> get copyWith => __$SelectionRangeOptionsCopyWithImpl<_SelectionRangeOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SelectionRangeOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SelectionRangeOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'SelectionRangeOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$SelectionRangeOptionsCopyWith<$Res> implements $SelectionRangeOptionsCopyWith<$Res> {
  factory _$SelectionRangeOptionsCopyWith(_SelectionRangeOptions value, $Res Function(_SelectionRangeOptions) _then) = __$SelectionRangeOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class __$SelectionRangeOptionsCopyWithImpl<$Res>
    implements _$SelectionRangeOptionsCopyWith<$Res> {
  __$SelectionRangeOptionsCopyWithImpl(this._self, this._then);

  final _SelectionRangeOptions _self;
  final $Res Function(_SelectionRangeOptions) _then;

/// Create a copy of SelectionRangeOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_SelectionRangeOptions(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$CallHierarchyOptions {

 bool? get workDoneProgress;
/// Create a copy of CallHierarchyOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CallHierarchyOptionsCopyWith<CallHierarchyOptions> get copyWith => _$CallHierarchyOptionsCopyWithImpl<CallHierarchyOptions>(this as CallHierarchyOptions, _$identity);

  /// Serializes this CallHierarchyOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CallHierarchyOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'CallHierarchyOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $CallHierarchyOptionsCopyWith<$Res>  {
  factory $CallHierarchyOptionsCopyWith(CallHierarchyOptions value, $Res Function(CallHierarchyOptions) _then) = _$CallHierarchyOptionsCopyWithImpl;
@useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class _$CallHierarchyOptionsCopyWithImpl<$Res>
    implements $CallHierarchyOptionsCopyWith<$Res> {
  _$CallHierarchyOptionsCopyWithImpl(this._self, this._then);

  final CallHierarchyOptions _self;
  final $Res Function(CallHierarchyOptions) _then;

/// Create a copy of CallHierarchyOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _CallHierarchyOptions implements CallHierarchyOptions {
  const _CallHierarchyOptions({this.workDoneProgress});
  factory _CallHierarchyOptions.fromJson(Map<String, dynamic> json) => _$CallHierarchyOptionsFromJson(json);

@override final  bool? workDoneProgress;

/// Create a copy of CallHierarchyOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CallHierarchyOptionsCopyWith<_CallHierarchyOptions> get copyWith => __$CallHierarchyOptionsCopyWithImpl<_CallHierarchyOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CallHierarchyOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CallHierarchyOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'CallHierarchyOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$CallHierarchyOptionsCopyWith<$Res> implements $CallHierarchyOptionsCopyWith<$Res> {
  factory _$CallHierarchyOptionsCopyWith(_CallHierarchyOptions value, $Res Function(_CallHierarchyOptions) _then) = __$CallHierarchyOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class __$CallHierarchyOptionsCopyWithImpl<$Res>
    implements _$CallHierarchyOptionsCopyWith<$Res> {
  __$CallHierarchyOptionsCopyWithImpl(this._self, this._then);

  final _CallHierarchyOptions _self;
  final $Res Function(_CallHierarchyOptions) _then;

/// Create a copy of CallHierarchyOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_CallHierarchyOptions(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$SemanticTokensOptions {

 SemanticTokensLegend get legend; dynamic? get full; dynamic? get range; bool? get workDoneProgress;
/// Create a copy of SemanticTokensOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SemanticTokensOptionsCopyWith<SemanticTokensOptions> get copyWith => _$SemanticTokensOptionsCopyWithImpl<SemanticTokensOptions>(this as SemanticTokensOptions, _$identity);

  /// Serializes this SemanticTokensOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SemanticTokensOptions&&(identical(other.legend, legend) || other.legend == legend)&&const DeepCollectionEquality().equals(other.full, full)&&const DeepCollectionEquality().equals(other.range, range)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,legend,const DeepCollectionEquality().hash(full),const DeepCollectionEquality().hash(range),workDoneProgress);

@override
String toString() {
  return 'SemanticTokensOptions(legend: $legend, full: $full, range: $range, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $SemanticTokensOptionsCopyWith<$Res>  {
  factory $SemanticTokensOptionsCopyWith(SemanticTokensOptions value, $Res Function(SemanticTokensOptions) _then) = _$SemanticTokensOptionsCopyWithImpl;
@useResult
$Res call({
 SemanticTokensLegend legend, dynamic? full, dynamic? range, bool? workDoneProgress
});


$SemanticTokensLegendCopyWith<$Res> get legend;

}
/// @nodoc
class _$SemanticTokensOptionsCopyWithImpl<$Res>
    implements $SemanticTokensOptionsCopyWith<$Res> {
  _$SemanticTokensOptionsCopyWithImpl(this._self, this._then);

  final SemanticTokensOptions _self;
  final $Res Function(SemanticTokensOptions) _then;

/// Create a copy of SemanticTokensOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? legend = null,Object? full = freezed,Object? range = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
legend: null == legend ? _self.legend : legend // ignore: cast_nullable_to_non_nullable
as SemanticTokensLegend,full: freezed == full ? _self.full : full // ignore: cast_nullable_to_non_nullable
as dynamic?,range: freezed == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as dynamic?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}
/// Create a copy of SemanticTokensOptions
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SemanticTokensLegendCopyWith<$Res> get legend {
  
  return $SemanticTokensLegendCopyWith<$Res>(_self.legend, (value) {
    return _then(_self.copyWith(legend: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _SemanticTokensOptions implements SemanticTokensOptions {
  const _SemanticTokensOptions({required this.legend, this.full, this.range, this.workDoneProgress});
  factory _SemanticTokensOptions.fromJson(Map<String, dynamic> json) => _$SemanticTokensOptionsFromJson(json);

@override final  SemanticTokensLegend legend;
@override final  dynamic? full;
@override final  dynamic? range;
@override final  bool? workDoneProgress;

/// Create a copy of SemanticTokensOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SemanticTokensOptionsCopyWith<_SemanticTokensOptions> get copyWith => __$SemanticTokensOptionsCopyWithImpl<_SemanticTokensOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SemanticTokensOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SemanticTokensOptions&&(identical(other.legend, legend) || other.legend == legend)&&const DeepCollectionEquality().equals(other.full, full)&&const DeepCollectionEquality().equals(other.range, range)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,legend,const DeepCollectionEquality().hash(full),const DeepCollectionEquality().hash(range),workDoneProgress);

@override
String toString() {
  return 'SemanticTokensOptions(legend: $legend, full: $full, range: $range, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$SemanticTokensOptionsCopyWith<$Res> implements $SemanticTokensOptionsCopyWith<$Res> {
  factory _$SemanticTokensOptionsCopyWith(_SemanticTokensOptions value, $Res Function(_SemanticTokensOptions) _then) = __$SemanticTokensOptionsCopyWithImpl;
@override @useResult
$Res call({
 SemanticTokensLegend legend, dynamic? full, dynamic? range, bool? workDoneProgress
});


@override $SemanticTokensLegendCopyWith<$Res> get legend;

}
/// @nodoc
class __$SemanticTokensOptionsCopyWithImpl<$Res>
    implements _$SemanticTokensOptionsCopyWith<$Res> {
  __$SemanticTokensOptionsCopyWithImpl(this._self, this._then);

  final _SemanticTokensOptions _self;
  final $Res Function(_SemanticTokensOptions) _then;

/// Create a copy of SemanticTokensOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? legend = null,Object? full = freezed,Object? range = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_SemanticTokensOptions(
legend: null == legend ? _self.legend : legend // ignore: cast_nullable_to_non_nullable
as SemanticTokensLegend,full: freezed == full ? _self.full : full // ignore: cast_nullable_to_non_nullable
as dynamic?,range: freezed == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as dynamic?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

/// Create a copy of SemanticTokensOptions
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SemanticTokensLegendCopyWith<$Res> get legend {
  
  return $SemanticTokensLegendCopyWith<$Res>(_self.legend, (value) {
    return _then(_self.copyWith(legend: value));
  });
}
}


/// @nodoc
mixin _$SemanticTokensEdit {

 int get start; int get deleteCount; List<int>? get data;
/// Create a copy of SemanticTokensEdit
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SemanticTokensEditCopyWith<SemanticTokensEdit> get copyWith => _$SemanticTokensEditCopyWithImpl<SemanticTokensEdit>(this as SemanticTokensEdit, _$identity);

  /// Serializes this SemanticTokensEdit to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SemanticTokensEdit&&(identical(other.start, start) || other.start == start)&&(identical(other.deleteCount, deleteCount) || other.deleteCount == deleteCount)&&const DeepCollectionEquality().equals(other.data, data));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,start,deleteCount,const DeepCollectionEquality().hash(data));

@override
String toString() {
  return 'SemanticTokensEdit(start: $start, deleteCount: $deleteCount, data: $data)';
}


}

/// @nodoc
abstract mixin class $SemanticTokensEditCopyWith<$Res>  {
  factory $SemanticTokensEditCopyWith(SemanticTokensEdit value, $Res Function(SemanticTokensEdit) _then) = _$SemanticTokensEditCopyWithImpl;
@useResult
$Res call({
 int start, int deleteCount, List<int>? data
});




}
/// @nodoc
class _$SemanticTokensEditCopyWithImpl<$Res>
    implements $SemanticTokensEditCopyWith<$Res> {
  _$SemanticTokensEditCopyWithImpl(this._self, this._then);

  final SemanticTokensEdit _self;
  final $Res Function(SemanticTokensEdit) _then;

/// Create a copy of SemanticTokensEdit
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? start = null,Object? deleteCount = null,Object? data = freezed,}) {
  return _then(_self.copyWith(
start: null == start ? _self.start : start // ignore: cast_nullable_to_non_nullable
as int,deleteCount: null == deleteCount ? _self.deleteCount : deleteCount // ignore: cast_nullable_to_non_nullable
as int,data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as List<int>?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _SemanticTokensEdit implements SemanticTokensEdit {
  const _SemanticTokensEdit({required this.start, required this.deleteCount, final  List<int>? data}): _data = data;
  factory _SemanticTokensEdit.fromJson(Map<String, dynamic> json) => _$SemanticTokensEditFromJson(json);

@override final  int start;
@override final  int deleteCount;
 final  List<int>? _data;
@override List<int>? get data {
  final value = _data;
  if (value == null) return null;
  if (_data is EqualUnmodifiableListView) return _data;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}


/// Create a copy of SemanticTokensEdit
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SemanticTokensEditCopyWith<_SemanticTokensEdit> get copyWith => __$SemanticTokensEditCopyWithImpl<_SemanticTokensEdit>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SemanticTokensEditToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SemanticTokensEdit&&(identical(other.start, start) || other.start == start)&&(identical(other.deleteCount, deleteCount) || other.deleteCount == deleteCount)&&const DeepCollectionEquality().equals(other._data, _data));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,start,deleteCount,const DeepCollectionEquality().hash(_data));

@override
String toString() {
  return 'SemanticTokensEdit(start: $start, deleteCount: $deleteCount, data: $data)';
}


}

/// @nodoc
abstract mixin class _$SemanticTokensEditCopyWith<$Res> implements $SemanticTokensEditCopyWith<$Res> {
  factory _$SemanticTokensEditCopyWith(_SemanticTokensEdit value, $Res Function(_SemanticTokensEdit) _then) = __$SemanticTokensEditCopyWithImpl;
@override @useResult
$Res call({
 int start, int deleteCount, List<int>? data
});




}
/// @nodoc
class __$SemanticTokensEditCopyWithImpl<$Res>
    implements _$SemanticTokensEditCopyWith<$Res> {
  __$SemanticTokensEditCopyWithImpl(this._self, this._then);

  final _SemanticTokensEdit _self;
  final $Res Function(_SemanticTokensEdit) _then;

/// Create a copy of SemanticTokensEdit
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? start = null,Object? deleteCount = null,Object? data = freezed,}) {
  return _then(_SemanticTokensEdit(
start: null == start ? _self.start : start // ignore: cast_nullable_to_non_nullable
as int,deleteCount: null == deleteCount ? _self.deleteCount : deleteCount // ignore: cast_nullable_to_non_nullable
as int,data: freezed == data ? _self._data : data // ignore: cast_nullable_to_non_nullable
as List<int>?,
  ));
}


}


/// @nodoc
mixin _$LinkedEditingRangeOptions {

 bool? get workDoneProgress;
/// Create a copy of LinkedEditingRangeOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LinkedEditingRangeOptionsCopyWith<LinkedEditingRangeOptions> get copyWith => _$LinkedEditingRangeOptionsCopyWithImpl<LinkedEditingRangeOptions>(this as LinkedEditingRangeOptions, _$identity);

  /// Serializes this LinkedEditingRangeOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LinkedEditingRangeOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'LinkedEditingRangeOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $LinkedEditingRangeOptionsCopyWith<$Res>  {
  factory $LinkedEditingRangeOptionsCopyWith(LinkedEditingRangeOptions value, $Res Function(LinkedEditingRangeOptions) _then) = _$LinkedEditingRangeOptionsCopyWithImpl;
@useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class _$LinkedEditingRangeOptionsCopyWithImpl<$Res>
    implements $LinkedEditingRangeOptionsCopyWith<$Res> {
  _$LinkedEditingRangeOptionsCopyWithImpl(this._self, this._then);

  final LinkedEditingRangeOptions _self;
  final $Res Function(LinkedEditingRangeOptions) _then;

/// Create a copy of LinkedEditingRangeOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _LinkedEditingRangeOptions implements LinkedEditingRangeOptions {
  const _LinkedEditingRangeOptions({this.workDoneProgress});
  factory _LinkedEditingRangeOptions.fromJson(Map<String, dynamic> json) => _$LinkedEditingRangeOptionsFromJson(json);

@override final  bool? workDoneProgress;

/// Create a copy of LinkedEditingRangeOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$LinkedEditingRangeOptionsCopyWith<_LinkedEditingRangeOptions> get copyWith => __$LinkedEditingRangeOptionsCopyWithImpl<_LinkedEditingRangeOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$LinkedEditingRangeOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _LinkedEditingRangeOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'LinkedEditingRangeOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$LinkedEditingRangeOptionsCopyWith<$Res> implements $LinkedEditingRangeOptionsCopyWith<$Res> {
  factory _$LinkedEditingRangeOptionsCopyWith(_LinkedEditingRangeOptions value, $Res Function(_LinkedEditingRangeOptions) _then) = __$LinkedEditingRangeOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class __$LinkedEditingRangeOptionsCopyWithImpl<$Res>
    implements _$LinkedEditingRangeOptionsCopyWith<$Res> {
  __$LinkedEditingRangeOptionsCopyWithImpl(this._self, this._then);

  final _LinkedEditingRangeOptions _self;
  final $Res Function(_LinkedEditingRangeOptions) _then;

/// Create a copy of LinkedEditingRangeOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_LinkedEditingRangeOptions(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$FileCreate {

 String get uri;
/// Create a copy of FileCreate
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FileCreateCopyWith<FileCreate> get copyWith => _$FileCreateCopyWithImpl<FileCreate>(this as FileCreate, _$identity);

  /// Serializes this FileCreate to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FileCreate&&(identical(other.uri, uri) || other.uri == uri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri);

@override
String toString() {
  return 'FileCreate(uri: $uri)';
}


}

/// @nodoc
abstract mixin class $FileCreateCopyWith<$Res>  {
  factory $FileCreateCopyWith(FileCreate value, $Res Function(FileCreate) _then) = _$FileCreateCopyWithImpl;
@useResult
$Res call({
 String uri
});




}
/// @nodoc
class _$FileCreateCopyWithImpl<$Res>
    implements $FileCreateCopyWith<$Res> {
  _$FileCreateCopyWithImpl(this._self, this._then);

  final FileCreate _self;
  final $Res Function(FileCreate) _then;

/// Create a copy of FileCreate
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? uri = null,}) {
  return _then(_self.copyWith(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _FileCreate implements FileCreate {
  const _FileCreate({required this.uri});
  factory _FileCreate.fromJson(Map<String, dynamic> json) => _$FileCreateFromJson(json);

@override final  String uri;

/// Create a copy of FileCreate
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$FileCreateCopyWith<_FileCreate> get copyWith => __$FileCreateCopyWithImpl<_FileCreate>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$FileCreateToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _FileCreate&&(identical(other.uri, uri) || other.uri == uri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri);

@override
String toString() {
  return 'FileCreate(uri: $uri)';
}


}

/// @nodoc
abstract mixin class _$FileCreateCopyWith<$Res> implements $FileCreateCopyWith<$Res> {
  factory _$FileCreateCopyWith(_FileCreate value, $Res Function(_FileCreate) _then) = __$FileCreateCopyWithImpl;
@override @useResult
$Res call({
 String uri
});




}
/// @nodoc
class __$FileCreateCopyWithImpl<$Res>
    implements _$FileCreateCopyWith<$Res> {
  __$FileCreateCopyWithImpl(this._self, this._then);

  final _FileCreate _self;
  final $Res Function(_FileCreate) _then;

/// Create a copy of FileCreate
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? uri = null,}) {
  return _then(_FileCreate(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}


/// @nodoc
mixin _$TextDocumentEdit {

 OptionalVersionedTextDocumentIdentifier get textDocument; List<dynamic> get edits;
/// Create a copy of TextDocumentEdit
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TextDocumentEditCopyWith<TextDocumentEdit> get copyWith => _$TextDocumentEditCopyWithImpl<TextDocumentEdit>(this as TextDocumentEdit, _$identity);

  /// Serializes this TextDocumentEdit to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TextDocumentEdit&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&const DeepCollectionEquality().equals(other.edits, edits));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,const DeepCollectionEquality().hash(edits));

@override
String toString() {
  return 'TextDocumentEdit(textDocument: $textDocument, edits: $edits)';
}


}

/// @nodoc
abstract mixin class $TextDocumentEditCopyWith<$Res>  {
  factory $TextDocumentEditCopyWith(TextDocumentEdit value, $Res Function(TextDocumentEdit) _then) = _$TextDocumentEditCopyWithImpl;
@useResult
$Res call({
 OptionalVersionedTextDocumentIdentifier textDocument, List<dynamic> edits
});


$OptionalVersionedTextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$TextDocumentEditCopyWithImpl<$Res>
    implements $TextDocumentEditCopyWith<$Res> {
  _$TextDocumentEditCopyWithImpl(this._self, this._then);

  final TextDocumentEdit _self;
  final $Res Function(TextDocumentEdit) _then;

/// Create a copy of TextDocumentEdit
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,Object? edits = null,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as OptionalVersionedTextDocumentIdentifier,edits: null == edits ? _self.edits : edits // ignore: cast_nullable_to_non_nullable
as List<dynamic>,
  ));
}
/// Create a copy of TextDocumentEdit
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$OptionalVersionedTextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $OptionalVersionedTextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _TextDocumentEdit implements TextDocumentEdit {
  const _TextDocumentEdit({required this.textDocument, required final  List<dynamic> edits}): _edits = edits;
  factory _TextDocumentEdit.fromJson(Map<String, dynamic> json) => _$TextDocumentEditFromJson(json);

@override final  OptionalVersionedTextDocumentIdentifier textDocument;
 final  List<dynamic> _edits;
@override List<dynamic> get edits {
  if (_edits is EqualUnmodifiableListView) return _edits;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_edits);
}


/// Create a copy of TextDocumentEdit
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TextDocumentEditCopyWith<_TextDocumentEdit> get copyWith => __$TextDocumentEditCopyWithImpl<_TextDocumentEdit>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TextDocumentEditToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TextDocumentEdit&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&const DeepCollectionEquality().equals(other._edits, _edits));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument,const DeepCollectionEquality().hash(_edits));

@override
String toString() {
  return 'TextDocumentEdit(textDocument: $textDocument, edits: $edits)';
}


}

/// @nodoc
abstract mixin class _$TextDocumentEditCopyWith<$Res> implements $TextDocumentEditCopyWith<$Res> {
  factory _$TextDocumentEditCopyWith(_TextDocumentEdit value, $Res Function(_TextDocumentEdit) _then) = __$TextDocumentEditCopyWithImpl;
@override @useResult
$Res call({
 OptionalVersionedTextDocumentIdentifier textDocument, List<dynamic> edits
});


@override $OptionalVersionedTextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$TextDocumentEditCopyWithImpl<$Res>
    implements _$TextDocumentEditCopyWith<$Res> {
  __$TextDocumentEditCopyWithImpl(this._self, this._then);

  final _TextDocumentEdit _self;
  final $Res Function(_TextDocumentEdit) _then;

/// Create a copy of TextDocumentEdit
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,Object? edits = null,}) {
  return _then(_TextDocumentEdit(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as OptionalVersionedTextDocumentIdentifier,edits: null == edits ? _self._edits : edits // ignore: cast_nullable_to_non_nullable
as List<dynamic>,
  ));
}

/// Create a copy of TextDocumentEdit
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$OptionalVersionedTextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $OptionalVersionedTextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$CreateFile {

 String get kind; String get uri; CreateFileOptions? get options; ChangeAnnotationIdentifier? get annotationId;
/// Create a copy of CreateFile
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CreateFileCopyWith<CreateFile> get copyWith => _$CreateFileCopyWithImpl<CreateFile>(this as CreateFile, _$identity);

  /// Serializes this CreateFile to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CreateFile&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.options, options) || other.options == options)&&(identical(other.annotationId, annotationId) || other.annotationId == annotationId));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,kind,uri,options,annotationId);

@override
String toString() {
  return 'CreateFile(kind: $kind, uri: $uri, options: $options, annotationId: $annotationId)';
}


}

/// @nodoc
abstract mixin class $CreateFileCopyWith<$Res>  {
  factory $CreateFileCopyWith(CreateFile value, $Res Function(CreateFile) _then) = _$CreateFileCopyWithImpl;
@useResult
$Res call({
 String kind, String uri, CreateFileOptions? options, ChangeAnnotationIdentifier? annotationId
});


$CreateFileOptionsCopyWith<$Res>? get options;

}
/// @nodoc
class _$CreateFileCopyWithImpl<$Res>
    implements $CreateFileCopyWith<$Res> {
  _$CreateFileCopyWithImpl(this._self, this._then);

  final CreateFile _self;
  final $Res Function(CreateFile) _then;

/// Create a copy of CreateFile
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? kind = null,Object? uri = null,Object? options = freezed,Object? annotationId = freezed,}) {
  return _then(_self.copyWith(
kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as String,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,options: freezed == options ? _self.options : options // ignore: cast_nullable_to_non_nullable
as CreateFileOptions?,annotationId: freezed == annotationId ? _self.annotationId : annotationId // ignore: cast_nullable_to_non_nullable
as ChangeAnnotationIdentifier?,
  ));
}
/// Create a copy of CreateFile
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CreateFileOptionsCopyWith<$Res>? get options {
    if (_self.options == null) {
    return null;
  }

  return $CreateFileOptionsCopyWith<$Res>(_self.options!, (value) {
    return _then(_self.copyWith(options: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _CreateFile implements CreateFile {
  const _CreateFile({required this.kind, required this.uri, this.options, this.annotationId});
  factory _CreateFile.fromJson(Map<String, dynamic> json) => _$CreateFileFromJson(json);

@override final  String kind;
@override final  String uri;
@override final  CreateFileOptions? options;
@override final  ChangeAnnotationIdentifier? annotationId;

/// Create a copy of CreateFile
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CreateFileCopyWith<_CreateFile> get copyWith => __$CreateFileCopyWithImpl<_CreateFile>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CreateFileToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CreateFile&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.options, options) || other.options == options)&&(identical(other.annotationId, annotationId) || other.annotationId == annotationId));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,kind,uri,options,annotationId);

@override
String toString() {
  return 'CreateFile(kind: $kind, uri: $uri, options: $options, annotationId: $annotationId)';
}


}

/// @nodoc
abstract mixin class _$CreateFileCopyWith<$Res> implements $CreateFileCopyWith<$Res> {
  factory _$CreateFileCopyWith(_CreateFile value, $Res Function(_CreateFile) _then) = __$CreateFileCopyWithImpl;
@override @useResult
$Res call({
 String kind, String uri, CreateFileOptions? options, ChangeAnnotationIdentifier? annotationId
});


@override $CreateFileOptionsCopyWith<$Res>? get options;

}
/// @nodoc
class __$CreateFileCopyWithImpl<$Res>
    implements _$CreateFileCopyWith<$Res> {
  __$CreateFileCopyWithImpl(this._self, this._then);

  final _CreateFile _self;
  final $Res Function(_CreateFile) _then;

/// Create a copy of CreateFile
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? kind = null,Object? uri = null,Object? options = freezed,Object? annotationId = freezed,}) {
  return _then(_CreateFile(
kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as String,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,options: freezed == options ? _self.options : options // ignore: cast_nullable_to_non_nullable
as CreateFileOptions?,annotationId: freezed == annotationId ? _self.annotationId : annotationId // ignore: cast_nullable_to_non_nullable
as ChangeAnnotationIdentifier?,
  ));
}

/// Create a copy of CreateFile
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CreateFileOptionsCopyWith<$Res>? get options {
    if (_self.options == null) {
    return null;
  }

  return $CreateFileOptionsCopyWith<$Res>(_self.options!, (value) {
    return _then(_self.copyWith(options: value));
  });
}
}


/// @nodoc
mixin _$RenameFile {

 String get kind; String get oldUri; String get newUri; RenameFileOptions? get options; ChangeAnnotationIdentifier? get annotationId;
/// Create a copy of RenameFile
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RenameFileCopyWith<RenameFile> get copyWith => _$RenameFileCopyWithImpl<RenameFile>(this as RenameFile, _$identity);

  /// Serializes this RenameFile to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RenameFile&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.oldUri, oldUri) || other.oldUri == oldUri)&&(identical(other.newUri, newUri) || other.newUri == newUri)&&(identical(other.options, options) || other.options == options)&&(identical(other.annotationId, annotationId) || other.annotationId == annotationId));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,kind,oldUri,newUri,options,annotationId);

@override
String toString() {
  return 'RenameFile(kind: $kind, oldUri: $oldUri, newUri: $newUri, options: $options, annotationId: $annotationId)';
}


}

/// @nodoc
abstract mixin class $RenameFileCopyWith<$Res>  {
  factory $RenameFileCopyWith(RenameFile value, $Res Function(RenameFile) _then) = _$RenameFileCopyWithImpl;
@useResult
$Res call({
 String kind, String oldUri, String newUri, RenameFileOptions? options, ChangeAnnotationIdentifier? annotationId
});


$RenameFileOptionsCopyWith<$Res>? get options;

}
/// @nodoc
class _$RenameFileCopyWithImpl<$Res>
    implements $RenameFileCopyWith<$Res> {
  _$RenameFileCopyWithImpl(this._self, this._then);

  final RenameFile _self;
  final $Res Function(RenameFile) _then;

/// Create a copy of RenameFile
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? kind = null,Object? oldUri = null,Object? newUri = null,Object? options = freezed,Object? annotationId = freezed,}) {
  return _then(_self.copyWith(
kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as String,oldUri: null == oldUri ? _self.oldUri : oldUri // ignore: cast_nullable_to_non_nullable
as String,newUri: null == newUri ? _self.newUri : newUri // ignore: cast_nullable_to_non_nullable
as String,options: freezed == options ? _self.options : options // ignore: cast_nullable_to_non_nullable
as RenameFileOptions?,annotationId: freezed == annotationId ? _self.annotationId : annotationId // ignore: cast_nullable_to_non_nullable
as ChangeAnnotationIdentifier?,
  ));
}
/// Create a copy of RenameFile
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RenameFileOptionsCopyWith<$Res>? get options {
    if (_self.options == null) {
    return null;
  }

  return $RenameFileOptionsCopyWith<$Res>(_self.options!, (value) {
    return _then(_self.copyWith(options: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _RenameFile implements RenameFile {
  const _RenameFile({required this.kind, required this.oldUri, required this.newUri, this.options, this.annotationId});
  factory _RenameFile.fromJson(Map<String, dynamic> json) => _$RenameFileFromJson(json);

@override final  String kind;
@override final  String oldUri;
@override final  String newUri;
@override final  RenameFileOptions? options;
@override final  ChangeAnnotationIdentifier? annotationId;

/// Create a copy of RenameFile
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RenameFileCopyWith<_RenameFile> get copyWith => __$RenameFileCopyWithImpl<_RenameFile>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$RenameFileToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _RenameFile&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.oldUri, oldUri) || other.oldUri == oldUri)&&(identical(other.newUri, newUri) || other.newUri == newUri)&&(identical(other.options, options) || other.options == options)&&(identical(other.annotationId, annotationId) || other.annotationId == annotationId));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,kind,oldUri,newUri,options,annotationId);

@override
String toString() {
  return 'RenameFile(kind: $kind, oldUri: $oldUri, newUri: $newUri, options: $options, annotationId: $annotationId)';
}


}

/// @nodoc
abstract mixin class _$RenameFileCopyWith<$Res> implements $RenameFileCopyWith<$Res> {
  factory _$RenameFileCopyWith(_RenameFile value, $Res Function(_RenameFile) _then) = __$RenameFileCopyWithImpl;
@override @useResult
$Res call({
 String kind, String oldUri, String newUri, RenameFileOptions? options, ChangeAnnotationIdentifier? annotationId
});


@override $RenameFileOptionsCopyWith<$Res>? get options;

}
/// @nodoc
class __$RenameFileCopyWithImpl<$Res>
    implements _$RenameFileCopyWith<$Res> {
  __$RenameFileCopyWithImpl(this._self, this._then);

  final _RenameFile _self;
  final $Res Function(_RenameFile) _then;

/// Create a copy of RenameFile
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? kind = null,Object? oldUri = null,Object? newUri = null,Object? options = freezed,Object? annotationId = freezed,}) {
  return _then(_RenameFile(
kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as String,oldUri: null == oldUri ? _self.oldUri : oldUri // ignore: cast_nullable_to_non_nullable
as String,newUri: null == newUri ? _self.newUri : newUri // ignore: cast_nullable_to_non_nullable
as String,options: freezed == options ? _self.options : options // ignore: cast_nullable_to_non_nullable
as RenameFileOptions?,annotationId: freezed == annotationId ? _self.annotationId : annotationId // ignore: cast_nullable_to_non_nullable
as ChangeAnnotationIdentifier?,
  ));
}

/// Create a copy of RenameFile
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RenameFileOptionsCopyWith<$Res>? get options {
    if (_self.options == null) {
    return null;
  }

  return $RenameFileOptionsCopyWith<$Res>(_self.options!, (value) {
    return _then(_self.copyWith(options: value));
  });
}
}


/// @nodoc
mixin _$DeleteFile {

 String get kind; String get uri; DeleteFileOptions? get options; ChangeAnnotationIdentifier? get annotationId;
/// Create a copy of DeleteFile
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DeleteFileCopyWith<DeleteFile> get copyWith => _$DeleteFileCopyWithImpl<DeleteFile>(this as DeleteFile, _$identity);

  /// Serializes this DeleteFile to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DeleteFile&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.options, options) || other.options == options)&&(identical(other.annotationId, annotationId) || other.annotationId == annotationId));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,kind,uri,options,annotationId);

@override
String toString() {
  return 'DeleteFile(kind: $kind, uri: $uri, options: $options, annotationId: $annotationId)';
}


}

/// @nodoc
abstract mixin class $DeleteFileCopyWith<$Res>  {
  factory $DeleteFileCopyWith(DeleteFile value, $Res Function(DeleteFile) _then) = _$DeleteFileCopyWithImpl;
@useResult
$Res call({
 String kind, String uri, DeleteFileOptions? options, ChangeAnnotationIdentifier? annotationId
});


$DeleteFileOptionsCopyWith<$Res>? get options;

}
/// @nodoc
class _$DeleteFileCopyWithImpl<$Res>
    implements $DeleteFileCopyWith<$Res> {
  _$DeleteFileCopyWithImpl(this._self, this._then);

  final DeleteFile _self;
  final $Res Function(DeleteFile) _then;

/// Create a copy of DeleteFile
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? kind = null,Object? uri = null,Object? options = freezed,Object? annotationId = freezed,}) {
  return _then(_self.copyWith(
kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as String,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,options: freezed == options ? _self.options : options // ignore: cast_nullable_to_non_nullable
as DeleteFileOptions?,annotationId: freezed == annotationId ? _self.annotationId : annotationId // ignore: cast_nullable_to_non_nullable
as ChangeAnnotationIdentifier?,
  ));
}
/// Create a copy of DeleteFile
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DeleteFileOptionsCopyWith<$Res>? get options {
    if (_self.options == null) {
    return null;
  }

  return $DeleteFileOptionsCopyWith<$Res>(_self.options!, (value) {
    return _then(_self.copyWith(options: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DeleteFile implements DeleteFile {
  const _DeleteFile({required this.kind, required this.uri, this.options, this.annotationId});
  factory _DeleteFile.fromJson(Map<String, dynamic> json) => _$DeleteFileFromJson(json);

@override final  String kind;
@override final  String uri;
@override final  DeleteFileOptions? options;
@override final  ChangeAnnotationIdentifier? annotationId;

/// Create a copy of DeleteFile
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DeleteFileCopyWith<_DeleteFile> get copyWith => __$DeleteFileCopyWithImpl<_DeleteFile>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DeleteFileToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DeleteFile&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.options, options) || other.options == options)&&(identical(other.annotationId, annotationId) || other.annotationId == annotationId));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,kind,uri,options,annotationId);

@override
String toString() {
  return 'DeleteFile(kind: $kind, uri: $uri, options: $options, annotationId: $annotationId)';
}


}

/// @nodoc
abstract mixin class _$DeleteFileCopyWith<$Res> implements $DeleteFileCopyWith<$Res> {
  factory _$DeleteFileCopyWith(_DeleteFile value, $Res Function(_DeleteFile) _then) = __$DeleteFileCopyWithImpl;
@override @useResult
$Res call({
 String kind, String uri, DeleteFileOptions? options, ChangeAnnotationIdentifier? annotationId
});


@override $DeleteFileOptionsCopyWith<$Res>? get options;

}
/// @nodoc
class __$DeleteFileCopyWithImpl<$Res>
    implements _$DeleteFileCopyWith<$Res> {
  __$DeleteFileCopyWithImpl(this._self, this._then);

  final _DeleteFile _self;
  final $Res Function(_DeleteFile) _then;

/// Create a copy of DeleteFile
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? kind = null,Object? uri = null,Object? options = freezed,Object? annotationId = freezed,}) {
  return _then(_DeleteFile(
kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as String,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,options: freezed == options ? _self.options : options // ignore: cast_nullable_to_non_nullable
as DeleteFileOptions?,annotationId: freezed == annotationId ? _self.annotationId : annotationId // ignore: cast_nullable_to_non_nullable
as ChangeAnnotationIdentifier?,
  ));
}

/// Create a copy of DeleteFile
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DeleteFileOptionsCopyWith<$Res>? get options {
    if (_self.options == null) {
    return null;
  }

  return $DeleteFileOptionsCopyWith<$Res>(_self.options!, (value) {
    return _then(_self.copyWith(options: value));
  });
}
}


/// @nodoc
mixin _$ChangeAnnotation {

 String get label; String? get description; bool? get needsConfirmation;
/// Create a copy of ChangeAnnotation
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ChangeAnnotationCopyWith<ChangeAnnotation> get copyWith => _$ChangeAnnotationCopyWithImpl<ChangeAnnotation>(this as ChangeAnnotation, _$identity);

  /// Serializes this ChangeAnnotation to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ChangeAnnotation&&(identical(other.label, label) || other.label == label)&&(identical(other.description, description) || other.description == description)&&(identical(other.needsConfirmation, needsConfirmation) || other.needsConfirmation == needsConfirmation));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,label,description,needsConfirmation);

@override
String toString() {
  return 'ChangeAnnotation(label: $label, description: $description, needsConfirmation: $needsConfirmation)';
}


}

/// @nodoc
abstract mixin class $ChangeAnnotationCopyWith<$Res>  {
  factory $ChangeAnnotationCopyWith(ChangeAnnotation value, $Res Function(ChangeAnnotation) _then) = _$ChangeAnnotationCopyWithImpl;
@useResult
$Res call({
 String label, String? description, bool? needsConfirmation
});




}
/// @nodoc
class _$ChangeAnnotationCopyWithImpl<$Res>
    implements $ChangeAnnotationCopyWith<$Res> {
  _$ChangeAnnotationCopyWithImpl(this._self, this._then);

  final ChangeAnnotation _self;
  final $Res Function(ChangeAnnotation) _then;

/// Create a copy of ChangeAnnotation
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? label = null,Object? description = freezed,Object? needsConfirmation = freezed,}) {
  return _then(_self.copyWith(
label: null == label ? _self.label : label // ignore: cast_nullable_to_non_nullable
as String,description: freezed == description ? _self.description : description // ignore: cast_nullable_to_non_nullable
as String?,needsConfirmation: freezed == needsConfirmation ? _self.needsConfirmation : needsConfirmation // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _ChangeAnnotation implements ChangeAnnotation {
  const _ChangeAnnotation({required this.label, this.description, this.needsConfirmation});
  factory _ChangeAnnotation.fromJson(Map<String, dynamic> json) => _$ChangeAnnotationFromJson(json);

@override final  String label;
@override final  String? description;
@override final  bool? needsConfirmation;

/// Create a copy of ChangeAnnotation
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ChangeAnnotationCopyWith<_ChangeAnnotation> get copyWith => __$ChangeAnnotationCopyWithImpl<_ChangeAnnotation>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ChangeAnnotationToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ChangeAnnotation&&(identical(other.label, label) || other.label == label)&&(identical(other.description, description) || other.description == description)&&(identical(other.needsConfirmation, needsConfirmation) || other.needsConfirmation == needsConfirmation));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,label,description,needsConfirmation);

@override
String toString() {
  return 'ChangeAnnotation(label: $label, description: $description, needsConfirmation: $needsConfirmation)';
}


}

/// @nodoc
abstract mixin class _$ChangeAnnotationCopyWith<$Res> implements $ChangeAnnotationCopyWith<$Res> {
  factory _$ChangeAnnotationCopyWith(_ChangeAnnotation value, $Res Function(_ChangeAnnotation) _then) = __$ChangeAnnotationCopyWithImpl;
@override @useResult
$Res call({
 String label, String? description, bool? needsConfirmation
});




}
/// @nodoc
class __$ChangeAnnotationCopyWithImpl<$Res>
    implements _$ChangeAnnotationCopyWith<$Res> {
  __$ChangeAnnotationCopyWithImpl(this._self, this._then);

  final _ChangeAnnotation _self;
  final $Res Function(_ChangeAnnotation) _then;

/// Create a copy of ChangeAnnotation
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? label = null,Object? description = freezed,Object? needsConfirmation = freezed,}) {
  return _then(_ChangeAnnotation(
label: null == label ? _self.label : label // ignore: cast_nullable_to_non_nullable
as String,description: freezed == description ? _self.description : description // ignore: cast_nullable_to_non_nullable
as String?,needsConfirmation: freezed == needsConfirmation ? _self.needsConfirmation : needsConfirmation // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$FileOperationFilter {

 FileOperationPattern get pattern; String? get scheme;
/// Create a copy of FileOperationFilter
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FileOperationFilterCopyWith<FileOperationFilter> get copyWith => _$FileOperationFilterCopyWithImpl<FileOperationFilter>(this as FileOperationFilter, _$identity);

  /// Serializes this FileOperationFilter to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FileOperationFilter&&(identical(other.pattern, pattern) || other.pattern == pattern)&&(identical(other.scheme, scheme) || other.scheme == scheme));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,pattern,scheme);

@override
String toString() {
  return 'FileOperationFilter(pattern: $pattern, scheme: $scheme)';
}


}

/// @nodoc
abstract mixin class $FileOperationFilterCopyWith<$Res>  {
  factory $FileOperationFilterCopyWith(FileOperationFilter value, $Res Function(FileOperationFilter) _then) = _$FileOperationFilterCopyWithImpl;
@useResult
$Res call({
 FileOperationPattern pattern, String? scheme
});


$FileOperationPatternCopyWith<$Res> get pattern;

}
/// @nodoc
class _$FileOperationFilterCopyWithImpl<$Res>
    implements $FileOperationFilterCopyWith<$Res> {
  _$FileOperationFilterCopyWithImpl(this._self, this._then);

  final FileOperationFilter _self;
  final $Res Function(FileOperationFilter) _then;

/// Create a copy of FileOperationFilter
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? pattern = null,Object? scheme = freezed,}) {
  return _then(_self.copyWith(
pattern: null == pattern ? _self.pattern : pattern // ignore: cast_nullable_to_non_nullable
as FileOperationPattern,scheme: freezed == scheme ? _self.scheme : scheme // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}
/// Create a copy of FileOperationFilter
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FileOperationPatternCopyWith<$Res> get pattern {
  
  return $FileOperationPatternCopyWith<$Res>(_self.pattern, (value) {
    return _then(_self.copyWith(pattern: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _FileOperationFilter implements FileOperationFilter {
  const _FileOperationFilter({required this.pattern, this.scheme});
  factory _FileOperationFilter.fromJson(Map<String, dynamic> json) => _$FileOperationFilterFromJson(json);

@override final  FileOperationPattern pattern;
@override final  String? scheme;

/// Create a copy of FileOperationFilter
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$FileOperationFilterCopyWith<_FileOperationFilter> get copyWith => __$FileOperationFilterCopyWithImpl<_FileOperationFilter>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$FileOperationFilterToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _FileOperationFilter&&(identical(other.pattern, pattern) || other.pattern == pattern)&&(identical(other.scheme, scheme) || other.scheme == scheme));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,pattern,scheme);

@override
String toString() {
  return 'FileOperationFilter(pattern: $pattern, scheme: $scheme)';
}


}

/// @nodoc
abstract mixin class _$FileOperationFilterCopyWith<$Res> implements $FileOperationFilterCopyWith<$Res> {
  factory _$FileOperationFilterCopyWith(_FileOperationFilter value, $Res Function(_FileOperationFilter) _then) = __$FileOperationFilterCopyWithImpl;
@override @useResult
$Res call({
 FileOperationPattern pattern, String? scheme
});


@override $FileOperationPatternCopyWith<$Res> get pattern;

}
/// @nodoc
class __$FileOperationFilterCopyWithImpl<$Res>
    implements _$FileOperationFilterCopyWith<$Res> {
  __$FileOperationFilterCopyWithImpl(this._self, this._then);

  final _FileOperationFilter _self;
  final $Res Function(_FileOperationFilter) _then;

/// Create a copy of FileOperationFilter
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? pattern = null,Object? scheme = freezed,}) {
  return _then(_FileOperationFilter(
pattern: null == pattern ? _self.pattern : pattern // ignore: cast_nullable_to_non_nullable
as FileOperationPattern,scheme: freezed == scheme ? _self.scheme : scheme // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

/// Create a copy of FileOperationFilter
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FileOperationPatternCopyWith<$Res> get pattern {
  
  return $FileOperationPatternCopyWith<$Res>(_self.pattern, (value) {
    return _then(_self.copyWith(pattern: value));
  });
}
}


/// @nodoc
mixin _$FileRename {

 String get oldUri; String get newUri;
/// Create a copy of FileRename
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FileRenameCopyWith<FileRename> get copyWith => _$FileRenameCopyWithImpl<FileRename>(this as FileRename, _$identity);

  /// Serializes this FileRename to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FileRename&&(identical(other.oldUri, oldUri) || other.oldUri == oldUri)&&(identical(other.newUri, newUri) || other.newUri == newUri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,oldUri,newUri);

@override
String toString() {
  return 'FileRename(oldUri: $oldUri, newUri: $newUri)';
}


}

/// @nodoc
abstract mixin class $FileRenameCopyWith<$Res>  {
  factory $FileRenameCopyWith(FileRename value, $Res Function(FileRename) _then) = _$FileRenameCopyWithImpl;
@useResult
$Res call({
 String oldUri, String newUri
});




}
/// @nodoc
class _$FileRenameCopyWithImpl<$Res>
    implements $FileRenameCopyWith<$Res> {
  _$FileRenameCopyWithImpl(this._self, this._then);

  final FileRename _self;
  final $Res Function(FileRename) _then;

/// Create a copy of FileRename
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? oldUri = null,Object? newUri = null,}) {
  return _then(_self.copyWith(
oldUri: null == oldUri ? _self.oldUri : oldUri // ignore: cast_nullable_to_non_nullable
as String,newUri: null == newUri ? _self.newUri : newUri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _FileRename implements FileRename {
  const _FileRename({required this.oldUri, required this.newUri});
  factory _FileRename.fromJson(Map<String, dynamic> json) => _$FileRenameFromJson(json);

@override final  String oldUri;
@override final  String newUri;

/// Create a copy of FileRename
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$FileRenameCopyWith<_FileRename> get copyWith => __$FileRenameCopyWithImpl<_FileRename>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$FileRenameToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _FileRename&&(identical(other.oldUri, oldUri) || other.oldUri == oldUri)&&(identical(other.newUri, newUri) || other.newUri == newUri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,oldUri,newUri);

@override
String toString() {
  return 'FileRename(oldUri: $oldUri, newUri: $newUri)';
}


}

/// @nodoc
abstract mixin class _$FileRenameCopyWith<$Res> implements $FileRenameCopyWith<$Res> {
  factory _$FileRenameCopyWith(_FileRename value, $Res Function(_FileRename) _then) = __$FileRenameCopyWithImpl;
@override @useResult
$Res call({
 String oldUri, String newUri
});




}
/// @nodoc
class __$FileRenameCopyWithImpl<$Res>
    implements _$FileRenameCopyWith<$Res> {
  __$FileRenameCopyWithImpl(this._self, this._then);

  final _FileRename _self;
  final $Res Function(_FileRename) _then;

/// Create a copy of FileRename
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? oldUri = null,Object? newUri = null,}) {
  return _then(_FileRename(
oldUri: null == oldUri ? _self.oldUri : oldUri // ignore: cast_nullable_to_non_nullable
as String,newUri: null == newUri ? _self.newUri : newUri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}


/// @nodoc
mixin _$FileDelete {

 String get uri;
/// Create a copy of FileDelete
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FileDeleteCopyWith<FileDelete> get copyWith => _$FileDeleteCopyWithImpl<FileDelete>(this as FileDelete, _$identity);

  /// Serializes this FileDelete to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FileDelete&&(identical(other.uri, uri) || other.uri == uri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri);

@override
String toString() {
  return 'FileDelete(uri: $uri)';
}


}

/// @nodoc
abstract mixin class $FileDeleteCopyWith<$Res>  {
  factory $FileDeleteCopyWith(FileDelete value, $Res Function(FileDelete) _then) = _$FileDeleteCopyWithImpl;
@useResult
$Res call({
 String uri
});




}
/// @nodoc
class _$FileDeleteCopyWithImpl<$Res>
    implements $FileDeleteCopyWith<$Res> {
  _$FileDeleteCopyWithImpl(this._self, this._then);

  final FileDelete _self;
  final $Res Function(FileDelete) _then;

/// Create a copy of FileDelete
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? uri = null,}) {
  return _then(_self.copyWith(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _FileDelete implements FileDelete {
  const _FileDelete({required this.uri});
  factory _FileDelete.fromJson(Map<String, dynamic> json) => _$FileDeleteFromJson(json);

@override final  String uri;

/// Create a copy of FileDelete
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$FileDeleteCopyWith<_FileDelete> get copyWith => __$FileDeleteCopyWithImpl<_FileDelete>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$FileDeleteToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _FileDelete&&(identical(other.uri, uri) || other.uri == uri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri);

@override
String toString() {
  return 'FileDelete(uri: $uri)';
}


}

/// @nodoc
abstract mixin class _$FileDeleteCopyWith<$Res> implements $FileDeleteCopyWith<$Res> {
  factory _$FileDeleteCopyWith(_FileDelete value, $Res Function(_FileDelete) _then) = __$FileDeleteCopyWithImpl;
@override @useResult
$Res call({
 String uri
});




}
/// @nodoc
class __$FileDeleteCopyWithImpl<$Res>
    implements _$FileDeleteCopyWith<$Res> {
  __$FileDeleteCopyWithImpl(this._self, this._then);

  final _FileDelete _self;
  final $Res Function(_FileDelete) _then;

/// Create a copy of FileDelete
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? uri = null,}) {
  return _then(_FileDelete(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}


/// @nodoc
mixin _$MonikerOptions {

 bool? get workDoneProgress;
/// Create a copy of MonikerOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$MonikerOptionsCopyWith<MonikerOptions> get copyWith => _$MonikerOptionsCopyWithImpl<MonikerOptions>(this as MonikerOptions, _$identity);

  /// Serializes this MonikerOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is MonikerOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'MonikerOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $MonikerOptionsCopyWith<$Res>  {
  factory $MonikerOptionsCopyWith(MonikerOptions value, $Res Function(MonikerOptions) _then) = _$MonikerOptionsCopyWithImpl;
@useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class _$MonikerOptionsCopyWithImpl<$Res>
    implements $MonikerOptionsCopyWith<$Res> {
  _$MonikerOptionsCopyWithImpl(this._self, this._then);

  final MonikerOptions _self;
  final $Res Function(MonikerOptions) _then;

/// Create a copy of MonikerOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _MonikerOptions implements MonikerOptions {
  const _MonikerOptions({this.workDoneProgress});
  factory _MonikerOptions.fromJson(Map<String, dynamic> json) => _$MonikerOptionsFromJson(json);

@override final  bool? workDoneProgress;

/// Create a copy of MonikerOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$MonikerOptionsCopyWith<_MonikerOptions> get copyWith => __$MonikerOptionsCopyWithImpl<_MonikerOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$MonikerOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _MonikerOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'MonikerOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$MonikerOptionsCopyWith<$Res> implements $MonikerOptionsCopyWith<$Res> {
  factory _$MonikerOptionsCopyWith(_MonikerOptions value, $Res Function(_MonikerOptions) _then) = __$MonikerOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class __$MonikerOptionsCopyWithImpl<$Res>
    implements _$MonikerOptionsCopyWith<$Res> {
  __$MonikerOptionsCopyWithImpl(this._self, this._then);

  final _MonikerOptions _self;
  final $Res Function(_MonikerOptions) _then;

/// Create a copy of MonikerOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_MonikerOptions(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$TypeHierarchyOptions {

 bool? get workDoneProgress;
/// Create a copy of TypeHierarchyOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TypeHierarchyOptionsCopyWith<TypeHierarchyOptions> get copyWith => _$TypeHierarchyOptionsCopyWithImpl<TypeHierarchyOptions>(this as TypeHierarchyOptions, _$identity);

  /// Serializes this TypeHierarchyOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TypeHierarchyOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'TypeHierarchyOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $TypeHierarchyOptionsCopyWith<$Res>  {
  factory $TypeHierarchyOptionsCopyWith(TypeHierarchyOptions value, $Res Function(TypeHierarchyOptions) _then) = _$TypeHierarchyOptionsCopyWithImpl;
@useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class _$TypeHierarchyOptionsCopyWithImpl<$Res>
    implements $TypeHierarchyOptionsCopyWith<$Res> {
  _$TypeHierarchyOptionsCopyWithImpl(this._self, this._then);

  final TypeHierarchyOptions _self;
  final $Res Function(TypeHierarchyOptions) _then;

/// Create a copy of TypeHierarchyOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _TypeHierarchyOptions implements TypeHierarchyOptions {
  const _TypeHierarchyOptions({this.workDoneProgress});
  factory _TypeHierarchyOptions.fromJson(Map<String, dynamic> json) => _$TypeHierarchyOptionsFromJson(json);

@override final  bool? workDoneProgress;

/// Create a copy of TypeHierarchyOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TypeHierarchyOptionsCopyWith<_TypeHierarchyOptions> get copyWith => __$TypeHierarchyOptionsCopyWithImpl<_TypeHierarchyOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TypeHierarchyOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TypeHierarchyOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'TypeHierarchyOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$TypeHierarchyOptionsCopyWith<$Res> implements $TypeHierarchyOptionsCopyWith<$Res> {
  factory _$TypeHierarchyOptionsCopyWith(_TypeHierarchyOptions value, $Res Function(_TypeHierarchyOptions) _then) = __$TypeHierarchyOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class __$TypeHierarchyOptionsCopyWithImpl<$Res>
    implements _$TypeHierarchyOptionsCopyWith<$Res> {
  __$TypeHierarchyOptionsCopyWithImpl(this._self, this._then);

  final _TypeHierarchyOptions _self;
  final $Res Function(_TypeHierarchyOptions) _then;

/// Create a copy of TypeHierarchyOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_TypeHierarchyOptions(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$InlineValueContext {

 int get frameId; Range get stoppedLocation;
/// Create a copy of InlineValueContext
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlineValueContextCopyWith<InlineValueContext> get copyWith => _$InlineValueContextCopyWithImpl<InlineValueContext>(this as InlineValueContext, _$identity);

  /// Serializes this InlineValueContext to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlineValueContext&&(identical(other.frameId, frameId) || other.frameId == frameId)&&(identical(other.stoppedLocation, stoppedLocation) || other.stoppedLocation == stoppedLocation));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,frameId,stoppedLocation);

@override
String toString() {
  return 'InlineValueContext(frameId: $frameId, stoppedLocation: $stoppedLocation)';
}


}

/// @nodoc
abstract mixin class $InlineValueContextCopyWith<$Res>  {
  factory $InlineValueContextCopyWith(InlineValueContext value, $Res Function(InlineValueContext) _then) = _$InlineValueContextCopyWithImpl;
@useResult
$Res call({
 int frameId, Range stoppedLocation
});


$RangeCopyWith<$Res> get stoppedLocation;

}
/// @nodoc
class _$InlineValueContextCopyWithImpl<$Res>
    implements $InlineValueContextCopyWith<$Res> {
  _$InlineValueContextCopyWithImpl(this._self, this._then);

  final InlineValueContext _self;
  final $Res Function(InlineValueContext) _then;

/// Create a copy of InlineValueContext
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? frameId = null,Object? stoppedLocation = null,}) {
  return _then(_self.copyWith(
frameId: null == frameId ? _self.frameId : frameId // ignore: cast_nullable_to_non_nullable
as int,stoppedLocation: null == stoppedLocation ? _self.stoppedLocation : stoppedLocation // ignore: cast_nullable_to_non_nullable
as Range,
  ));
}
/// Create a copy of InlineValueContext
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get stoppedLocation {
  
  return $RangeCopyWith<$Res>(_self.stoppedLocation, (value) {
    return _then(_self.copyWith(stoppedLocation: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _InlineValueContext implements InlineValueContext {
  const _InlineValueContext({required this.frameId, required this.stoppedLocation});
  factory _InlineValueContext.fromJson(Map<String, dynamic> json) => _$InlineValueContextFromJson(json);

@override final  int frameId;
@override final  Range stoppedLocation;

/// Create a copy of InlineValueContext
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlineValueContextCopyWith<_InlineValueContext> get copyWith => __$InlineValueContextCopyWithImpl<_InlineValueContext>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlineValueContextToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlineValueContext&&(identical(other.frameId, frameId) || other.frameId == frameId)&&(identical(other.stoppedLocation, stoppedLocation) || other.stoppedLocation == stoppedLocation));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,frameId,stoppedLocation);

@override
String toString() {
  return 'InlineValueContext(frameId: $frameId, stoppedLocation: $stoppedLocation)';
}


}

/// @nodoc
abstract mixin class _$InlineValueContextCopyWith<$Res> implements $InlineValueContextCopyWith<$Res> {
  factory _$InlineValueContextCopyWith(_InlineValueContext value, $Res Function(_InlineValueContext) _then) = __$InlineValueContextCopyWithImpl;
@override @useResult
$Res call({
 int frameId, Range stoppedLocation
});


@override $RangeCopyWith<$Res> get stoppedLocation;

}
/// @nodoc
class __$InlineValueContextCopyWithImpl<$Res>
    implements _$InlineValueContextCopyWith<$Res> {
  __$InlineValueContextCopyWithImpl(this._self, this._then);

  final _InlineValueContext _self;
  final $Res Function(_InlineValueContext) _then;

/// Create a copy of InlineValueContext
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? frameId = null,Object? stoppedLocation = null,}) {
  return _then(_InlineValueContext(
frameId: null == frameId ? _self.frameId : frameId // ignore: cast_nullable_to_non_nullable
as int,stoppedLocation: null == stoppedLocation ? _self.stoppedLocation : stoppedLocation // ignore: cast_nullable_to_non_nullable
as Range,
  ));
}

/// Create a copy of InlineValueContext
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get stoppedLocation {
  
  return $RangeCopyWith<$Res>(_self.stoppedLocation, (value) {
    return _then(_self.copyWith(stoppedLocation: value));
  });
}
}


/// @nodoc
mixin _$InlineValueText {

 Range get range; String get text;
/// Create a copy of InlineValueText
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlineValueTextCopyWith<InlineValueText> get copyWith => _$InlineValueTextCopyWithImpl<InlineValueText>(this as InlineValueText, _$identity);

  /// Serializes this InlineValueText to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlineValueText&&(identical(other.range, range) || other.range == range)&&(identical(other.text, text) || other.text == text));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,range,text);

@override
String toString() {
  return 'InlineValueText(range: $range, text: $text)';
}


}

/// @nodoc
abstract mixin class $InlineValueTextCopyWith<$Res>  {
  factory $InlineValueTextCopyWith(InlineValueText value, $Res Function(InlineValueText) _then) = _$InlineValueTextCopyWithImpl;
@useResult
$Res call({
 Range range, String text
});


$RangeCopyWith<$Res> get range;

}
/// @nodoc
class _$InlineValueTextCopyWithImpl<$Res>
    implements $InlineValueTextCopyWith<$Res> {
  _$InlineValueTextCopyWithImpl(this._self, this._then);

  final InlineValueText _self;
  final $Res Function(InlineValueText) _then;

/// Create a copy of InlineValueText
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? range = null,Object? text = null,}) {
  return _then(_self.copyWith(
range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,text: null == text ? _self.text : text // ignore: cast_nullable_to_non_nullable
as String,
  ));
}
/// Create a copy of InlineValueText
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _InlineValueText implements InlineValueText {
  const _InlineValueText({required this.range, required this.text});
  factory _InlineValueText.fromJson(Map<String, dynamic> json) => _$InlineValueTextFromJson(json);

@override final  Range range;
@override final  String text;

/// Create a copy of InlineValueText
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlineValueTextCopyWith<_InlineValueText> get copyWith => __$InlineValueTextCopyWithImpl<_InlineValueText>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlineValueTextToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlineValueText&&(identical(other.range, range) || other.range == range)&&(identical(other.text, text) || other.text == text));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,range,text);

@override
String toString() {
  return 'InlineValueText(range: $range, text: $text)';
}


}

/// @nodoc
abstract mixin class _$InlineValueTextCopyWith<$Res> implements $InlineValueTextCopyWith<$Res> {
  factory _$InlineValueTextCopyWith(_InlineValueText value, $Res Function(_InlineValueText) _then) = __$InlineValueTextCopyWithImpl;
@override @useResult
$Res call({
 Range range, String text
});


@override $RangeCopyWith<$Res> get range;

}
/// @nodoc
class __$InlineValueTextCopyWithImpl<$Res>
    implements _$InlineValueTextCopyWith<$Res> {
  __$InlineValueTextCopyWithImpl(this._self, this._then);

  final _InlineValueText _self;
  final $Res Function(_InlineValueText) _then;

/// Create a copy of InlineValueText
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? range = null,Object? text = null,}) {
  return _then(_InlineValueText(
range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,text: null == text ? _self.text : text // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

/// Create a copy of InlineValueText
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}


/// @nodoc
mixin _$InlineValueVariableLookup {

 Range get range; bool get caseSensitiveLookup; String? get variableName;
/// Create a copy of InlineValueVariableLookup
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlineValueVariableLookupCopyWith<InlineValueVariableLookup> get copyWith => _$InlineValueVariableLookupCopyWithImpl<InlineValueVariableLookup>(this as InlineValueVariableLookup, _$identity);

  /// Serializes this InlineValueVariableLookup to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlineValueVariableLookup&&(identical(other.range, range) || other.range == range)&&(identical(other.caseSensitiveLookup, caseSensitiveLookup) || other.caseSensitiveLookup == caseSensitiveLookup)&&(identical(other.variableName, variableName) || other.variableName == variableName));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,range,caseSensitiveLookup,variableName);

@override
String toString() {
  return 'InlineValueVariableLookup(range: $range, caseSensitiveLookup: $caseSensitiveLookup, variableName: $variableName)';
}


}

/// @nodoc
abstract mixin class $InlineValueVariableLookupCopyWith<$Res>  {
  factory $InlineValueVariableLookupCopyWith(InlineValueVariableLookup value, $Res Function(InlineValueVariableLookup) _then) = _$InlineValueVariableLookupCopyWithImpl;
@useResult
$Res call({
 Range range, bool caseSensitiveLookup, String? variableName
});


$RangeCopyWith<$Res> get range;

}
/// @nodoc
class _$InlineValueVariableLookupCopyWithImpl<$Res>
    implements $InlineValueVariableLookupCopyWith<$Res> {
  _$InlineValueVariableLookupCopyWithImpl(this._self, this._then);

  final InlineValueVariableLookup _self;
  final $Res Function(InlineValueVariableLookup) _then;

/// Create a copy of InlineValueVariableLookup
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? range = null,Object? caseSensitiveLookup = null,Object? variableName = freezed,}) {
  return _then(_self.copyWith(
range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,caseSensitiveLookup: null == caseSensitiveLookup ? _self.caseSensitiveLookup : caseSensitiveLookup // ignore: cast_nullable_to_non_nullable
as bool,variableName: freezed == variableName ? _self.variableName : variableName // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}
/// Create a copy of InlineValueVariableLookup
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _InlineValueVariableLookup implements InlineValueVariableLookup {
  const _InlineValueVariableLookup({required this.range, required this.caseSensitiveLookup, this.variableName});
  factory _InlineValueVariableLookup.fromJson(Map<String, dynamic> json) => _$InlineValueVariableLookupFromJson(json);

@override final  Range range;
@override final  bool caseSensitiveLookup;
@override final  String? variableName;

/// Create a copy of InlineValueVariableLookup
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlineValueVariableLookupCopyWith<_InlineValueVariableLookup> get copyWith => __$InlineValueVariableLookupCopyWithImpl<_InlineValueVariableLookup>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlineValueVariableLookupToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlineValueVariableLookup&&(identical(other.range, range) || other.range == range)&&(identical(other.caseSensitiveLookup, caseSensitiveLookup) || other.caseSensitiveLookup == caseSensitiveLookup)&&(identical(other.variableName, variableName) || other.variableName == variableName));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,range,caseSensitiveLookup,variableName);

@override
String toString() {
  return 'InlineValueVariableLookup(range: $range, caseSensitiveLookup: $caseSensitiveLookup, variableName: $variableName)';
}


}

/// @nodoc
abstract mixin class _$InlineValueVariableLookupCopyWith<$Res> implements $InlineValueVariableLookupCopyWith<$Res> {
  factory _$InlineValueVariableLookupCopyWith(_InlineValueVariableLookup value, $Res Function(_InlineValueVariableLookup) _then) = __$InlineValueVariableLookupCopyWithImpl;
@override @useResult
$Res call({
 Range range, bool caseSensitiveLookup, String? variableName
});


@override $RangeCopyWith<$Res> get range;

}
/// @nodoc
class __$InlineValueVariableLookupCopyWithImpl<$Res>
    implements _$InlineValueVariableLookupCopyWith<$Res> {
  __$InlineValueVariableLookupCopyWithImpl(this._self, this._then);

  final _InlineValueVariableLookup _self;
  final $Res Function(_InlineValueVariableLookup) _then;

/// Create a copy of InlineValueVariableLookup
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? range = null,Object? caseSensitiveLookup = null,Object? variableName = freezed,}) {
  return _then(_InlineValueVariableLookup(
range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,caseSensitiveLookup: null == caseSensitiveLookup ? _self.caseSensitiveLookup : caseSensitiveLookup // ignore: cast_nullable_to_non_nullable
as bool,variableName: freezed == variableName ? _self.variableName : variableName // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

/// Create a copy of InlineValueVariableLookup
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}


/// @nodoc
mixin _$InlineValueEvaluatableExpression {

 Range get range; String? get expression;
/// Create a copy of InlineValueEvaluatableExpression
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlineValueEvaluatableExpressionCopyWith<InlineValueEvaluatableExpression> get copyWith => _$InlineValueEvaluatableExpressionCopyWithImpl<InlineValueEvaluatableExpression>(this as InlineValueEvaluatableExpression, _$identity);

  /// Serializes this InlineValueEvaluatableExpression to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlineValueEvaluatableExpression&&(identical(other.range, range) || other.range == range)&&(identical(other.expression, expression) || other.expression == expression));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,range,expression);

@override
String toString() {
  return 'InlineValueEvaluatableExpression(range: $range, expression: $expression)';
}


}

/// @nodoc
abstract mixin class $InlineValueEvaluatableExpressionCopyWith<$Res>  {
  factory $InlineValueEvaluatableExpressionCopyWith(InlineValueEvaluatableExpression value, $Res Function(InlineValueEvaluatableExpression) _then) = _$InlineValueEvaluatableExpressionCopyWithImpl;
@useResult
$Res call({
 Range range, String? expression
});


$RangeCopyWith<$Res> get range;

}
/// @nodoc
class _$InlineValueEvaluatableExpressionCopyWithImpl<$Res>
    implements $InlineValueEvaluatableExpressionCopyWith<$Res> {
  _$InlineValueEvaluatableExpressionCopyWithImpl(this._self, this._then);

  final InlineValueEvaluatableExpression _self;
  final $Res Function(InlineValueEvaluatableExpression) _then;

/// Create a copy of InlineValueEvaluatableExpression
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? range = null,Object? expression = freezed,}) {
  return _then(_self.copyWith(
range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,expression: freezed == expression ? _self.expression : expression // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}
/// Create a copy of InlineValueEvaluatableExpression
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _InlineValueEvaluatableExpression implements InlineValueEvaluatableExpression {
  const _InlineValueEvaluatableExpression({required this.range, this.expression});
  factory _InlineValueEvaluatableExpression.fromJson(Map<String, dynamic> json) => _$InlineValueEvaluatableExpressionFromJson(json);

@override final  Range range;
@override final  String? expression;

/// Create a copy of InlineValueEvaluatableExpression
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlineValueEvaluatableExpressionCopyWith<_InlineValueEvaluatableExpression> get copyWith => __$InlineValueEvaluatableExpressionCopyWithImpl<_InlineValueEvaluatableExpression>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlineValueEvaluatableExpressionToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlineValueEvaluatableExpression&&(identical(other.range, range) || other.range == range)&&(identical(other.expression, expression) || other.expression == expression));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,range,expression);

@override
String toString() {
  return 'InlineValueEvaluatableExpression(range: $range, expression: $expression)';
}


}

/// @nodoc
abstract mixin class _$InlineValueEvaluatableExpressionCopyWith<$Res> implements $InlineValueEvaluatableExpressionCopyWith<$Res> {
  factory _$InlineValueEvaluatableExpressionCopyWith(_InlineValueEvaluatableExpression value, $Res Function(_InlineValueEvaluatableExpression) _then) = __$InlineValueEvaluatableExpressionCopyWithImpl;
@override @useResult
$Res call({
 Range range, String? expression
});


@override $RangeCopyWith<$Res> get range;

}
/// @nodoc
class __$InlineValueEvaluatableExpressionCopyWithImpl<$Res>
    implements _$InlineValueEvaluatableExpressionCopyWith<$Res> {
  __$InlineValueEvaluatableExpressionCopyWithImpl(this._self, this._then);

  final _InlineValueEvaluatableExpression _self;
  final $Res Function(_InlineValueEvaluatableExpression) _then;

/// Create a copy of InlineValueEvaluatableExpression
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? range = null,Object? expression = freezed,}) {
  return _then(_InlineValueEvaluatableExpression(
range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,expression: freezed == expression ? _self.expression : expression // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

/// Create a copy of InlineValueEvaluatableExpression
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}


/// @nodoc
mixin _$InlineValueOptions {

 bool? get workDoneProgress;
/// Create a copy of InlineValueOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlineValueOptionsCopyWith<InlineValueOptions> get copyWith => _$InlineValueOptionsCopyWithImpl<InlineValueOptions>(this as InlineValueOptions, _$identity);

  /// Serializes this InlineValueOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlineValueOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'InlineValueOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $InlineValueOptionsCopyWith<$Res>  {
  factory $InlineValueOptionsCopyWith(InlineValueOptions value, $Res Function(InlineValueOptions) _then) = _$InlineValueOptionsCopyWithImpl;
@useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class _$InlineValueOptionsCopyWithImpl<$Res>
    implements $InlineValueOptionsCopyWith<$Res> {
  _$InlineValueOptionsCopyWithImpl(this._self, this._then);

  final InlineValueOptions _self;
  final $Res Function(InlineValueOptions) _then;

/// Create a copy of InlineValueOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _InlineValueOptions implements InlineValueOptions {
  const _InlineValueOptions({this.workDoneProgress});
  factory _InlineValueOptions.fromJson(Map<String, dynamic> json) => _$InlineValueOptionsFromJson(json);

@override final  bool? workDoneProgress;

/// Create a copy of InlineValueOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlineValueOptionsCopyWith<_InlineValueOptions> get copyWith => __$InlineValueOptionsCopyWithImpl<_InlineValueOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlineValueOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlineValueOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'InlineValueOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$InlineValueOptionsCopyWith<$Res> implements $InlineValueOptionsCopyWith<$Res> {
  factory _$InlineValueOptionsCopyWith(_InlineValueOptions value, $Res Function(_InlineValueOptions) _then) = __$InlineValueOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class __$InlineValueOptionsCopyWithImpl<$Res>
    implements _$InlineValueOptionsCopyWith<$Res> {
  __$InlineValueOptionsCopyWithImpl(this._self, this._then);

  final _InlineValueOptions _self;
  final $Res Function(_InlineValueOptions) _then;

/// Create a copy of InlineValueOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_InlineValueOptions(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$InlayHintLabelPart {

 String get value; Command? get command; Location? get location; dynamic? get tooltip;
/// Create a copy of InlayHintLabelPart
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlayHintLabelPartCopyWith<InlayHintLabelPart> get copyWith => _$InlayHintLabelPartCopyWithImpl<InlayHintLabelPart>(this as InlayHintLabelPart, _$identity);

  /// Serializes this InlayHintLabelPart to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlayHintLabelPart&&(identical(other.value, value) || other.value == value)&&(identical(other.command, command) || other.command == command)&&(identical(other.location, location) || other.location == location)&&const DeepCollectionEquality().equals(other.tooltip, tooltip));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,value,command,location,const DeepCollectionEquality().hash(tooltip));

@override
String toString() {
  return 'InlayHintLabelPart(value: $value, command: $command, location: $location, tooltip: $tooltip)';
}


}

/// @nodoc
abstract mixin class $InlayHintLabelPartCopyWith<$Res>  {
  factory $InlayHintLabelPartCopyWith(InlayHintLabelPart value, $Res Function(InlayHintLabelPart) _then) = _$InlayHintLabelPartCopyWithImpl;
@useResult
$Res call({
 String value, Command? command, Location? location, dynamic? tooltip
});


$CommandCopyWith<$Res>? get command;$LocationCopyWith<$Res>? get location;

}
/// @nodoc
class _$InlayHintLabelPartCopyWithImpl<$Res>
    implements $InlayHintLabelPartCopyWith<$Res> {
  _$InlayHintLabelPartCopyWithImpl(this._self, this._then);

  final InlayHintLabelPart _self;
  final $Res Function(InlayHintLabelPart) _then;

/// Create a copy of InlayHintLabelPart
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? value = null,Object? command = freezed,Object? location = freezed,Object? tooltip = freezed,}) {
  return _then(_self.copyWith(
value: null == value ? _self.value : value // ignore: cast_nullable_to_non_nullable
as String,command: freezed == command ? _self.command : command // ignore: cast_nullable_to_non_nullable
as Command?,location: freezed == location ? _self.location : location // ignore: cast_nullable_to_non_nullable
as Location?,tooltip: freezed == tooltip ? _self.tooltip : tooltip // ignore: cast_nullable_to_non_nullable
as dynamic?,
  ));
}
/// Create a copy of InlayHintLabelPart
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CommandCopyWith<$Res>? get command {
    if (_self.command == null) {
    return null;
  }

  return $CommandCopyWith<$Res>(_self.command!, (value) {
    return _then(_self.copyWith(command: value));
  });
}/// Create a copy of InlayHintLabelPart
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$LocationCopyWith<$Res>? get location {
    if (_self.location == null) {
    return null;
  }

  return $LocationCopyWith<$Res>(_self.location!, (value) {
    return _then(_self.copyWith(location: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _InlayHintLabelPart implements InlayHintLabelPart {
  const _InlayHintLabelPart({required this.value, this.command, this.location, this.tooltip});
  factory _InlayHintLabelPart.fromJson(Map<String, dynamic> json) => _$InlayHintLabelPartFromJson(json);

@override final  String value;
@override final  Command? command;
@override final  Location? location;
@override final  dynamic? tooltip;

/// Create a copy of InlayHintLabelPart
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlayHintLabelPartCopyWith<_InlayHintLabelPart> get copyWith => __$InlayHintLabelPartCopyWithImpl<_InlayHintLabelPart>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlayHintLabelPartToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlayHintLabelPart&&(identical(other.value, value) || other.value == value)&&(identical(other.command, command) || other.command == command)&&(identical(other.location, location) || other.location == location)&&const DeepCollectionEquality().equals(other.tooltip, tooltip));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,value,command,location,const DeepCollectionEquality().hash(tooltip));

@override
String toString() {
  return 'InlayHintLabelPart(value: $value, command: $command, location: $location, tooltip: $tooltip)';
}


}

/// @nodoc
abstract mixin class _$InlayHintLabelPartCopyWith<$Res> implements $InlayHintLabelPartCopyWith<$Res> {
  factory _$InlayHintLabelPartCopyWith(_InlayHintLabelPart value, $Res Function(_InlayHintLabelPart) _then) = __$InlayHintLabelPartCopyWithImpl;
@override @useResult
$Res call({
 String value, Command? command, Location? location, dynamic? tooltip
});


@override $CommandCopyWith<$Res>? get command;@override $LocationCopyWith<$Res>? get location;

}
/// @nodoc
class __$InlayHintLabelPartCopyWithImpl<$Res>
    implements _$InlayHintLabelPartCopyWith<$Res> {
  __$InlayHintLabelPartCopyWithImpl(this._self, this._then);

  final _InlayHintLabelPart _self;
  final $Res Function(_InlayHintLabelPart) _then;

/// Create a copy of InlayHintLabelPart
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? value = null,Object? command = freezed,Object? location = freezed,Object? tooltip = freezed,}) {
  return _then(_InlayHintLabelPart(
value: null == value ? _self.value : value // ignore: cast_nullable_to_non_nullable
as String,command: freezed == command ? _self.command : command // ignore: cast_nullable_to_non_nullable
as Command?,location: freezed == location ? _self.location : location // ignore: cast_nullable_to_non_nullable
as Location?,tooltip: freezed == tooltip ? _self.tooltip : tooltip // ignore: cast_nullable_to_non_nullable
as dynamic?,
  ));
}

/// Create a copy of InlayHintLabelPart
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CommandCopyWith<$Res>? get command {
    if (_self.command == null) {
    return null;
  }

  return $CommandCopyWith<$Res>(_self.command!, (value) {
    return _then(_self.copyWith(command: value));
  });
}/// Create a copy of InlayHintLabelPart
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$LocationCopyWith<$Res>? get location {
    if (_self.location == null) {
    return null;
  }

  return $LocationCopyWith<$Res>(_self.location!, (value) {
    return _then(_self.copyWith(location: value));
  });
}
}


/// @nodoc
mixin _$MarkupContent {

 MarkupKind get kind; String get value;
/// Create a copy of MarkupContent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$MarkupContentCopyWith<MarkupContent> get copyWith => _$MarkupContentCopyWithImpl<MarkupContent>(this as MarkupContent, _$identity);

  /// Serializes this MarkupContent to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is MarkupContent&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.value, value) || other.value == value));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,kind,value);

@override
String toString() {
  return 'MarkupContent(kind: $kind, value: $value)';
}


}

/// @nodoc
abstract mixin class $MarkupContentCopyWith<$Res>  {
  factory $MarkupContentCopyWith(MarkupContent value, $Res Function(MarkupContent) _then) = _$MarkupContentCopyWithImpl;
@useResult
$Res call({
 MarkupKind kind, String value
});




}
/// @nodoc
class _$MarkupContentCopyWithImpl<$Res>
    implements $MarkupContentCopyWith<$Res> {
  _$MarkupContentCopyWithImpl(this._self, this._then);

  final MarkupContent _self;
  final $Res Function(MarkupContent) _then;

/// Create a copy of MarkupContent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? kind = null,Object? value = null,}) {
  return _then(_self.copyWith(
kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as MarkupKind,value: null == value ? _self.value : value // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _MarkupContent implements MarkupContent {
  const _MarkupContent({required this.kind, required this.value});
  factory _MarkupContent.fromJson(Map<String, dynamic> json) => _$MarkupContentFromJson(json);

@override final  MarkupKind kind;
@override final  String value;

/// Create a copy of MarkupContent
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$MarkupContentCopyWith<_MarkupContent> get copyWith => __$MarkupContentCopyWithImpl<_MarkupContent>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$MarkupContentToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _MarkupContent&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.value, value) || other.value == value));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,kind,value);

@override
String toString() {
  return 'MarkupContent(kind: $kind, value: $value)';
}


}

/// @nodoc
abstract mixin class _$MarkupContentCopyWith<$Res> implements $MarkupContentCopyWith<$Res> {
  factory _$MarkupContentCopyWith(_MarkupContent value, $Res Function(_MarkupContent) _then) = __$MarkupContentCopyWithImpl;
@override @useResult
$Res call({
 MarkupKind kind, String value
});




}
/// @nodoc
class __$MarkupContentCopyWithImpl<$Res>
    implements _$MarkupContentCopyWith<$Res> {
  __$MarkupContentCopyWithImpl(this._self, this._then);

  final _MarkupContent _self;
  final $Res Function(_MarkupContent) _then;

/// Create a copy of MarkupContent
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? kind = null,Object? value = null,}) {
  return _then(_MarkupContent(
kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as MarkupKind,value: null == value ? _self.value : value // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}


/// @nodoc
mixin _$InlayHintOptions {

 bool? get resolveProvider; bool? get workDoneProgress;
/// Create a copy of InlayHintOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlayHintOptionsCopyWith<InlayHintOptions> get copyWith => _$InlayHintOptionsCopyWithImpl<InlayHintOptions>(this as InlayHintOptions, _$identity);

  /// Serializes this InlayHintOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlayHintOptions&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,resolveProvider,workDoneProgress);

@override
String toString() {
  return 'InlayHintOptions(resolveProvider: $resolveProvider, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $InlayHintOptionsCopyWith<$Res>  {
  factory $InlayHintOptionsCopyWith(InlayHintOptions value, $Res Function(InlayHintOptions) _then) = _$InlayHintOptionsCopyWithImpl;
@useResult
$Res call({
 bool? resolveProvider, bool? workDoneProgress
});




}
/// @nodoc
class _$InlayHintOptionsCopyWithImpl<$Res>
    implements $InlayHintOptionsCopyWith<$Res> {
  _$InlayHintOptionsCopyWithImpl(this._self, this._then);

  final InlayHintOptions _self;
  final $Res Function(InlayHintOptions) _then;

/// Create a copy of InlayHintOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? resolveProvider = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _InlayHintOptions implements InlayHintOptions {
  const _InlayHintOptions({this.resolveProvider, this.workDoneProgress});
  factory _InlayHintOptions.fromJson(Map<String, dynamic> json) => _$InlayHintOptionsFromJson(json);

@override final  bool? resolveProvider;
@override final  bool? workDoneProgress;

/// Create a copy of InlayHintOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlayHintOptionsCopyWith<_InlayHintOptions> get copyWith => __$InlayHintOptionsCopyWithImpl<_InlayHintOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlayHintOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlayHintOptions&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,resolveProvider,workDoneProgress);

@override
String toString() {
  return 'InlayHintOptions(resolveProvider: $resolveProvider, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$InlayHintOptionsCopyWith<$Res> implements $InlayHintOptionsCopyWith<$Res> {
  factory _$InlayHintOptionsCopyWith(_InlayHintOptions value, $Res Function(_InlayHintOptions) _then) = __$InlayHintOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? resolveProvider, bool? workDoneProgress
});




}
/// @nodoc
class __$InlayHintOptionsCopyWithImpl<$Res>
    implements _$InlayHintOptionsCopyWith<$Res> {
  __$InlayHintOptionsCopyWithImpl(this._self, this._then);

  final _InlayHintOptions _self;
  final $Res Function(_InlayHintOptions) _then;

/// Create a copy of InlayHintOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? resolveProvider = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_InlayHintOptions(
resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$RelatedFullDocumentDiagnosticReport {

 String get kind; List<Diagnostic> get items; Map<String, dynamic>? get relatedDocuments; String? get resultId;
/// Create a copy of RelatedFullDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RelatedFullDocumentDiagnosticReportCopyWith<RelatedFullDocumentDiagnosticReport> get copyWith => _$RelatedFullDocumentDiagnosticReportCopyWithImpl<RelatedFullDocumentDiagnosticReport>(this as RelatedFullDocumentDiagnosticReport, _$identity);

  /// Serializes this RelatedFullDocumentDiagnosticReport to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RelatedFullDocumentDiagnosticReport&&(identical(other.kind, kind) || other.kind == kind)&&const DeepCollectionEquality().equals(other.items, items)&&const DeepCollectionEquality().equals(other.relatedDocuments, relatedDocuments)&&(identical(other.resultId, resultId) || other.resultId == resultId));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,kind,const DeepCollectionEquality().hash(items),const DeepCollectionEquality().hash(relatedDocuments),resultId);

@override
String toString() {
  return 'RelatedFullDocumentDiagnosticReport(kind: $kind, items: $items, relatedDocuments: $relatedDocuments, resultId: $resultId)';
}


}

/// @nodoc
abstract mixin class $RelatedFullDocumentDiagnosticReportCopyWith<$Res>  {
  factory $RelatedFullDocumentDiagnosticReportCopyWith(RelatedFullDocumentDiagnosticReport value, $Res Function(RelatedFullDocumentDiagnosticReport) _then) = _$RelatedFullDocumentDiagnosticReportCopyWithImpl;
@useResult
$Res call({
 String kind, List<Diagnostic> items, Map<String, dynamic>? relatedDocuments, String? resultId
});




}
/// @nodoc
class _$RelatedFullDocumentDiagnosticReportCopyWithImpl<$Res>
    implements $RelatedFullDocumentDiagnosticReportCopyWith<$Res> {
  _$RelatedFullDocumentDiagnosticReportCopyWithImpl(this._self, this._then);

  final RelatedFullDocumentDiagnosticReport _self;
  final $Res Function(RelatedFullDocumentDiagnosticReport) _then;

/// Create a copy of RelatedFullDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? kind = null,Object? items = null,Object? relatedDocuments = freezed,Object? resultId = freezed,}) {
  return _then(_self.copyWith(
kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as String,items: null == items ? _self.items : items // ignore: cast_nullable_to_non_nullable
as List<Diagnostic>,relatedDocuments: freezed == relatedDocuments ? _self.relatedDocuments : relatedDocuments // ignore: cast_nullable_to_non_nullable
as Map<String, dynamic>?,resultId: freezed == resultId ? _self.resultId : resultId // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _RelatedFullDocumentDiagnosticReport implements RelatedFullDocumentDiagnosticReport {
  const _RelatedFullDocumentDiagnosticReport({required this.kind, required final  List<Diagnostic> items, final  Map<String, dynamic>? relatedDocuments, this.resultId}): _items = items,_relatedDocuments = relatedDocuments;
  factory _RelatedFullDocumentDiagnosticReport.fromJson(Map<String, dynamic> json) => _$RelatedFullDocumentDiagnosticReportFromJson(json);

@override final  String kind;
 final  List<Diagnostic> _items;
@override List<Diagnostic> get items {
  if (_items is EqualUnmodifiableListView) return _items;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_items);
}

 final  Map<String, dynamic>? _relatedDocuments;
@override Map<String, dynamic>? get relatedDocuments {
  final value = _relatedDocuments;
  if (value == null) return null;
  if (_relatedDocuments is EqualUnmodifiableMapView) return _relatedDocuments;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(value);
}

@override final  String? resultId;

/// Create a copy of RelatedFullDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RelatedFullDocumentDiagnosticReportCopyWith<_RelatedFullDocumentDiagnosticReport> get copyWith => __$RelatedFullDocumentDiagnosticReportCopyWithImpl<_RelatedFullDocumentDiagnosticReport>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$RelatedFullDocumentDiagnosticReportToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _RelatedFullDocumentDiagnosticReport&&(identical(other.kind, kind) || other.kind == kind)&&const DeepCollectionEquality().equals(other._items, _items)&&const DeepCollectionEquality().equals(other._relatedDocuments, _relatedDocuments)&&(identical(other.resultId, resultId) || other.resultId == resultId));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,kind,const DeepCollectionEquality().hash(_items),const DeepCollectionEquality().hash(_relatedDocuments),resultId);

@override
String toString() {
  return 'RelatedFullDocumentDiagnosticReport(kind: $kind, items: $items, relatedDocuments: $relatedDocuments, resultId: $resultId)';
}


}

/// @nodoc
abstract mixin class _$RelatedFullDocumentDiagnosticReportCopyWith<$Res> implements $RelatedFullDocumentDiagnosticReportCopyWith<$Res> {
  factory _$RelatedFullDocumentDiagnosticReportCopyWith(_RelatedFullDocumentDiagnosticReport value, $Res Function(_RelatedFullDocumentDiagnosticReport) _then) = __$RelatedFullDocumentDiagnosticReportCopyWithImpl;
@override @useResult
$Res call({
 String kind, List<Diagnostic> items, Map<String, dynamic>? relatedDocuments, String? resultId
});




}
/// @nodoc
class __$RelatedFullDocumentDiagnosticReportCopyWithImpl<$Res>
    implements _$RelatedFullDocumentDiagnosticReportCopyWith<$Res> {
  __$RelatedFullDocumentDiagnosticReportCopyWithImpl(this._self, this._then);

  final _RelatedFullDocumentDiagnosticReport _self;
  final $Res Function(_RelatedFullDocumentDiagnosticReport) _then;

/// Create a copy of RelatedFullDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? kind = null,Object? items = null,Object? relatedDocuments = freezed,Object? resultId = freezed,}) {
  return _then(_RelatedFullDocumentDiagnosticReport(
kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as String,items: null == items ? _self._items : items // ignore: cast_nullable_to_non_nullable
as List<Diagnostic>,relatedDocuments: freezed == relatedDocuments ? _self._relatedDocuments : relatedDocuments // ignore: cast_nullable_to_non_nullable
as Map<String, dynamic>?,resultId: freezed == resultId ? _self.resultId : resultId // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$RelatedUnchangedDocumentDiagnosticReport {

 String get kind; String get resultId; Map<String, dynamic>? get relatedDocuments;
/// Create a copy of RelatedUnchangedDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RelatedUnchangedDocumentDiagnosticReportCopyWith<RelatedUnchangedDocumentDiagnosticReport> get copyWith => _$RelatedUnchangedDocumentDiagnosticReportCopyWithImpl<RelatedUnchangedDocumentDiagnosticReport>(this as RelatedUnchangedDocumentDiagnosticReport, _$identity);

  /// Serializes this RelatedUnchangedDocumentDiagnosticReport to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RelatedUnchangedDocumentDiagnosticReport&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.resultId, resultId) || other.resultId == resultId)&&const DeepCollectionEquality().equals(other.relatedDocuments, relatedDocuments));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,kind,resultId,const DeepCollectionEquality().hash(relatedDocuments));

@override
String toString() {
  return 'RelatedUnchangedDocumentDiagnosticReport(kind: $kind, resultId: $resultId, relatedDocuments: $relatedDocuments)';
}


}

/// @nodoc
abstract mixin class $RelatedUnchangedDocumentDiagnosticReportCopyWith<$Res>  {
  factory $RelatedUnchangedDocumentDiagnosticReportCopyWith(RelatedUnchangedDocumentDiagnosticReport value, $Res Function(RelatedUnchangedDocumentDiagnosticReport) _then) = _$RelatedUnchangedDocumentDiagnosticReportCopyWithImpl;
@useResult
$Res call({
 String kind, String resultId, Map<String, dynamic>? relatedDocuments
});




}
/// @nodoc
class _$RelatedUnchangedDocumentDiagnosticReportCopyWithImpl<$Res>
    implements $RelatedUnchangedDocumentDiagnosticReportCopyWith<$Res> {
  _$RelatedUnchangedDocumentDiagnosticReportCopyWithImpl(this._self, this._then);

  final RelatedUnchangedDocumentDiagnosticReport _self;
  final $Res Function(RelatedUnchangedDocumentDiagnosticReport) _then;

/// Create a copy of RelatedUnchangedDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? kind = null,Object? resultId = null,Object? relatedDocuments = freezed,}) {
  return _then(_self.copyWith(
kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as String,resultId: null == resultId ? _self.resultId : resultId // ignore: cast_nullable_to_non_nullable
as String,relatedDocuments: freezed == relatedDocuments ? _self.relatedDocuments : relatedDocuments // ignore: cast_nullable_to_non_nullable
as Map<String, dynamic>?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _RelatedUnchangedDocumentDiagnosticReport implements RelatedUnchangedDocumentDiagnosticReport {
  const _RelatedUnchangedDocumentDiagnosticReport({required this.kind, required this.resultId, final  Map<String, dynamic>? relatedDocuments}): _relatedDocuments = relatedDocuments;
  factory _RelatedUnchangedDocumentDiagnosticReport.fromJson(Map<String, dynamic> json) => _$RelatedUnchangedDocumentDiagnosticReportFromJson(json);

@override final  String kind;
@override final  String resultId;
 final  Map<String, dynamic>? _relatedDocuments;
@override Map<String, dynamic>? get relatedDocuments {
  final value = _relatedDocuments;
  if (value == null) return null;
  if (_relatedDocuments is EqualUnmodifiableMapView) return _relatedDocuments;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(value);
}


/// Create a copy of RelatedUnchangedDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RelatedUnchangedDocumentDiagnosticReportCopyWith<_RelatedUnchangedDocumentDiagnosticReport> get copyWith => __$RelatedUnchangedDocumentDiagnosticReportCopyWithImpl<_RelatedUnchangedDocumentDiagnosticReport>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$RelatedUnchangedDocumentDiagnosticReportToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _RelatedUnchangedDocumentDiagnosticReport&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.resultId, resultId) || other.resultId == resultId)&&const DeepCollectionEquality().equals(other._relatedDocuments, _relatedDocuments));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,kind,resultId,const DeepCollectionEquality().hash(_relatedDocuments));

@override
String toString() {
  return 'RelatedUnchangedDocumentDiagnosticReport(kind: $kind, resultId: $resultId, relatedDocuments: $relatedDocuments)';
}


}

/// @nodoc
abstract mixin class _$RelatedUnchangedDocumentDiagnosticReportCopyWith<$Res> implements $RelatedUnchangedDocumentDiagnosticReportCopyWith<$Res> {
  factory _$RelatedUnchangedDocumentDiagnosticReportCopyWith(_RelatedUnchangedDocumentDiagnosticReport value, $Res Function(_RelatedUnchangedDocumentDiagnosticReport) _then) = __$RelatedUnchangedDocumentDiagnosticReportCopyWithImpl;
@override @useResult
$Res call({
 String kind, String resultId, Map<String, dynamic>? relatedDocuments
});




}
/// @nodoc
class __$RelatedUnchangedDocumentDiagnosticReportCopyWithImpl<$Res>
    implements _$RelatedUnchangedDocumentDiagnosticReportCopyWith<$Res> {
  __$RelatedUnchangedDocumentDiagnosticReportCopyWithImpl(this._self, this._then);

  final _RelatedUnchangedDocumentDiagnosticReport _self;
  final $Res Function(_RelatedUnchangedDocumentDiagnosticReport) _then;

/// Create a copy of RelatedUnchangedDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? kind = null,Object? resultId = null,Object? relatedDocuments = freezed,}) {
  return _then(_RelatedUnchangedDocumentDiagnosticReport(
kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as String,resultId: null == resultId ? _self.resultId : resultId // ignore: cast_nullable_to_non_nullable
as String,relatedDocuments: freezed == relatedDocuments ? _self._relatedDocuments : relatedDocuments // ignore: cast_nullable_to_non_nullable
as Map<String, dynamic>?,
  ));
}


}


/// @nodoc
mixin _$FullDocumentDiagnosticReport {

 String get kind; List<Diagnostic> get items; String? get resultId;
/// Create a copy of FullDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FullDocumentDiagnosticReportCopyWith<FullDocumentDiagnosticReport> get copyWith => _$FullDocumentDiagnosticReportCopyWithImpl<FullDocumentDiagnosticReport>(this as FullDocumentDiagnosticReport, _$identity);

  /// Serializes this FullDocumentDiagnosticReport to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FullDocumentDiagnosticReport&&(identical(other.kind, kind) || other.kind == kind)&&const DeepCollectionEquality().equals(other.items, items)&&(identical(other.resultId, resultId) || other.resultId == resultId));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,kind,const DeepCollectionEquality().hash(items),resultId);

@override
String toString() {
  return 'FullDocumentDiagnosticReport(kind: $kind, items: $items, resultId: $resultId)';
}


}

/// @nodoc
abstract mixin class $FullDocumentDiagnosticReportCopyWith<$Res>  {
  factory $FullDocumentDiagnosticReportCopyWith(FullDocumentDiagnosticReport value, $Res Function(FullDocumentDiagnosticReport) _then) = _$FullDocumentDiagnosticReportCopyWithImpl;
@useResult
$Res call({
 String kind, List<Diagnostic> items, String? resultId
});




}
/// @nodoc
class _$FullDocumentDiagnosticReportCopyWithImpl<$Res>
    implements $FullDocumentDiagnosticReportCopyWith<$Res> {
  _$FullDocumentDiagnosticReportCopyWithImpl(this._self, this._then);

  final FullDocumentDiagnosticReport _self;
  final $Res Function(FullDocumentDiagnosticReport) _then;

/// Create a copy of FullDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? kind = null,Object? items = null,Object? resultId = freezed,}) {
  return _then(_self.copyWith(
kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as String,items: null == items ? _self.items : items // ignore: cast_nullable_to_non_nullable
as List<Diagnostic>,resultId: freezed == resultId ? _self.resultId : resultId // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _FullDocumentDiagnosticReport implements FullDocumentDiagnosticReport {
  const _FullDocumentDiagnosticReport({required this.kind, required final  List<Diagnostic> items, this.resultId}): _items = items;
  factory _FullDocumentDiagnosticReport.fromJson(Map<String, dynamic> json) => _$FullDocumentDiagnosticReportFromJson(json);

@override final  String kind;
 final  List<Diagnostic> _items;
@override List<Diagnostic> get items {
  if (_items is EqualUnmodifiableListView) return _items;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_items);
}

@override final  String? resultId;

/// Create a copy of FullDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$FullDocumentDiagnosticReportCopyWith<_FullDocumentDiagnosticReport> get copyWith => __$FullDocumentDiagnosticReportCopyWithImpl<_FullDocumentDiagnosticReport>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$FullDocumentDiagnosticReportToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _FullDocumentDiagnosticReport&&(identical(other.kind, kind) || other.kind == kind)&&const DeepCollectionEquality().equals(other._items, _items)&&(identical(other.resultId, resultId) || other.resultId == resultId));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,kind,const DeepCollectionEquality().hash(_items),resultId);

@override
String toString() {
  return 'FullDocumentDiagnosticReport(kind: $kind, items: $items, resultId: $resultId)';
}


}

/// @nodoc
abstract mixin class _$FullDocumentDiagnosticReportCopyWith<$Res> implements $FullDocumentDiagnosticReportCopyWith<$Res> {
  factory _$FullDocumentDiagnosticReportCopyWith(_FullDocumentDiagnosticReport value, $Res Function(_FullDocumentDiagnosticReport) _then) = __$FullDocumentDiagnosticReportCopyWithImpl;
@override @useResult
$Res call({
 String kind, List<Diagnostic> items, String? resultId
});




}
/// @nodoc
class __$FullDocumentDiagnosticReportCopyWithImpl<$Res>
    implements _$FullDocumentDiagnosticReportCopyWith<$Res> {
  __$FullDocumentDiagnosticReportCopyWithImpl(this._self, this._then);

  final _FullDocumentDiagnosticReport _self;
  final $Res Function(_FullDocumentDiagnosticReport) _then;

/// Create a copy of FullDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? kind = null,Object? items = null,Object? resultId = freezed,}) {
  return _then(_FullDocumentDiagnosticReport(
kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as String,items: null == items ? _self._items : items // ignore: cast_nullable_to_non_nullable
as List<Diagnostic>,resultId: freezed == resultId ? _self.resultId : resultId // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$UnchangedDocumentDiagnosticReport {

 String get kind; String get resultId;
/// Create a copy of UnchangedDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UnchangedDocumentDiagnosticReportCopyWith<UnchangedDocumentDiagnosticReport> get copyWith => _$UnchangedDocumentDiagnosticReportCopyWithImpl<UnchangedDocumentDiagnosticReport>(this as UnchangedDocumentDiagnosticReport, _$identity);

  /// Serializes this UnchangedDocumentDiagnosticReport to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UnchangedDocumentDiagnosticReport&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.resultId, resultId) || other.resultId == resultId));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,kind,resultId);

@override
String toString() {
  return 'UnchangedDocumentDiagnosticReport(kind: $kind, resultId: $resultId)';
}


}

/// @nodoc
abstract mixin class $UnchangedDocumentDiagnosticReportCopyWith<$Res>  {
  factory $UnchangedDocumentDiagnosticReportCopyWith(UnchangedDocumentDiagnosticReport value, $Res Function(UnchangedDocumentDiagnosticReport) _then) = _$UnchangedDocumentDiagnosticReportCopyWithImpl;
@useResult
$Res call({
 String kind, String resultId
});




}
/// @nodoc
class _$UnchangedDocumentDiagnosticReportCopyWithImpl<$Res>
    implements $UnchangedDocumentDiagnosticReportCopyWith<$Res> {
  _$UnchangedDocumentDiagnosticReportCopyWithImpl(this._self, this._then);

  final UnchangedDocumentDiagnosticReport _self;
  final $Res Function(UnchangedDocumentDiagnosticReport) _then;

/// Create a copy of UnchangedDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? kind = null,Object? resultId = null,}) {
  return _then(_self.copyWith(
kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as String,resultId: null == resultId ? _self.resultId : resultId // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _UnchangedDocumentDiagnosticReport implements UnchangedDocumentDiagnosticReport {
  const _UnchangedDocumentDiagnosticReport({required this.kind, required this.resultId});
  factory _UnchangedDocumentDiagnosticReport.fromJson(Map<String, dynamic> json) => _$UnchangedDocumentDiagnosticReportFromJson(json);

@override final  String kind;
@override final  String resultId;

/// Create a copy of UnchangedDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$UnchangedDocumentDiagnosticReportCopyWith<_UnchangedDocumentDiagnosticReport> get copyWith => __$UnchangedDocumentDiagnosticReportCopyWithImpl<_UnchangedDocumentDiagnosticReport>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$UnchangedDocumentDiagnosticReportToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _UnchangedDocumentDiagnosticReport&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.resultId, resultId) || other.resultId == resultId));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,kind,resultId);

@override
String toString() {
  return 'UnchangedDocumentDiagnosticReport(kind: $kind, resultId: $resultId)';
}


}

/// @nodoc
abstract mixin class _$UnchangedDocumentDiagnosticReportCopyWith<$Res> implements $UnchangedDocumentDiagnosticReportCopyWith<$Res> {
  factory _$UnchangedDocumentDiagnosticReportCopyWith(_UnchangedDocumentDiagnosticReport value, $Res Function(_UnchangedDocumentDiagnosticReport) _then) = __$UnchangedDocumentDiagnosticReportCopyWithImpl;
@override @useResult
$Res call({
 String kind, String resultId
});




}
/// @nodoc
class __$UnchangedDocumentDiagnosticReportCopyWithImpl<$Res>
    implements _$UnchangedDocumentDiagnosticReportCopyWith<$Res> {
  __$UnchangedDocumentDiagnosticReportCopyWithImpl(this._self, this._then);

  final _UnchangedDocumentDiagnosticReport _self;
  final $Res Function(_UnchangedDocumentDiagnosticReport) _then;

/// Create a copy of UnchangedDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? kind = null,Object? resultId = null,}) {
  return _then(_UnchangedDocumentDiagnosticReport(
kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as String,resultId: null == resultId ? _self.resultId : resultId // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}


/// @nodoc
mixin _$DiagnosticOptions {

 bool get interFileDependencies; bool get workspaceDiagnostics; String? get identifier; bool? get workDoneProgress;
/// Create a copy of DiagnosticOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DiagnosticOptionsCopyWith<DiagnosticOptions> get copyWith => _$DiagnosticOptionsCopyWithImpl<DiagnosticOptions>(this as DiagnosticOptions, _$identity);

  /// Serializes this DiagnosticOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DiagnosticOptions&&(identical(other.interFileDependencies, interFileDependencies) || other.interFileDependencies == interFileDependencies)&&(identical(other.workspaceDiagnostics, workspaceDiagnostics) || other.workspaceDiagnostics == workspaceDiagnostics)&&(identical(other.identifier, identifier) || other.identifier == identifier)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,interFileDependencies,workspaceDiagnostics,identifier,workDoneProgress);

@override
String toString() {
  return 'DiagnosticOptions(interFileDependencies: $interFileDependencies, workspaceDiagnostics: $workspaceDiagnostics, identifier: $identifier, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $DiagnosticOptionsCopyWith<$Res>  {
  factory $DiagnosticOptionsCopyWith(DiagnosticOptions value, $Res Function(DiagnosticOptions) _then) = _$DiagnosticOptionsCopyWithImpl;
@useResult
$Res call({
 bool interFileDependencies, bool workspaceDiagnostics, String? identifier, bool? workDoneProgress
});




}
/// @nodoc
class _$DiagnosticOptionsCopyWithImpl<$Res>
    implements $DiagnosticOptionsCopyWith<$Res> {
  _$DiagnosticOptionsCopyWithImpl(this._self, this._then);

  final DiagnosticOptions _self;
  final $Res Function(DiagnosticOptions) _then;

/// Create a copy of DiagnosticOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? interFileDependencies = null,Object? workspaceDiagnostics = null,Object? identifier = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
interFileDependencies: null == interFileDependencies ? _self.interFileDependencies : interFileDependencies // ignore: cast_nullable_to_non_nullable
as bool,workspaceDiagnostics: null == workspaceDiagnostics ? _self.workspaceDiagnostics : workspaceDiagnostics // ignore: cast_nullable_to_non_nullable
as bool,identifier: freezed == identifier ? _self.identifier : identifier // ignore: cast_nullable_to_non_nullable
as String?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DiagnosticOptions implements DiagnosticOptions {
  const _DiagnosticOptions({required this.interFileDependencies, required this.workspaceDiagnostics, this.identifier, this.workDoneProgress});
  factory _DiagnosticOptions.fromJson(Map<String, dynamic> json) => _$DiagnosticOptionsFromJson(json);

@override final  bool interFileDependencies;
@override final  bool workspaceDiagnostics;
@override final  String? identifier;
@override final  bool? workDoneProgress;

/// Create a copy of DiagnosticOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DiagnosticOptionsCopyWith<_DiagnosticOptions> get copyWith => __$DiagnosticOptionsCopyWithImpl<_DiagnosticOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DiagnosticOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DiagnosticOptions&&(identical(other.interFileDependencies, interFileDependencies) || other.interFileDependencies == interFileDependencies)&&(identical(other.workspaceDiagnostics, workspaceDiagnostics) || other.workspaceDiagnostics == workspaceDiagnostics)&&(identical(other.identifier, identifier) || other.identifier == identifier)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,interFileDependencies,workspaceDiagnostics,identifier,workDoneProgress);

@override
String toString() {
  return 'DiagnosticOptions(interFileDependencies: $interFileDependencies, workspaceDiagnostics: $workspaceDiagnostics, identifier: $identifier, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$DiagnosticOptionsCopyWith<$Res> implements $DiagnosticOptionsCopyWith<$Res> {
  factory _$DiagnosticOptionsCopyWith(_DiagnosticOptions value, $Res Function(_DiagnosticOptions) _then) = __$DiagnosticOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool interFileDependencies, bool workspaceDiagnostics, String? identifier, bool? workDoneProgress
});




}
/// @nodoc
class __$DiagnosticOptionsCopyWithImpl<$Res>
    implements _$DiagnosticOptionsCopyWith<$Res> {
  __$DiagnosticOptionsCopyWithImpl(this._self, this._then);

  final _DiagnosticOptions _self;
  final $Res Function(_DiagnosticOptions) _then;

/// Create a copy of DiagnosticOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? interFileDependencies = null,Object? workspaceDiagnostics = null,Object? identifier = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_DiagnosticOptions(
interFileDependencies: null == interFileDependencies ? _self.interFileDependencies : interFileDependencies // ignore: cast_nullable_to_non_nullable
as bool,workspaceDiagnostics: null == workspaceDiagnostics ? _self.workspaceDiagnostics : workspaceDiagnostics // ignore: cast_nullable_to_non_nullable
as bool,identifier: freezed == identifier ? _self.identifier : identifier // ignore: cast_nullable_to_non_nullable
as String?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$PreviousResultId {

 String get uri; String get value;
/// Create a copy of PreviousResultId
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$PreviousResultIdCopyWith<PreviousResultId> get copyWith => _$PreviousResultIdCopyWithImpl<PreviousResultId>(this as PreviousResultId, _$identity);

  /// Serializes this PreviousResultId to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is PreviousResultId&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.value, value) || other.value == value));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri,value);

@override
String toString() {
  return 'PreviousResultId(uri: $uri, value: $value)';
}


}

/// @nodoc
abstract mixin class $PreviousResultIdCopyWith<$Res>  {
  factory $PreviousResultIdCopyWith(PreviousResultId value, $Res Function(PreviousResultId) _then) = _$PreviousResultIdCopyWithImpl;
@useResult
$Res call({
 String uri, String value
});




}
/// @nodoc
class _$PreviousResultIdCopyWithImpl<$Res>
    implements $PreviousResultIdCopyWith<$Res> {
  _$PreviousResultIdCopyWithImpl(this._self, this._then);

  final PreviousResultId _self;
  final $Res Function(PreviousResultId) _then;

/// Create a copy of PreviousResultId
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? uri = null,Object? value = null,}) {
  return _then(_self.copyWith(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,value: null == value ? _self.value : value // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _PreviousResultId implements PreviousResultId {
  const _PreviousResultId({required this.uri, required this.value});
  factory _PreviousResultId.fromJson(Map<String, dynamic> json) => _$PreviousResultIdFromJson(json);

@override final  String uri;
@override final  String value;

/// Create a copy of PreviousResultId
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$PreviousResultIdCopyWith<_PreviousResultId> get copyWith => __$PreviousResultIdCopyWithImpl<_PreviousResultId>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$PreviousResultIdToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _PreviousResultId&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.value, value) || other.value == value));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri,value);

@override
String toString() {
  return 'PreviousResultId(uri: $uri, value: $value)';
}


}

/// @nodoc
abstract mixin class _$PreviousResultIdCopyWith<$Res> implements $PreviousResultIdCopyWith<$Res> {
  factory _$PreviousResultIdCopyWith(_PreviousResultId value, $Res Function(_PreviousResultId) _then) = __$PreviousResultIdCopyWithImpl;
@override @useResult
$Res call({
 String uri, String value
});




}
/// @nodoc
class __$PreviousResultIdCopyWithImpl<$Res>
    implements _$PreviousResultIdCopyWith<$Res> {
  __$PreviousResultIdCopyWithImpl(this._self, this._then);

  final _PreviousResultId _self;
  final $Res Function(_PreviousResultId) _then;

/// Create a copy of PreviousResultId
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? uri = null,Object? value = null,}) {
  return _then(_PreviousResultId(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,value: null == value ? _self.value : value // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}


/// @nodoc
mixin _$NotebookDocument {

 String get uri; String get notebookType; int get version; List<NotebookCell> get cells; LSPObject? get metadata;
/// Create a copy of NotebookDocument
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$NotebookDocumentCopyWith<NotebookDocument> get copyWith => _$NotebookDocumentCopyWithImpl<NotebookDocument>(this as NotebookDocument, _$identity);

  /// Serializes this NotebookDocument to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is NotebookDocument&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.notebookType, notebookType) || other.notebookType == notebookType)&&(identical(other.version, version) || other.version == version)&&const DeepCollectionEquality().equals(other.cells, cells)&&const DeepCollectionEquality().equals(other.metadata, metadata));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri,notebookType,version,const DeepCollectionEquality().hash(cells),const DeepCollectionEquality().hash(metadata));

@override
String toString() {
  return 'NotebookDocument(uri: $uri, notebookType: $notebookType, version: $version, cells: $cells, metadata: $metadata)';
}


}

/// @nodoc
abstract mixin class $NotebookDocumentCopyWith<$Res>  {
  factory $NotebookDocumentCopyWith(NotebookDocument value, $Res Function(NotebookDocument) _then) = _$NotebookDocumentCopyWithImpl;
@useResult
$Res call({
 String uri, String notebookType, int version, List<NotebookCell> cells, LSPObject? metadata
});




}
/// @nodoc
class _$NotebookDocumentCopyWithImpl<$Res>
    implements $NotebookDocumentCopyWith<$Res> {
  _$NotebookDocumentCopyWithImpl(this._self, this._then);

  final NotebookDocument _self;
  final $Res Function(NotebookDocument) _then;

/// Create a copy of NotebookDocument
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? uri = null,Object? notebookType = null,Object? version = null,Object? cells = null,Object? metadata = freezed,}) {
  return _then(_self.copyWith(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,notebookType: null == notebookType ? _self.notebookType : notebookType // ignore: cast_nullable_to_non_nullable
as String,version: null == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as int,cells: null == cells ? _self.cells : cells // ignore: cast_nullable_to_non_nullable
as List<NotebookCell>,metadata: freezed == metadata ? _self.metadata : metadata // ignore: cast_nullable_to_non_nullable
as LSPObject?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _NotebookDocument implements NotebookDocument {
  const _NotebookDocument({required this.uri, required this.notebookType, required this.version, required final  List<NotebookCell> cells, final  LSPObject? metadata}): _cells = cells,_metadata = metadata;
  factory _NotebookDocument.fromJson(Map<String, dynamic> json) => _$NotebookDocumentFromJson(json);

@override final  String uri;
@override final  String notebookType;
@override final  int version;
 final  List<NotebookCell> _cells;
@override List<NotebookCell> get cells {
  if (_cells is EqualUnmodifiableListView) return _cells;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_cells);
}

 final  LSPObject? _metadata;
@override LSPObject? get metadata {
  final value = _metadata;
  if (value == null) return null;
  if (_metadata is EqualUnmodifiableMapView) return _metadata;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(value);
}


/// Create a copy of NotebookDocument
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$NotebookDocumentCopyWith<_NotebookDocument> get copyWith => __$NotebookDocumentCopyWithImpl<_NotebookDocument>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$NotebookDocumentToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _NotebookDocument&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.notebookType, notebookType) || other.notebookType == notebookType)&&(identical(other.version, version) || other.version == version)&&const DeepCollectionEquality().equals(other._cells, _cells)&&const DeepCollectionEquality().equals(other._metadata, _metadata));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri,notebookType,version,const DeepCollectionEquality().hash(_cells),const DeepCollectionEquality().hash(_metadata));

@override
String toString() {
  return 'NotebookDocument(uri: $uri, notebookType: $notebookType, version: $version, cells: $cells, metadata: $metadata)';
}


}

/// @nodoc
abstract mixin class _$NotebookDocumentCopyWith<$Res> implements $NotebookDocumentCopyWith<$Res> {
  factory _$NotebookDocumentCopyWith(_NotebookDocument value, $Res Function(_NotebookDocument) _then) = __$NotebookDocumentCopyWithImpl;
@override @useResult
$Res call({
 String uri, String notebookType, int version, List<NotebookCell> cells, LSPObject? metadata
});




}
/// @nodoc
class __$NotebookDocumentCopyWithImpl<$Res>
    implements _$NotebookDocumentCopyWith<$Res> {
  __$NotebookDocumentCopyWithImpl(this._self, this._then);

  final _NotebookDocument _self;
  final $Res Function(_NotebookDocument) _then;

/// Create a copy of NotebookDocument
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? uri = null,Object? notebookType = null,Object? version = null,Object? cells = null,Object? metadata = freezed,}) {
  return _then(_NotebookDocument(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,notebookType: null == notebookType ? _self.notebookType : notebookType // ignore: cast_nullable_to_non_nullable
as String,version: null == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as int,cells: null == cells ? _self._cells : cells // ignore: cast_nullable_to_non_nullable
as List<NotebookCell>,metadata: freezed == metadata ? _self._metadata : metadata // ignore: cast_nullable_to_non_nullable
as LSPObject?,
  ));
}


}


/// @nodoc
mixin _$TextDocumentItem {

 String get uri; String get languageId; int get version; String get text;
/// Create a copy of TextDocumentItem
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TextDocumentItemCopyWith<TextDocumentItem> get copyWith => _$TextDocumentItemCopyWithImpl<TextDocumentItem>(this as TextDocumentItem, _$identity);

  /// Serializes this TextDocumentItem to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TextDocumentItem&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.languageId, languageId) || other.languageId == languageId)&&(identical(other.version, version) || other.version == version)&&(identical(other.text, text) || other.text == text));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri,languageId,version,text);

@override
String toString() {
  return 'TextDocumentItem(uri: $uri, languageId: $languageId, version: $version, text: $text)';
}


}

/// @nodoc
abstract mixin class $TextDocumentItemCopyWith<$Res>  {
  factory $TextDocumentItemCopyWith(TextDocumentItem value, $Res Function(TextDocumentItem) _then) = _$TextDocumentItemCopyWithImpl;
@useResult
$Res call({
 String uri, String languageId, int version, String text
});




}
/// @nodoc
class _$TextDocumentItemCopyWithImpl<$Res>
    implements $TextDocumentItemCopyWith<$Res> {
  _$TextDocumentItemCopyWithImpl(this._self, this._then);

  final TextDocumentItem _self;
  final $Res Function(TextDocumentItem) _then;

/// Create a copy of TextDocumentItem
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? uri = null,Object? languageId = null,Object? version = null,Object? text = null,}) {
  return _then(_self.copyWith(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,languageId: null == languageId ? _self.languageId : languageId // ignore: cast_nullable_to_non_nullable
as String,version: null == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as int,text: null == text ? _self.text : text // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _TextDocumentItem implements TextDocumentItem {
  const _TextDocumentItem({required this.uri, required this.languageId, required this.version, required this.text});
  factory _TextDocumentItem.fromJson(Map<String, dynamic> json) => _$TextDocumentItemFromJson(json);

@override final  String uri;
@override final  String languageId;
@override final  int version;
@override final  String text;

/// Create a copy of TextDocumentItem
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TextDocumentItemCopyWith<_TextDocumentItem> get copyWith => __$TextDocumentItemCopyWithImpl<_TextDocumentItem>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TextDocumentItemToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TextDocumentItem&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.languageId, languageId) || other.languageId == languageId)&&(identical(other.version, version) || other.version == version)&&(identical(other.text, text) || other.text == text));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri,languageId,version,text);

@override
String toString() {
  return 'TextDocumentItem(uri: $uri, languageId: $languageId, version: $version, text: $text)';
}


}

/// @nodoc
abstract mixin class _$TextDocumentItemCopyWith<$Res> implements $TextDocumentItemCopyWith<$Res> {
  factory _$TextDocumentItemCopyWith(_TextDocumentItem value, $Res Function(_TextDocumentItem) _then) = __$TextDocumentItemCopyWithImpl;
@override @useResult
$Res call({
 String uri, String languageId, int version, String text
});




}
/// @nodoc
class __$TextDocumentItemCopyWithImpl<$Res>
    implements _$TextDocumentItemCopyWith<$Res> {
  __$TextDocumentItemCopyWithImpl(this._self, this._then);

  final _TextDocumentItem _self;
  final $Res Function(_TextDocumentItem) _then;

/// Create a copy of TextDocumentItem
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? uri = null,Object? languageId = null,Object? version = null,Object? text = null,}) {
  return _then(_TextDocumentItem(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,languageId: null == languageId ? _self.languageId : languageId // ignore: cast_nullable_to_non_nullable
as String,version: null == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as int,text: null == text ? _self.text : text // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}


/// @nodoc
mixin _$VersionedNotebookDocumentIdentifier {

 int get version; String get uri;
/// Create a copy of VersionedNotebookDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$VersionedNotebookDocumentIdentifierCopyWith<VersionedNotebookDocumentIdentifier> get copyWith => _$VersionedNotebookDocumentIdentifierCopyWithImpl<VersionedNotebookDocumentIdentifier>(this as VersionedNotebookDocumentIdentifier, _$identity);

  /// Serializes this VersionedNotebookDocumentIdentifier to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is VersionedNotebookDocumentIdentifier&&(identical(other.version, version) || other.version == version)&&(identical(other.uri, uri) || other.uri == uri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,version,uri);

@override
String toString() {
  return 'VersionedNotebookDocumentIdentifier(version: $version, uri: $uri)';
}


}

/// @nodoc
abstract mixin class $VersionedNotebookDocumentIdentifierCopyWith<$Res>  {
  factory $VersionedNotebookDocumentIdentifierCopyWith(VersionedNotebookDocumentIdentifier value, $Res Function(VersionedNotebookDocumentIdentifier) _then) = _$VersionedNotebookDocumentIdentifierCopyWithImpl;
@useResult
$Res call({
 int version, String uri
});




}
/// @nodoc
class _$VersionedNotebookDocumentIdentifierCopyWithImpl<$Res>
    implements $VersionedNotebookDocumentIdentifierCopyWith<$Res> {
  _$VersionedNotebookDocumentIdentifierCopyWithImpl(this._self, this._then);

  final VersionedNotebookDocumentIdentifier _self;
  final $Res Function(VersionedNotebookDocumentIdentifier) _then;

/// Create a copy of VersionedNotebookDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? version = null,Object? uri = null,}) {
  return _then(_self.copyWith(
version: null == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as int,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _VersionedNotebookDocumentIdentifier implements VersionedNotebookDocumentIdentifier {
  const _VersionedNotebookDocumentIdentifier({required this.version, required this.uri});
  factory _VersionedNotebookDocumentIdentifier.fromJson(Map<String, dynamic> json) => _$VersionedNotebookDocumentIdentifierFromJson(json);

@override final  int version;
@override final  String uri;

/// Create a copy of VersionedNotebookDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$VersionedNotebookDocumentIdentifierCopyWith<_VersionedNotebookDocumentIdentifier> get copyWith => __$VersionedNotebookDocumentIdentifierCopyWithImpl<_VersionedNotebookDocumentIdentifier>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$VersionedNotebookDocumentIdentifierToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _VersionedNotebookDocumentIdentifier&&(identical(other.version, version) || other.version == version)&&(identical(other.uri, uri) || other.uri == uri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,version,uri);

@override
String toString() {
  return 'VersionedNotebookDocumentIdentifier(version: $version, uri: $uri)';
}


}

/// @nodoc
abstract mixin class _$VersionedNotebookDocumentIdentifierCopyWith<$Res> implements $VersionedNotebookDocumentIdentifierCopyWith<$Res> {
  factory _$VersionedNotebookDocumentIdentifierCopyWith(_VersionedNotebookDocumentIdentifier value, $Res Function(_VersionedNotebookDocumentIdentifier) _then) = __$VersionedNotebookDocumentIdentifierCopyWithImpl;
@override @useResult
$Res call({
 int version, String uri
});




}
/// @nodoc
class __$VersionedNotebookDocumentIdentifierCopyWithImpl<$Res>
    implements _$VersionedNotebookDocumentIdentifierCopyWith<$Res> {
  __$VersionedNotebookDocumentIdentifierCopyWithImpl(this._self, this._then);

  final _VersionedNotebookDocumentIdentifier _self;
  final $Res Function(_VersionedNotebookDocumentIdentifier) _then;

/// Create a copy of VersionedNotebookDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? version = null,Object? uri = null,}) {
  return _then(_VersionedNotebookDocumentIdentifier(
version: null == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as int,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}


/// @nodoc
mixin _$NotebookDocumentChangeEvent {

 ({({NotebookCellArrayChange array, List<TextDocumentItem>? didOpen, List<TextDocumentIdentifier>? didClose})? structure, List<NotebookCell>? data, List<({VersionedTextDocumentIdentifier document, List<TextDocumentContentChangeEvent> changes})>? textContent})? get cells; LSPObject? get metadata;
/// Create a copy of NotebookDocumentChangeEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$NotebookDocumentChangeEventCopyWith<NotebookDocumentChangeEvent> get copyWith => _$NotebookDocumentChangeEventCopyWithImpl<NotebookDocumentChangeEvent>(this as NotebookDocumentChangeEvent, _$identity);

  /// Serializes this NotebookDocumentChangeEvent to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is NotebookDocumentChangeEvent&&(identical(other.cells, cells) || other.cells == cells)&&const DeepCollectionEquality().equals(other.metadata, metadata));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,cells,const DeepCollectionEquality().hash(metadata));

@override
String toString() {
  return 'NotebookDocumentChangeEvent(cells: $cells, metadata: $metadata)';
}


}

/// @nodoc
abstract mixin class $NotebookDocumentChangeEventCopyWith<$Res>  {
  factory $NotebookDocumentChangeEventCopyWith(NotebookDocumentChangeEvent value, $Res Function(NotebookDocumentChangeEvent) _then) = _$NotebookDocumentChangeEventCopyWithImpl;
@useResult
$Res call({
 ({({NotebookCellArrayChange array, List<TextDocumentItem>? didOpen, List<TextDocumentIdentifier>? didClose})? structure, List<NotebookCell>? data, List<({VersionedTextDocumentIdentifier document, List<TextDocumentContentChangeEvent> changes})>? textContent})? cells, LSPObject? metadata
});




}
/// @nodoc
class _$NotebookDocumentChangeEventCopyWithImpl<$Res>
    implements $NotebookDocumentChangeEventCopyWith<$Res> {
  _$NotebookDocumentChangeEventCopyWithImpl(this._self, this._then);

  final NotebookDocumentChangeEvent _self;
  final $Res Function(NotebookDocumentChangeEvent) _then;

/// Create a copy of NotebookDocumentChangeEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? cells = freezed,Object? metadata = freezed,}) {
  return _then(_self.copyWith(
cells: freezed == cells ? _self.cells : cells // ignore: cast_nullable_to_non_nullable
as ({({NotebookCellArrayChange array, List<TextDocumentItem>? didOpen, List<TextDocumentIdentifier>? didClose})? structure, List<NotebookCell>? data, List<({VersionedTextDocumentIdentifier document, List<TextDocumentContentChangeEvent> changes})>? textContent})?,metadata: freezed == metadata ? _self.metadata : metadata // ignore: cast_nullable_to_non_nullable
as LSPObject?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _NotebookDocumentChangeEvent implements NotebookDocumentChangeEvent {
  const _NotebookDocumentChangeEvent({this.cells, final  LSPObject? metadata}): _metadata = metadata;
  factory _NotebookDocumentChangeEvent.fromJson(Map<String, dynamic> json) => _$NotebookDocumentChangeEventFromJson(json);

@override final  ({({NotebookCellArrayChange array, List<TextDocumentItem>? didOpen, List<TextDocumentIdentifier>? didClose})? structure, List<NotebookCell>? data, List<({VersionedTextDocumentIdentifier document, List<TextDocumentContentChangeEvent> changes})>? textContent})? cells;
 final  LSPObject? _metadata;
@override LSPObject? get metadata {
  final value = _metadata;
  if (value == null) return null;
  if (_metadata is EqualUnmodifiableMapView) return _metadata;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(value);
}


/// Create a copy of NotebookDocumentChangeEvent
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$NotebookDocumentChangeEventCopyWith<_NotebookDocumentChangeEvent> get copyWith => __$NotebookDocumentChangeEventCopyWithImpl<_NotebookDocumentChangeEvent>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$NotebookDocumentChangeEventToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _NotebookDocumentChangeEvent&&(identical(other.cells, cells) || other.cells == cells)&&const DeepCollectionEquality().equals(other._metadata, _metadata));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,cells,const DeepCollectionEquality().hash(_metadata));

@override
String toString() {
  return 'NotebookDocumentChangeEvent(cells: $cells, metadata: $metadata)';
}


}

/// @nodoc
abstract mixin class _$NotebookDocumentChangeEventCopyWith<$Res> implements $NotebookDocumentChangeEventCopyWith<$Res> {
  factory _$NotebookDocumentChangeEventCopyWith(_NotebookDocumentChangeEvent value, $Res Function(_NotebookDocumentChangeEvent) _then) = __$NotebookDocumentChangeEventCopyWithImpl;
@override @useResult
$Res call({
 ({({NotebookCellArrayChange array, List<TextDocumentItem>? didOpen, List<TextDocumentIdentifier>? didClose})? structure, List<NotebookCell>? data, List<({VersionedTextDocumentIdentifier document, List<TextDocumentContentChangeEvent> changes})>? textContent})? cells, LSPObject? metadata
});




}
/// @nodoc
class __$NotebookDocumentChangeEventCopyWithImpl<$Res>
    implements _$NotebookDocumentChangeEventCopyWith<$Res> {
  __$NotebookDocumentChangeEventCopyWithImpl(this._self, this._then);

  final _NotebookDocumentChangeEvent _self;
  final $Res Function(_NotebookDocumentChangeEvent) _then;

/// Create a copy of NotebookDocumentChangeEvent
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? cells = freezed,Object? metadata = freezed,}) {
  return _then(_NotebookDocumentChangeEvent(
cells: freezed == cells ? _self.cells : cells // ignore: cast_nullable_to_non_nullable
as ({({NotebookCellArrayChange array, List<TextDocumentItem>? didOpen, List<TextDocumentIdentifier>? didClose})? structure, List<NotebookCell>? data, List<({VersionedTextDocumentIdentifier document, List<TextDocumentContentChangeEvent> changes})>? textContent})?,metadata: freezed == metadata ? _self._metadata : metadata // ignore: cast_nullable_to_non_nullable
as LSPObject?,
  ));
}


}


/// @nodoc
mixin _$NotebookDocumentIdentifier {

 String get uri;
/// Create a copy of NotebookDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$NotebookDocumentIdentifierCopyWith<NotebookDocumentIdentifier> get copyWith => _$NotebookDocumentIdentifierCopyWithImpl<NotebookDocumentIdentifier>(this as NotebookDocumentIdentifier, _$identity);

  /// Serializes this NotebookDocumentIdentifier to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is NotebookDocumentIdentifier&&(identical(other.uri, uri) || other.uri == uri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri);

@override
String toString() {
  return 'NotebookDocumentIdentifier(uri: $uri)';
}


}

/// @nodoc
abstract mixin class $NotebookDocumentIdentifierCopyWith<$Res>  {
  factory $NotebookDocumentIdentifierCopyWith(NotebookDocumentIdentifier value, $Res Function(NotebookDocumentIdentifier) _then) = _$NotebookDocumentIdentifierCopyWithImpl;
@useResult
$Res call({
 String uri
});




}
/// @nodoc
class _$NotebookDocumentIdentifierCopyWithImpl<$Res>
    implements $NotebookDocumentIdentifierCopyWith<$Res> {
  _$NotebookDocumentIdentifierCopyWithImpl(this._self, this._then);

  final NotebookDocumentIdentifier _self;
  final $Res Function(NotebookDocumentIdentifier) _then;

/// Create a copy of NotebookDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? uri = null,}) {
  return _then(_self.copyWith(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _NotebookDocumentIdentifier implements NotebookDocumentIdentifier {
  const _NotebookDocumentIdentifier({required this.uri});
  factory _NotebookDocumentIdentifier.fromJson(Map<String, dynamic> json) => _$NotebookDocumentIdentifierFromJson(json);

@override final  String uri;

/// Create a copy of NotebookDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$NotebookDocumentIdentifierCopyWith<_NotebookDocumentIdentifier> get copyWith => __$NotebookDocumentIdentifierCopyWithImpl<_NotebookDocumentIdentifier>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$NotebookDocumentIdentifierToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _NotebookDocumentIdentifier&&(identical(other.uri, uri) || other.uri == uri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri);

@override
String toString() {
  return 'NotebookDocumentIdentifier(uri: $uri)';
}


}

/// @nodoc
abstract mixin class _$NotebookDocumentIdentifierCopyWith<$Res> implements $NotebookDocumentIdentifierCopyWith<$Res> {
  factory _$NotebookDocumentIdentifierCopyWith(_NotebookDocumentIdentifier value, $Res Function(_NotebookDocumentIdentifier) _then) = __$NotebookDocumentIdentifierCopyWithImpl;
@override @useResult
$Res call({
 String uri
});




}
/// @nodoc
class __$NotebookDocumentIdentifierCopyWithImpl<$Res>
    implements _$NotebookDocumentIdentifierCopyWith<$Res> {
  __$NotebookDocumentIdentifierCopyWithImpl(this._self, this._then);

  final _NotebookDocumentIdentifier _self;
  final $Res Function(_NotebookDocumentIdentifier) _then;

/// Create a copy of NotebookDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? uri = null,}) {
  return _then(_NotebookDocumentIdentifier(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}


/// @nodoc
mixin _$InlineCompletionContext {

 InlineCompletionTriggerKind get triggerKind; SelectedCompletionInfo? get selectedCompletionInfo;
/// Create a copy of InlineCompletionContext
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlineCompletionContextCopyWith<InlineCompletionContext> get copyWith => _$InlineCompletionContextCopyWithImpl<InlineCompletionContext>(this as InlineCompletionContext, _$identity);

  /// Serializes this InlineCompletionContext to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlineCompletionContext&&(identical(other.triggerKind, triggerKind) || other.triggerKind == triggerKind)&&(identical(other.selectedCompletionInfo, selectedCompletionInfo) || other.selectedCompletionInfo == selectedCompletionInfo));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,triggerKind,selectedCompletionInfo);

@override
String toString() {
  return 'InlineCompletionContext(triggerKind: $triggerKind, selectedCompletionInfo: $selectedCompletionInfo)';
}


}

/// @nodoc
abstract mixin class $InlineCompletionContextCopyWith<$Res>  {
  factory $InlineCompletionContextCopyWith(InlineCompletionContext value, $Res Function(InlineCompletionContext) _then) = _$InlineCompletionContextCopyWithImpl;
@useResult
$Res call({
 InlineCompletionTriggerKind triggerKind, SelectedCompletionInfo? selectedCompletionInfo
});


$SelectedCompletionInfoCopyWith<$Res>? get selectedCompletionInfo;

}
/// @nodoc
class _$InlineCompletionContextCopyWithImpl<$Res>
    implements $InlineCompletionContextCopyWith<$Res> {
  _$InlineCompletionContextCopyWithImpl(this._self, this._then);

  final InlineCompletionContext _self;
  final $Res Function(InlineCompletionContext) _then;

/// Create a copy of InlineCompletionContext
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? triggerKind = null,Object? selectedCompletionInfo = freezed,}) {
  return _then(_self.copyWith(
triggerKind: null == triggerKind ? _self.triggerKind : triggerKind // ignore: cast_nullable_to_non_nullable
as InlineCompletionTriggerKind,selectedCompletionInfo: freezed == selectedCompletionInfo ? _self.selectedCompletionInfo : selectedCompletionInfo // ignore: cast_nullable_to_non_nullable
as SelectedCompletionInfo?,
  ));
}
/// Create a copy of InlineCompletionContext
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SelectedCompletionInfoCopyWith<$Res>? get selectedCompletionInfo {
    if (_self.selectedCompletionInfo == null) {
    return null;
  }

  return $SelectedCompletionInfoCopyWith<$Res>(_self.selectedCompletionInfo!, (value) {
    return _then(_self.copyWith(selectedCompletionInfo: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _InlineCompletionContext implements InlineCompletionContext {
  const _InlineCompletionContext({required this.triggerKind, this.selectedCompletionInfo});
  factory _InlineCompletionContext.fromJson(Map<String, dynamic> json) => _$InlineCompletionContextFromJson(json);

@override final  InlineCompletionTriggerKind triggerKind;
@override final  SelectedCompletionInfo? selectedCompletionInfo;

/// Create a copy of InlineCompletionContext
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlineCompletionContextCopyWith<_InlineCompletionContext> get copyWith => __$InlineCompletionContextCopyWithImpl<_InlineCompletionContext>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlineCompletionContextToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlineCompletionContext&&(identical(other.triggerKind, triggerKind) || other.triggerKind == triggerKind)&&(identical(other.selectedCompletionInfo, selectedCompletionInfo) || other.selectedCompletionInfo == selectedCompletionInfo));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,triggerKind,selectedCompletionInfo);

@override
String toString() {
  return 'InlineCompletionContext(triggerKind: $triggerKind, selectedCompletionInfo: $selectedCompletionInfo)';
}


}

/// @nodoc
abstract mixin class _$InlineCompletionContextCopyWith<$Res> implements $InlineCompletionContextCopyWith<$Res> {
  factory _$InlineCompletionContextCopyWith(_InlineCompletionContext value, $Res Function(_InlineCompletionContext) _then) = __$InlineCompletionContextCopyWithImpl;
@override @useResult
$Res call({
 InlineCompletionTriggerKind triggerKind, SelectedCompletionInfo? selectedCompletionInfo
});


@override $SelectedCompletionInfoCopyWith<$Res>? get selectedCompletionInfo;

}
/// @nodoc
class __$InlineCompletionContextCopyWithImpl<$Res>
    implements _$InlineCompletionContextCopyWith<$Res> {
  __$InlineCompletionContextCopyWithImpl(this._self, this._then);

  final _InlineCompletionContext _self;
  final $Res Function(_InlineCompletionContext) _then;

/// Create a copy of InlineCompletionContext
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? triggerKind = null,Object? selectedCompletionInfo = freezed,}) {
  return _then(_InlineCompletionContext(
triggerKind: null == triggerKind ? _self.triggerKind : triggerKind // ignore: cast_nullable_to_non_nullable
as InlineCompletionTriggerKind,selectedCompletionInfo: freezed == selectedCompletionInfo ? _self.selectedCompletionInfo : selectedCompletionInfo // ignore: cast_nullable_to_non_nullable
as SelectedCompletionInfo?,
  ));
}

/// Create a copy of InlineCompletionContext
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SelectedCompletionInfoCopyWith<$Res>? get selectedCompletionInfo {
    if (_self.selectedCompletionInfo == null) {
    return null;
  }

  return $SelectedCompletionInfoCopyWith<$Res>(_self.selectedCompletionInfo!, (value) {
    return _then(_self.copyWith(selectedCompletionInfo: value));
  });
}
}


/// @nodoc
mixin _$StringValue {

 String get kind; String get value;
/// Create a copy of StringValue
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$StringValueCopyWith<StringValue> get copyWith => _$StringValueCopyWithImpl<StringValue>(this as StringValue, _$identity);

  /// Serializes this StringValue to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is StringValue&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.value, value) || other.value == value));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,kind,value);

@override
String toString() {
  return 'StringValue(kind: $kind, value: $value)';
}


}

/// @nodoc
abstract mixin class $StringValueCopyWith<$Res>  {
  factory $StringValueCopyWith(StringValue value, $Res Function(StringValue) _then) = _$StringValueCopyWithImpl;
@useResult
$Res call({
 String kind, String value
});




}
/// @nodoc
class _$StringValueCopyWithImpl<$Res>
    implements $StringValueCopyWith<$Res> {
  _$StringValueCopyWithImpl(this._self, this._then);

  final StringValue _self;
  final $Res Function(StringValue) _then;

/// Create a copy of StringValue
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? kind = null,Object? value = null,}) {
  return _then(_self.copyWith(
kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as String,value: null == value ? _self.value : value // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _StringValue implements StringValue {
  const _StringValue({required this.kind, required this.value});
  factory _StringValue.fromJson(Map<String, dynamic> json) => _$StringValueFromJson(json);

@override final  String kind;
@override final  String value;

/// Create a copy of StringValue
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$StringValueCopyWith<_StringValue> get copyWith => __$StringValueCopyWithImpl<_StringValue>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$StringValueToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _StringValue&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.value, value) || other.value == value));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,kind,value);

@override
String toString() {
  return 'StringValue(kind: $kind, value: $value)';
}


}

/// @nodoc
abstract mixin class _$StringValueCopyWith<$Res> implements $StringValueCopyWith<$Res> {
  factory _$StringValueCopyWith(_StringValue value, $Res Function(_StringValue) _then) = __$StringValueCopyWithImpl;
@override @useResult
$Res call({
 String kind, String value
});




}
/// @nodoc
class __$StringValueCopyWithImpl<$Res>
    implements _$StringValueCopyWith<$Res> {
  __$StringValueCopyWithImpl(this._self, this._then);

  final _StringValue _self;
  final $Res Function(_StringValue) _then;

/// Create a copy of StringValue
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? kind = null,Object? value = null,}) {
  return _then(_StringValue(
kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as String,value: null == value ? _self.value : value // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}


/// @nodoc
mixin _$InlineCompletionOptions {

 bool? get workDoneProgress;
/// Create a copy of InlineCompletionOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlineCompletionOptionsCopyWith<InlineCompletionOptions> get copyWith => _$InlineCompletionOptionsCopyWithImpl<InlineCompletionOptions>(this as InlineCompletionOptions, _$identity);

  /// Serializes this InlineCompletionOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlineCompletionOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'InlineCompletionOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $InlineCompletionOptionsCopyWith<$Res>  {
  factory $InlineCompletionOptionsCopyWith(InlineCompletionOptions value, $Res Function(InlineCompletionOptions) _then) = _$InlineCompletionOptionsCopyWithImpl;
@useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class _$InlineCompletionOptionsCopyWithImpl<$Res>
    implements $InlineCompletionOptionsCopyWith<$Res> {
  _$InlineCompletionOptionsCopyWithImpl(this._self, this._then);

  final InlineCompletionOptions _self;
  final $Res Function(InlineCompletionOptions) _then;

/// Create a copy of InlineCompletionOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _InlineCompletionOptions implements InlineCompletionOptions {
  const _InlineCompletionOptions({this.workDoneProgress});
  factory _InlineCompletionOptions.fromJson(Map<String, dynamic> json) => _$InlineCompletionOptionsFromJson(json);

@override final  bool? workDoneProgress;

/// Create a copy of InlineCompletionOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlineCompletionOptionsCopyWith<_InlineCompletionOptions> get copyWith => __$InlineCompletionOptionsCopyWithImpl<_InlineCompletionOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlineCompletionOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlineCompletionOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'InlineCompletionOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$InlineCompletionOptionsCopyWith<$Res> implements $InlineCompletionOptionsCopyWith<$Res> {
  factory _$InlineCompletionOptionsCopyWith(_InlineCompletionOptions value, $Res Function(_InlineCompletionOptions) _then) = __$InlineCompletionOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class __$InlineCompletionOptionsCopyWithImpl<$Res>
    implements _$InlineCompletionOptionsCopyWith<$Res> {
  __$InlineCompletionOptionsCopyWithImpl(this._self, this._then);

  final _InlineCompletionOptions _self;
  final $Res Function(_InlineCompletionOptions) _then;

/// Create a copy of InlineCompletionOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_InlineCompletionOptions(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$Registration {

 String get id; String get method; LSPAny? get registerOptions;
/// Create a copy of Registration
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RegistrationCopyWith<Registration> get copyWith => _$RegistrationCopyWithImpl<Registration>(this as Registration, _$identity);

  /// Serializes this Registration to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Registration&&(identical(other.id, id) || other.id == id)&&(identical(other.method, method) || other.method == method)&&const DeepCollectionEquality().equals(other.registerOptions, registerOptions));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,method,const DeepCollectionEquality().hash(registerOptions));

@override
String toString() {
  return 'Registration(id: $id, method: $method, registerOptions: $registerOptions)';
}


}

/// @nodoc
abstract mixin class $RegistrationCopyWith<$Res>  {
  factory $RegistrationCopyWith(Registration value, $Res Function(Registration) _then) = _$RegistrationCopyWithImpl;
@useResult
$Res call({
 String id, String method, LSPAny? registerOptions
});




}
/// @nodoc
class _$RegistrationCopyWithImpl<$Res>
    implements $RegistrationCopyWith<$Res> {
  _$RegistrationCopyWithImpl(this._self, this._then);

  final Registration _self;
  final $Res Function(Registration) _then;

/// Create a copy of Registration
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = null,Object? method = null,Object? registerOptions = freezed,}) {
  return _then(_self.copyWith(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,method: null == method ? _self.method : method // ignore: cast_nullable_to_non_nullable
as String,registerOptions: freezed == registerOptions ? _self.registerOptions : registerOptions // ignore: cast_nullable_to_non_nullable
as LSPAny?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _Registration implements Registration {
  const _Registration({required this.id, required this.method, this.registerOptions});
  factory _Registration.fromJson(Map<String, dynamic> json) => _$RegistrationFromJson(json);

@override final  String id;
@override final  String method;
@override final  LSPAny? registerOptions;

/// Create a copy of Registration
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RegistrationCopyWith<_Registration> get copyWith => __$RegistrationCopyWithImpl<_Registration>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$RegistrationToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _Registration&&(identical(other.id, id) || other.id == id)&&(identical(other.method, method) || other.method == method)&&const DeepCollectionEquality().equals(other.registerOptions, registerOptions));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,method,const DeepCollectionEquality().hash(registerOptions));

@override
String toString() {
  return 'Registration(id: $id, method: $method, registerOptions: $registerOptions)';
}


}

/// @nodoc
abstract mixin class _$RegistrationCopyWith<$Res> implements $RegistrationCopyWith<$Res> {
  factory _$RegistrationCopyWith(_Registration value, $Res Function(_Registration) _then) = __$RegistrationCopyWithImpl;
@override @useResult
$Res call({
 String id, String method, LSPAny? registerOptions
});




}
/// @nodoc
class __$RegistrationCopyWithImpl<$Res>
    implements _$RegistrationCopyWith<$Res> {
  __$RegistrationCopyWithImpl(this._self, this._then);

  final _Registration _self;
  final $Res Function(_Registration) _then;

/// Create a copy of Registration
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = null,Object? method = null,Object? registerOptions = freezed,}) {
  return _then(_Registration(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,method: null == method ? _self.method : method // ignore: cast_nullable_to_non_nullable
as String,registerOptions: freezed == registerOptions ? _self.registerOptions : registerOptions // ignore: cast_nullable_to_non_nullable
as LSPAny?,
  ));
}


}


/// @nodoc
mixin _$Unregistration {

 String get id; String get method;
/// Create a copy of Unregistration
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UnregistrationCopyWith<Unregistration> get copyWith => _$UnregistrationCopyWithImpl<Unregistration>(this as Unregistration, _$identity);

  /// Serializes this Unregistration to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Unregistration&&(identical(other.id, id) || other.id == id)&&(identical(other.method, method) || other.method == method));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,method);

@override
String toString() {
  return 'Unregistration(id: $id, method: $method)';
}


}

/// @nodoc
abstract mixin class $UnregistrationCopyWith<$Res>  {
  factory $UnregistrationCopyWith(Unregistration value, $Res Function(Unregistration) _then) = _$UnregistrationCopyWithImpl;
@useResult
$Res call({
 String id, String method
});




}
/// @nodoc
class _$UnregistrationCopyWithImpl<$Res>
    implements $UnregistrationCopyWith<$Res> {
  _$UnregistrationCopyWithImpl(this._self, this._then);

  final Unregistration _self;
  final $Res Function(Unregistration) _then;

/// Create a copy of Unregistration
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = null,Object? method = null,}) {
  return _then(_self.copyWith(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,method: null == method ? _self.method : method // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _Unregistration implements Unregistration {
  const _Unregistration({required this.id, required this.method});
  factory _Unregistration.fromJson(Map<String, dynamic> json) => _$UnregistrationFromJson(json);

@override final  String id;
@override final  String method;

/// Create a copy of Unregistration
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$UnregistrationCopyWith<_Unregistration> get copyWith => __$UnregistrationCopyWithImpl<_Unregistration>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$UnregistrationToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _Unregistration&&(identical(other.id, id) || other.id == id)&&(identical(other.method, method) || other.method == method));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,method);

@override
String toString() {
  return 'Unregistration(id: $id, method: $method)';
}


}

/// @nodoc
abstract mixin class _$UnregistrationCopyWith<$Res> implements $UnregistrationCopyWith<$Res> {
  factory _$UnregistrationCopyWith(_Unregistration value, $Res Function(_Unregistration) _then) = __$UnregistrationCopyWithImpl;
@override @useResult
$Res call({
 String id, String method
});




}
/// @nodoc
class __$UnregistrationCopyWithImpl<$Res>
    implements _$UnregistrationCopyWith<$Res> {
  __$UnregistrationCopyWithImpl(this._self, this._then);

  final _Unregistration _self;
  final $Res Function(_Unregistration) _then;

/// Create a copy of Unregistration
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = null,Object? method = null,}) {
  return _then(_Unregistration(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,method: null == method ? _self.method : method // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}


/// @nodoc
mixin _$TInitializeParams {

 dynamic get processId; dynamic get rootUri; ClientCapabilities get capabilities; TraceValues? get trace; LSPAny? get initializationOptions; dynamic? get rootPath; String? get locale; ({String name, String? version})? get clientInfo; ProgressToken? get workDoneToken;
/// Create a copy of TInitializeParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TInitializeParamsCopyWith<TInitializeParams> get copyWith => _$TInitializeParamsCopyWithImpl<TInitializeParams>(this as TInitializeParams, _$identity);

  /// Serializes this TInitializeParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TInitializeParams&&const DeepCollectionEquality().equals(other.processId, processId)&&const DeepCollectionEquality().equals(other.rootUri, rootUri)&&(identical(other.capabilities, capabilities) || other.capabilities == capabilities)&&(identical(other.trace, trace) || other.trace == trace)&&const DeepCollectionEquality().equals(other.initializationOptions, initializationOptions)&&const DeepCollectionEquality().equals(other.rootPath, rootPath)&&(identical(other.locale, locale) || other.locale == locale)&&(identical(other.clientInfo, clientInfo) || other.clientInfo == clientInfo)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(processId),const DeepCollectionEquality().hash(rootUri),capabilities,trace,const DeepCollectionEquality().hash(initializationOptions),const DeepCollectionEquality().hash(rootPath),locale,clientInfo,const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'TInitializeParams(processId: $processId, rootUri: $rootUri, capabilities: $capabilities, trace: $trace, initializationOptions: $initializationOptions, rootPath: $rootPath, locale: $locale, clientInfo: $clientInfo, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $TInitializeParamsCopyWith<$Res>  {
  factory $TInitializeParamsCopyWith(TInitializeParams value, $Res Function(TInitializeParams) _then) = _$TInitializeParamsCopyWithImpl;
@useResult
$Res call({
 dynamic processId, dynamic rootUri, ClientCapabilities capabilities, TraceValues? trace, LSPAny? initializationOptions, dynamic? rootPath, String? locale, ({String name, String? version})? clientInfo, ProgressToken? workDoneToken
});


$ClientCapabilitiesCopyWith<$Res> get capabilities;

}
/// @nodoc
class _$TInitializeParamsCopyWithImpl<$Res>
    implements $TInitializeParamsCopyWith<$Res> {
  _$TInitializeParamsCopyWithImpl(this._self, this._then);

  final TInitializeParams _self;
  final $Res Function(TInitializeParams) _then;

/// Create a copy of TInitializeParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? processId = freezed,Object? rootUri = freezed,Object? capabilities = null,Object? trace = freezed,Object? initializationOptions = freezed,Object? rootPath = freezed,Object? locale = freezed,Object? clientInfo = freezed,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
processId: freezed == processId ? _self.processId : processId // ignore: cast_nullable_to_non_nullable
as dynamic,rootUri: freezed == rootUri ? _self.rootUri : rootUri // ignore: cast_nullable_to_non_nullable
as dynamic,capabilities: null == capabilities ? _self.capabilities : capabilities // ignore: cast_nullable_to_non_nullable
as ClientCapabilities,trace: freezed == trace ? _self.trace : trace // ignore: cast_nullable_to_non_nullable
as TraceValues?,initializationOptions: freezed == initializationOptions ? _self.initializationOptions : initializationOptions // ignore: cast_nullable_to_non_nullable
as LSPAny?,rootPath: freezed == rootPath ? _self.rootPath : rootPath // ignore: cast_nullable_to_non_nullable
as dynamic?,locale: freezed == locale ? _self.locale : locale // ignore: cast_nullable_to_non_nullable
as String?,clientInfo: freezed == clientInfo ? _self.clientInfo : clientInfo // ignore: cast_nullable_to_non_nullable
as ({String name, String? version})?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of TInitializeParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ClientCapabilitiesCopyWith<$Res> get capabilities {
  
  return $ClientCapabilitiesCopyWith<$Res>(_self.capabilities, (value) {
    return _then(_self.copyWith(capabilities: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _TInitializeParams implements TInitializeParams {
  const _TInitializeParams({required this.processId, required this.rootUri, required this.capabilities, this.trace, this.initializationOptions, this.rootPath, this.locale, this.clientInfo, this.workDoneToken});
  factory _TInitializeParams.fromJson(Map<String, dynamic> json) => _$TInitializeParamsFromJson(json);

@override final  dynamic processId;
@override final  dynamic rootUri;
@override final  ClientCapabilities capabilities;
@override final  TraceValues? trace;
@override final  LSPAny? initializationOptions;
@override final  dynamic? rootPath;
@override final  String? locale;
@override final  ({String name, String? version})? clientInfo;
@override final  ProgressToken? workDoneToken;

/// Create a copy of TInitializeParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TInitializeParamsCopyWith<_TInitializeParams> get copyWith => __$TInitializeParamsCopyWithImpl<_TInitializeParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TInitializeParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TInitializeParams&&const DeepCollectionEquality().equals(other.processId, processId)&&const DeepCollectionEquality().equals(other.rootUri, rootUri)&&(identical(other.capabilities, capabilities) || other.capabilities == capabilities)&&(identical(other.trace, trace) || other.trace == trace)&&const DeepCollectionEquality().equals(other.initializationOptions, initializationOptions)&&const DeepCollectionEquality().equals(other.rootPath, rootPath)&&(identical(other.locale, locale) || other.locale == locale)&&(identical(other.clientInfo, clientInfo) || other.clientInfo == clientInfo)&&const DeepCollectionEquality().equals(other.workDoneToken, workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(processId),const DeepCollectionEquality().hash(rootUri),capabilities,trace,const DeepCollectionEquality().hash(initializationOptions),const DeepCollectionEquality().hash(rootPath),locale,clientInfo,const DeepCollectionEquality().hash(workDoneToken));

@override
String toString() {
  return 'TInitializeParams(processId: $processId, rootUri: $rootUri, capabilities: $capabilities, trace: $trace, initializationOptions: $initializationOptions, rootPath: $rootPath, locale: $locale, clientInfo: $clientInfo, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$TInitializeParamsCopyWith<$Res> implements $TInitializeParamsCopyWith<$Res> {
  factory _$TInitializeParamsCopyWith(_TInitializeParams value, $Res Function(_TInitializeParams) _then) = __$TInitializeParamsCopyWithImpl;
@override @useResult
$Res call({
 dynamic processId, dynamic rootUri, ClientCapabilities capabilities, TraceValues? trace, LSPAny? initializationOptions, dynamic? rootPath, String? locale, ({String name, String? version})? clientInfo, ProgressToken? workDoneToken
});


@override $ClientCapabilitiesCopyWith<$Res> get capabilities;

}
/// @nodoc
class __$TInitializeParamsCopyWithImpl<$Res>
    implements _$TInitializeParamsCopyWith<$Res> {
  __$TInitializeParamsCopyWithImpl(this._self, this._then);

  final _TInitializeParams _self;
  final $Res Function(_TInitializeParams) _then;

/// Create a copy of TInitializeParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? processId = freezed,Object? rootUri = freezed,Object? capabilities = null,Object? trace = freezed,Object? initializationOptions = freezed,Object? rootPath = freezed,Object? locale = freezed,Object? clientInfo = freezed,Object? workDoneToken = freezed,}) {
  return _then(_TInitializeParams(
processId: freezed == processId ? _self.processId : processId // ignore: cast_nullable_to_non_nullable
as dynamic,rootUri: freezed == rootUri ? _self.rootUri : rootUri // ignore: cast_nullable_to_non_nullable
as dynamic,capabilities: null == capabilities ? _self.capabilities : capabilities // ignore: cast_nullable_to_non_nullable
as ClientCapabilities,trace: freezed == trace ? _self.trace : trace // ignore: cast_nullable_to_non_nullable
as TraceValues?,initializationOptions: freezed == initializationOptions ? _self.initializationOptions : initializationOptions // ignore: cast_nullable_to_non_nullable
as LSPAny?,rootPath: freezed == rootPath ? _self.rootPath : rootPath // ignore: cast_nullable_to_non_nullable
as dynamic?,locale: freezed == locale ? _self.locale : locale // ignore: cast_nullable_to_non_nullable
as String?,clientInfo: freezed == clientInfo ? _self.clientInfo : clientInfo // ignore: cast_nullable_to_non_nullable
as ({String name, String? version})?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of TInitializeParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ClientCapabilitiesCopyWith<$Res> get capabilities {
  
  return $ClientCapabilitiesCopyWith<$Res>(_self.capabilities, (value) {
    return _then(_self.copyWith(capabilities: value));
  });
}
}


/// @nodoc
mixin _$WorkspaceFoldersInitializeParams {

 dynamic? get workspaceFolders;
/// Create a copy of WorkspaceFoldersInitializeParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkspaceFoldersInitializeParamsCopyWith<WorkspaceFoldersInitializeParams> get copyWith => _$WorkspaceFoldersInitializeParamsCopyWithImpl<WorkspaceFoldersInitializeParams>(this as WorkspaceFoldersInitializeParams, _$identity);

  /// Serializes this WorkspaceFoldersInitializeParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkspaceFoldersInitializeParams&&const DeepCollectionEquality().equals(other.workspaceFolders, workspaceFolders));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(workspaceFolders));

@override
String toString() {
  return 'WorkspaceFoldersInitializeParams(workspaceFolders: $workspaceFolders)';
}


}

/// @nodoc
abstract mixin class $WorkspaceFoldersInitializeParamsCopyWith<$Res>  {
  factory $WorkspaceFoldersInitializeParamsCopyWith(WorkspaceFoldersInitializeParams value, $Res Function(WorkspaceFoldersInitializeParams) _then) = _$WorkspaceFoldersInitializeParamsCopyWithImpl;
@useResult
$Res call({
 dynamic? workspaceFolders
});




}
/// @nodoc
class _$WorkspaceFoldersInitializeParamsCopyWithImpl<$Res>
    implements $WorkspaceFoldersInitializeParamsCopyWith<$Res> {
  _$WorkspaceFoldersInitializeParamsCopyWithImpl(this._self, this._then);

  final WorkspaceFoldersInitializeParams _self;
  final $Res Function(WorkspaceFoldersInitializeParams) _then;

/// Create a copy of WorkspaceFoldersInitializeParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workspaceFolders = freezed,}) {
  return _then(_self.copyWith(
workspaceFolders: freezed == workspaceFolders ? _self.workspaceFolders : workspaceFolders // ignore: cast_nullable_to_non_nullable
as dynamic?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _WorkspaceFoldersInitializeParams implements WorkspaceFoldersInitializeParams {
  const _WorkspaceFoldersInitializeParams({this.workspaceFolders});
  factory _WorkspaceFoldersInitializeParams.fromJson(Map<String, dynamic> json) => _$WorkspaceFoldersInitializeParamsFromJson(json);

@override final  dynamic? workspaceFolders;

/// Create a copy of WorkspaceFoldersInitializeParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkspaceFoldersInitializeParamsCopyWith<_WorkspaceFoldersInitializeParams> get copyWith => __$WorkspaceFoldersInitializeParamsCopyWithImpl<_WorkspaceFoldersInitializeParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkspaceFoldersInitializeParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkspaceFoldersInitializeParams&&const DeepCollectionEquality().equals(other.workspaceFolders, workspaceFolders));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(workspaceFolders));

@override
String toString() {
  return 'WorkspaceFoldersInitializeParams(workspaceFolders: $workspaceFolders)';
}


}

/// @nodoc
abstract mixin class _$WorkspaceFoldersInitializeParamsCopyWith<$Res> implements $WorkspaceFoldersInitializeParamsCopyWith<$Res> {
  factory _$WorkspaceFoldersInitializeParamsCopyWith(_WorkspaceFoldersInitializeParams value, $Res Function(_WorkspaceFoldersInitializeParams) _then) = __$WorkspaceFoldersInitializeParamsCopyWithImpl;
@override @useResult
$Res call({
 dynamic? workspaceFolders
});




}
/// @nodoc
class __$WorkspaceFoldersInitializeParamsCopyWithImpl<$Res>
    implements _$WorkspaceFoldersInitializeParamsCopyWith<$Res> {
  __$WorkspaceFoldersInitializeParamsCopyWithImpl(this._self, this._then);

  final _WorkspaceFoldersInitializeParams _self;
  final $Res Function(_WorkspaceFoldersInitializeParams) _then;

/// Create a copy of WorkspaceFoldersInitializeParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workspaceFolders = freezed,}) {
  return _then(_WorkspaceFoldersInitializeParams(
workspaceFolders: freezed == workspaceFolders ? _self.workspaceFolders : workspaceFolders // ignore: cast_nullable_to_non_nullable
as dynamic?,
  ));
}


}


/// @nodoc
mixin _$ServerCapabilities {

 dynamic? get workspaceSymbolProvider; dynamic? get documentHighlightProvider; dynamic? get documentFormattingProvider; dynamic? get codeActionProvider; CompletionOptions? get completionProvider; ({WorkspaceFoldersServerCapabilities? workspaceFolders, FileOperationOptions? fileOperations})? get workspace; dynamic? get inlineCompletionProvider; dynamic? get diagnosticProvider; dynamic? get inlayHintProvider; dynamic? get definitionProvider; dynamic? get declarationProvider; dynamic? get monikerProvider; dynamic? get semanticTokensProvider; dynamic? get linkedEditingRangeProvider; dynamic? get callHierarchyProvider; ExecuteCommandOptions? get executeCommandProvider; dynamic? get textDocumentSync; dynamic? get foldingRangeProvider; dynamic? get renameProvider; DocumentOnTypeFormattingOptions? get documentOnTypeFormattingProvider; dynamic? get documentRangeFormattingProvider; LSPAny? get experimental; dynamic? get selectionRangeProvider; dynamic? get colorProvider; DocumentLinkOptions? get documentLinkProvider; CodeLensOptions? get codeLensProvider; dynamic? get notebookDocumentSync; dynamic? get documentSymbolProvider; PositionEncodingKind? get positionEncoding; dynamic? get referencesProvider; dynamic? get implementationProvider; dynamic? get typeDefinitionProvider; dynamic? get inlineValueProvider; dynamic? get typeHierarchyProvider; SignatureHelpOptions? get signatureHelpProvider; dynamic? get hoverProvider;
/// Create a copy of ServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ServerCapabilitiesCopyWith<ServerCapabilities> get copyWith => _$ServerCapabilitiesCopyWithImpl<ServerCapabilities>(this as ServerCapabilities, _$identity);

  /// Serializes this ServerCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ServerCapabilities&&const DeepCollectionEquality().equals(other.workspaceSymbolProvider, workspaceSymbolProvider)&&const DeepCollectionEquality().equals(other.documentHighlightProvider, documentHighlightProvider)&&const DeepCollectionEquality().equals(other.documentFormattingProvider, documentFormattingProvider)&&const DeepCollectionEquality().equals(other.codeActionProvider, codeActionProvider)&&(identical(other.completionProvider, completionProvider) || other.completionProvider == completionProvider)&&(identical(other.workspace, workspace) || other.workspace == workspace)&&const DeepCollectionEquality().equals(other.inlineCompletionProvider, inlineCompletionProvider)&&const DeepCollectionEquality().equals(other.diagnosticProvider, diagnosticProvider)&&const DeepCollectionEquality().equals(other.inlayHintProvider, inlayHintProvider)&&const DeepCollectionEquality().equals(other.definitionProvider, definitionProvider)&&const DeepCollectionEquality().equals(other.declarationProvider, declarationProvider)&&const DeepCollectionEquality().equals(other.monikerProvider, monikerProvider)&&const DeepCollectionEquality().equals(other.semanticTokensProvider, semanticTokensProvider)&&const DeepCollectionEquality().equals(other.linkedEditingRangeProvider, linkedEditingRangeProvider)&&const DeepCollectionEquality().equals(other.callHierarchyProvider, callHierarchyProvider)&&(identical(other.executeCommandProvider, executeCommandProvider) || other.executeCommandProvider == executeCommandProvider)&&const DeepCollectionEquality().equals(other.textDocumentSync, textDocumentSync)&&const DeepCollectionEquality().equals(other.foldingRangeProvider, foldingRangeProvider)&&const DeepCollectionEquality().equals(other.renameProvider, renameProvider)&&(identical(other.documentOnTypeFormattingProvider, documentOnTypeFormattingProvider) || other.documentOnTypeFormattingProvider == documentOnTypeFormattingProvider)&&const DeepCollectionEquality().equals(other.documentRangeFormattingProvider, documentRangeFormattingProvider)&&const DeepCollectionEquality().equals(other.experimental, experimental)&&const DeepCollectionEquality().equals(other.selectionRangeProvider, selectionRangeProvider)&&const DeepCollectionEquality().equals(other.colorProvider, colorProvider)&&(identical(other.documentLinkProvider, documentLinkProvider) || other.documentLinkProvider == documentLinkProvider)&&(identical(other.codeLensProvider, codeLensProvider) || other.codeLensProvider == codeLensProvider)&&const DeepCollectionEquality().equals(other.notebookDocumentSync, notebookDocumentSync)&&const DeepCollectionEquality().equals(other.documentSymbolProvider, documentSymbolProvider)&&(identical(other.positionEncoding, positionEncoding) || other.positionEncoding == positionEncoding)&&const DeepCollectionEquality().equals(other.referencesProvider, referencesProvider)&&const DeepCollectionEquality().equals(other.implementationProvider, implementationProvider)&&const DeepCollectionEquality().equals(other.typeDefinitionProvider, typeDefinitionProvider)&&const DeepCollectionEquality().equals(other.inlineValueProvider, inlineValueProvider)&&const DeepCollectionEquality().equals(other.typeHierarchyProvider, typeHierarchyProvider)&&(identical(other.signatureHelpProvider, signatureHelpProvider) || other.signatureHelpProvider == signatureHelpProvider)&&const DeepCollectionEquality().equals(other.hoverProvider, hoverProvider));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hashAll([runtimeType,const DeepCollectionEquality().hash(workspaceSymbolProvider),const DeepCollectionEquality().hash(documentHighlightProvider),const DeepCollectionEquality().hash(documentFormattingProvider),const DeepCollectionEquality().hash(codeActionProvider),completionProvider,workspace,const DeepCollectionEquality().hash(inlineCompletionProvider),const DeepCollectionEquality().hash(diagnosticProvider),const DeepCollectionEquality().hash(inlayHintProvider),const DeepCollectionEquality().hash(definitionProvider),const DeepCollectionEquality().hash(declarationProvider),const DeepCollectionEquality().hash(monikerProvider),const DeepCollectionEquality().hash(semanticTokensProvider),const DeepCollectionEquality().hash(linkedEditingRangeProvider),const DeepCollectionEquality().hash(callHierarchyProvider),executeCommandProvider,const DeepCollectionEquality().hash(textDocumentSync),const DeepCollectionEquality().hash(foldingRangeProvider),const DeepCollectionEquality().hash(renameProvider),documentOnTypeFormattingProvider,const DeepCollectionEquality().hash(documentRangeFormattingProvider),const DeepCollectionEquality().hash(experimental),const DeepCollectionEquality().hash(selectionRangeProvider),const DeepCollectionEquality().hash(colorProvider),documentLinkProvider,codeLensProvider,const DeepCollectionEquality().hash(notebookDocumentSync),const DeepCollectionEquality().hash(documentSymbolProvider),positionEncoding,const DeepCollectionEquality().hash(referencesProvider),const DeepCollectionEquality().hash(implementationProvider),const DeepCollectionEquality().hash(typeDefinitionProvider),const DeepCollectionEquality().hash(inlineValueProvider),const DeepCollectionEquality().hash(typeHierarchyProvider),signatureHelpProvider,const DeepCollectionEquality().hash(hoverProvider)]);

@override
String toString() {
  return 'ServerCapabilities(workspaceSymbolProvider: $workspaceSymbolProvider, documentHighlightProvider: $documentHighlightProvider, documentFormattingProvider: $documentFormattingProvider, codeActionProvider: $codeActionProvider, completionProvider: $completionProvider, workspace: $workspace, inlineCompletionProvider: $inlineCompletionProvider, diagnosticProvider: $diagnosticProvider, inlayHintProvider: $inlayHintProvider, definitionProvider: $definitionProvider, declarationProvider: $declarationProvider, monikerProvider: $monikerProvider, semanticTokensProvider: $semanticTokensProvider, linkedEditingRangeProvider: $linkedEditingRangeProvider, callHierarchyProvider: $callHierarchyProvider, executeCommandProvider: $executeCommandProvider, textDocumentSync: $textDocumentSync, foldingRangeProvider: $foldingRangeProvider, renameProvider: $renameProvider, documentOnTypeFormattingProvider: $documentOnTypeFormattingProvider, documentRangeFormattingProvider: $documentRangeFormattingProvider, experimental: $experimental, selectionRangeProvider: $selectionRangeProvider, colorProvider: $colorProvider, documentLinkProvider: $documentLinkProvider, codeLensProvider: $codeLensProvider, notebookDocumentSync: $notebookDocumentSync, documentSymbolProvider: $documentSymbolProvider, positionEncoding: $positionEncoding, referencesProvider: $referencesProvider, implementationProvider: $implementationProvider, typeDefinitionProvider: $typeDefinitionProvider, inlineValueProvider: $inlineValueProvider, typeHierarchyProvider: $typeHierarchyProvider, signatureHelpProvider: $signatureHelpProvider, hoverProvider: $hoverProvider)';
}


}

/// @nodoc
abstract mixin class $ServerCapabilitiesCopyWith<$Res>  {
  factory $ServerCapabilitiesCopyWith(ServerCapabilities value, $Res Function(ServerCapabilities) _then) = _$ServerCapabilitiesCopyWithImpl;
@useResult
$Res call({
 dynamic? workspaceSymbolProvider, dynamic? documentHighlightProvider, dynamic? documentFormattingProvider, dynamic? codeActionProvider, CompletionOptions? completionProvider, ({WorkspaceFoldersServerCapabilities? workspaceFolders, FileOperationOptions? fileOperations})? workspace, dynamic? inlineCompletionProvider, dynamic? diagnosticProvider, dynamic? inlayHintProvider, dynamic? definitionProvider, dynamic? declarationProvider, dynamic? monikerProvider, dynamic? semanticTokensProvider, dynamic? linkedEditingRangeProvider, dynamic? callHierarchyProvider, ExecuteCommandOptions? executeCommandProvider, dynamic? textDocumentSync, dynamic? foldingRangeProvider, dynamic? renameProvider, DocumentOnTypeFormattingOptions? documentOnTypeFormattingProvider, dynamic? documentRangeFormattingProvider, LSPAny? experimental, dynamic? selectionRangeProvider, dynamic? colorProvider, DocumentLinkOptions? documentLinkProvider, CodeLensOptions? codeLensProvider, dynamic? notebookDocumentSync, dynamic? documentSymbolProvider, PositionEncodingKind? positionEncoding, dynamic? referencesProvider, dynamic? implementationProvider, dynamic? typeDefinitionProvider, dynamic? inlineValueProvider, dynamic? typeHierarchyProvider, SignatureHelpOptions? signatureHelpProvider, dynamic? hoverProvider
});


$CompletionOptionsCopyWith<$Res>? get completionProvider;$ExecuteCommandOptionsCopyWith<$Res>? get executeCommandProvider;$DocumentOnTypeFormattingOptionsCopyWith<$Res>? get documentOnTypeFormattingProvider;$DocumentLinkOptionsCopyWith<$Res>? get documentLinkProvider;$CodeLensOptionsCopyWith<$Res>? get codeLensProvider;$SignatureHelpOptionsCopyWith<$Res>? get signatureHelpProvider;

}
/// @nodoc
class _$ServerCapabilitiesCopyWithImpl<$Res>
    implements $ServerCapabilitiesCopyWith<$Res> {
  _$ServerCapabilitiesCopyWithImpl(this._self, this._then);

  final ServerCapabilities _self;
  final $Res Function(ServerCapabilities) _then;

/// Create a copy of ServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workspaceSymbolProvider = freezed,Object? documentHighlightProvider = freezed,Object? documentFormattingProvider = freezed,Object? codeActionProvider = freezed,Object? completionProvider = freezed,Object? workspace = freezed,Object? inlineCompletionProvider = freezed,Object? diagnosticProvider = freezed,Object? inlayHintProvider = freezed,Object? definitionProvider = freezed,Object? declarationProvider = freezed,Object? monikerProvider = freezed,Object? semanticTokensProvider = freezed,Object? linkedEditingRangeProvider = freezed,Object? callHierarchyProvider = freezed,Object? executeCommandProvider = freezed,Object? textDocumentSync = freezed,Object? foldingRangeProvider = freezed,Object? renameProvider = freezed,Object? documentOnTypeFormattingProvider = freezed,Object? documentRangeFormattingProvider = freezed,Object? experimental = freezed,Object? selectionRangeProvider = freezed,Object? colorProvider = freezed,Object? documentLinkProvider = freezed,Object? codeLensProvider = freezed,Object? notebookDocumentSync = freezed,Object? documentSymbolProvider = freezed,Object? positionEncoding = freezed,Object? referencesProvider = freezed,Object? implementationProvider = freezed,Object? typeDefinitionProvider = freezed,Object? inlineValueProvider = freezed,Object? typeHierarchyProvider = freezed,Object? signatureHelpProvider = freezed,Object? hoverProvider = freezed,}) {
  return _then(_self.copyWith(
workspaceSymbolProvider: freezed == workspaceSymbolProvider ? _self.workspaceSymbolProvider : workspaceSymbolProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,documentHighlightProvider: freezed == documentHighlightProvider ? _self.documentHighlightProvider : documentHighlightProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,documentFormattingProvider: freezed == documentFormattingProvider ? _self.documentFormattingProvider : documentFormattingProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,codeActionProvider: freezed == codeActionProvider ? _self.codeActionProvider : codeActionProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,completionProvider: freezed == completionProvider ? _self.completionProvider : completionProvider // ignore: cast_nullable_to_non_nullable
as CompletionOptions?,workspace: freezed == workspace ? _self.workspace : workspace // ignore: cast_nullable_to_non_nullable
as ({WorkspaceFoldersServerCapabilities? workspaceFolders, FileOperationOptions? fileOperations})?,inlineCompletionProvider: freezed == inlineCompletionProvider ? _self.inlineCompletionProvider : inlineCompletionProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,diagnosticProvider: freezed == diagnosticProvider ? _self.diagnosticProvider : diagnosticProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,inlayHintProvider: freezed == inlayHintProvider ? _self.inlayHintProvider : inlayHintProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,definitionProvider: freezed == definitionProvider ? _self.definitionProvider : definitionProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,declarationProvider: freezed == declarationProvider ? _self.declarationProvider : declarationProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,monikerProvider: freezed == monikerProvider ? _self.monikerProvider : monikerProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,semanticTokensProvider: freezed == semanticTokensProvider ? _self.semanticTokensProvider : semanticTokensProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,linkedEditingRangeProvider: freezed == linkedEditingRangeProvider ? _self.linkedEditingRangeProvider : linkedEditingRangeProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,callHierarchyProvider: freezed == callHierarchyProvider ? _self.callHierarchyProvider : callHierarchyProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,executeCommandProvider: freezed == executeCommandProvider ? _self.executeCommandProvider : executeCommandProvider // ignore: cast_nullable_to_non_nullable
as ExecuteCommandOptions?,textDocumentSync: freezed == textDocumentSync ? _self.textDocumentSync : textDocumentSync // ignore: cast_nullable_to_non_nullable
as dynamic?,foldingRangeProvider: freezed == foldingRangeProvider ? _self.foldingRangeProvider : foldingRangeProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,renameProvider: freezed == renameProvider ? _self.renameProvider : renameProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,documentOnTypeFormattingProvider: freezed == documentOnTypeFormattingProvider ? _self.documentOnTypeFormattingProvider : documentOnTypeFormattingProvider // ignore: cast_nullable_to_non_nullable
as DocumentOnTypeFormattingOptions?,documentRangeFormattingProvider: freezed == documentRangeFormattingProvider ? _self.documentRangeFormattingProvider : documentRangeFormattingProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,experimental: freezed == experimental ? _self.experimental : experimental // ignore: cast_nullable_to_non_nullable
as LSPAny?,selectionRangeProvider: freezed == selectionRangeProvider ? _self.selectionRangeProvider : selectionRangeProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,colorProvider: freezed == colorProvider ? _self.colorProvider : colorProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,documentLinkProvider: freezed == documentLinkProvider ? _self.documentLinkProvider : documentLinkProvider // ignore: cast_nullable_to_non_nullable
as DocumentLinkOptions?,codeLensProvider: freezed == codeLensProvider ? _self.codeLensProvider : codeLensProvider // ignore: cast_nullable_to_non_nullable
as CodeLensOptions?,notebookDocumentSync: freezed == notebookDocumentSync ? _self.notebookDocumentSync : notebookDocumentSync // ignore: cast_nullable_to_non_nullable
as dynamic?,documentSymbolProvider: freezed == documentSymbolProvider ? _self.documentSymbolProvider : documentSymbolProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,positionEncoding: freezed == positionEncoding ? _self.positionEncoding : positionEncoding // ignore: cast_nullable_to_non_nullable
as PositionEncodingKind?,referencesProvider: freezed == referencesProvider ? _self.referencesProvider : referencesProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,implementationProvider: freezed == implementationProvider ? _self.implementationProvider : implementationProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,typeDefinitionProvider: freezed == typeDefinitionProvider ? _self.typeDefinitionProvider : typeDefinitionProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,inlineValueProvider: freezed == inlineValueProvider ? _self.inlineValueProvider : inlineValueProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,typeHierarchyProvider: freezed == typeHierarchyProvider ? _self.typeHierarchyProvider : typeHierarchyProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,signatureHelpProvider: freezed == signatureHelpProvider ? _self.signatureHelpProvider : signatureHelpProvider // ignore: cast_nullable_to_non_nullable
as SignatureHelpOptions?,hoverProvider: freezed == hoverProvider ? _self.hoverProvider : hoverProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,
  ));
}
/// Create a copy of ServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CompletionOptionsCopyWith<$Res>? get completionProvider {
    if (_self.completionProvider == null) {
    return null;
  }

  return $CompletionOptionsCopyWith<$Res>(_self.completionProvider!, (value) {
    return _then(_self.copyWith(completionProvider: value));
  });
}/// Create a copy of ServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ExecuteCommandOptionsCopyWith<$Res>? get executeCommandProvider {
    if (_self.executeCommandProvider == null) {
    return null;
  }

  return $ExecuteCommandOptionsCopyWith<$Res>(_self.executeCommandProvider!, (value) {
    return _then(_self.copyWith(executeCommandProvider: value));
  });
}/// Create a copy of ServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DocumentOnTypeFormattingOptionsCopyWith<$Res>? get documentOnTypeFormattingProvider {
    if (_self.documentOnTypeFormattingProvider == null) {
    return null;
  }

  return $DocumentOnTypeFormattingOptionsCopyWith<$Res>(_self.documentOnTypeFormattingProvider!, (value) {
    return _then(_self.copyWith(documentOnTypeFormattingProvider: value));
  });
}/// Create a copy of ServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DocumentLinkOptionsCopyWith<$Res>? get documentLinkProvider {
    if (_self.documentLinkProvider == null) {
    return null;
  }

  return $DocumentLinkOptionsCopyWith<$Res>(_self.documentLinkProvider!, (value) {
    return _then(_self.copyWith(documentLinkProvider: value));
  });
}/// Create a copy of ServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CodeLensOptionsCopyWith<$Res>? get codeLensProvider {
    if (_self.codeLensProvider == null) {
    return null;
  }

  return $CodeLensOptionsCopyWith<$Res>(_self.codeLensProvider!, (value) {
    return _then(_self.copyWith(codeLensProvider: value));
  });
}/// Create a copy of ServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SignatureHelpOptionsCopyWith<$Res>? get signatureHelpProvider {
    if (_self.signatureHelpProvider == null) {
    return null;
  }

  return $SignatureHelpOptionsCopyWith<$Res>(_self.signatureHelpProvider!, (value) {
    return _then(_self.copyWith(signatureHelpProvider: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _ServerCapabilities implements ServerCapabilities {
  const _ServerCapabilities({this.workspaceSymbolProvider, this.documentHighlightProvider, this.documentFormattingProvider, this.codeActionProvider, this.completionProvider, this.workspace, this.inlineCompletionProvider, this.diagnosticProvider, this.inlayHintProvider, this.definitionProvider, this.declarationProvider, this.monikerProvider, this.semanticTokensProvider, this.linkedEditingRangeProvider, this.callHierarchyProvider, this.executeCommandProvider, this.textDocumentSync, this.foldingRangeProvider, this.renameProvider, this.documentOnTypeFormattingProvider, this.documentRangeFormattingProvider, this.experimental, this.selectionRangeProvider, this.colorProvider, this.documentLinkProvider, this.codeLensProvider, this.notebookDocumentSync, this.documentSymbolProvider, this.positionEncoding, this.referencesProvider, this.implementationProvider, this.typeDefinitionProvider, this.inlineValueProvider, this.typeHierarchyProvider, this.signatureHelpProvider, this.hoverProvider});
  factory _ServerCapabilities.fromJson(Map<String, dynamic> json) => _$ServerCapabilitiesFromJson(json);

@override final  dynamic? workspaceSymbolProvider;
@override final  dynamic? documentHighlightProvider;
@override final  dynamic? documentFormattingProvider;
@override final  dynamic? codeActionProvider;
@override final  CompletionOptions? completionProvider;
@override final  ({WorkspaceFoldersServerCapabilities? workspaceFolders, FileOperationOptions? fileOperations})? workspace;
@override final  dynamic? inlineCompletionProvider;
@override final  dynamic? diagnosticProvider;
@override final  dynamic? inlayHintProvider;
@override final  dynamic? definitionProvider;
@override final  dynamic? declarationProvider;
@override final  dynamic? monikerProvider;
@override final  dynamic? semanticTokensProvider;
@override final  dynamic? linkedEditingRangeProvider;
@override final  dynamic? callHierarchyProvider;
@override final  ExecuteCommandOptions? executeCommandProvider;
@override final  dynamic? textDocumentSync;
@override final  dynamic? foldingRangeProvider;
@override final  dynamic? renameProvider;
@override final  DocumentOnTypeFormattingOptions? documentOnTypeFormattingProvider;
@override final  dynamic? documentRangeFormattingProvider;
@override final  LSPAny? experimental;
@override final  dynamic? selectionRangeProvider;
@override final  dynamic? colorProvider;
@override final  DocumentLinkOptions? documentLinkProvider;
@override final  CodeLensOptions? codeLensProvider;
@override final  dynamic? notebookDocumentSync;
@override final  dynamic? documentSymbolProvider;
@override final  PositionEncodingKind? positionEncoding;
@override final  dynamic? referencesProvider;
@override final  dynamic? implementationProvider;
@override final  dynamic? typeDefinitionProvider;
@override final  dynamic? inlineValueProvider;
@override final  dynamic? typeHierarchyProvider;
@override final  SignatureHelpOptions? signatureHelpProvider;
@override final  dynamic? hoverProvider;

/// Create a copy of ServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ServerCapabilitiesCopyWith<_ServerCapabilities> get copyWith => __$ServerCapabilitiesCopyWithImpl<_ServerCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ServerCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ServerCapabilities&&const DeepCollectionEquality().equals(other.workspaceSymbolProvider, workspaceSymbolProvider)&&const DeepCollectionEquality().equals(other.documentHighlightProvider, documentHighlightProvider)&&const DeepCollectionEquality().equals(other.documentFormattingProvider, documentFormattingProvider)&&const DeepCollectionEquality().equals(other.codeActionProvider, codeActionProvider)&&(identical(other.completionProvider, completionProvider) || other.completionProvider == completionProvider)&&(identical(other.workspace, workspace) || other.workspace == workspace)&&const DeepCollectionEquality().equals(other.inlineCompletionProvider, inlineCompletionProvider)&&const DeepCollectionEquality().equals(other.diagnosticProvider, diagnosticProvider)&&const DeepCollectionEquality().equals(other.inlayHintProvider, inlayHintProvider)&&const DeepCollectionEquality().equals(other.definitionProvider, definitionProvider)&&const DeepCollectionEquality().equals(other.declarationProvider, declarationProvider)&&const DeepCollectionEquality().equals(other.monikerProvider, monikerProvider)&&const DeepCollectionEquality().equals(other.semanticTokensProvider, semanticTokensProvider)&&const DeepCollectionEquality().equals(other.linkedEditingRangeProvider, linkedEditingRangeProvider)&&const DeepCollectionEquality().equals(other.callHierarchyProvider, callHierarchyProvider)&&(identical(other.executeCommandProvider, executeCommandProvider) || other.executeCommandProvider == executeCommandProvider)&&const DeepCollectionEquality().equals(other.textDocumentSync, textDocumentSync)&&const DeepCollectionEquality().equals(other.foldingRangeProvider, foldingRangeProvider)&&const DeepCollectionEquality().equals(other.renameProvider, renameProvider)&&(identical(other.documentOnTypeFormattingProvider, documentOnTypeFormattingProvider) || other.documentOnTypeFormattingProvider == documentOnTypeFormattingProvider)&&const DeepCollectionEquality().equals(other.documentRangeFormattingProvider, documentRangeFormattingProvider)&&const DeepCollectionEquality().equals(other.experimental, experimental)&&const DeepCollectionEquality().equals(other.selectionRangeProvider, selectionRangeProvider)&&const DeepCollectionEquality().equals(other.colorProvider, colorProvider)&&(identical(other.documentLinkProvider, documentLinkProvider) || other.documentLinkProvider == documentLinkProvider)&&(identical(other.codeLensProvider, codeLensProvider) || other.codeLensProvider == codeLensProvider)&&const DeepCollectionEquality().equals(other.notebookDocumentSync, notebookDocumentSync)&&const DeepCollectionEquality().equals(other.documentSymbolProvider, documentSymbolProvider)&&(identical(other.positionEncoding, positionEncoding) || other.positionEncoding == positionEncoding)&&const DeepCollectionEquality().equals(other.referencesProvider, referencesProvider)&&const DeepCollectionEquality().equals(other.implementationProvider, implementationProvider)&&const DeepCollectionEquality().equals(other.typeDefinitionProvider, typeDefinitionProvider)&&const DeepCollectionEquality().equals(other.inlineValueProvider, inlineValueProvider)&&const DeepCollectionEquality().equals(other.typeHierarchyProvider, typeHierarchyProvider)&&(identical(other.signatureHelpProvider, signatureHelpProvider) || other.signatureHelpProvider == signatureHelpProvider)&&const DeepCollectionEquality().equals(other.hoverProvider, hoverProvider));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hashAll([runtimeType,const DeepCollectionEquality().hash(workspaceSymbolProvider),const DeepCollectionEquality().hash(documentHighlightProvider),const DeepCollectionEquality().hash(documentFormattingProvider),const DeepCollectionEquality().hash(codeActionProvider),completionProvider,workspace,const DeepCollectionEquality().hash(inlineCompletionProvider),const DeepCollectionEquality().hash(diagnosticProvider),const DeepCollectionEquality().hash(inlayHintProvider),const DeepCollectionEquality().hash(definitionProvider),const DeepCollectionEquality().hash(declarationProvider),const DeepCollectionEquality().hash(monikerProvider),const DeepCollectionEquality().hash(semanticTokensProvider),const DeepCollectionEquality().hash(linkedEditingRangeProvider),const DeepCollectionEquality().hash(callHierarchyProvider),executeCommandProvider,const DeepCollectionEquality().hash(textDocumentSync),const DeepCollectionEquality().hash(foldingRangeProvider),const DeepCollectionEquality().hash(renameProvider),documentOnTypeFormattingProvider,const DeepCollectionEquality().hash(documentRangeFormattingProvider),const DeepCollectionEquality().hash(experimental),const DeepCollectionEquality().hash(selectionRangeProvider),const DeepCollectionEquality().hash(colorProvider),documentLinkProvider,codeLensProvider,const DeepCollectionEquality().hash(notebookDocumentSync),const DeepCollectionEquality().hash(documentSymbolProvider),positionEncoding,const DeepCollectionEquality().hash(referencesProvider),const DeepCollectionEquality().hash(implementationProvider),const DeepCollectionEquality().hash(typeDefinitionProvider),const DeepCollectionEquality().hash(inlineValueProvider),const DeepCollectionEquality().hash(typeHierarchyProvider),signatureHelpProvider,const DeepCollectionEquality().hash(hoverProvider)]);

@override
String toString() {
  return 'ServerCapabilities(workspaceSymbolProvider: $workspaceSymbolProvider, documentHighlightProvider: $documentHighlightProvider, documentFormattingProvider: $documentFormattingProvider, codeActionProvider: $codeActionProvider, completionProvider: $completionProvider, workspace: $workspace, inlineCompletionProvider: $inlineCompletionProvider, diagnosticProvider: $diagnosticProvider, inlayHintProvider: $inlayHintProvider, definitionProvider: $definitionProvider, declarationProvider: $declarationProvider, monikerProvider: $monikerProvider, semanticTokensProvider: $semanticTokensProvider, linkedEditingRangeProvider: $linkedEditingRangeProvider, callHierarchyProvider: $callHierarchyProvider, executeCommandProvider: $executeCommandProvider, textDocumentSync: $textDocumentSync, foldingRangeProvider: $foldingRangeProvider, renameProvider: $renameProvider, documentOnTypeFormattingProvider: $documentOnTypeFormattingProvider, documentRangeFormattingProvider: $documentRangeFormattingProvider, experimental: $experimental, selectionRangeProvider: $selectionRangeProvider, colorProvider: $colorProvider, documentLinkProvider: $documentLinkProvider, codeLensProvider: $codeLensProvider, notebookDocumentSync: $notebookDocumentSync, documentSymbolProvider: $documentSymbolProvider, positionEncoding: $positionEncoding, referencesProvider: $referencesProvider, implementationProvider: $implementationProvider, typeDefinitionProvider: $typeDefinitionProvider, inlineValueProvider: $inlineValueProvider, typeHierarchyProvider: $typeHierarchyProvider, signatureHelpProvider: $signatureHelpProvider, hoverProvider: $hoverProvider)';
}


}

/// @nodoc
abstract mixin class _$ServerCapabilitiesCopyWith<$Res> implements $ServerCapabilitiesCopyWith<$Res> {
  factory _$ServerCapabilitiesCopyWith(_ServerCapabilities value, $Res Function(_ServerCapabilities) _then) = __$ServerCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 dynamic? workspaceSymbolProvider, dynamic? documentHighlightProvider, dynamic? documentFormattingProvider, dynamic? codeActionProvider, CompletionOptions? completionProvider, ({WorkspaceFoldersServerCapabilities? workspaceFolders, FileOperationOptions? fileOperations})? workspace, dynamic? inlineCompletionProvider, dynamic? diagnosticProvider, dynamic? inlayHintProvider, dynamic? definitionProvider, dynamic? declarationProvider, dynamic? monikerProvider, dynamic? semanticTokensProvider, dynamic? linkedEditingRangeProvider, dynamic? callHierarchyProvider, ExecuteCommandOptions? executeCommandProvider, dynamic? textDocumentSync, dynamic? foldingRangeProvider, dynamic? renameProvider, DocumentOnTypeFormattingOptions? documentOnTypeFormattingProvider, dynamic? documentRangeFormattingProvider, LSPAny? experimental, dynamic? selectionRangeProvider, dynamic? colorProvider, DocumentLinkOptions? documentLinkProvider, CodeLensOptions? codeLensProvider, dynamic? notebookDocumentSync, dynamic? documentSymbolProvider, PositionEncodingKind? positionEncoding, dynamic? referencesProvider, dynamic? implementationProvider, dynamic? typeDefinitionProvider, dynamic? inlineValueProvider, dynamic? typeHierarchyProvider, SignatureHelpOptions? signatureHelpProvider, dynamic? hoverProvider
});


@override $CompletionOptionsCopyWith<$Res>? get completionProvider;@override $ExecuteCommandOptionsCopyWith<$Res>? get executeCommandProvider;@override $DocumentOnTypeFormattingOptionsCopyWith<$Res>? get documentOnTypeFormattingProvider;@override $DocumentLinkOptionsCopyWith<$Res>? get documentLinkProvider;@override $CodeLensOptionsCopyWith<$Res>? get codeLensProvider;@override $SignatureHelpOptionsCopyWith<$Res>? get signatureHelpProvider;

}
/// @nodoc
class __$ServerCapabilitiesCopyWithImpl<$Res>
    implements _$ServerCapabilitiesCopyWith<$Res> {
  __$ServerCapabilitiesCopyWithImpl(this._self, this._then);

  final _ServerCapabilities _self;
  final $Res Function(_ServerCapabilities) _then;

/// Create a copy of ServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workspaceSymbolProvider = freezed,Object? documentHighlightProvider = freezed,Object? documentFormattingProvider = freezed,Object? codeActionProvider = freezed,Object? completionProvider = freezed,Object? workspace = freezed,Object? inlineCompletionProvider = freezed,Object? diagnosticProvider = freezed,Object? inlayHintProvider = freezed,Object? definitionProvider = freezed,Object? declarationProvider = freezed,Object? monikerProvider = freezed,Object? semanticTokensProvider = freezed,Object? linkedEditingRangeProvider = freezed,Object? callHierarchyProvider = freezed,Object? executeCommandProvider = freezed,Object? textDocumentSync = freezed,Object? foldingRangeProvider = freezed,Object? renameProvider = freezed,Object? documentOnTypeFormattingProvider = freezed,Object? documentRangeFormattingProvider = freezed,Object? experimental = freezed,Object? selectionRangeProvider = freezed,Object? colorProvider = freezed,Object? documentLinkProvider = freezed,Object? codeLensProvider = freezed,Object? notebookDocumentSync = freezed,Object? documentSymbolProvider = freezed,Object? positionEncoding = freezed,Object? referencesProvider = freezed,Object? implementationProvider = freezed,Object? typeDefinitionProvider = freezed,Object? inlineValueProvider = freezed,Object? typeHierarchyProvider = freezed,Object? signatureHelpProvider = freezed,Object? hoverProvider = freezed,}) {
  return _then(_ServerCapabilities(
workspaceSymbolProvider: freezed == workspaceSymbolProvider ? _self.workspaceSymbolProvider : workspaceSymbolProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,documentHighlightProvider: freezed == documentHighlightProvider ? _self.documentHighlightProvider : documentHighlightProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,documentFormattingProvider: freezed == documentFormattingProvider ? _self.documentFormattingProvider : documentFormattingProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,codeActionProvider: freezed == codeActionProvider ? _self.codeActionProvider : codeActionProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,completionProvider: freezed == completionProvider ? _self.completionProvider : completionProvider // ignore: cast_nullable_to_non_nullable
as CompletionOptions?,workspace: freezed == workspace ? _self.workspace : workspace // ignore: cast_nullable_to_non_nullable
as ({WorkspaceFoldersServerCapabilities? workspaceFolders, FileOperationOptions? fileOperations})?,inlineCompletionProvider: freezed == inlineCompletionProvider ? _self.inlineCompletionProvider : inlineCompletionProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,diagnosticProvider: freezed == diagnosticProvider ? _self.diagnosticProvider : diagnosticProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,inlayHintProvider: freezed == inlayHintProvider ? _self.inlayHintProvider : inlayHintProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,definitionProvider: freezed == definitionProvider ? _self.definitionProvider : definitionProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,declarationProvider: freezed == declarationProvider ? _self.declarationProvider : declarationProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,monikerProvider: freezed == monikerProvider ? _self.monikerProvider : monikerProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,semanticTokensProvider: freezed == semanticTokensProvider ? _self.semanticTokensProvider : semanticTokensProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,linkedEditingRangeProvider: freezed == linkedEditingRangeProvider ? _self.linkedEditingRangeProvider : linkedEditingRangeProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,callHierarchyProvider: freezed == callHierarchyProvider ? _self.callHierarchyProvider : callHierarchyProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,executeCommandProvider: freezed == executeCommandProvider ? _self.executeCommandProvider : executeCommandProvider // ignore: cast_nullable_to_non_nullable
as ExecuteCommandOptions?,textDocumentSync: freezed == textDocumentSync ? _self.textDocumentSync : textDocumentSync // ignore: cast_nullable_to_non_nullable
as dynamic?,foldingRangeProvider: freezed == foldingRangeProvider ? _self.foldingRangeProvider : foldingRangeProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,renameProvider: freezed == renameProvider ? _self.renameProvider : renameProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,documentOnTypeFormattingProvider: freezed == documentOnTypeFormattingProvider ? _self.documentOnTypeFormattingProvider : documentOnTypeFormattingProvider // ignore: cast_nullable_to_non_nullable
as DocumentOnTypeFormattingOptions?,documentRangeFormattingProvider: freezed == documentRangeFormattingProvider ? _self.documentRangeFormattingProvider : documentRangeFormattingProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,experimental: freezed == experimental ? _self.experimental : experimental // ignore: cast_nullable_to_non_nullable
as LSPAny?,selectionRangeProvider: freezed == selectionRangeProvider ? _self.selectionRangeProvider : selectionRangeProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,colorProvider: freezed == colorProvider ? _self.colorProvider : colorProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,documentLinkProvider: freezed == documentLinkProvider ? _self.documentLinkProvider : documentLinkProvider // ignore: cast_nullable_to_non_nullable
as DocumentLinkOptions?,codeLensProvider: freezed == codeLensProvider ? _self.codeLensProvider : codeLensProvider // ignore: cast_nullable_to_non_nullable
as CodeLensOptions?,notebookDocumentSync: freezed == notebookDocumentSync ? _self.notebookDocumentSync : notebookDocumentSync // ignore: cast_nullable_to_non_nullable
as dynamic?,documentSymbolProvider: freezed == documentSymbolProvider ? _self.documentSymbolProvider : documentSymbolProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,positionEncoding: freezed == positionEncoding ? _self.positionEncoding : positionEncoding // ignore: cast_nullable_to_non_nullable
as PositionEncodingKind?,referencesProvider: freezed == referencesProvider ? _self.referencesProvider : referencesProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,implementationProvider: freezed == implementationProvider ? _self.implementationProvider : implementationProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,typeDefinitionProvider: freezed == typeDefinitionProvider ? _self.typeDefinitionProvider : typeDefinitionProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,inlineValueProvider: freezed == inlineValueProvider ? _self.inlineValueProvider : inlineValueProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,typeHierarchyProvider: freezed == typeHierarchyProvider ? _self.typeHierarchyProvider : typeHierarchyProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,signatureHelpProvider: freezed == signatureHelpProvider ? _self.signatureHelpProvider : signatureHelpProvider // ignore: cast_nullable_to_non_nullable
as SignatureHelpOptions?,hoverProvider: freezed == hoverProvider ? _self.hoverProvider : hoverProvider // ignore: cast_nullable_to_non_nullable
as dynamic?,
  ));
}

/// Create a copy of ServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CompletionOptionsCopyWith<$Res>? get completionProvider {
    if (_self.completionProvider == null) {
    return null;
  }

  return $CompletionOptionsCopyWith<$Res>(_self.completionProvider!, (value) {
    return _then(_self.copyWith(completionProvider: value));
  });
}/// Create a copy of ServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ExecuteCommandOptionsCopyWith<$Res>? get executeCommandProvider {
    if (_self.executeCommandProvider == null) {
    return null;
  }

  return $ExecuteCommandOptionsCopyWith<$Res>(_self.executeCommandProvider!, (value) {
    return _then(_self.copyWith(executeCommandProvider: value));
  });
}/// Create a copy of ServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DocumentOnTypeFormattingOptionsCopyWith<$Res>? get documentOnTypeFormattingProvider {
    if (_self.documentOnTypeFormattingProvider == null) {
    return null;
  }

  return $DocumentOnTypeFormattingOptionsCopyWith<$Res>(_self.documentOnTypeFormattingProvider!, (value) {
    return _then(_self.copyWith(documentOnTypeFormattingProvider: value));
  });
}/// Create a copy of ServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DocumentLinkOptionsCopyWith<$Res>? get documentLinkProvider {
    if (_self.documentLinkProvider == null) {
    return null;
  }

  return $DocumentLinkOptionsCopyWith<$Res>(_self.documentLinkProvider!, (value) {
    return _then(_self.copyWith(documentLinkProvider: value));
  });
}/// Create a copy of ServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CodeLensOptionsCopyWith<$Res>? get codeLensProvider {
    if (_self.codeLensProvider == null) {
    return null;
  }

  return $CodeLensOptionsCopyWith<$Res>(_self.codeLensProvider!, (value) {
    return _then(_self.copyWith(codeLensProvider: value));
  });
}/// Create a copy of ServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SignatureHelpOptionsCopyWith<$Res>? get signatureHelpProvider {
    if (_self.signatureHelpProvider == null) {
    return null;
  }

  return $SignatureHelpOptionsCopyWith<$Res>(_self.signatureHelpProvider!, (value) {
    return _then(_self.copyWith(signatureHelpProvider: value));
  });
}
}


/// @nodoc
mixin _$VersionedTextDocumentIdentifier {

 String get uri; int get version;
/// Create a copy of VersionedTextDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$VersionedTextDocumentIdentifierCopyWith<VersionedTextDocumentIdentifier> get copyWith => _$VersionedTextDocumentIdentifierCopyWithImpl<VersionedTextDocumentIdentifier>(this as VersionedTextDocumentIdentifier, _$identity);

  /// Serializes this VersionedTextDocumentIdentifier to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is VersionedTextDocumentIdentifier&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.version, version) || other.version == version));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri,version);

@override
String toString() {
  return 'VersionedTextDocumentIdentifier(uri: $uri, version: $version)';
}


}

/// @nodoc
abstract mixin class $VersionedTextDocumentIdentifierCopyWith<$Res>  {
  factory $VersionedTextDocumentIdentifierCopyWith(VersionedTextDocumentIdentifier value, $Res Function(VersionedTextDocumentIdentifier) _then) = _$VersionedTextDocumentIdentifierCopyWithImpl;
@useResult
$Res call({
 String uri, int version
});




}
/// @nodoc
class _$VersionedTextDocumentIdentifierCopyWithImpl<$Res>
    implements $VersionedTextDocumentIdentifierCopyWith<$Res> {
  _$VersionedTextDocumentIdentifierCopyWithImpl(this._self, this._then);

  final VersionedTextDocumentIdentifier _self;
  final $Res Function(VersionedTextDocumentIdentifier) _then;

/// Create a copy of VersionedTextDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? uri = null,Object? version = null,}) {
  return _then(_self.copyWith(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,version: null == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as int,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _VersionedTextDocumentIdentifier implements VersionedTextDocumentIdentifier {
  const _VersionedTextDocumentIdentifier({required this.uri, required this.version});
  factory _VersionedTextDocumentIdentifier.fromJson(Map<String, dynamic> json) => _$VersionedTextDocumentIdentifierFromJson(json);

@override final  String uri;
@override final  int version;

/// Create a copy of VersionedTextDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$VersionedTextDocumentIdentifierCopyWith<_VersionedTextDocumentIdentifier> get copyWith => __$VersionedTextDocumentIdentifierCopyWithImpl<_VersionedTextDocumentIdentifier>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$VersionedTextDocumentIdentifierToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _VersionedTextDocumentIdentifier&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.version, version) || other.version == version));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri,version);

@override
String toString() {
  return 'VersionedTextDocumentIdentifier(uri: $uri, version: $version)';
}


}

/// @nodoc
abstract mixin class _$VersionedTextDocumentIdentifierCopyWith<$Res> implements $VersionedTextDocumentIdentifierCopyWith<$Res> {
  factory _$VersionedTextDocumentIdentifierCopyWith(_VersionedTextDocumentIdentifier value, $Res Function(_VersionedTextDocumentIdentifier) _then) = __$VersionedTextDocumentIdentifierCopyWithImpl;
@override @useResult
$Res call({
 String uri, int version
});




}
/// @nodoc
class __$VersionedTextDocumentIdentifierCopyWithImpl<$Res>
    implements _$VersionedTextDocumentIdentifierCopyWith<$Res> {
  __$VersionedTextDocumentIdentifierCopyWithImpl(this._self, this._then);

  final _VersionedTextDocumentIdentifier _self;
  final $Res Function(_VersionedTextDocumentIdentifier) _then;

/// Create a copy of VersionedTextDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? uri = null,Object? version = null,}) {
  return _then(_VersionedTextDocumentIdentifier(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,version: null == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as int,
  ));
}


}


/// @nodoc
mixin _$SaveOptions {

 bool? get includeText;
/// Create a copy of SaveOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SaveOptionsCopyWith<SaveOptions> get copyWith => _$SaveOptionsCopyWithImpl<SaveOptions>(this as SaveOptions, _$identity);

  /// Serializes this SaveOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SaveOptions&&(identical(other.includeText, includeText) || other.includeText == includeText));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,includeText);

@override
String toString() {
  return 'SaveOptions(includeText: $includeText)';
}


}

/// @nodoc
abstract mixin class $SaveOptionsCopyWith<$Res>  {
  factory $SaveOptionsCopyWith(SaveOptions value, $Res Function(SaveOptions) _then) = _$SaveOptionsCopyWithImpl;
@useResult
$Res call({
 bool? includeText
});




}
/// @nodoc
class _$SaveOptionsCopyWithImpl<$Res>
    implements $SaveOptionsCopyWith<$Res> {
  _$SaveOptionsCopyWithImpl(this._self, this._then);

  final SaveOptions _self;
  final $Res Function(SaveOptions) _then;

/// Create a copy of SaveOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? includeText = freezed,}) {
  return _then(_self.copyWith(
includeText: freezed == includeText ? _self.includeText : includeText // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _SaveOptions implements SaveOptions {
  const _SaveOptions({this.includeText});
  factory _SaveOptions.fromJson(Map<String, dynamic> json) => _$SaveOptionsFromJson(json);

@override final  bool? includeText;

/// Create a copy of SaveOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SaveOptionsCopyWith<_SaveOptions> get copyWith => __$SaveOptionsCopyWithImpl<_SaveOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SaveOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SaveOptions&&(identical(other.includeText, includeText) || other.includeText == includeText));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,includeText);

@override
String toString() {
  return 'SaveOptions(includeText: $includeText)';
}


}

/// @nodoc
abstract mixin class _$SaveOptionsCopyWith<$Res> implements $SaveOptionsCopyWith<$Res> {
  factory _$SaveOptionsCopyWith(_SaveOptions value, $Res Function(_SaveOptions) _then) = __$SaveOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? includeText
});




}
/// @nodoc
class __$SaveOptionsCopyWithImpl<$Res>
    implements _$SaveOptionsCopyWith<$Res> {
  __$SaveOptionsCopyWithImpl(this._self, this._then);

  final _SaveOptions _self;
  final $Res Function(_SaveOptions) _then;

/// Create a copy of SaveOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? includeText = freezed,}) {
  return _then(_SaveOptions(
includeText: freezed == includeText ? _self.includeText : includeText // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$FileEvent {

 String get uri; FileChangeType get type;
/// Create a copy of FileEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FileEventCopyWith<FileEvent> get copyWith => _$FileEventCopyWithImpl<FileEvent>(this as FileEvent, _$identity);

  /// Serializes this FileEvent to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FileEvent&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.type, type) || other.type == type));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri,type);

@override
String toString() {
  return 'FileEvent(uri: $uri, type: $type)';
}


}

/// @nodoc
abstract mixin class $FileEventCopyWith<$Res>  {
  factory $FileEventCopyWith(FileEvent value, $Res Function(FileEvent) _then) = _$FileEventCopyWithImpl;
@useResult
$Res call({
 String uri, FileChangeType type
});




}
/// @nodoc
class _$FileEventCopyWithImpl<$Res>
    implements $FileEventCopyWith<$Res> {
  _$FileEventCopyWithImpl(this._self, this._then);

  final FileEvent _self;
  final $Res Function(FileEvent) _then;

/// Create a copy of FileEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? uri = null,Object? type = null,}) {
  return _then(_self.copyWith(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,type: null == type ? _self.type : type // ignore: cast_nullable_to_non_nullable
as FileChangeType,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _FileEvent implements FileEvent {
  const _FileEvent({required this.uri, required this.type});
  factory _FileEvent.fromJson(Map<String, dynamic> json) => _$FileEventFromJson(json);

@override final  String uri;
@override final  FileChangeType type;

/// Create a copy of FileEvent
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$FileEventCopyWith<_FileEvent> get copyWith => __$FileEventCopyWithImpl<_FileEvent>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$FileEventToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _FileEvent&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.type, type) || other.type == type));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri,type);

@override
String toString() {
  return 'FileEvent(uri: $uri, type: $type)';
}


}

/// @nodoc
abstract mixin class _$FileEventCopyWith<$Res> implements $FileEventCopyWith<$Res> {
  factory _$FileEventCopyWith(_FileEvent value, $Res Function(_FileEvent) _then) = __$FileEventCopyWithImpl;
@override @useResult
$Res call({
 String uri, FileChangeType type
});




}
/// @nodoc
class __$FileEventCopyWithImpl<$Res>
    implements _$FileEventCopyWith<$Res> {
  __$FileEventCopyWithImpl(this._self, this._then);

  final _FileEvent _self;
  final $Res Function(_FileEvent) _then;

/// Create a copy of FileEvent
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? uri = null,Object? type = null,}) {
  return _then(_FileEvent(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,type: null == type ? _self.type : type // ignore: cast_nullable_to_non_nullable
as FileChangeType,
  ));
}


}


/// @nodoc
mixin _$FileSystemWatcher {

 GlobPattern get globPattern; WatchKind? get kind;
/// Create a copy of FileSystemWatcher
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FileSystemWatcherCopyWith<FileSystemWatcher> get copyWith => _$FileSystemWatcherCopyWithImpl<FileSystemWatcher>(this as FileSystemWatcher, _$identity);

  /// Serializes this FileSystemWatcher to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FileSystemWatcher&&const DeepCollectionEquality().equals(other.globPattern, globPattern)&&(identical(other.kind, kind) || other.kind == kind));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(globPattern),kind);

@override
String toString() {
  return 'FileSystemWatcher(globPattern: $globPattern, kind: $kind)';
}


}

/// @nodoc
abstract mixin class $FileSystemWatcherCopyWith<$Res>  {
  factory $FileSystemWatcherCopyWith(FileSystemWatcher value, $Res Function(FileSystemWatcher) _then) = _$FileSystemWatcherCopyWithImpl;
@useResult
$Res call({
 GlobPattern globPattern, WatchKind? kind
});




}
/// @nodoc
class _$FileSystemWatcherCopyWithImpl<$Res>
    implements $FileSystemWatcherCopyWith<$Res> {
  _$FileSystemWatcherCopyWithImpl(this._self, this._then);

  final FileSystemWatcher _self;
  final $Res Function(FileSystemWatcher) _then;

/// Create a copy of FileSystemWatcher
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? globPattern = freezed,Object? kind = freezed,}) {
  return _then(_self.copyWith(
globPattern: freezed == globPattern ? _self.globPattern : globPattern // ignore: cast_nullable_to_non_nullable
as GlobPattern,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as WatchKind?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _FileSystemWatcher implements FileSystemWatcher {
  const _FileSystemWatcher({required this.globPattern, this.kind});
  factory _FileSystemWatcher.fromJson(Map<String, dynamic> json) => _$FileSystemWatcherFromJson(json);

@override final  GlobPattern globPattern;
@override final  WatchKind? kind;

/// Create a copy of FileSystemWatcher
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$FileSystemWatcherCopyWith<_FileSystemWatcher> get copyWith => __$FileSystemWatcherCopyWithImpl<_FileSystemWatcher>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$FileSystemWatcherToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _FileSystemWatcher&&const DeepCollectionEquality().equals(other.globPattern, globPattern)&&(identical(other.kind, kind) || other.kind == kind));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(globPattern),kind);

@override
String toString() {
  return 'FileSystemWatcher(globPattern: $globPattern, kind: $kind)';
}


}

/// @nodoc
abstract mixin class _$FileSystemWatcherCopyWith<$Res> implements $FileSystemWatcherCopyWith<$Res> {
  factory _$FileSystemWatcherCopyWith(_FileSystemWatcher value, $Res Function(_FileSystemWatcher) _then) = __$FileSystemWatcherCopyWithImpl;
@override @useResult
$Res call({
 GlobPattern globPattern, WatchKind? kind
});




}
/// @nodoc
class __$FileSystemWatcherCopyWithImpl<$Res>
    implements _$FileSystemWatcherCopyWith<$Res> {
  __$FileSystemWatcherCopyWithImpl(this._self, this._then);

  final _FileSystemWatcher _self;
  final $Res Function(_FileSystemWatcher) _then;

/// Create a copy of FileSystemWatcher
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? globPattern = freezed,Object? kind = freezed,}) {
  return _then(_FileSystemWatcher(
globPattern: freezed == globPattern ? _self.globPattern : globPattern // ignore: cast_nullable_to_non_nullable
as GlobPattern,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as WatchKind?,
  ));
}


}


/// @nodoc
mixin _$Diagnostic {

 Range get range; String get message; LSPAny? get data; List<DiagnosticRelatedInformation>? get relatedInformation; List<DiagnosticTag>? get tags; String? get source; CodeDescription? get codeDescription; dynamic? get code; DiagnosticSeverity? get severity;
/// Create a copy of Diagnostic
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DiagnosticCopyWith<Diagnostic> get copyWith => _$DiagnosticCopyWithImpl<Diagnostic>(this as Diagnostic, _$identity);

  /// Serializes this Diagnostic to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Diagnostic&&(identical(other.range, range) || other.range == range)&&(identical(other.message, message) || other.message == message)&&const DeepCollectionEquality().equals(other.data, data)&&const DeepCollectionEquality().equals(other.relatedInformation, relatedInformation)&&const DeepCollectionEquality().equals(other.tags, tags)&&(identical(other.source, source) || other.source == source)&&(identical(other.codeDescription, codeDescription) || other.codeDescription == codeDescription)&&const DeepCollectionEquality().equals(other.code, code)&&(identical(other.severity, severity) || other.severity == severity));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,range,message,const DeepCollectionEquality().hash(data),const DeepCollectionEquality().hash(relatedInformation),const DeepCollectionEquality().hash(tags),source,codeDescription,const DeepCollectionEquality().hash(code),severity);

@override
String toString() {
  return 'Diagnostic(range: $range, message: $message, data: $data, relatedInformation: $relatedInformation, tags: $tags, source: $source, codeDescription: $codeDescription, code: $code, severity: $severity)';
}


}

/// @nodoc
abstract mixin class $DiagnosticCopyWith<$Res>  {
  factory $DiagnosticCopyWith(Diagnostic value, $Res Function(Diagnostic) _then) = _$DiagnosticCopyWithImpl;
@useResult
$Res call({
 Range range, String message, LSPAny? data, List<DiagnosticRelatedInformation>? relatedInformation, List<DiagnosticTag>? tags, String? source, CodeDescription? codeDescription, dynamic? code, DiagnosticSeverity? severity
});


$RangeCopyWith<$Res> get range;$CodeDescriptionCopyWith<$Res>? get codeDescription;

}
/// @nodoc
class _$DiagnosticCopyWithImpl<$Res>
    implements $DiagnosticCopyWith<$Res> {
  _$DiagnosticCopyWithImpl(this._self, this._then);

  final Diagnostic _self;
  final $Res Function(Diagnostic) _then;

/// Create a copy of Diagnostic
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? range = null,Object? message = null,Object? data = freezed,Object? relatedInformation = freezed,Object? tags = freezed,Object? source = freezed,Object? codeDescription = freezed,Object? code = freezed,Object? severity = freezed,}) {
  return _then(_self.copyWith(
range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LSPAny?,relatedInformation: freezed == relatedInformation ? _self.relatedInformation : relatedInformation // ignore: cast_nullable_to_non_nullable
as List<DiagnosticRelatedInformation>?,tags: freezed == tags ? _self.tags : tags // ignore: cast_nullable_to_non_nullable
as List<DiagnosticTag>?,source: freezed == source ? _self.source : source // ignore: cast_nullable_to_non_nullable
as String?,codeDescription: freezed == codeDescription ? _self.codeDescription : codeDescription // ignore: cast_nullable_to_non_nullable
as CodeDescription?,code: freezed == code ? _self.code : code // ignore: cast_nullable_to_non_nullable
as dynamic?,severity: freezed == severity ? _self.severity : severity // ignore: cast_nullable_to_non_nullable
as DiagnosticSeverity?,
  ));
}
/// Create a copy of Diagnostic
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}/// Create a copy of Diagnostic
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CodeDescriptionCopyWith<$Res>? get codeDescription {
    if (_self.codeDescription == null) {
    return null;
  }

  return $CodeDescriptionCopyWith<$Res>(_self.codeDescription!, (value) {
    return _then(_self.copyWith(codeDescription: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _Diagnostic implements Diagnostic {
  const _Diagnostic({required this.range, required this.message, this.data, final  List<DiagnosticRelatedInformation>? relatedInformation, final  List<DiagnosticTag>? tags, this.source, this.codeDescription, this.code, this.severity}): _relatedInformation = relatedInformation,_tags = tags;
  factory _Diagnostic.fromJson(Map<String, dynamic> json) => _$DiagnosticFromJson(json);

@override final  Range range;
@override final  String message;
@override final  LSPAny? data;
 final  List<DiagnosticRelatedInformation>? _relatedInformation;
@override List<DiagnosticRelatedInformation>? get relatedInformation {
  final value = _relatedInformation;
  if (value == null) return null;
  if (_relatedInformation is EqualUnmodifiableListView) return _relatedInformation;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

 final  List<DiagnosticTag>? _tags;
@override List<DiagnosticTag>? get tags {
  final value = _tags;
  if (value == null) return null;
  if (_tags is EqualUnmodifiableListView) return _tags;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

@override final  String? source;
@override final  CodeDescription? codeDescription;
@override final  dynamic? code;
@override final  DiagnosticSeverity? severity;

/// Create a copy of Diagnostic
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DiagnosticCopyWith<_Diagnostic> get copyWith => __$DiagnosticCopyWithImpl<_Diagnostic>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DiagnosticToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _Diagnostic&&(identical(other.range, range) || other.range == range)&&(identical(other.message, message) || other.message == message)&&const DeepCollectionEquality().equals(other.data, data)&&const DeepCollectionEquality().equals(other._relatedInformation, _relatedInformation)&&const DeepCollectionEquality().equals(other._tags, _tags)&&(identical(other.source, source) || other.source == source)&&(identical(other.codeDescription, codeDescription) || other.codeDescription == codeDescription)&&const DeepCollectionEquality().equals(other.code, code)&&(identical(other.severity, severity) || other.severity == severity));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,range,message,const DeepCollectionEquality().hash(data),const DeepCollectionEquality().hash(_relatedInformation),const DeepCollectionEquality().hash(_tags),source,codeDescription,const DeepCollectionEquality().hash(code),severity);

@override
String toString() {
  return 'Diagnostic(range: $range, message: $message, data: $data, relatedInformation: $relatedInformation, tags: $tags, source: $source, codeDescription: $codeDescription, code: $code, severity: $severity)';
}


}

/// @nodoc
abstract mixin class _$DiagnosticCopyWith<$Res> implements $DiagnosticCopyWith<$Res> {
  factory _$DiagnosticCopyWith(_Diagnostic value, $Res Function(_Diagnostic) _then) = __$DiagnosticCopyWithImpl;
@override @useResult
$Res call({
 Range range, String message, LSPAny? data, List<DiagnosticRelatedInformation>? relatedInformation, List<DiagnosticTag>? tags, String? source, CodeDescription? codeDescription, dynamic? code, DiagnosticSeverity? severity
});


@override $RangeCopyWith<$Res> get range;@override $CodeDescriptionCopyWith<$Res>? get codeDescription;

}
/// @nodoc
class __$DiagnosticCopyWithImpl<$Res>
    implements _$DiagnosticCopyWith<$Res> {
  __$DiagnosticCopyWithImpl(this._self, this._then);

  final _Diagnostic _self;
  final $Res Function(_Diagnostic) _then;

/// Create a copy of Diagnostic
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? range = null,Object? message = null,Object? data = freezed,Object? relatedInformation = freezed,Object? tags = freezed,Object? source = freezed,Object? codeDescription = freezed,Object? code = freezed,Object? severity = freezed,}) {
  return _then(_Diagnostic(
range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LSPAny?,relatedInformation: freezed == relatedInformation ? _self._relatedInformation : relatedInformation // ignore: cast_nullable_to_non_nullable
as List<DiagnosticRelatedInformation>?,tags: freezed == tags ? _self._tags : tags // ignore: cast_nullable_to_non_nullable
as List<DiagnosticTag>?,source: freezed == source ? _self.source : source // ignore: cast_nullable_to_non_nullable
as String?,codeDescription: freezed == codeDescription ? _self.codeDescription : codeDescription // ignore: cast_nullable_to_non_nullable
as CodeDescription?,code: freezed == code ? _self.code : code // ignore: cast_nullable_to_non_nullable
as dynamic?,severity: freezed == severity ? _self.severity : severity // ignore: cast_nullable_to_non_nullable
as DiagnosticSeverity?,
  ));
}

/// Create a copy of Diagnostic
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}/// Create a copy of Diagnostic
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CodeDescriptionCopyWith<$Res>? get codeDescription {
    if (_self.codeDescription == null) {
    return null;
  }

  return $CodeDescriptionCopyWith<$Res>(_self.codeDescription!, (value) {
    return _then(_self.copyWith(codeDescription: value));
  });
}
}


/// @nodoc
mixin _$CompletionContext {

 CompletionTriggerKind get triggerKind; String? get triggerCharacter;
/// Create a copy of CompletionContext
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CompletionContextCopyWith<CompletionContext> get copyWith => _$CompletionContextCopyWithImpl<CompletionContext>(this as CompletionContext, _$identity);

  /// Serializes this CompletionContext to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CompletionContext&&(identical(other.triggerKind, triggerKind) || other.triggerKind == triggerKind)&&(identical(other.triggerCharacter, triggerCharacter) || other.triggerCharacter == triggerCharacter));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,triggerKind,triggerCharacter);

@override
String toString() {
  return 'CompletionContext(triggerKind: $triggerKind, triggerCharacter: $triggerCharacter)';
}


}

/// @nodoc
abstract mixin class $CompletionContextCopyWith<$Res>  {
  factory $CompletionContextCopyWith(CompletionContext value, $Res Function(CompletionContext) _then) = _$CompletionContextCopyWithImpl;
@useResult
$Res call({
 CompletionTriggerKind triggerKind, String? triggerCharacter
});




}
/// @nodoc
class _$CompletionContextCopyWithImpl<$Res>
    implements $CompletionContextCopyWith<$Res> {
  _$CompletionContextCopyWithImpl(this._self, this._then);

  final CompletionContext _self;
  final $Res Function(CompletionContext) _then;

/// Create a copy of CompletionContext
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? triggerKind = null,Object? triggerCharacter = freezed,}) {
  return _then(_self.copyWith(
triggerKind: null == triggerKind ? _self.triggerKind : triggerKind // ignore: cast_nullable_to_non_nullable
as CompletionTriggerKind,triggerCharacter: freezed == triggerCharacter ? _self.triggerCharacter : triggerCharacter // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _CompletionContext implements CompletionContext {
  const _CompletionContext({required this.triggerKind, this.triggerCharacter});
  factory _CompletionContext.fromJson(Map<String, dynamic> json) => _$CompletionContextFromJson(json);

@override final  CompletionTriggerKind triggerKind;
@override final  String? triggerCharacter;

/// Create a copy of CompletionContext
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CompletionContextCopyWith<_CompletionContext> get copyWith => __$CompletionContextCopyWithImpl<_CompletionContext>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CompletionContextToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CompletionContext&&(identical(other.triggerKind, triggerKind) || other.triggerKind == triggerKind)&&(identical(other.triggerCharacter, triggerCharacter) || other.triggerCharacter == triggerCharacter));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,triggerKind,triggerCharacter);

@override
String toString() {
  return 'CompletionContext(triggerKind: $triggerKind, triggerCharacter: $triggerCharacter)';
}


}

/// @nodoc
abstract mixin class _$CompletionContextCopyWith<$Res> implements $CompletionContextCopyWith<$Res> {
  factory _$CompletionContextCopyWith(_CompletionContext value, $Res Function(_CompletionContext) _then) = __$CompletionContextCopyWithImpl;
@override @useResult
$Res call({
 CompletionTriggerKind triggerKind, String? triggerCharacter
});




}
/// @nodoc
class __$CompletionContextCopyWithImpl<$Res>
    implements _$CompletionContextCopyWith<$Res> {
  __$CompletionContextCopyWithImpl(this._self, this._then);

  final _CompletionContext _self;
  final $Res Function(_CompletionContext) _then;

/// Create a copy of CompletionContext
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? triggerKind = null,Object? triggerCharacter = freezed,}) {
  return _then(_CompletionContext(
triggerKind: null == triggerKind ? _self.triggerKind : triggerKind // ignore: cast_nullable_to_non_nullable
as CompletionTriggerKind,triggerCharacter: freezed == triggerCharacter ? _self.triggerCharacter : triggerCharacter // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$CompletionItemLabelDetails {

 String? get description; String? get detail;
/// Create a copy of CompletionItemLabelDetails
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CompletionItemLabelDetailsCopyWith<CompletionItemLabelDetails> get copyWith => _$CompletionItemLabelDetailsCopyWithImpl<CompletionItemLabelDetails>(this as CompletionItemLabelDetails, _$identity);

  /// Serializes this CompletionItemLabelDetails to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CompletionItemLabelDetails&&(identical(other.description, description) || other.description == description)&&(identical(other.detail, detail) || other.detail == detail));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,description,detail);

@override
String toString() {
  return 'CompletionItemLabelDetails(description: $description, detail: $detail)';
}


}

/// @nodoc
abstract mixin class $CompletionItemLabelDetailsCopyWith<$Res>  {
  factory $CompletionItemLabelDetailsCopyWith(CompletionItemLabelDetails value, $Res Function(CompletionItemLabelDetails) _then) = _$CompletionItemLabelDetailsCopyWithImpl;
@useResult
$Res call({
 String? description, String? detail
});




}
/// @nodoc
class _$CompletionItemLabelDetailsCopyWithImpl<$Res>
    implements $CompletionItemLabelDetailsCopyWith<$Res> {
  _$CompletionItemLabelDetailsCopyWithImpl(this._self, this._then);

  final CompletionItemLabelDetails _self;
  final $Res Function(CompletionItemLabelDetails) _then;

/// Create a copy of CompletionItemLabelDetails
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? description = freezed,Object? detail = freezed,}) {
  return _then(_self.copyWith(
description: freezed == description ? _self.description : description // ignore: cast_nullable_to_non_nullable
as String?,detail: freezed == detail ? _self.detail : detail // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _CompletionItemLabelDetails implements CompletionItemLabelDetails {
  const _CompletionItemLabelDetails({this.description, this.detail});
  factory _CompletionItemLabelDetails.fromJson(Map<String, dynamic> json) => _$CompletionItemLabelDetailsFromJson(json);

@override final  String? description;
@override final  String? detail;

/// Create a copy of CompletionItemLabelDetails
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CompletionItemLabelDetailsCopyWith<_CompletionItemLabelDetails> get copyWith => __$CompletionItemLabelDetailsCopyWithImpl<_CompletionItemLabelDetails>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CompletionItemLabelDetailsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CompletionItemLabelDetails&&(identical(other.description, description) || other.description == description)&&(identical(other.detail, detail) || other.detail == detail));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,description,detail);

@override
String toString() {
  return 'CompletionItemLabelDetails(description: $description, detail: $detail)';
}


}

/// @nodoc
abstract mixin class _$CompletionItemLabelDetailsCopyWith<$Res> implements $CompletionItemLabelDetailsCopyWith<$Res> {
  factory _$CompletionItemLabelDetailsCopyWith(_CompletionItemLabelDetails value, $Res Function(_CompletionItemLabelDetails) _then) = __$CompletionItemLabelDetailsCopyWithImpl;
@override @useResult
$Res call({
 String? description, String? detail
});




}
/// @nodoc
class __$CompletionItemLabelDetailsCopyWithImpl<$Res>
    implements _$CompletionItemLabelDetailsCopyWith<$Res> {
  __$CompletionItemLabelDetailsCopyWithImpl(this._self, this._then);

  final _CompletionItemLabelDetails _self;
  final $Res Function(_CompletionItemLabelDetails) _then;

/// Create a copy of CompletionItemLabelDetails
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? description = freezed,Object? detail = freezed,}) {
  return _then(_CompletionItemLabelDetails(
description: freezed == description ? _self.description : description // ignore: cast_nullable_to_non_nullable
as String?,detail: freezed == detail ? _self.detail : detail // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$InsertReplaceEdit {

 String get newText; Range get insert; Range get replace;
/// Create a copy of InsertReplaceEdit
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InsertReplaceEditCopyWith<InsertReplaceEdit> get copyWith => _$InsertReplaceEditCopyWithImpl<InsertReplaceEdit>(this as InsertReplaceEdit, _$identity);

  /// Serializes this InsertReplaceEdit to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InsertReplaceEdit&&(identical(other.newText, newText) || other.newText == newText)&&(identical(other.insert, insert) || other.insert == insert)&&(identical(other.replace, replace) || other.replace == replace));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,newText,insert,replace);

@override
String toString() {
  return 'InsertReplaceEdit(newText: $newText, insert: $insert, replace: $replace)';
}


}

/// @nodoc
abstract mixin class $InsertReplaceEditCopyWith<$Res>  {
  factory $InsertReplaceEditCopyWith(InsertReplaceEdit value, $Res Function(InsertReplaceEdit) _then) = _$InsertReplaceEditCopyWithImpl;
@useResult
$Res call({
 String newText, Range insert, Range replace
});


$RangeCopyWith<$Res> get insert;$RangeCopyWith<$Res> get replace;

}
/// @nodoc
class _$InsertReplaceEditCopyWithImpl<$Res>
    implements $InsertReplaceEditCopyWith<$Res> {
  _$InsertReplaceEditCopyWithImpl(this._self, this._then);

  final InsertReplaceEdit _self;
  final $Res Function(InsertReplaceEdit) _then;

/// Create a copy of InsertReplaceEdit
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? newText = null,Object? insert = null,Object? replace = null,}) {
  return _then(_self.copyWith(
newText: null == newText ? _self.newText : newText // ignore: cast_nullable_to_non_nullable
as String,insert: null == insert ? _self.insert : insert // ignore: cast_nullable_to_non_nullable
as Range,replace: null == replace ? _self.replace : replace // ignore: cast_nullable_to_non_nullable
as Range,
  ));
}
/// Create a copy of InsertReplaceEdit
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get insert {
  
  return $RangeCopyWith<$Res>(_self.insert, (value) {
    return _then(_self.copyWith(insert: value));
  });
}/// Create a copy of InsertReplaceEdit
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get replace {
  
  return $RangeCopyWith<$Res>(_self.replace, (value) {
    return _then(_self.copyWith(replace: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _InsertReplaceEdit implements InsertReplaceEdit {
  const _InsertReplaceEdit({required this.newText, required this.insert, required this.replace});
  factory _InsertReplaceEdit.fromJson(Map<String, dynamic> json) => _$InsertReplaceEditFromJson(json);

@override final  String newText;
@override final  Range insert;
@override final  Range replace;

/// Create a copy of InsertReplaceEdit
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InsertReplaceEditCopyWith<_InsertReplaceEdit> get copyWith => __$InsertReplaceEditCopyWithImpl<_InsertReplaceEdit>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InsertReplaceEditToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InsertReplaceEdit&&(identical(other.newText, newText) || other.newText == newText)&&(identical(other.insert, insert) || other.insert == insert)&&(identical(other.replace, replace) || other.replace == replace));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,newText,insert,replace);

@override
String toString() {
  return 'InsertReplaceEdit(newText: $newText, insert: $insert, replace: $replace)';
}


}

/// @nodoc
abstract mixin class _$InsertReplaceEditCopyWith<$Res> implements $InsertReplaceEditCopyWith<$Res> {
  factory _$InsertReplaceEditCopyWith(_InsertReplaceEdit value, $Res Function(_InsertReplaceEdit) _then) = __$InsertReplaceEditCopyWithImpl;
@override @useResult
$Res call({
 String newText, Range insert, Range replace
});


@override $RangeCopyWith<$Res> get insert;@override $RangeCopyWith<$Res> get replace;

}
/// @nodoc
class __$InsertReplaceEditCopyWithImpl<$Res>
    implements _$InsertReplaceEditCopyWith<$Res> {
  __$InsertReplaceEditCopyWithImpl(this._self, this._then);

  final _InsertReplaceEdit _self;
  final $Res Function(_InsertReplaceEdit) _then;

/// Create a copy of InsertReplaceEdit
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? newText = null,Object? insert = null,Object? replace = null,}) {
  return _then(_InsertReplaceEdit(
newText: null == newText ? _self.newText : newText // ignore: cast_nullable_to_non_nullable
as String,insert: null == insert ? _self.insert : insert // ignore: cast_nullable_to_non_nullable
as Range,replace: null == replace ? _self.replace : replace // ignore: cast_nullable_to_non_nullable
as Range,
  ));
}

/// Create a copy of InsertReplaceEdit
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get insert {
  
  return $RangeCopyWith<$Res>(_self.insert, (value) {
    return _then(_self.copyWith(insert: value));
  });
}/// Create a copy of InsertReplaceEdit
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get replace {
  
  return $RangeCopyWith<$Res>(_self.replace, (value) {
    return _then(_self.copyWith(replace: value));
  });
}
}


/// @nodoc
mixin _$CompletionOptions {

 ({bool? labelDetailsSupport})? get completionItem; bool? get resolveProvider; List<String>? get allCommitCharacters; List<String>? get triggerCharacters; bool? get workDoneProgress;
/// Create a copy of CompletionOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CompletionOptionsCopyWith<CompletionOptions> get copyWith => _$CompletionOptionsCopyWithImpl<CompletionOptions>(this as CompletionOptions, _$identity);

  /// Serializes this CompletionOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CompletionOptions&&(identical(other.completionItem, completionItem) || other.completionItem == completionItem)&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider)&&const DeepCollectionEquality().equals(other.allCommitCharacters, allCommitCharacters)&&const DeepCollectionEquality().equals(other.triggerCharacters, triggerCharacters)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,completionItem,resolveProvider,const DeepCollectionEquality().hash(allCommitCharacters),const DeepCollectionEquality().hash(triggerCharacters),workDoneProgress);

@override
String toString() {
  return 'CompletionOptions(completionItem: $completionItem, resolveProvider: $resolveProvider, allCommitCharacters: $allCommitCharacters, triggerCharacters: $triggerCharacters, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $CompletionOptionsCopyWith<$Res>  {
  factory $CompletionOptionsCopyWith(CompletionOptions value, $Res Function(CompletionOptions) _then) = _$CompletionOptionsCopyWithImpl;
@useResult
$Res call({
 ({bool? labelDetailsSupport})? completionItem, bool? resolveProvider, List<String>? allCommitCharacters, List<String>? triggerCharacters, bool? workDoneProgress
});




}
/// @nodoc
class _$CompletionOptionsCopyWithImpl<$Res>
    implements $CompletionOptionsCopyWith<$Res> {
  _$CompletionOptionsCopyWithImpl(this._self, this._then);

  final CompletionOptions _self;
  final $Res Function(CompletionOptions) _then;

/// Create a copy of CompletionOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? completionItem = freezed,Object? resolveProvider = freezed,Object? allCommitCharacters = freezed,Object? triggerCharacters = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
completionItem: freezed == completionItem ? _self.completionItem : completionItem // ignore: cast_nullable_to_non_nullable
as ({bool? labelDetailsSupport})?,resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,allCommitCharacters: freezed == allCommitCharacters ? _self.allCommitCharacters : allCommitCharacters // ignore: cast_nullable_to_non_nullable
as List<String>?,triggerCharacters: freezed == triggerCharacters ? _self.triggerCharacters : triggerCharacters // ignore: cast_nullable_to_non_nullable
as List<String>?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _CompletionOptions implements CompletionOptions {
  const _CompletionOptions({this.completionItem, this.resolveProvider, final  List<String>? allCommitCharacters, final  List<String>? triggerCharacters, this.workDoneProgress}): _allCommitCharacters = allCommitCharacters,_triggerCharacters = triggerCharacters;
  factory _CompletionOptions.fromJson(Map<String, dynamic> json) => _$CompletionOptionsFromJson(json);

@override final  ({bool? labelDetailsSupport})? completionItem;
@override final  bool? resolveProvider;
 final  List<String>? _allCommitCharacters;
@override List<String>? get allCommitCharacters {
  final value = _allCommitCharacters;
  if (value == null) return null;
  if (_allCommitCharacters is EqualUnmodifiableListView) return _allCommitCharacters;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

 final  List<String>? _triggerCharacters;
@override List<String>? get triggerCharacters {
  final value = _triggerCharacters;
  if (value == null) return null;
  if (_triggerCharacters is EqualUnmodifiableListView) return _triggerCharacters;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

@override final  bool? workDoneProgress;

/// Create a copy of CompletionOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CompletionOptionsCopyWith<_CompletionOptions> get copyWith => __$CompletionOptionsCopyWithImpl<_CompletionOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CompletionOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CompletionOptions&&(identical(other.completionItem, completionItem) || other.completionItem == completionItem)&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider)&&const DeepCollectionEquality().equals(other._allCommitCharacters, _allCommitCharacters)&&const DeepCollectionEquality().equals(other._triggerCharacters, _triggerCharacters)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,completionItem,resolveProvider,const DeepCollectionEquality().hash(_allCommitCharacters),const DeepCollectionEquality().hash(_triggerCharacters),workDoneProgress);

@override
String toString() {
  return 'CompletionOptions(completionItem: $completionItem, resolveProvider: $resolveProvider, allCommitCharacters: $allCommitCharacters, triggerCharacters: $triggerCharacters, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$CompletionOptionsCopyWith<$Res> implements $CompletionOptionsCopyWith<$Res> {
  factory _$CompletionOptionsCopyWith(_CompletionOptions value, $Res Function(_CompletionOptions) _then) = __$CompletionOptionsCopyWithImpl;
@override @useResult
$Res call({
 ({bool? labelDetailsSupport})? completionItem, bool? resolveProvider, List<String>? allCommitCharacters, List<String>? triggerCharacters, bool? workDoneProgress
});




}
/// @nodoc
class __$CompletionOptionsCopyWithImpl<$Res>
    implements _$CompletionOptionsCopyWith<$Res> {
  __$CompletionOptionsCopyWithImpl(this._self, this._then);

  final _CompletionOptions _self;
  final $Res Function(_CompletionOptions) _then;

/// Create a copy of CompletionOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? completionItem = freezed,Object? resolveProvider = freezed,Object? allCommitCharacters = freezed,Object? triggerCharacters = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_CompletionOptions(
completionItem: freezed == completionItem ? _self.completionItem : completionItem // ignore: cast_nullable_to_non_nullable
as ({bool? labelDetailsSupport})?,resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,allCommitCharacters: freezed == allCommitCharacters ? _self._allCommitCharacters : allCommitCharacters // ignore: cast_nullable_to_non_nullable
as List<String>?,triggerCharacters: freezed == triggerCharacters ? _self._triggerCharacters : triggerCharacters // ignore: cast_nullable_to_non_nullable
as List<String>?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$HoverOptions {

 bool? get workDoneProgress;
/// Create a copy of HoverOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$HoverOptionsCopyWith<HoverOptions> get copyWith => _$HoverOptionsCopyWithImpl<HoverOptions>(this as HoverOptions, _$identity);

  /// Serializes this HoverOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is HoverOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'HoverOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $HoverOptionsCopyWith<$Res>  {
  factory $HoverOptionsCopyWith(HoverOptions value, $Res Function(HoverOptions) _then) = _$HoverOptionsCopyWithImpl;
@useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class _$HoverOptionsCopyWithImpl<$Res>
    implements $HoverOptionsCopyWith<$Res> {
  _$HoverOptionsCopyWithImpl(this._self, this._then);

  final HoverOptions _self;
  final $Res Function(HoverOptions) _then;

/// Create a copy of HoverOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _HoverOptions implements HoverOptions {
  const _HoverOptions({this.workDoneProgress});
  factory _HoverOptions.fromJson(Map<String, dynamic> json) => _$HoverOptionsFromJson(json);

@override final  bool? workDoneProgress;

/// Create a copy of HoverOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$HoverOptionsCopyWith<_HoverOptions> get copyWith => __$HoverOptionsCopyWithImpl<_HoverOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$HoverOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _HoverOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'HoverOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$HoverOptionsCopyWith<$Res> implements $HoverOptionsCopyWith<$Res> {
  factory _$HoverOptionsCopyWith(_HoverOptions value, $Res Function(_HoverOptions) _then) = __$HoverOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class __$HoverOptionsCopyWithImpl<$Res>
    implements _$HoverOptionsCopyWith<$Res> {
  __$HoverOptionsCopyWithImpl(this._self, this._then);

  final _HoverOptions _self;
  final $Res Function(_HoverOptions) _then;

/// Create a copy of HoverOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_HoverOptions(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$SignatureHelpContext {

 SignatureHelpTriggerKind get triggerKind; bool get isRetrigger; SignatureHelp? get activeSignatureHelp; String? get triggerCharacter;
/// Create a copy of SignatureHelpContext
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SignatureHelpContextCopyWith<SignatureHelpContext> get copyWith => _$SignatureHelpContextCopyWithImpl<SignatureHelpContext>(this as SignatureHelpContext, _$identity);

  /// Serializes this SignatureHelpContext to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SignatureHelpContext&&(identical(other.triggerKind, triggerKind) || other.triggerKind == triggerKind)&&(identical(other.isRetrigger, isRetrigger) || other.isRetrigger == isRetrigger)&&(identical(other.activeSignatureHelp, activeSignatureHelp) || other.activeSignatureHelp == activeSignatureHelp)&&(identical(other.triggerCharacter, triggerCharacter) || other.triggerCharacter == triggerCharacter));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,triggerKind,isRetrigger,activeSignatureHelp,triggerCharacter);

@override
String toString() {
  return 'SignatureHelpContext(triggerKind: $triggerKind, isRetrigger: $isRetrigger, activeSignatureHelp: $activeSignatureHelp, triggerCharacter: $triggerCharacter)';
}


}

/// @nodoc
abstract mixin class $SignatureHelpContextCopyWith<$Res>  {
  factory $SignatureHelpContextCopyWith(SignatureHelpContext value, $Res Function(SignatureHelpContext) _then) = _$SignatureHelpContextCopyWithImpl;
@useResult
$Res call({
 SignatureHelpTriggerKind triggerKind, bool isRetrigger, SignatureHelp? activeSignatureHelp, String? triggerCharacter
});


$SignatureHelpCopyWith<$Res>? get activeSignatureHelp;

}
/// @nodoc
class _$SignatureHelpContextCopyWithImpl<$Res>
    implements $SignatureHelpContextCopyWith<$Res> {
  _$SignatureHelpContextCopyWithImpl(this._self, this._then);

  final SignatureHelpContext _self;
  final $Res Function(SignatureHelpContext) _then;

/// Create a copy of SignatureHelpContext
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? triggerKind = null,Object? isRetrigger = null,Object? activeSignatureHelp = freezed,Object? triggerCharacter = freezed,}) {
  return _then(_self.copyWith(
triggerKind: null == triggerKind ? _self.triggerKind : triggerKind // ignore: cast_nullable_to_non_nullable
as SignatureHelpTriggerKind,isRetrigger: null == isRetrigger ? _self.isRetrigger : isRetrigger // ignore: cast_nullable_to_non_nullable
as bool,activeSignatureHelp: freezed == activeSignatureHelp ? _self.activeSignatureHelp : activeSignatureHelp // ignore: cast_nullable_to_non_nullable
as SignatureHelp?,triggerCharacter: freezed == triggerCharacter ? _self.triggerCharacter : triggerCharacter // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}
/// Create a copy of SignatureHelpContext
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SignatureHelpCopyWith<$Res>? get activeSignatureHelp {
    if (_self.activeSignatureHelp == null) {
    return null;
  }

  return $SignatureHelpCopyWith<$Res>(_self.activeSignatureHelp!, (value) {
    return _then(_self.copyWith(activeSignatureHelp: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _SignatureHelpContext implements SignatureHelpContext {
  const _SignatureHelpContext({required this.triggerKind, required this.isRetrigger, this.activeSignatureHelp, this.triggerCharacter});
  factory _SignatureHelpContext.fromJson(Map<String, dynamic> json) => _$SignatureHelpContextFromJson(json);

@override final  SignatureHelpTriggerKind triggerKind;
@override final  bool isRetrigger;
@override final  SignatureHelp? activeSignatureHelp;
@override final  String? triggerCharacter;

/// Create a copy of SignatureHelpContext
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SignatureHelpContextCopyWith<_SignatureHelpContext> get copyWith => __$SignatureHelpContextCopyWithImpl<_SignatureHelpContext>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SignatureHelpContextToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SignatureHelpContext&&(identical(other.triggerKind, triggerKind) || other.triggerKind == triggerKind)&&(identical(other.isRetrigger, isRetrigger) || other.isRetrigger == isRetrigger)&&(identical(other.activeSignatureHelp, activeSignatureHelp) || other.activeSignatureHelp == activeSignatureHelp)&&(identical(other.triggerCharacter, triggerCharacter) || other.triggerCharacter == triggerCharacter));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,triggerKind,isRetrigger,activeSignatureHelp,triggerCharacter);

@override
String toString() {
  return 'SignatureHelpContext(triggerKind: $triggerKind, isRetrigger: $isRetrigger, activeSignatureHelp: $activeSignatureHelp, triggerCharacter: $triggerCharacter)';
}


}

/// @nodoc
abstract mixin class _$SignatureHelpContextCopyWith<$Res> implements $SignatureHelpContextCopyWith<$Res> {
  factory _$SignatureHelpContextCopyWith(_SignatureHelpContext value, $Res Function(_SignatureHelpContext) _then) = __$SignatureHelpContextCopyWithImpl;
@override @useResult
$Res call({
 SignatureHelpTriggerKind triggerKind, bool isRetrigger, SignatureHelp? activeSignatureHelp, String? triggerCharacter
});


@override $SignatureHelpCopyWith<$Res>? get activeSignatureHelp;

}
/// @nodoc
class __$SignatureHelpContextCopyWithImpl<$Res>
    implements _$SignatureHelpContextCopyWith<$Res> {
  __$SignatureHelpContextCopyWithImpl(this._self, this._then);

  final _SignatureHelpContext _self;
  final $Res Function(_SignatureHelpContext) _then;

/// Create a copy of SignatureHelpContext
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? triggerKind = null,Object? isRetrigger = null,Object? activeSignatureHelp = freezed,Object? triggerCharacter = freezed,}) {
  return _then(_SignatureHelpContext(
triggerKind: null == triggerKind ? _self.triggerKind : triggerKind // ignore: cast_nullable_to_non_nullable
as SignatureHelpTriggerKind,isRetrigger: null == isRetrigger ? _self.isRetrigger : isRetrigger // ignore: cast_nullable_to_non_nullable
as bool,activeSignatureHelp: freezed == activeSignatureHelp ? _self.activeSignatureHelp : activeSignatureHelp // ignore: cast_nullable_to_non_nullable
as SignatureHelp?,triggerCharacter: freezed == triggerCharacter ? _self.triggerCharacter : triggerCharacter // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

/// Create a copy of SignatureHelpContext
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SignatureHelpCopyWith<$Res>? get activeSignatureHelp {
    if (_self.activeSignatureHelp == null) {
    return null;
  }

  return $SignatureHelpCopyWith<$Res>(_self.activeSignatureHelp!, (value) {
    return _then(_self.copyWith(activeSignatureHelp: value));
  });
}
}


/// @nodoc
mixin _$SignatureInformation {

 String get label; int? get activeParameter; List<ParameterInformation>? get parameters; dynamic? get documentation;
/// Create a copy of SignatureInformation
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SignatureInformationCopyWith<SignatureInformation> get copyWith => _$SignatureInformationCopyWithImpl<SignatureInformation>(this as SignatureInformation, _$identity);

  /// Serializes this SignatureInformation to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SignatureInformation&&(identical(other.label, label) || other.label == label)&&(identical(other.activeParameter, activeParameter) || other.activeParameter == activeParameter)&&const DeepCollectionEquality().equals(other.parameters, parameters)&&const DeepCollectionEquality().equals(other.documentation, documentation));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,label,activeParameter,const DeepCollectionEquality().hash(parameters),const DeepCollectionEquality().hash(documentation));

@override
String toString() {
  return 'SignatureInformation(label: $label, activeParameter: $activeParameter, parameters: $parameters, documentation: $documentation)';
}


}

/// @nodoc
abstract mixin class $SignatureInformationCopyWith<$Res>  {
  factory $SignatureInformationCopyWith(SignatureInformation value, $Res Function(SignatureInformation) _then) = _$SignatureInformationCopyWithImpl;
@useResult
$Res call({
 String label, int? activeParameter, List<ParameterInformation>? parameters, dynamic? documentation
});




}
/// @nodoc
class _$SignatureInformationCopyWithImpl<$Res>
    implements $SignatureInformationCopyWith<$Res> {
  _$SignatureInformationCopyWithImpl(this._self, this._then);

  final SignatureInformation _self;
  final $Res Function(SignatureInformation) _then;

/// Create a copy of SignatureInformation
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? label = null,Object? activeParameter = freezed,Object? parameters = freezed,Object? documentation = freezed,}) {
  return _then(_self.copyWith(
label: null == label ? _self.label : label // ignore: cast_nullable_to_non_nullable
as String,activeParameter: freezed == activeParameter ? _self.activeParameter : activeParameter // ignore: cast_nullable_to_non_nullable
as int?,parameters: freezed == parameters ? _self.parameters : parameters // ignore: cast_nullable_to_non_nullable
as List<ParameterInformation>?,documentation: freezed == documentation ? _self.documentation : documentation // ignore: cast_nullable_to_non_nullable
as dynamic?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _SignatureInformation implements SignatureInformation {
  const _SignatureInformation({required this.label, this.activeParameter, final  List<ParameterInformation>? parameters, this.documentation}): _parameters = parameters;
  factory _SignatureInformation.fromJson(Map<String, dynamic> json) => _$SignatureInformationFromJson(json);

@override final  String label;
@override final  int? activeParameter;
 final  List<ParameterInformation>? _parameters;
@override List<ParameterInformation>? get parameters {
  final value = _parameters;
  if (value == null) return null;
  if (_parameters is EqualUnmodifiableListView) return _parameters;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

@override final  dynamic? documentation;

/// Create a copy of SignatureInformation
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SignatureInformationCopyWith<_SignatureInformation> get copyWith => __$SignatureInformationCopyWithImpl<_SignatureInformation>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SignatureInformationToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SignatureInformation&&(identical(other.label, label) || other.label == label)&&(identical(other.activeParameter, activeParameter) || other.activeParameter == activeParameter)&&const DeepCollectionEquality().equals(other._parameters, _parameters)&&const DeepCollectionEquality().equals(other.documentation, documentation));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,label,activeParameter,const DeepCollectionEquality().hash(_parameters),const DeepCollectionEquality().hash(documentation));

@override
String toString() {
  return 'SignatureInformation(label: $label, activeParameter: $activeParameter, parameters: $parameters, documentation: $documentation)';
}


}

/// @nodoc
abstract mixin class _$SignatureInformationCopyWith<$Res> implements $SignatureInformationCopyWith<$Res> {
  factory _$SignatureInformationCopyWith(_SignatureInformation value, $Res Function(_SignatureInformation) _then) = __$SignatureInformationCopyWithImpl;
@override @useResult
$Res call({
 String label, int? activeParameter, List<ParameterInformation>? parameters, dynamic? documentation
});




}
/// @nodoc
class __$SignatureInformationCopyWithImpl<$Res>
    implements _$SignatureInformationCopyWith<$Res> {
  __$SignatureInformationCopyWithImpl(this._self, this._then);

  final _SignatureInformation _self;
  final $Res Function(_SignatureInformation) _then;

/// Create a copy of SignatureInformation
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? label = null,Object? activeParameter = freezed,Object? parameters = freezed,Object? documentation = freezed,}) {
  return _then(_SignatureInformation(
label: null == label ? _self.label : label // ignore: cast_nullable_to_non_nullable
as String,activeParameter: freezed == activeParameter ? _self.activeParameter : activeParameter // ignore: cast_nullable_to_non_nullable
as int?,parameters: freezed == parameters ? _self._parameters : parameters // ignore: cast_nullable_to_non_nullable
as List<ParameterInformation>?,documentation: freezed == documentation ? _self.documentation : documentation // ignore: cast_nullable_to_non_nullable
as dynamic?,
  ));
}


}


/// @nodoc
mixin _$SignatureHelpOptions {

 List<String>? get retriggerCharacters; List<String>? get triggerCharacters; bool? get workDoneProgress;
/// Create a copy of SignatureHelpOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SignatureHelpOptionsCopyWith<SignatureHelpOptions> get copyWith => _$SignatureHelpOptionsCopyWithImpl<SignatureHelpOptions>(this as SignatureHelpOptions, _$identity);

  /// Serializes this SignatureHelpOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SignatureHelpOptions&&const DeepCollectionEquality().equals(other.retriggerCharacters, retriggerCharacters)&&const DeepCollectionEquality().equals(other.triggerCharacters, triggerCharacters)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(retriggerCharacters),const DeepCollectionEquality().hash(triggerCharacters),workDoneProgress);

@override
String toString() {
  return 'SignatureHelpOptions(retriggerCharacters: $retriggerCharacters, triggerCharacters: $triggerCharacters, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $SignatureHelpOptionsCopyWith<$Res>  {
  factory $SignatureHelpOptionsCopyWith(SignatureHelpOptions value, $Res Function(SignatureHelpOptions) _then) = _$SignatureHelpOptionsCopyWithImpl;
@useResult
$Res call({
 List<String>? retriggerCharacters, List<String>? triggerCharacters, bool? workDoneProgress
});




}
/// @nodoc
class _$SignatureHelpOptionsCopyWithImpl<$Res>
    implements $SignatureHelpOptionsCopyWith<$Res> {
  _$SignatureHelpOptionsCopyWithImpl(this._self, this._then);

  final SignatureHelpOptions _self;
  final $Res Function(SignatureHelpOptions) _then;

/// Create a copy of SignatureHelpOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? retriggerCharacters = freezed,Object? triggerCharacters = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
retriggerCharacters: freezed == retriggerCharacters ? _self.retriggerCharacters : retriggerCharacters // ignore: cast_nullable_to_non_nullable
as List<String>?,triggerCharacters: freezed == triggerCharacters ? _self.triggerCharacters : triggerCharacters // ignore: cast_nullable_to_non_nullable
as List<String>?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _SignatureHelpOptions implements SignatureHelpOptions {
  const _SignatureHelpOptions({final  List<String>? retriggerCharacters, final  List<String>? triggerCharacters, this.workDoneProgress}): _retriggerCharacters = retriggerCharacters,_triggerCharacters = triggerCharacters;
  factory _SignatureHelpOptions.fromJson(Map<String, dynamic> json) => _$SignatureHelpOptionsFromJson(json);

 final  List<String>? _retriggerCharacters;
@override List<String>? get retriggerCharacters {
  final value = _retriggerCharacters;
  if (value == null) return null;
  if (_retriggerCharacters is EqualUnmodifiableListView) return _retriggerCharacters;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

 final  List<String>? _triggerCharacters;
@override List<String>? get triggerCharacters {
  final value = _triggerCharacters;
  if (value == null) return null;
  if (_triggerCharacters is EqualUnmodifiableListView) return _triggerCharacters;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

@override final  bool? workDoneProgress;

/// Create a copy of SignatureHelpOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SignatureHelpOptionsCopyWith<_SignatureHelpOptions> get copyWith => __$SignatureHelpOptionsCopyWithImpl<_SignatureHelpOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SignatureHelpOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SignatureHelpOptions&&const DeepCollectionEquality().equals(other._retriggerCharacters, _retriggerCharacters)&&const DeepCollectionEquality().equals(other._triggerCharacters, _triggerCharacters)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_retriggerCharacters),const DeepCollectionEquality().hash(_triggerCharacters),workDoneProgress);

@override
String toString() {
  return 'SignatureHelpOptions(retriggerCharacters: $retriggerCharacters, triggerCharacters: $triggerCharacters, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$SignatureHelpOptionsCopyWith<$Res> implements $SignatureHelpOptionsCopyWith<$Res> {
  factory _$SignatureHelpOptionsCopyWith(_SignatureHelpOptions value, $Res Function(_SignatureHelpOptions) _then) = __$SignatureHelpOptionsCopyWithImpl;
@override @useResult
$Res call({
 List<String>? retriggerCharacters, List<String>? triggerCharacters, bool? workDoneProgress
});




}
/// @nodoc
class __$SignatureHelpOptionsCopyWithImpl<$Res>
    implements _$SignatureHelpOptionsCopyWith<$Res> {
  __$SignatureHelpOptionsCopyWithImpl(this._self, this._then);

  final _SignatureHelpOptions _self;
  final $Res Function(_SignatureHelpOptions) _then;

/// Create a copy of SignatureHelpOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? retriggerCharacters = freezed,Object? triggerCharacters = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_SignatureHelpOptions(
retriggerCharacters: freezed == retriggerCharacters ? _self._retriggerCharacters : retriggerCharacters // ignore: cast_nullable_to_non_nullable
as List<String>?,triggerCharacters: freezed == triggerCharacters ? _self._triggerCharacters : triggerCharacters // ignore: cast_nullable_to_non_nullable
as List<String>?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DefinitionOptions {

 bool? get workDoneProgress;
/// Create a copy of DefinitionOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DefinitionOptionsCopyWith<DefinitionOptions> get copyWith => _$DefinitionOptionsCopyWithImpl<DefinitionOptions>(this as DefinitionOptions, _$identity);

  /// Serializes this DefinitionOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DefinitionOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'DefinitionOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $DefinitionOptionsCopyWith<$Res>  {
  factory $DefinitionOptionsCopyWith(DefinitionOptions value, $Res Function(DefinitionOptions) _then) = _$DefinitionOptionsCopyWithImpl;
@useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class _$DefinitionOptionsCopyWithImpl<$Res>
    implements $DefinitionOptionsCopyWith<$Res> {
  _$DefinitionOptionsCopyWithImpl(this._self, this._then);

  final DefinitionOptions _self;
  final $Res Function(DefinitionOptions) _then;

/// Create a copy of DefinitionOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DefinitionOptions implements DefinitionOptions {
  const _DefinitionOptions({this.workDoneProgress});
  factory _DefinitionOptions.fromJson(Map<String, dynamic> json) => _$DefinitionOptionsFromJson(json);

@override final  bool? workDoneProgress;

/// Create a copy of DefinitionOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DefinitionOptionsCopyWith<_DefinitionOptions> get copyWith => __$DefinitionOptionsCopyWithImpl<_DefinitionOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DefinitionOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DefinitionOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'DefinitionOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$DefinitionOptionsCopyWith<$Res> implements $DefinitionOptionsCopyWith<$Res> {
  factory _$DefinitionOptionsCopyWith(_DefinitionOptions value, $Res Function(_DefinitionOptions) _then) = __$DefinitionOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class __$DefinitionOptionsCopyWithImpl<$Res>
    implements _$DefinitionOptionsCopyWith<$Res> {
  __$DefinitionOptionsCopyWithImpl(this._self, this._then);

  final _DefinitionOptions _self;
  final $Res Function(_DefinitionOptions) _then;

/// Create a copy of DefinitionOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_DefinitionOptions(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$ReferenceContext {

 bool get includeDeclaration;
/// Create a copy of ReferenceContext
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ReferenceContextCopyWith<ReferenceContext> get copyWith => _$ReferenceContextCopyWithImpl<ReferenceContext>(this as ReferenceContext, _$identity);

  /// Serializes this ReferenceContext to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ReferenceContext&&(identical(other.includeDeclaration, includeDeclaration) || other.includeDeclaration == includeDeclaration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,includeDeclaration);

@override
String toString() {
  return 'ReferenceContext(includeDeclaration: $includeDeclaration)';
}


}

/// @nodoc
abstract mixin class $ReferenceContextCopyWith<$Res>  {
  factory $ReferenceContextCopyWith(ReferenceContext value, $Res Function(ReferenceContext) _then) = _$ReferenceContextCopyWithImpl;
@useResult
$Res call({
 bool includeDeclaration
});




}
/// @nodoc
class _$ReferenceContextCopyWithImpl<$Res>
    implements $ReferenceContextCopyWith<$Res> {
  _$ReferenceContextCopyWithImpl(this._self, this._then);

  final ReferenceContext _self;
  final $Res Function(ReferenceContext) _then;

/// Create a copy of ReferenceContext
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? includeDeclaration = null,}) {
  return _then(_self.copyWith(
includeDeclaration: null == includeDeclaration ? _self.includeDeclaration : includeDeclaration // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _ReferenceContext implements ReferenceContext {
  const _ReferenceContext({required this.includeDeclaration});
  factory _ReferenceContext.fromJson(Map<String, dynamic> json) => _$ReferenceContextFromJson(json);

@override final  bool includeDeclaration;

/// Create a copy of ReferenceContext
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ReferenceContextCopyWith<_ReferenceContext> get copyWith => __$ReferenceContextCopyWithImpl<_ReferenceContext>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ReferenceContextToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ReferenceContext&&(identical(other.includeDeclaration, includeDeclaration) || other.includeDeclaration == includeDeclaration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,includeDeclaration);

@override
String toString() {
  return 'ReferenceContext(includeDeclaration: $includeDeclaration)';
}


}

/// @nodoc
abstract mixin class _$ReferenceContextCopyWith<$Res> implements $ReferenceContextCopyWith<$Res> {
  factory _$ReferenceContextCopyWith(_ReferenceContext value, $Res Function(_ReferenceContext) _then) = __$ReferenceContextCopyWithImpl;
@override @useResult
$Res call({
 bool includeDeclaration
});




}
/// @nodoc
class __$ReferenceContextCopyWithImpl<$Res>
    implements _$ReferenceContextCopyWith<$Res> {
  __$ReferenceContextCopyWithImpl(this._self, this._then);

  final _ReferenceContext _self;
  final $Res Function(_ReferenceContext) _then;

/// Create a copy of ReferenceContext
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? includeDeclaration = null,}) {
  return _then(_ReferenceContext(
includeDeclaration: null == includeDeclaration ? _self.includeDeclaration : includeDeclaration // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}


}


/// @nodoc
mixin _$ReferenceOptions {

 bool? get workDoneProgress;
/// Create a copy of ReferenceOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ReferenceOptionsCopyWith<ReferenceOptions> get copyWith => _$ReferenceOptionsCopyWithImpl<ReferenceOptions>(this as ReferenceOptions, _$identity);

  /// Serializes this ReferenceOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ReferenceOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'ReferenceOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $ReferenceOptionsCopyWith<$Res>  {
  factory $ReferenceOptionsCopyWith(ReferenceOptions value, $Res Function(ReferenceOptions) _then) = _$ReferenceOptionsCopyWithImpl;
@useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class _$ReferenceOptionsCopyWithImpl<$Res>
    implements $ReferenceOptionsCopyWith<$Res> {
  _$ReferenceOptionsCopyWithImpl(this._self, this._then);

  final ReferenceOptions _self;
  final $Res Function(ReferenceOptions) _then;

/// Create a copy of ReferenceOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _ReferenceOptions implements ReferenceOptions {
  const _ReferenceOptions({this.workDoneProgress});
  factory _ReferenceOptions.fromJson(Map<String, dynamic> json) => _$ReferenceOptionsFromJson(json);

@override final  bool? workDoneProgress;

/// Create a copy of ReferenceOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ReferenceOptionsCopyWith<_ReferenceOptions> get copyWith => __$ReferenceOptionsCopyWithImpl<_ReferenceOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ReferenceOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ReferenceOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'ReferenceOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$ReferenceOptionsCopyWith<$Res> implements $ReferenceOptionsCopyWith<$Res> {
  factory _$ReferenceOptionsCopyWith(_ReferenceOptions value, $Res Function(_ReferenceOptions) _then) = __$ReferenceOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class __$ReferenceOptionsCopyWithImpl<$Res>
    implements _$ReferenceOptionsCopyWith<$Res> {
  __$ReferenceOptionsCopyWithImpl(this._self, this._then);

  final _ReferenceOptions _self;
  final $Res Function(_ReferenceOptions) _then;

/// Create a copy of ReferenceOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_ReferenceOptions(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DocumentHighlightOptions {

 bool? get workDoneProgress;
/// Create a copy of DocumentHighlightOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentHighlightOptionsCopyWith<DocumentHighlightOptions> get copyWith => _$DocumentHighlightOptionsCopyWithImpl<DocumentHighlightOptions>(this as DocumentHighlightOptions, _$identity);

  /// Serializes this DocumentHighlightOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentHighlightOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'DocumentHighlightOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $DocumentHighlightOptionsCopyWith<$Res>  {
  factory $DocumentHighlightOptionsCopyWith(DocumentHighlightOptions value, $Res Function(DocumentHighlightOptions) _then) = _$DocumentHighlightOptionsCopyWithImpl;
@useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class _$DocumentHighlightOptionsCopyWithImpl<$Res>
    implements $DocumentHighlightOptionsCopyWith<$Res> {
  _$DocumentHighlightOptionsCopyWithImpl(this._self, this._then);

  final DocumentHighlightOptions _self;
  final $Res Function(DocumentHighlightOptions) _then;

/// Create a copy of DocumentHighlightOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DocumentHighlightOptions implements DocumentHighlightOptions {
  const _DocumentHighlightOptions({this.workDoneProgress});
  factory _DocumentHighlightOptions.fromJson(Map<String, dynamic> json) => _$DocumentHighlightOptionsFromJson(json);

@override final  bool? workDoneProgress;

/// Create a copy of DocumentHighlightOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentHighlightOptionsCopyWith<_DocumentHighlightOptions> get copyWith => __$DocumentHighlightOptionsCopyWithImpl<_DocumentHighlightOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentHighlightOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentHighlightOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'DocumentHighlightOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$DocumentHighlightOptionsCopyWith<$Res> implements $DocumentHighlightOptionsCopyWith<$Res> {
  factory _$DocumentHighlightOptionsCopyWith(_DocumentHighlightOptions value, $Res Function(_DocumentHighlightOptions) _then) = __$DocumentHighlightOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class __$DocumentHighlightOptionsCopyWithImpl<$Res>
    implements _$DocumentHighlightOptionsCopyWith<$Res> {
  __$DocumentHighlightOptionsCopyWithImpl(this._self, this._then);

  final _DocumentHighlightOptions _self;
  final $Res Function(_DocumentHighlightOptions) _then;

/// Create a copy of DocumentHighlightOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_DocumentHighlightOptions(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$BaseSymbolInformation {

 String get name; SymbolKind get kind; String? get containerName; List<SymbolTag>? get tags;
/// Create a copy of BaseSymbolInformation
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$BaseSymbolInformationCopyWith<BaseSymbolInformation> get copyWith => _$BaseSymbolInformationCopyWithImpl<BaseSymbolInformation>(this as BaseSymbolInformation, _$identity);

  /// Serializes this BaseSymbolInformation to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is BaseSymbolInformation&&(identical(other.name, name) || other.name == name)&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.containerName, containerName) || other.containerName == containerName)&&const DeepCollectionEquality().equals(other.tags, tags));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,name,kind,containerName,const DeepCollectionEquality().hash(tags));

@override
String toString() {
  return 'BaseSymbolInformation(name: $name, kind: $kind, containerName: $containerName, tags: $tags)';
}


}

/// @nodoc
abstract mixin class $BaseSymbolInformationCopyWith<$Res>  {
  factory $BaseSymbolInformationCopyWith(BaseSymbolInformation value, $Res Function(BaseSymbolInformation) _then) = _$BaseSymbolInformationCopyWithImpl;
@useResult
$Res call({
 String name, SymbolKind kind, String? containerName, List<SymbolTag>? tags
});




}
/// @nodoc
class _$BaseSymbolInformationCopyWithImpl<$Res>
    implements $BaseSymbolInformationCopyWith<$Res> {
  _$BaseSymbolInformationCopyWithImpl(this._self, this._then);

  final BaseSymbolInformation _self;
  final $Res Function(BaseSymbolInformation) _then;

/// Create a copy of BaseSymbolInformation
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? name = null,Object? kind = null,Object? containerName = freezed,Object? tags = freezed,}) {
  return _then(_self.copyWith(
name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as SymbolKind,containerName: freezed == containerName ? _self.containerName : containerName // ignore: cast_nullable_to_non_nullable
as String?,tags: freezed == tags ? _self.tags : tags // ignore: cast_nullable_to_non_nullable
as List<SymbolTag>?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _BaseSymbolInformation implements BaseSymbolInformation {
  const _BaseSymbolInformation({required this.name, required this.kind, this.containerName, final  List<SymbolTag>? tags}): _tags = tags;
  factory _BaseSymbolInformation.fromJson(Map<String, dynamic> json) => _$BaseSymbolInformationFromJson(json);

@override final  String name;
@override final  SymbolKind kind;
@override final  String? containerName;
 final  List<SymbolTag>? _tags;
@override List<SymbolTag>? get tags {
  final value = _tags;
  if (value == null) return null;
  if (_tags is EqualUnmodifiableListView) return _tags;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}


/// Create a copy of BaseSymbolInformation
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$BaseSymbolInformationCopyWith<_BaseSymbolInformation> get copyWith => __$BaseSymbolInformationCopyWithImpl<_BaseSymbolInformation>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$BaseSymbolInformationToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _BaseSymbolInformation&&(identical(other.name, name) || other.name == name)&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.containerName, containerName) || other.containerName == containerName)&&const DeepCollectionEquality().equals(other._tags, _tags));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,name,kind,containerName,const DeepCollectionEquality().hash(_tags));

@override
String toString() {
  return 'BaseSymbolInformation(name: $name, kind: $kind, containerName: $containerName, tags: $tags)';
}


}

/// @nodoc
abstract mixin class _$BaseSymbolInformationCopyWith<$Res> implements $BaseSymbolInformationCopyWith<$Res> {
  factory _$BaseSymbolInformationCopyWith(_BaseSymbolInformation value, $Res Function(_BaseSymbolInformation) _then) = __$BaseSymbolInformationCopyWithImpl;
@override @useResult
$Res call({
 String name, SymbolKind kind, String? containerName, List<SymbolTag>? tags
});




}
/// @nodoc
class __$BaseSymbolInformationCopyWithImpl<$Res>
    implements _$BaseSymbolInformationCopyWith<$Res> {
  __$BaseSymbolInformationCopyWithImpl(this._self, this._then);

  final _BaseSymbolInformation _self;
  final $Res Function(_BaseSymbolInformation) _then;

/// Create a copy of BaseSymbolInformation
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? name = null,Object? kind = null,Object? containerName = freezed,Object? tags = freezed,}) {
  return _then(_BaseSymbolInformation(
name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as SymbolKind,containerName: freezed == containerName ? _self.containerName : containerName // ignore: cast_nullable_to_non_nullable
as String?,tags: freezed == tags ? _self._tags : tags // ignore: cast_nullable_to_non_nullable
as List<SymbolTag>?,
  ));
}


}


/// @nodoc
mixin _$DocumentSymbolOptions {

 String? get label; bool? get workDoneProgress;
/// Create a copy of DocumentSymbolOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentSymbolOptionsCopyWith<DocumentSymbolOptions> get copyWith => _$DocumentSymbolOptionsCopyWithImpl<DocumentSymbolOptions>(this as DocumentSymbolOptions, _$identity);

  /// Serializes this DocumentSymbolOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentSymbolOptions&&(identical(other.label, label) || other.label == label)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,label,workDoneProgress);

@override
String toString() {
  return 'DocumentSymbolOptions(label: $label, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $DocumentSymbolOptionsCopyWith<$Res>  {
  factory $DocumentSymbolOptionsCopyWith(DocumentSymbolOptions value, $Res Function(DocumentSymbolOptions) _then) = _$DocumentSymbolOptionsCopyWithImpl;
@useResult
$Res call({
 String? label, bool? workDoneProgress
});




}
/// @nodoc
class _$DocumentSymbolOptionsCopyWithImpl<$Res>
    implements $DocumentSymbolOptionsCopyWith<$Res> {
  _$DocumentSymbolOptionsCopyWithImpl(this._self, this._then);

  final DocumentSymbolOptions _self;
  final $Res Function(DocumentSymbolOptions) _then;

/// Create a copy of DocumentSymbolOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? label = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
label: freezed == label ? _self.label : label // ignore: cast_nullable_to_non_nullable
as String?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DocumentSymbolOptions implements DocumentSymbolOptions {
  const _DocumentSymbolOptions({this.label, this.workDoneProgress});
  factory _DocumentSymbolOptions.fromJson(Map<String, dynamic> json) => _$DocumentSymbolOptionsFromJson(json);

@override final  String? label;
@override final  bool? workDoneProgress;

/// Create a copy of DocumentSymbolOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentSymbolOptionsCopyWith<_DocumentSymbolOptions> get copyWith => __$DocumentSymbolOptionsCopyWithImpl<_DocumentSymbolOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentSymbolOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentSymbolOptions&&(identical(other.label, label) || other.label == label)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,label,workDoneProgress);

@override
String toString() {
  return 'DocumentSymbolOptions(label: $label, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$DocumentSymbolOptionsCopyWith<$Res> implements $DocumentSymbolOptionsCopyWith<$Res> {
  factory _$DocumentSymbolOptionsCopyWith(_DocumentSymbolOptions value, $Res Function(_DocumentSymbolOptions) _then) = __$DocumentSymbolOptionsCopyWithImpl;
@override @useResult
$Res call({
 String? label, bool? workDoneProgress
});




}
/// @nodoc
class __$DocumentSymbolOptionsCopyWithImpl<$Res>
    implements _$DocumentSymbolOptionsCopyWith<$Res> {
  __$DocumentSymbolOptionsCopyWithImpl(this._self, this._then);

  final _DocumentSymbolOptions _self;
  final $Res Function(_DocumentSymbolOptions) _then;

/// Create a copy of DocumentSymbolOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? label = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_DocumentSymbolOptions(
label: freezed == label ? _self.label : label // ignore: cast_nullable_to_non_nullable
as String?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$CodeActionContext {

 List<Diagnostic> get diagnostics; CodeActionTriggerKind? get triggerKind; List<CodeActionKind>? get only;
/// Create a copy of CodeActionContext
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CodeActionContextCopyWith<CodeActionContext> get copyWith => _$CodeActionContextCopyWithImpl<CodeActionContext>(this as CodeActionContext, _$identity);

  /// Serializes this CodeActionContext to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CodeActionContext&&const DeepCollectionEquality().equals(other.diagnostics, diagnostics)&&(identical(other.triggerKind, triggerKind) || other.triggerKind == triggerKind)&&const DeepCollectionEquality().equals(other.only, only));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(diagnostics),triggerKind,const DeepCollectionEquality().hash(only));

@override
String toString() {
  return 'CodeActionContext(diagnostics: $diagnostics, triggerKind: $triggerKind, only: $only)';
}


}

/// @nodoc
abstract mixin class $CodeActionContextCopyWith<$Res>  {
  factory $CodeActionContextCopyWith(CodeActionContext value, $Res Function(CodeActionContext) _then) = _$CodeActionContextCopyWithImpl;
@useResult
$Res call({
 List<Diagnostic> diagnostics, CodeActionTriggerKind? triggerKind, List<CodeActionKind>? only
});




}
/// @nodoc
class _$CodeActionContextCopyWithImpl<$Res>
    implements $CodeActionContextCopyWith<$Res> {
  _$CodeActionContextCopyWithImpl(this._self, this._then);

  final CodeActionContext _self;
  final $Res Function(CodeActionContext) _then;

/// Create a copy of CodeActionContext
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? diagnostics = null,Object? triggerKind = freezed,Object? only = freezed,}) {
  return _then(_self.copyWith(
diagnostics: null == diagnostics ? _self.diagnostics : diagnostics // ignore: cast_nullable_to_non_nullable
as List<Diagnostic>,triggerKind: freezed == triggerKind ? _self.triggerKind : triggerKind // ignore: cast_nullable_to_non_nullable
as CodeActionTriggerKind?,only: freezed == only ? _self.only : only // ignore: cast_nullable_to_non_nullable
as List<CodeActionKind>?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _CodeActionContext implements CodeActionContext {
  const _CodeActionContext({required final  List<Diagnostic> diagnostics, this.triggerKind, final  List<CodeActionKind>? only}): _diagnostics = diagnostics,_only = only;
  factory _CodeActionContext.fromJson(Map<String, dynamic> json) => _$CodeActionContextFromJson(json);

 final  List<Diagnostic> _diagnostics;
@override List<Diagnostic> get diagnostics {
  if (_diagnostics is EqualUnmodifiableListView) return _diagnostics;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_diagnostics);
}

@override final  CodeActionTriggerKind? triggerKind;
 final  List<CodeActionKind>? _only;
@override List<CodeActionKind>? get only {
  final value = _only;
  if (value == null) return null;
  if (_only is EqualUnmodifiableListView) return _only;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}


/// Create a copy of CodeActionContext
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CodeActionContextCopyWith<_CodeActionContext> get copyWith => __$CodeActionContextCopyWithImpl<_CodeActionContext>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CodeActionContextToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CodeActionContext&&const DeepCollectionEquality().equals(other._diagnostics, _diagnostics)&&(identical(other.triggerKind, triggerKind) || other.triggerKind == triggerKind)&&const DeepCollectionEquality().equals(other._only, _only));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_diagnostics),triggerKind,const DeepCollectionEquality().hash(_only));

@override
String toString() {
  return 'CodeActionContext(diagnostics: $diagnostics, triggerKind: $triggerKind, only: $only)';
}


}

/// @nodoc
abstract mixin class _$CodeActionContextCopyWith<$Res> implements $CodeActionContextCopyWith<$Res> {
  factory _$CodeActionContextCopyWith(_CodeActionContext value, $Res Function(_CodeActionContext) _then) = __$CodeActionContextCopyWithImpl;
@override @useResult
$Res call({
 List<Diagnostic> diagnostics, CodeActionTriggerKind? triggerKind, List<CodeActionKind>? only
});




}
/// @nodoc
class __$CodeActionContextCopyWithImpl<$Res>
    implements _$CodeActionContextCopyWith<$Res> {
  __$CodeActionContextCopyWithImpl(this._self, this._then);

  final _CodeActionContext _self;
  final $Res Function(_CodeActionContext) _then;

/// Create a copy of CodeActionContext
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? diagnostics = null,Object? triggerKind = freezed,Object? only = freezed,}) {
  return _then(_CodeActionContext(
diagnostics: null == diagnostics ? _self._diagnostics : diagnostics // ignore: cast_nullable_to_non_nullable
as List<Diagnostic>,triggerKind: freezed == triggerKind ? _self.triggerKind : triggerKind // ignore: cast_nullable_to_non_nullable
as CodeActionTriggerKind?,only: freezed == only ? _self._only : only // ignore: cast_nullable_to_non_nullable
as List<CodeActionKind>?,
  ));
}


}


/// @nodoc
mixin _$CodeActionOptions {

 bool? get resolveProvider; List<CodeActionKind>? get codeActionKinds; bool? get workDoneProgress;
/// Create a copy of CodeActionOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CodeActionOptionsCopyWith<CodeActionOptions> get copyWith => _$CodeActionOptionsCopyWithImpl<CodeActionOptions>(this as CodeActionOptions, _$identity);

  /// Serializes this CodeActionOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CodeActionOptions&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider)&&const DeepCollectionEquality().equals(other.codeActionKinds, codeActionKinds)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,resolveProvider,const DeepCollectionEquality().hash(codeActionKinds),workDoneProgress);

@override
String toString() {
  return 'CodeActionOptions(resolveProvider: $resolveProvider, codeActionKinds: $codeActionKinds, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $CodeActionOptionsCopyWith<$Res>  {
  factory $CodeActionOptionsCopyWith(CodeActionOptions value, $Res Function(CodeActionOptions) _then) = _$CodeActionOptionsCopyWithImpl;
@useResult
$Res call({
 bool? resolveProvider, List<CodeActionKind>? codeActionKinds, bool? workDoneProgress
});




}
/// @nodoc
class _$CodeActionOptionsCopyWithImpl<$Res>
    implements $CodeActionOptionsCopyWith<$Res> {
  _$CodeActionOptionsCopyWithImpl(this._self, this._then);

  final CodeActionOptions _self;
  final $Res Function(CodeActionOptions) _then;

/// Create a copy of CodeActionOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? resolveProvider = freezed,Object? codeActionKinds = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,codeActionKinds: freezed == codeActionKinds ? _self.codeActionKinds : codeActionKinds // ignore: cast_nullable_to_non_nullable
as List<CodeActionKind>?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _CodeActionOptions implements CodeActionOptions {
  const _CodeActionOptions({this.resolveProvider, final  List<CodeActionKind>? codeActionKinds, this.workDoneProgress}): _codeActionKinds = codeActionKinds;
  factory _CodeActionOptions.fromJson(Map<String, dynamic> json) => _$CodeActionOptionsFromJson(json);

@override final  bool? resolveProvider;
 final  List<CodeActionKind>? _codeActionKinds;
@override List<CodeActionKind>? get codeActionKinds {
  final value = _codeActionKinds;
  if (value == null) return null;
  if (_codeActionKinds is EqualUnmodifiableListView) return _codeActionKinds;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

@override final  bool? workDoneProgress;

/// Create a copy of CodeActionOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CodeActionOptionsCopyWith<_CodeActionOptions> get copyWith => __$CodeActionOptionsCopyWithImpl<_CodeActionOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CodeActionOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CodeActionOptions&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider)&&const DeepCollectionEquality().equals(other._codeActionKinds, _codeActionKinds)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,resolveProvider,const DeepCollectionEquality().hash(_codeActionKinds),workDoneProgress);

@override
String toString() {
  return 'CodeActionOptions(resolveProvider: $resolveProvider, codeActionKinds: $codeActionKinds, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$CodeActionOptionsCopyWith<$Res> implements $CodeActionOptionsCopyWith<$Res> {
  factory _$CodeActionOptionsCopyWith(_CodeActionOptions value, $Res Function(_CodeActionOptions) _then) = __$CodeActionOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? resolveProvider, List<CodeActionKind>? codeActionKinds, bool? workDoneProgress
});




}
/// @nodoc
class __$CodeActionOptionsCopyWithImpl<$Res>
    implements _$CodeActionOptionsCopyWith<$Res> {
  __$CodeActionOptionsCopyWithImpl(this._self, this._then);

  final _CodeActionOptions _self;
  final $Res Function(_CodeActionOptions) _then;

/// Create a copy of CodeActionOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? resolveProvider = freezed,Object? codeActionKinds = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_CodeActionOptions(
resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,codeActionKinds: freezed == codeActionKinds ? _self._codeActionKinds : codeActionKinds // ignore: cast_nullable_to_non_nullable
as List<CodeActionKind>?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$WorkspaceSymbolOptions {

 bool? get resolveProvider; bool? get workDoneProgress;
/// Create a copy of WorkspaceSymbolOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkspaceSymbolOptionsCopyWith<WorkspaceSymbolOptions> get copyWith => _$WorkspaceSymbolOptionsCopyWithImpl<WorkspaceSymbolOptions>(this as WorkspaceSymbolOptions, _$identity);

  /// Serializes this WorkspaceSymbolOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkspaceSymbolOptions&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,resolveProvider,workDoneProgress);

@override
String toString() {
  return 'WorkspaceSymbolOptions(resolveProvider: $resolveProvider, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $WorkspaceSymbolOptionsCopyWith<$Res>  {
  factory $WorkspaceSymbolOptionsCopyWith(WorkspaceSymbolOptions value, $Res Function(WorkspaceSymbolOptions) _then) = _$WorkspaceSymbolOptionsCopyWithImpl;
@useResult
$Res call({
 bool? resolveProvider, bool? workDoneProgress
});




}
/// @nodoc
class _$WorkspaceSymbolOptionsCopyWithImpl<$Res>
    implements $WorkspaceSymbolOptionsCopyWith<$Res> {
  _$WorkspaceSymbolOptionsCopyWithImpl(this._self, this._then);

  final WorkspaceSymbolOptions _self;
  final $Res Function(WorkspaceSymbolOptions) _then;

/// Create a copy of WorkspaceSymbolOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? resolveProvider = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _WorkspaceSymbolOptions implements WorkspaceSymbolOptions {
  const _WorkspaceSymbolOptions({this.resolveProvider, this.workDoneProgress});
  factory _WorkspaceSymbolOptions.fromJson(Map<String, dynamic> json) => _$WorkspaceSymbolOptionsFromJson(json);

@override final  bool? resolveProvider;
@override final  bool? workDoneProgress;

/// Create a copy of WorkspaceSymbolOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkspaceSymbolOptionsCopyWith<_WorkspaceSymbolOptions> get copyWith => __$WorkspaceSymbolOptionsCopyWithImpl<_WorkspaceSymbolOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkspaceSymbolOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkspaceSymbolOptions&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,resolveProvider,workDoneProgress);

@override
String toString() {
  return 'WorkspaceSymbolOptions(resolveProvider: $resolveProvider, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$WorkspaceSymbolOptionsCopyWith<$Res> implements $WorkspaceSymbolOptionsCopyWith<$Res> {
  factory _$WorkspaceSymbolOptionsCopyWith(_WorkspaceSymbolOptions value, $Res Function(_WorkspaceSymbolOptions) _then) = __$WorkspaceSymbolOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? resolveProvider, bool? workDoneProgress
});




}
/// @nodoc
class __$WorkspaceSymbolOptionsCopyWithImpl<$Res>
    implements _$WorkspaceSymbolOptionsCopyWith<$Res> {
  __$WorkspaceSymbolOptionsCopyWithImpl(this._self, this._then);

  final _WorkspaceSymbolOptions _self;
  final $Res Function(_WorkspaceSymbolOptions) _then;

/// Create a copy of WorkspaceSymbolOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? resolveProvider = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_WorkspaceSymbolOptions(
resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$CodeLensOptions {

 bool? get resolveProvider; bool? get workDoneProgress;
/// Create a copy of CodeLensOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CodeLensOptionsCopyWith<CodeLensOptions> get copyWith => _$CodeLensOptionsCopyWithImpl<CodeLensOptions>(this as CodeLensOptions, _$identity);

  /// Serializes this CodeLensOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CodeLensOptions&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,resolveProvider,workDoneProgress);

@override
String toString() {
  return 'CodeLensOptions(resolveProvider: $resolveProvider, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $CodeLensOptionsCopyWith<$Res>  {
  factory $CodeLensOptionsCopyWith(CodeLensOptions value, $Res Function(CodeLensOptions) _then) = _$CodeLensOptionsCopyWithImpl;
@useResult
$Res call({
 bool? resolveProvider, bool? workDoneProgress
});




}
/// @nodoc
class _$CodeLensOptionsCopyWithImpl<$Res>
    implements $CodeLensOptionsCopyWith<$Res> {
  _$CodeLensOptionsCopyWithImpl(this._self, this._then);

  final CodeLensOptions _self;
  final $Res Function(CodeLensOptions) _then;

/// Create a copy of CodeLensOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? resolveProvider = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _CodeLensOptions implements CodeLensOptions {
  const _CodeLensOptions({this.resolveProvider, this.workDoneProgress});
  factory _CodeLensOptions.fromJson(Map<String, dynamic> json) => _$CodeLensOptionsFromJson(json);

@override final  bool? resolveProvider;
@override final  bool? workDoneProgress;

/// Create a copy of CodeLensOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CodeLensOptionsCopyWith<_CodeLensOptions> get copyWith => __$CodeLensOptionsCopyWithImpl<_CodeLensOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CodeLensOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CodeLensOptions&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,resolveProvider,workDoneProgress);

@override
String toString() {
  return 'CodeLensOptions(resolveProvider: $resolveProvider, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$CodeLensOptionsCopyWith<$Res> implements $CodeLensOptionsCopyWith<$Res> {
  factory _$CodeLensOptionsCopyWith(_CodeLensOptions value, $Res Function(_CodeLensOptions) _then) = __$CodeLensOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? resolveProvider, bool? workDoneProgress
});




}
/// @nodoc
class __$CodeLensOptionsCopyWithImpl<$Res>
    implements _$CodeLensOptionsCopyWith<$Res> {
  __$CodeLensOptionsCopyWithImpl(this._self, this._then);

  final _CodeLensOptions _self;
  final $Res Function(_CodeLensOptions) _then;

/// Create a copy of CodeLensOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? resolveProvider = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_CodeLensOptions(
resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DocumentLinkOptions {

 bool? get resolveProvider; bool? get workDoneProgress;
/// Create a copy of DocumentLinkOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentLinkOptionsCopyWith<DocumentLinkOptions> get copyWith => _$DocumentLinkOptionsCopyWithImpl<DocumentLinkOptions>(this as DocumentLinkOptions, _$identity);

  /// Serializes this DocumentLinkOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentLinkOptions&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,resolveProvider,workDoneProgress);

@override
String toString() {
  return 'DocumentLinkOptions(resolveProvider: $resolveProvider, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $DocumentLinkOptionsCopyWith<$Res>  {
  factory $DocumentLinkOptionsCopyWith(DocumentLinkOptions value, $Res Function(DocumentLinkOptions) _then) = _$DocumentLinkOptionsCopyWithImpl;
@useResult
$Res call({
 bool? resolveProvider, bool? workDoneProgress
});




}
/// @nodoc
class _$DocumentLinkOptionsCopyWithImpl<$Res>
    implements $DocumentLinkOptionsCopyWith<$Res> {
  _$DocumentLinkOptionsCopyWithImpl(this._self, this._then);

  final DocumentLinkOptions _self;
  final $Res Function(DocumentLinkOptions) _then;

/// Create a copy of DocumentLinkOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? resolveProvider = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DocumentLinkOptions implements DocumentLinkOptions {
  const _DocumentLinkOptions({this.resolveProvider, this.workDoneProgress});
  factory _DocumentLinkOptions.fromJson(Map<String, dynamic> json) => _$DocumentLinkOptionsFromJson(json);

@override final  bool? resolveProvider;
@override final  bool? workDoneProgress;

/// Create a copy of DocumentLinkOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentLinkOptionsCopyWith<_DocumentLinkOptions> get copyWith => __$DocumentLinkOptionsCopyWithImpl<_DocumentLinkOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentLinkOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentLinkOptions&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,resolveProvider,workDoneProgress);

@override
String toString() {
  return 'DocumentLinkOptions(resolveProvider: $resolveProvider, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$DocumentLinkOptionsCopyWith<$Res> implements $DocumentLinkOptionsCopyWith<$Res> {
  factory _$DocumentLinkOptionsCopyWith(_DocumentLinkOptions value, $Res Function(_DocumentLinkOptions) _then) = __$DocumentLinkOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? resolveProvider, bool? workDoneProgress
});




}
/// @nodoc
class __$DocumentLinkOptionsCopyWithImpl<$Res>
    implements _$DocumentLinkOptionsCopyWith<$Res> {
  __$DocumentLinkOptionsCopyWithImpl(this._self, this._then);

  final _DocumentLinkOptions _self;
  final $Res Function(_DocumentLinkOptions) _then;

/// Create a copy of DocumentLinkOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? resolveProvider = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_DocumentLinkOptions(
resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$FormattingOptions {

 int get tabSize; bool get insertSpaces; bool? get trimFinalNewlines; bool? get insertFinalNewline; bool? get trimTrailingWhitespace;
/// Create a copy of FormattingOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FormattingOptionsCopyWith<FormattingOptions> get copyWith => _$FormattingOptionsCopyWithImpl<FormattingOptions>(this as FormattingOptions, _$identity);

  /// Serializes this FormattingOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FormattingOptions&&(identical(other.tabSize, tabSize) || other.tabSize == tabSize)&&(identical(other.insertSpaces, insertSpaces) || other.insertSpaces == insertSpaces)&&(identical(other.trimFinalNewlines, trimFinalNewlines) || other.trimFinalNewlines == trimFinalNewlines)&&(identical(other.insertFinalNewline, insertFinalNewline) || other.insertFinalNewline == insertFinalNewline)&&(identical(other.trimTrailingWhitespace, trimTrailingWhitespace) || other.trimTrailingWhitespace == trimTrailingWhitespace));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,tabSize,insertSpaces,trimFinalNewlines,insertFinalNewline,trimTrailingWhitespace);

@override
String toString() {
  return 'FormattingOptions(tabSize: $tabSize, insertSpaces: $insertSpaces, trimFinalNewlines: $trimFinalNewlines, insertFinalNewline: $insertFinalNewline, trimTrailingWhitespace: $trimTrailingWhitespace)';
}


}

/// @nodoc
abstract mixin class $FormattingOptionsCopyWith<$Res>  {
  factory $FormattingOptionsCopyWith(FormattingOptions value, $Res Function(FormattingOptions) _then) = _$FormattingOptionsCopyWithImpl;
@useResult
$Res call({
 int tabSize, bool insertSpaces, bool? trimFinalNewlines, bool? insertFinalNewline, bool? trimTrailingWhitespace
});




}
/// @nodoc
class _$FormattingOptionsCopyWithImpl<$Res>
    implements $FormattingOptionsCopyWith<$Res> {
  _$FormattingOptionsCopyWithImpl(this._self, this._then);

  final FormattingOptions _self;
  final $Res Function(FormattingOptions) _then;

/// Create a copy of FormattingOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? tabSize = null,Object? insertSpaces = null,Object? trimFinalNewlines = freezed,Object? insertFinalNewline = freezed,Object? trimTrailingWhitespace = freezed,}) {
  return _then(_self.copyWith(
tabSize: null == tabSize ? _self.tabSize : tabSize // ignore: cast_nullable_to_non_nullable
as int,insertSpaces: null == insertSpaces ? _self.insertSpaces : insertSpaces // ignore: cast_nullable_to_non_nullable
as bool,trimFinalNewlines: freezed == trimFinalNewlines ? _self.trimFinalNewlines : trimFinalNewlines // ignore: cast_nullable_to_non_nullable
as bool?,insertFinalNewline: freezed == insertFinalNewline ? _self.insertFinalNewline : insertFinalNewline // ignore: cast_nullable_to_non_nullable
as bool?,trimTrailingWhitespace: freezed == trimTrailingWhitespace ? _self.trimTrailingWhitespace : trimTrailingWhitespace // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _FormattingOptions implements FormattingOptions {
  const _FormattingOptions({required this.tabSize, required this.insertSpaces, this.trimFinalNewlines, this.insertFinalNewline, this.trimTrailingWhitespace});
  factory _FormattingOptions.fromJson(Map<String, dynamic> json) => _$FormattingOptionsFromJson(json);

@override final  int tabSize;
@override final  bool insertSpaces;
@override final  bool? trimFinalNewlines;
@override final  bool? insertFinalNewline;
@override final  bool? trimTrailingWhitespace;

/// Create a copy of FormattingOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$FormattingOptionsCopyWith<_FormattingOptions> get copyWith => __$FormattingOptionsCopyWithImpl<_FormattingOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$FormattingOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _FormattingOptions&&(identical(other.tabSize, tabSize) || other.tabSize == tabSize)&&(identical(other.insertSpaces, insertSpaces) || other.insertSpaces == insertSpaces)&&(identical(other.trimFinalNewlines, trimFinalNewlines) || other.trimFinalNewlines == trimFinalNewlines)&&(identical(other.insertFinalNewline, insertFinalNewline) || other.insertFinalNewline == insertFinalNewline)&&(identical(other.trimTrailingWhitespace, trimTrailingWhitespace) || other.trimTrailingWhitespace == trimTrailingWhitespace));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,tabSize,insertSpaces,trimFinalNewlines,insertFinalNewline,trimTrailingWhitespace);

@override
String toString() {
  return 'FormattingOptions(tabSize: $tabSize, insertSpaces: $insertSpaces, trimFinalNewlines: $trimFinalNewlines, insertFinalNewline: $insertFinalNewline, trimTrailingWhitespace: $trimTrailingWhitespace)';
}


}

/// @nodoc
abstract mixin class _$FormattingOptionsCopyWith<$Res> implements $FormattingOptionsCopyWith<$Res> {
  factory _$FormattingOptionsCopyWith(_FormattingOptions value, $Res Function(_FormattingOptions) _then) = __$FormattingOptionsCopyWithImpl;
@override @useResult
$Res call({
 int tabSize, bool insertSpaces, bool? trimFinalNewlines, bool? insertFinalNewline, bool? trimTrailingWhitespace
});




}
/// @nodoc
class __$FormattingOptionsCopyWithImpl<$Res>
    implements _$FormattingOptionsCopyWith<$Res> {
  __$FormattingOptionsCopyWithImpl(this._self, this._then);

  final _FormattingOptions _self;
  final $Res Function(_FormattingOptions) _then;

/// Create a copy of FormattingOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? tabSize = null,Object? insertSpaces = null,Object? trimFinalNewlines = freezed,Object? insertFinalNewline = freezed,Object? trimTrailingWhitespace = freezed,}) {
  return _then(_FormattingOptions(
tabSize: null == tabSize ? _self.tabSize : tabSize // ignore: cast_nullable_to_non_nullable
as int,insertSpaces: null == insertSpaces ? _self.insertSpaces : insertSpaces // ignore: cast_nullable_to_non_nullable
as bool,trimFinalNewlines: freezed == trimFinalNewlines ? _self.trimFinalNewlines : trimFinalNewlines // ignore: cast_nullable_to_non_nullable
as bool?,insertFinalNewline: freezed == insertFinalNewline ? _self.insertFinalNewline : insertFinalNewline // ignore: cast_nullable_to_non_nullable
as bool?,trimTrailingWhitespace: freezed == trimTrailingWhitespace ? _self.trimTrailingWhitespace : trimTrailingWhitespace // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DocumentFormattingOptions {

 bool? get workDoneProgress;
/// Create a copy of DocumentFormattingOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentFormattingOptionsCopyWith<DocumentFormattingOptions> get copyWith => _$DocumentFormattingOptionsCopyWithImpl<DocumentFormattingOptions>(this as DocumentFormattingOptions, _$identity);

  /// Serializes this DocumentFormattingOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentFormattingOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'DocumentFormattingOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $DocumentFormattingOptionsCopyWith<$Res>  {
  factory $DocumentFormattingOptionsCopyWith(DocumentFormattingOptions value, $Res Function(DocumentFormattingOptions) _then) = _$DocumentFormattingOptionsCopyWithImpl;
@useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class _$DocumentFormattingOptionsCopyWithImpl<$Res>
    implements $DocumentFormattingOptionsCopyWith<$Res> {
  _$DocumentFormattingOptionsCopyWithImpl(this._self, this._then);

  final DocumentFormattingOptions _self;
  final $Res Function(DocumentFormattingOptions) _then;

/// Create a copy of DocumentFormattingOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DocumentFormattingOptions implements DocumentFormattingOptions {
  const _DocumentFormattingOptions({this.workDoneProgress});
  factory _DocumentFormattingOptions.fromJson(Map<String, dynamic> json) => _$DocumentFormattingOptionsFromJson(json);

@override final  bool? workDoneProgress;

/// Create a copy of DocumentFormattingOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentFormattingOptionsCopyWith<_DocumentFormattingOptions> get copyWith => __$DocumentFormattingOptionsCopyWithImpl<_DocumentFormattingOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentFormattingOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentFormattingOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'DocumentFormattingOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$DocumentFormattingOptionsCopyWith<$Res> implements $DocumentFormattingOptionsCopyWith<$Res> {
  factory _$DocumentFormattingOptionsCopyWith(_DocumentFormattingOptions value, $Res Function(_DocumentFormattingOptions) _then) = __$DocumentFormattingOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class __$DocumentFormattingOptionsCopyWithImpl<$Res>
    implements _$DocumentFormattingOptionsCopyWith<$Res> {
  __$DocumentFormattingOptionsCopyWithImpl(this._self, this._then);

  final _DocumentFormattingOptions _self;
  final $Res Function(_DocumentFormattingOptions) _then;

/// Create a copy of DocumentFormattingOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_DocumentFormattingOptions(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DocumentRangeFormattingOptions {

 bool? get rangesSupport; bool? get workDoneProgress;
/// Create a copy of DocumentRangeFormattingOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentRangeFormattingOptionsCopyWith<DocumentRangeFormattingOptions> get copyWith => _$DocumentRangeFormattingOptionsCopyWithImpl<DocumentRangeFormattingOptions>(this as DocumentRangeFormattingOptions, _$identity);

  /// Serializes this DocumentRangeFormattingOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentRangeFormattingOptions&&(identical(other.rangesSupport, rangesSupport) || other.rangesSupport == rangesSupport)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,rangesSupport,workDoneProgress);

@override
String toString() {
  return 'DocumentRangeFormattingOptions(rangesSupport: $rangesSupport, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $DocumentRangeFormattingOptionsCopyWith<$Res>  {
  factory $DocumentRangeFormattingOptionsCopyWith(DocumentRangeFormattingOptions value, $Res Function(DocumentRangeFormattingOptions) _then) = _$DocumentRangeFormattingOptionsCopyWithImpl;
@useResult
$Res call({
 bool? rangesSupport, bool? workDoneProgress
});




}
/// @nodoc
class _$DocumentRangeFormattingOptionsCopyWithImpl<$Res>
    implements $DocumentRangeFormattingOptionsCopyWith<$Res> {
  _$DocumentRangeFormattingOptionsCopyWithImpl(this._self, this._then);

  final DocumentRangeFormattingOptions _self;
  final $Res Function(DocumentRangeFormattingOptions) _then;

/// Create a copy of DocumentRangeFormattingOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? rangesSupport = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
rangesSupport: freezed == rangesSupport ? _self.rangesSupport : rangesSupport // ignore: cast_nullable_to_non_nullable
as bool?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DocumentRangeFormattingOptions implements DocumentRangeFormattingOptions {
  const _DocumentRangeFormattingOptions({this.rangesSupport, this.workDoneProgress});
  factory _DocumentRangeFormattingOptions.fromJson(Map<String, dynamic> json) => _$DocumentRangeFormattingOptionsFromJson(json);

@override final  bool? rangesSupport;
@override final  bool? workDoneProgress;

/// Create a copy of DocumentRangeFormattingOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentRangeFormattingOptionsCopyWith<_DocumentRangeFormattingOptions> get copyWith => __$DocumentRangeFormattingOptionsCopyWithImpl<_DocumentRangeFormattingOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentRangeFormattingOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentRangeFormattingOptions&&(identical(other.rangesSupport, rangesSupport) || other.rangesSupport == rangesSupport)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,rangesSupport,workDoneProgress);

@override
String toString() {
  return 'DocumentRangeFormattingOptions(rangesSupport: $rangesSupport, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$DocumentRangeFormattingOptionsCopyWith<$Res> implements $DocumentRangeFormattingOptionsCopyWith<$Res> {
  factory _$DocumentRangeFormattingOptionsCopyWith(_DocumentRangeFormattingOptions value, $Res Function(_DocumentRangeFormattingOptions) _then) = __$DocumentRangeFormattingOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? rangesSupport, bool? workDoneProgress
});




}
/// @nodoc
class __$DocumentRangeFormattingOptionsCopyWithImpl<$Res>
    implements _$DocumentRangeFormattingOptionsCopyWith<$Res> {
  __$DocumentRangeFormattingOptionsCopyWithImpl(this._self, this._then);

  final _DocumentRangeFormattingOptions _self;
  final $Res Function(_DocumentRangeFormattingOptions) _then;

/// Create a copy of DocumentRangeFormattingOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? rangesSupport = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_DocumentRangeFormattingOptions(
rangesSupport: freezed == rangesSupport ? _self.rangesSupport : rangesSupport // ignore: cast_nullable_to_non_nullable
as bool?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DocumentOnTypeFormattingOptions {

 String get firstTriggerCharacter; List<String>? get moreTriggerCharacter;
/// Create a copy of DocumentOnTypeFormattingOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentOnTypeFormattingOptionsCopyWith<DocumentOnTypeFormattingOptions> get copyWith => _$DocumentOnTypeFormattingOptionsCopyWithImpl<DocumentOnTypeFormattingOptions>(this as DocumentOnTypeFormattingOptions, _$identity);

  /// Serializes this DocumentOnTypeFormattingOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentOnTypeFormattingOptions&&(identical(other.firstTriggerCharacter, firstTriggerCharacter) || other.firstTriggerCharacter == firstTriggerCharacter)&&const DeepCollectionEquality().equals(other.moreTriggerCharacter, moreTriggerCharacter));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,firstTriggerCharacter,const DeepCollectionEquality().hash(moreTriggerCharacter));

@override
String toString() {
  return 'DocumentOnTypeFormattingOptions(firstTriggerCharacter: $firstTriggerCharacter, moreTriggerCharacter: $moreTriggerCharacter)';
}


}

/// @nodoc
abstract mixin class $DocumentOnTypeFormattingOptionsCopyWith<$Res>  {
  factory $DocumentOnTypeFormattingOptionsCopyWith(DocumentOnTypeFormattingOptions value, $Res Function(DocumentOnTypeFormattingOptions) _then) = _$DocumentOnTypeFormattingOptionsCopyWithImpl;
@useResult
$Res call({
 String firstTriggerCharacter, List<String>? moreTriggerCharacter
});




}
/// @nodoc
class _$DocumentOnTypeFormattingOptionsCopyWithImpl<$Res>
    implements $DocumentOnTypeFormattingOptionsCopyWith<$Res> {
  _$DocumentOnTypeFormattingOptionsCopyWithImpl(this._self, this._then);

  final DocumentOnTypeFormattingOptions _self;
  final $Res Function(DocumentOnTypeFormattingOptions) _then;

/// Create a copy of DocumentOnTypeFormattingOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? firstTriggerCharacter = null,Object? moreTriggerCharacter = freezed,}) {
  return _then(_self.copyWith(
firstTriggerCharacter: null == firstTriggerCharacter ? _self.firstTriggerCharacter : firstTriggerCharacter // ignore: cast_nullable_to_non_nullable
as String,moreTriggerCharacter: freezed == moreTriggerCharacter ? _self.moreTriggerCharacter : moreTriggerCharacter // ignore: cast_nullable_to_non_nullable
as List<String>?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DocumentOnTypeFormattingOptions implements DocumentOnTypeFormattingOptions {
  const _DocumentOnTypeFormattingOptions({required this.firstTriggerCharacter, final  List<String>? moreTriggerCharacter}): _moreTriggerCharacter = moreTriggerCharacter;
  factory _DocumentOnTypeFormattingOptions.fromJson(Map<String, dynamic> json) => _$DocumentOnTypeFormattingOptionsFromJson(json);

@override final  String firstTriggerCharacter;
 final  List<String>? _moreTriggerCharacter;
@override List<String>? get moreTriggerCharacter {
  final value = _moreTriggerCharacter;
  if (value == null) return null;
  if (_moreTriggerCharacter is EqualUnmodifiableListView) return _moreTriggerCharacter;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}


/// Create a copy of DocumentOnTypeFormattingOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentOnTypeFormattingOptionsCopyWith<_DocumentOnTypeFormattingOptions> get copyWith => __$DocumentOnTypeFormattingOptionsCopyWithImpl<_DocumentOnTypeFormattingOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentOnTypeFormattingOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentOnTypeFormattingOptions&&(identical(other.firstTriggerCharacter, firstTriggerCharacter) || other.firstTriggerCharacter == firstTriggerCharacter)&&const DeepCollectionEquality().equals(other._moreTriggerCharacter, _moreTriggerCharacter));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,firstTriggerCharacter,const DeepCollectionEquality().hash(_moreTriggerCharacter));

@override
String toString() {
  return 'DocumentOnTypeFormattingOptions(firstTriggerCharacter: $firstTriggerCharacter, moreTriggerCharacter: $moreTriggerCharacter)';
}


}

/// @nodoc
abstract mixin class _$DocumentOnTypeFormattingOptionsCopyWith<$Res> implements $DocumentOnTypeFormattingOptionsCopyWith<$Res> {
  factory _$DocumentOnTypeFormattingOptionsCopyWith(_DocumentOnTypeFormattingOptions value, $Res Function(_DocumentOnTypeFormattingOptions) _then) = __$DocumentOnTypeFormattingOptionsCopyWithImpl;
@override @useResult
$Res call({
 String firstTriggerCharacter, List<String>? moreTriggerCharacter
});




}
/// @nodoc
class __$DocumentOnTypeFormattingOptionsCopyWithImpl<$Res>
    implements _$DocumentOnTypeFormattingOptionsCopyWith<$Res> {
  __$DocumentOnTypeFormattingOptionsCopyWithImpl(this._self, this._then);

  final _DocumentOnTypeFormattingOptions _self;
  final $Res Function(_DocumentOnTypeFormattingOptions) _then;

/// Create a copy of DocumentOnTypeFormattingOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? firstTriggerCharacter = null,Object? moreTriggerCharacter = freezed,}) {
  return _then(_DocumentOnTypeFormattingOptions(
firstTriggerCharacter: null == firstTriggerCharacter ? _self.firstTriggerCharacter : firstTriggerCharacter // ignore: cast_nullable_to_non_nullable
as String,moreTriggerCharacter: freezed == moreTriggerCharacter ? _self._moreTriggerCharacter : moreTriggerCharacter // ignore: cast_nullable_to_non_nullable
as List<String>?,
  ));
}


}


/// @nodoc
mixin _$RenameOptions {

 bool? get prepareProvider; bool? get workDoneProgress;
/// Create a copy of RenameOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RenameOptionsCopyWith<RenameOptions> get copyWith => _$RenameOptionsCopyWithImpl<RenameOptions>(this as RenameOptions, _$identity);

  /// Serializes this RenameOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RenameOptions&&(identical(other.prepareProvider, prepareProvider) || other.prepareProvider == prepareProvider)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,prepareProvider,workDoneProgress);

@override
String toString() {
  return 'RenameOptions(prepareProvider: $prepareProvider, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $RenameOptionsCopyWith<$Res>  {
  factory $RenameOptionsCopyWith(RenameOptions value, $Res Function(RenameOptions) _then) = _$RenameOptionsCopyWithImpl;
@useResult
$Res call({
 bool? prepareProvider, bool? workDoneProgress
});




}
/// @nodoc
class _$RenameOptionsCopyWithImpl<$Res>
    implements $RenameOptionsCopyWith<$Res> {
  _$RenameOptionsCopyWithImpl(this._self, this._then);

  final RenameOptions _self;
  final $Res Function(RenameOptions) _then;

/// Create a copy of RenameOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? prepareProvider = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
prepareProvider: freezed == prepareProvider ? _self.prepareProvider : prepareProvider // ignore: cast_nullable_to_non_nullable
as bool?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _RenameOptions implements RenameOptions {
  const _RenameOptions({this.prepareProvider, this.workDoneProgress});
  factory _RenameOptions.fromJson(Map<String, dynamic> json) => _$RenameOptionsFromJson(json);

@override final  bool? prepareProvider;
@override final  bool? workDoneProgress;

/// Create a copy of RenameOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RenameOptionsCopyWith<_RenameOptions> get copyWith => __$RenameOptionsCopyWithImpl<_RenameOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$RenameOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _RenameOptions&&(identical(other.prepareProvider, prepareProvider) || other.prepareProvider == prepareProvider)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,prepareProvider,workDoneProgress);

@override
String toString() {
  return 'RenameOptions(prepareProvider: $prepareProvider, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$RenameOptionsCopyWith<$Res> implements $RenameOptionsCopyWith<$Res> {
  factory _$RenameOptionsCopyWith(_RenameOptions value, $Res Function(_RenameOptions) _then) = __$RenameOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? prepareProvider, bool? workDoneProgress
});




}
/// @nodoc
class __$RenameOptionsCopyWithImpl<$Res>
    implements _$RenameOptionsCopyWith<$Res> {
  __$RenameOptionsCopyWithImpl(this._self, this._then);

  final _RenameOptions _self;
  final $Res Function(_RenameOptions) _then;

/// Create a copy of RenameOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? prepareProvider = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_RenameOptions(
prepareProvider: freezed == prepareProvider ? _self.prepareProvider : prepareProvider // ignore: cast_nullable_to_non_nullable
as bool?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$ExecuteCommandOptions {

 List<String> get commands; bool? get workDoneProgress;
/// Create a copy of ExecuteCommandOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ExecuteCommandOptionsCopyWith<ExecuteCommandOptions> get copyWith => _$ExecuteCommandOptionsCopyWithImpl<ExecuteCommandOptions>(this as ExecuteCommandOptions, _$identity);

  /// Serializes this ExecuteCommandOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ExecuteCommandOptions&&const DeepCollectionEquality().equals(other.commands, commands)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(commands),workDoneProgress);

@override
String toString() {
  return 'ExecuteCommandOptions(commands: $commands, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $ExecuteCommandOptionsCopyWith<$Res>  {
  factory $ExecuteCommandOptionsCopyWith(ExecuteCommandOptions value, $Res Function(ExecuteCommandOptions) _then) = _$ExecuteCommandOptionsCopyWithImpl;
@useResult
$Res call({
 List<String> commands, bool? workDoneProgress
});




}
/// @nodoc
class _$ExecuteCommandOptionsCopyWithImpl<$Res>
    implements $ExecuteCommandOptionsCopyWith<$Res> {
  _$ExecuteCommandOptionsCopyWithImpl(this._self, this._then);

  final ExecuteCommandOptions _self;
  final $Res Function(ExecuteCommandOptions) _then;

/// Create a copy of ExecuteCommandOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? commands = null,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
commands: null == commands ? _self.commands : commands // ignore: cast_nullable_to_non_nullable
as List<String>,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _ExecuteCommandOptions implements ExecuteCommandOptions {
  const _ExecuteCommandOptions({required final  List<String> commands, this.workDoneProgress}): _commands = commands;
  factory _ExecuteCommandOptions.fromJson(Map<String, dynamic> json) => _$ExecuteCommandOptionsFromJson(json);

 final  List<String> _commands;
@override List<String> get commands {
  if (_commands is EqualUnmodifiableListView) return _commands;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_commands);
}

@override final  bool? workDoneProgress;

/// Create a copy of ExecuteCommandOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ExecuteCommandOptionsCopyWith<_ExecuteCommandOptions> get copyWith => __$ExecuteCommandOptionsCopyWithImpl<_ExecuteCommandOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ExecuteCommandOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ExecuteCommandOptions&&const DeepCollectionEquality().equals(other._commands, _commands)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_commands),workDoneProgress);

@override
String toString() {
  return 'ExecuteCommandOptions(commands: $commands, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$ExecuteCommandOptionsCopyWith<$Res> implements $ExecuteCommandOptionsCopyWith<$Res> {
  factory _$ExecuteCommandOptionsCopyWith(_ExecuteCommandOptions value, $Res Function(_ExecuteCommandOptions) _then) = __$ExecuteCommandOptionsCopyWithImpl;
@override @useResult
$Res call({
 List<String> commands, bool? workDoneProgress
});




}
/// @nodoc
class __$ExecuteCommandOptionsCopyWithImpl<$Res>
    implements _$ExecuteCommandOptionsCopyWith<$Res> {
  __$ExecuteCommandOptionsCopyWithImpl(this._self, this._then);

  final _ExecuteCommandOptions _self;
  final $Res Function(_ExecuteCommandOptions) _then;

/// Create a copy of ExecuteCommandOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? commands = null,Object? workDoneProgress = freezed,}) {
  return _then(_ExecuteCommandOptions(
commands: null == commands ? _self._commands : commands // ignore: cast_nullable_to_non_nullable
as List<String>,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$SemanticTokensLegend {

 List<String> get tokenTypes; List<String> get tokenModifiers;
/// Create a copy of SemanticTokensLegend
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SemanticTokensLegendCopyWith<SemanticTokensLegend> get copyWith => _$SemanticTokensLegendCopyWithImpl<SemanticTokensLegend>(this as SemanticTokensLegend, _$identity);

  /// Serializes this SemanticTokensLegend to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SemanticTokensLegend&&const DeepCollectionEquality().equals(other.tokenTypes, tokenTypes)&&const DeepCollectionEquality().equals(other.tokenModifiers, tokenModifiers));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(tokenTypes),const DeepCollectionEquality().hash(tokenModifiers));

@override
String toString() {
  return 'SemanticTokensLegend(tokenTypes: $tokenTypes, tokenModifiers: $tokenModifiers)';
}


}

/// @nodoc
abstract mixin class $SemanticTokensLegendCopyWith<$Res>  {
  factory $SemanticTokensLegendCopyWith(SemanticTokensLegend value, $Res Function(SemanticTokensLegend) _then) = _$SemanticTokensLegendCopyWithImpl;
@useResult
$Res call({
 List<String> tokenTypes, List<String> tokenModifiers
});




}
/// @nodoc
class _$SemanticTokensLegendCopyWithImpl<$Res>
    implements $SemanticTokensLegendCopyWith<$Res> {
  _$SemanticTokensLegendCopyWithImpl(this._self, this._then);

  final SemanticTokensLegend _self;
  final $Res Function(SemanticTokensLegend) _then;

/// Create a copy of SemanticTokensLegend
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? tokenTypes = null,Object? tokenModifiers = null,}) {
  return _then(_self.copyWith(
tokenTypes: null == tokenTypes ? _self.tokenTypes : tokenTypes // ignore: cast_nullable_to_non_nullable
as List<String>,tokenModifiers: null == tokenModifiers ? _self.tokenModifiers : tokenModifiers // ignore: cast_nullable_to_non_nullable
as List<String>,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _SemanticTokensLegend implements SemanticTokensLegend {
  const _SemanticTokensLegend({required final  List<String> tokenTypes, required final  List<String> tokenModifiers}): _tokenTypes = tokenTypes,_tokenModifiers = tokenModifiers;
  factory _SemanticTokensLegend.fromJson(Map<String, dynamic> json) => _$SemanticTokensLegendFromJson(json);

 final  List<String> _tokenTypes;
@override List<String> get tokenTypes {
  if (_tokenTypes is EqualUnmodifiableListView) return _tokenTypes;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_tokenTypes);
}

 final  List<String> _tokenModifiers;
@override List<String> get tokenModifiers {
  if (_tokenModifiers is EqualUnmodifiableListView) return _tokenModifiers;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_tokenModifiers);
}


/// Create a copy of SemanticTokensLegend
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SemanticTokensLegendCopyWith<_SemanticTokensLegend> get copyWith => __$SemanticTokensLegendCopyWithImpl<_SemanticTokensLegend>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SemanticTokensLegendToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SemanticTokensLegend&&const DeepCollectionEquality().equals(other._tokenTypes, _tokenTypes)&&const DeepCollectionEquality().equals(other._tokenModifiers, _tokenModifiers));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_tokenTypes),const DeepCollectionEquality().hash(_tokenModifiers));

@override
String toString() {
  return 'SemanticTokensLegend(tokenTypes: $tokenTypes, tokenModifiers: $tokenModifiers)';
}


}

/// @nodoc
abstract mixin class _$SemanticTokensLegendCopyWith<$Res> implements $SemanticTokensLegendCopyWith<$Res> {
  factory _$SemanticTokensLegendCopyWith(_SemanticTokensLegend value, $Res Function(_SemanticTokensLegend) _then) = __$SemanticTokensLegendCopyWithImpl;
@override @useResult
$Res call({
 List<String> tokenTypes, List<String> tokenModifiers
});




}
/// @nodoc
class __$SemanticTokensLegendCopyWithImpl<$Res>
    implements _$SemanticTokensLegendCopyWith<$Res> {
  __$SemanticTokensLegendCopyWithImpl(this._self, this._then);

  final _SemanticTokensLegend _self;
  final $Res Function(_SemanticTokensLegend) _then;

/// Create a copy of SemanticTokensLegend
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? tokenTypes = null,Object? tokenModifiers = null,}) {
  return _then(_SemanticTokensLegend(
tokenTypes: null == tokenTypes ? _self._tokenTypes : tokenTypes // ignore: cast_nullable_to_non_nullable
as List<String>,tokenModifiers: null == tokenModifiers ? _self._tokenModifiers : tokenModifiers // ignore: cast_nullable_to_non_nullable
as List<String>,
  ));
}


}


/// @nodoc
mixin _$OptionalVersionedTextDocumentIdentifier {

 String get uri; dynamic get version;
/// Create a copy of OptionalVersionedTextDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$OptionalVersionedTextDocumentIdentifierCopyWith<OptionalVersionedTextDocumentIdentifier> get copyWith => _$OptionalVersionedTextDocumentIdentifierCopyWithImpl<OptionalVersionedTextDocumentIdentifier>(this as OptionalVersionedTextDocumentIdentifier, _$identity);

  /// Serializes this OptionalVersionedTextDocumentIdentifier to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is OptionalVersionedTextDocumentIdentifier&&(identical(other.uri, uri) || other.uri == uri)&&const DeepCollectionEquality().equals(other.version, version));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri,const DeepCollectionEquality().hash(version));

@override
String toString() {
  return 'OptionalVersionedTextDocumentIdentifier(uri: $uri, version: $version)';
}


}

/// @nodoc
abstract mixin class $OptionalVersionedTextDocumentIdentifierCopyWith<$Res>  {
  factory $OptionalVersionedTextDocumentIdentifierCopyWith(OptionalVersionedTextDocumentIdentifier value, $Res Function(OptionalVersionedTextDocumentIdentifier) _then) = _$OptionalVersionedTextDocumentIdentifierCopyWithImpl;
@useResult
$Res call({
 String uri, dynamic version
});




}
/// @nodoc
class _$OptionalVersionedTextDocumentIdentifierCopyWithImpl<$Res>
    implements $OptionalVersionedTextDocumentIdentifierCopyWith<$Res> {
  _$OptionalVersionedTextDocumentIdentifierCopyWithImpl(this._self, this._then);

  final OptionalVersionedTextDocumentIdentifier _self;
  final $Res Function(OptionalVersionedTextDocumentIdentifier) _then;

/// Create a copy of OptionalVersionedTextDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? uri = null,Object? version = freezed,}) {
  return _then(_self.copyWith(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,version: freezed == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as dynamic,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _OptionalVersionedTextDocumentIdentifier implements OptionalVersionedTextDocumentIdentifier {
  const _OptionalVersionedTextDocumentIdentifier({required this.uri, required this.version});
  factory _OptionalVersionedTextDocumentIdentifier.fromJson(Map<String, dynamic> json) => _$OptionalVersionedTextDocumentIdentifierFromJson(json);

@override final  String uri;
@override final  dynamic version;

/// Create a copy of OptionalVersionedTextDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$OptionalVersionedTextDocumentIdentifierCopyWith<_OptionalVersionedTextDocumentIdentifier> get copyWith => __$OptionalVersionedTextDocumentIdentifierCopyWithImpl<_OptionalVersionedTextDocumentIdentifier>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$OptionalVersionedTextDocumentIdentifierToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _OptionalVersionedTextDocumentIdentifier&&(identical(other.uri, uri) || other.uri == uri)&&const DeepCollectionEquality().equals(other.version, version));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri,const DeepCollectionEquality().hash(version));

@override
String toString() {
  return 'OptionalVersionedTextDocumentIdentifier(uri: $uri, version: $version)';
}


}

/// @nodoc
abstract mixin class _$OptionalVersionedTextDocumentIdentifierCopyWith<$Res> implements $OptionalVersionedTextDocumentIdentifierCopyWith<$Res> {
  factory _$OptionalVersionedTextDocumentIdentifierCopyWith(_OptionalVersionedTextDocumentIdentifier value, $Res Function(_OptionalVersionedTextDocumentIdentifier) _then) = __$OptionalVersionedTextDocumentIdentifierCopyWithImpl;
@override @useResult
$Res call({
 String uri, dynamic version
});




}
/// @nodoc
class __$OptionalVersionedTextDocumentIdentifierCopyWithImpl<$Res>
    implements _$OptionalVersionedTextDocumentIdentifierCopyWith<$Res> {
  __$OptionalVersionedTextDocumentIdentifierCopyWithImpl(this._self, this._then);

  final _OptionalVersionedTextDocumentIdentifier _self;
  final $Res Function(_OptionalVersionedTextDocumentIdentifier) _then;

/// Create a copy of OptionalVersionedTextDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? uri = null,Object? version = freezed,}) {
  return _then(_OptionalVersionedTextDocumentIdentifier(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,version: freezed == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as dynamic,
  ));
}


}


/// @nodoc
mixin _$AnnotatedTextEdit {

 Range get range; String get newText; ChangeAnnotationIdentifier get annotationId;
/// Create a copy of AnnotatedTextEdit
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$AnnotatedTextEditCopyWith<AnnotatedTextEdit> get copyWith => _$AnnotatedTextEditCopyWithImpl<AnnotatedTextEdit>(this as AnnotatedTextEdit, _$identity);

  /// Serializes this AnnotatedTextEdit to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is AnnotatedTextEdit&&(identical(other.range, range) || other.range == range)&&(identical(other.newText, newText) || other.newText == newText)&&(identical(other.annotationId, annotationId) || other.annotationId == annotationId));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,range,newText,annotationId);

@override
String toString() {
  return 'AnnotatedTextEdit(range: $range, newText: $newText, annotationId: $annotationId)';
}


}

/// @nodoc
abstract mixin class $AnnotatedTextEditCopyWith<$Res>  {
  factory $AnnotatedTextEditCopyWith(AnnotatedTextEdit value, $Res Function(AnnotatedTextEdit) _then) = _$AnnotatedTextEditCopyWithImpl;
@useResult
$Res call({
 Range range, String newText, ChangeAnnotationIdentifier annotationId
});


$RangeCopyWith<$Res> get range;

}
/// @nodoc
class _$AnnotatedTextEditCopyWithImpl<$Res>
    implements $AnnotatedTextEditCopyWith<$Res> {
  _$AnnotatedTextEditCopyWithImpl(this._self, this._then);

  final AnnotatedTextEdit _self;
  final $Res Function(AnnotatedTextEdit) _then;

/// Create a copy of AnnotatedTextEdit
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? range = null,Object? newText = null,Object? annotationId = null,}) {
  return _then(_self.copyWith(
range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,newText: null == newText ? _self.newText : newText // ignore: cast_nullable_to_non_nullable
as String,annotationId: null == annotationId ? _self.annotationId : annotationId // ignore: cast_nullable_to_non_nullable
as ChangeAnnotationIdentifier,
  ));
}
/// Create a copy of AnnotatedTextEdit
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _AnnotatedTextEdit implements AnnotatedTextEdit {
  const _AnnotatedTextEdit({required this.range, required this.newText, required this.annotationId});
  factory _AnnotatedTextEdit.fromJson(Map<String, dynamic> json) => _$AnnotatedTextEditFromJson(json);

@override final  Range range;
@override final  String newText;
@override final  ChangeAnnotationIdentifier annotationId;

/// Create a copy of AnnotatedTextEdit
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$AnnotatedTextEditCopyWith<_AnnotatedTextEdit> get copyWith => __$AnnotatedTextEditCopyWithImpl<_AnnotatedTextEdit>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$AnnotatedTextEditToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _AnnotatedTextEdit&&(identical(other.range, range) || other.range == range)&&(identical(other.newText, newText) || other.newText == newText)&&(identical(other.annotationId, annotationId) || other.annotationId == annotationId));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,range,newText,annotationId);

@override
String toString() {
  return 'AnnotatedTextEdit(range: $range, newText: $newText, annotationId: $annotationId)';
}


}

/// @nodoc
abstract mixin class _$AnnotatedTextEditCopyWith<$Res> implements $AnnotatedTextEditCopyWith<$Res> {
  factory _$AnnotatedTextEditCopyWith(_AnnotatedTextEdit value, $Res Function(_AnnotatedTextEdit) _then) = __$AnnotatedTextEditCopyWithImpl;
@override @useResult
$Res call({
 Range range, String newText, ChangeAnnotationIdentifier annotationId
});


@override $RangeCopyWith<$Res> get range;

}
/// @nodoc
class __$AnnotatedTextEditCopyWithImpl<$Res>
    implements _$AnnotatedTextEditCopyWith<$Res> {
  __$AnnotatedTextEditCopyWithImpl(this._self, this._then);

  final _AnnotatedTextEdit _self;
  final $Res Function(_AnnotatedTextEdit) _then;

/// Create a copy of AnnotatedTextEdit
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? range = null,Object? newText = null,Object? annotationId = null,}) {
  return _then(_AnnotatedTextEdit(
range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,newText: null == newText ? _self.newText : newText // ignore: cast_nullable_to_non_nullable
as String,annotationId: null == annotationId ? _self.annotationId : annotationId // ignore: cast_nullable_to_non_nullable
as ChangeAnnotationIdentifier,
  ));
}

/// Create a copy of AnnotatedTextEdit
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}


/// @nodoc
mixin _$ResourceOperation {

 String get kind; ChangeAnnotationIdentifier? get annotationId;
/// Create a copy of ResourceOperation
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ResourceOperationCopyWith<ResourceOperation> get copyWith => _$ResourceOperationCopyWithImpl<ResourceOperation>(this as ResourceOperation, _$identity);

  /// Serializes this ResourceOperation to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ResourceOperation&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.annotationId, annotationId) || other.annotationId == annotationId));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,kind,annotationId);

@override
String toString() {
  return 'ResourceOperation(kind: $kind, annotationId: $annotationId)';
}


}

/// @nodoc
abstract mixin class $ResourceOperationCopyWith<$Res>  {
  factory $ResourceOperationCopyWith(ResourceOperation value, $Res Function(ResourceOperation) _then) = _$ResourceOperationCopyWithImpl;
@useResult
$Res call({
 String kind, ChangeAnnotationIdentifier? annotationId
});




}
/// @nodoc
class _$ResourceOperationCopyWithImpl<$Res>
    implements $ResourceOperationCopyWith<$Res> {
  _$ResourceOperationCopyWithImpl(this._self, this._then);

  final ResourceOperation _self;
  final $Res Function(ResourceOperation) _then;

/// Create a copy of ResourceOperation
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? kind = null,Object? annotationId = freezed,}) {
  return _then(_self.copyWith(
kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as String,annotationId: freezed == annotationId ? _self.annotationId : annotationId // ignore: cast_nullable_to_non_nullable
as ChangeAnnotationIdentifier?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _ResourceOperation implements ResourceOperation {
  const _ResourceOperation({required this.kind, this.annotationId});
  factory _ResourceOperation.fromJson(Map<String, dynamic> json) => _$ResourceOperationFromJson(json);

@override final  String kind;
@override final  ChangeAnnotationIdentifier? annotationId;

/// Create a copy of ResourceOperation
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ResourceOperationCopyWith<_ResourceOperation> get copyWith => __$ResourceOperationCopyWithImpl<_ResourceOperation>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ResourceOperationToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ResourceOperation&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.annotationId, annotationId) || other.annotationId == annotationId));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,kind,annotationId);

@override
String toString() {
  return 'ResourceOperation(kind: $kind, annotationId: $annotationId)';
}


}

/// @nodoc
abstract mixin class _$ResourceOperationCopyWith<$Res> implements $ResourceOperationCopyWith<$Res> {
  factory _$ResourceOperationCopyWith(_ResourceOperation value, $Res Function(_ResourceOperation) _then) = __$ResourceOperationCopyWithImpl;
@override @useResult
$Res call({
 String kind, ChangeAnnotationIdentifier? annotationId
});




}
/// @nodoc
class __$ResourceOperationCopyWithImpl<$Res>
    implements _$ResourceOperationCopyWith<$Res> {
  __$ResourceOperationCopyWithImpl(this._self, this._then);

  final _ResourceOperation _self;
  final $Res Function(_ResourceOperation) _then;

/// Create a copy of ResourceOperation
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? kind = null,Object? annotationId = freezed,}) {
  return _then(_ResourceOperation(
kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as String,annotationId: freezed == annotationId ? _self.annotationId : annotationId // ignore: cast_nullable_to_non_nullable
as ChangeAnnotationIdentifier?,
  ));
}


}


/// @nodoc
mixin _$CreateFileOptions {

 bool? get ignoreIfExists; bool? get overwrite;
/// Create a copy of CreateFileOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CreateFileOptionsCopyWith<CreateFileOptions> get copyWith => _$CreateFileOptionsCopyWithImpl<CreateFileOptions>(this as CreateFileOptions, _$identity);

  /// Serializes this CreateFileOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CreateFileOptions&&(identical(other.ignoreIfExists, ignoreIfExists) || other.ignoreIfExists == ignoreIfExists)&&(identical(other.overwrite, overwrite) || other.overwrite == overwrite));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,ignoreIfExists,overwrite);

@override
String toString() {
  return 'CreateFileOptions(ignoreIfExists: $ignoreIfExists, overwrite: $overwrite)';
}


}

/// @nodoc
abstract mixin class $CreateFileOptionsCopyWith<$Res>  {
  factory $CreateFileOptionsCopyWith(CreateFileOptions value, $Res Function(CreateFileOptions) _then) = _$CreateFileOptionsCopyWithImpl;
@useResult
$Res call({
 bool? ignoreIfExists, bool? overwrite
});




}
/// @nodoc
class _$CreateFileOptionsCopyWithImpl<$Res>
    implements $CreateFileOptionsCopyWith<$Res> {
  _$CreateFileOptionsCopyWithImpl(this._self, this._then);

  final CreateFileOptions _self;
  final $Res Function(CreateFileOptions) _then;

/// Create a copy of CreateFileOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? ignoreIfExists = freezed,Object? overwrite = freezed,}) {
  return _then(_self.copyWith(
ignoreIfExists: freezed == ignoreIfExists ? _self.ignoreIfExists : ignoreIfExists // ignore: cast_nullable_to_non_nullable
as bool?,overwrite: freezed == overwrite ? _self.overwrite : overwrite // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _CreateFileOptions implements CreateFileOptions {
  const _CreateFileOptions({this.ignoreIfExists, this.overwrite});
  factory _CreateFileOptions.fromJson(Map<String, dynamic> json) => _$CreateFileOptionsFromJson(json);

@override final  bool? ignoreIfExists;
@override final  bool? overwrite;

/// Create a copy of CreateFileOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CreateFileOptionsCopyWith<_CreateFileOptions> get copyWith => __$CreateFileOptionsCopyWithImpl<_CreateFileOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CreateFileOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CreateFileOptions&&(identical(other.ignoreIfExists, ignoreIfExists) || other.ignoreIfExists == ignoreIfExists)&&(identical(other.overwrite, overwrite) || other.overwrite == overwrite));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,ignoreIfExists,overwrite);

@override
String toString() {
  return 'CreateFileOptions(ignoreIfExists: $ignoreIfExists, overwrite: $overwrite)';
}


}

/// @nodoc
abstract mixin class _$CreateFileOptionsCopyWith<$Res> implements $CreateFileOptionsCopyWith<$Res> {
  factory _$CreateFileOptionsCopyWith(_CreateFileOptions value, $Res Function(_CreateFileOptions) _then) = __$CreateFileOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? ignoreIfExists, bool? overwrite
});




}
/// @nodoc
class __$CreateFileOptionsCopyWithImpl<$Res>
    implements _$CreateFileOptionsCopyWith<$Res> {
  __$CreateFileOptionsCopyWithImpl(this._self, this._then);

  final _CreateFileOptions _self;
  final $Res Function(_CreateFileOptions) _then;

/// Create a copy of CreateFileOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? ignoreIfExists = freezed,Object? overwrite = freezed,}) {
  return _then(_CreateFileOptions(
ignoreIfExists: freezed == ignoreIfExists ? _self.ignoreIfExists : ignoreIfExists // ignore: cast_nullable_to_non_nullable
as bool?,overwrite: freezed == overwrite ? _self.overwrite : overwrite // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$RenameFileOptions {

 bool? get ignoreIfExists; bool? get overwrite;
/// Create a copy of RenameFileOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RenameFileOptionsCopyWith<RenameFileOptions> get copyWith => _$RenameFileOptionsCopyWithImpl<RenameFileOptions>(this as RenameFileOptions, _$identity);

  /// Serializes this RenameFileOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RenameFileOptions&&(identical(other.ignoreIfExists, ignoreIfExists) || other.ignoreIfExists == ignoreIfExists)&&(identical(other.overwrite, overwrite) || other.overwrite == overwrite));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,ignoreIfExists,overwrite);

@override
String toString() {
  return 'RenameFileOptions(ignoreIfExists: $ignoreIfExists, overwrite: $overwrite)';
}


}

/// @nodoc
abstract mixin class $RenameFileOptionsCopyWith<$Res>  {
  factory $RenameFileOptionsCopyWith(RenameFileOptions value, $Res Function(RenameFileOptions) _then) = _$RenameFileOptionsCopyWithImpl;
@useResult
$Res call({
 bool? ignoreIfExists, bool? overwrite
});




}
/// @nodoc
class _$RenameFileOptionsCopyWithImpl<$Res>
    implements $RenameFileOptionsCopyWith<$Res> {
  _$RenameFileOptionsCopyWithImpl(this._self, this._then);

  final RenameFileOptions _self;
  final $Res Function(RenameFileOptions) _then;

/// Create a copy of RenameFileOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? ignoreIfExists = freezed,Object? overwrite = freezed,}) {
  return _then(_self.copyWith(
ignoreIfExists: freezed == ignoreIfExists ? _self.ignoreIfExists : ignoreIfExists // ignore: cast_nullable_to_non_nullable
as bool?,overwrite: freezed == overwrite ? _self.overwrite : overwrite // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _RenameFileOptions implements RenameFileOptions {
  const _RenameFileOptions({this.ignoreIfExists, this.overwrite});
  factory _RenameFileOptions.fromJson(Map<String, dynamic> json) => _$RenameFileOptionsFromJson(json);

@override final  bool? ignoreIfExists;
@override final  bool? overwrite;

/// Create a copy of RenameFileOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RenameFileOptionsCopyWith<_RenameFileOptions> get copyWith => __$RenameFileOptionsCopyWithImpl<_RenameFileOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$RenameFileOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _RenameFileOptions&&(identical(other.ignoreIfExists, ignoreIfExists) || other.ignoreIfExists == ignoreIfExists)&&(identical(other.overwrite, overwrite) || other.overwrite == overwrite));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,ignoreIfExists,overwrite);

@override
String toString() {
  return 'RenameFileOptions(ignoreIfExists: $ignoreIfExists, overwrite: $overwrite)';
}


}

/// @nodoc
abstract mixin class _$RenameFileOptionsCopyWith<$Res> implements $RenameFileOptionsCopyWith<$Res> {
  factory _$RenameFileOptionsCopyWith(_RenameFileOptions value, $Res Function(_RenameFileOptions) _then) = __$RenameFileOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? ignoreIfExists, bool? overwrite
});




}
/// @nodoc
class __$RenameFileOptionsCopyWithImpl<$Res>
    implements _$RenameFileOptionsCopyWith<$Res> {
  __$RenameFileOptionsCopyWithImpl(this._self, this._then);

  final _RenameFileOptions _self;
  final $Res Function(_RenameFileOptions) _then;

/// Create a copy of RenameFileOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? ignoreIfExists = freezed,Object? overwrite = freezed,}) {
  return _then(_RenameFileOptions(
ignoreIfExists: freezed == ignoreIfExists ? _self.ignoreIfExists : ignoreIfExists // ignore: cast_nullable_to_non_nullable
as bool?,overwrite: freezed == overwrite ? _self.overwrite : overwrite // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DeleteFileOptions {

 bool? get ignoreIfNotExists; bool? get recursive;
/// Create a copy of DeleteFileOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DeleteFileOptionsCopyWith<DeleteFileOptions> get copyWith => _$DeleteFileOptionsCopyWithImpl<DeleteFileOptions>(this as DeleteFileOptions, _$identity);

  /// Serializes this DeleteFileOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DeleteFileOptions&&(identical(other.ignoreIfNotExists, ignoreIfNotExists) || other.ignoreIfNotExists == ignoreIfNotExists)&&(identical(other.recursive, recursive) || other.recursive == recursive));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,ignoreIfNotExists,recursive);

@override
String toString() {
  return 'DeleteFileOptions(ignoreIfNotExists: $ignoreIfNotExists, recursive: $recursive)';
}


}

/// @nodoc
abstract mixin class $DeleteFileOptionsCopyWith<$Res>  {
  factory $DeleteFileOptionsCopyWith(DeleteFileOptions value, $Res Function(DeleteFileOptions) _then) = _$DeleteFileOptionsCopyWithImpl;
@useResult
$Res call({
 bool? ignoreIfNotExists, bool? recursive
});




}
/// @nodoc
class _$DeleteFileOptionsCopyWithImpl<$Res>
    implements $DeleteFileOptionsCopyWith<$Res> {
  _$DeleteFileOptionsCopyWithImpl(this._self, this._then);

  final DeleteFileOptions _self;
  final $Res Function(DeleteFileOptions) _then;

/// Create a copy of DeleteFileOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? ignoreIfNotExists = freezed,Object? recursive = freezed,}) {
  return _then(_self.copyWith(
ignoreIfNotExists: freezed == ignoreIfNotExists ? _self.ignoreIfNotExists : ignoreIfNotExists // ignore: cast_nullable_to_non_nullable
as bool?,recursive: freezed == recursive ? _self.recursive : recursive // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DeleteFileOptions implements DeleteFileOptions {
  const _DeleteFileOptions({this.ignoreIfNotExists, this.recursive});
  factory _DeleteFileOptions.fromJson(Map<String, dynamic> json) => _$DeleteFileOptionsFromJson(json);

@override final  bool? ignoreIfNotExists;
@override final  bool? recursive;

/// Create a copy of DeleteFileOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DeleteFileOptionsCopyWith<_DeleteFileOptions> get copyWith => __$DeleteFileOptionsCopyWithImpl<_DeleteFileOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DeleteFileOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DeleteFileOptions&&(identical(other.ignoreIfNotExists, ignoreIfNotExists) || other.ignoreIfNotExists == ignoreIfNotExists)&&(identical(other.recursive, recursive) || other.recursive == recursive));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,ignoreIfNotExists,recursive);

@override
String toString() {
  return 'DeleteFileOptions(ignoreIfNotExists: $ignoreIfNotExists, recursive: $recursive)';
}


}

/// @nodoc
abstract mixin class _$DeleteFileOptionsCopyWith<$Res> implements $DeleteFileOptionsCopyWith<$Res> {
  factory _$DeleteFileOptionsCopyWith(_DeleteFileOptions value, $Res Function(_DeleteFileOptions) _then) = __$DeleteFileOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? ignoreIfNotExists, bool? recursive
});




}
/// @nodoc
class __$DeleteFileOptionsCopyWithImpl<$Res>
    implements _$DeleteFileOptionsCopyWith<$Res> {
  __$DeleteFileOptionsCopyWithImpl(this._self, this._then);

  final _DeleteFileOptions _self;
  final $Res Function(_DeleteFileOptions) _then;

/// Create a copy of DeleteFileOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? ignoreIfNotExists = freezed,Object? recursive = freezed,}) {
  return _then(_DeleteFileOptions(
ignoreIfNotExists: freezed == ignoreIfNotExists ? _self.ignoreIfNotExists : ignoreIfNotExists // ignore: cast_nullable_to_non_nullable
as bool?,recursive: freezed == recursive ? _self.recursive : recursive // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$FileOperationPattern {

 String get glob; FileOperationPatternOptions? get options; FileOperationPatternKind? get matches;
/// Create a copy of FileOperationPattern
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FileOperationPatternCopyWith<FileOperationPattern> get copyWith => _$FileOperationPatternCopyWithImpl<FileOperationPattern>(this as FileOperationPattern, _$identity);

  /// Serializes this FileOperationPattern to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FileOperationPattern&&(identical(other.glob, glob) || other.glob == glob)&&(identical(other.options, options) || other.options == options)&&(identical(other.matches, matches) || other.matches == matches));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,glob,options,matches);

@override
String toString() {
  return 'FileOperationPattern(glob: $glob, options: $options, matches: $matches)';
}


}

/// @nodoc
abstract mixin class $FileOperationPatternCopyWith<$Res>  {
  factory $FileOperationPatternCopyWith(FileOperationPattern value, $Res Function(FileOperationPattern) _then) = _$FileOperationPatternCopyWithImpl;
@useResult
$Res call({
 String glob, FileOperationPatternOptions? options, FileOperationPatternKind? matches
});


$FileOperationPatternOptionsCopyWith<$Res>? get options;

}
/// @nodoc
class _$FileOperationPatternCopyWithImpl<$Res>
    implements $FileOperationPatternCopyWith<$Res> {
  _$FileOperationPatternCopyWithImpl(this._self, this._then);

  final FileOperationPattern _self;
  final $Res Function(FileOperationPattern) _then;

/// Create a copy of FileOperationPattern
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? glob = null,Object? options = freezed,Object? matches = freezed,}) {
  return _then(_self.copyWith(
glob: null == glob ? _self.glob : glob // ignore: cast_nullable_to_non_nullable
as String,options: freezed == options ? _self.options : options // ignore: cast_nullable_to_non_nullable
as FileOperationPatternOptions?,matches: freezed == matches ? _self.matches : matches // ignore: cast_nullable_to_non_nullable
as FileOperationPatternKind?,
  ));
}
/// Create a copy of FileOperationPattern
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FileOperationPatternOptionsCopyWith<$Res>? get options {
    if (_self.options == null) {
    return null;
  }

  return $FileOperationPatternOptionsCopyWith<$Res>(_self.options!, (value) {
    return _then(_self.copyWith(options: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _FileOperationPattern implements FileOperationPattern {
  const _FileOperationPattern({required this.glob, this.options, this.matches});
  factory _FileOperationPattern.fromJson(Map<String, dynamic> json) => _$FileOperationPatternFromJson(json);

@override final  String glob;
@override final  FileOperationPatternOptions? options;
@override final  FileOperationPatternKind? matches;

/// Create a copy of FileOperationPattern
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$FileOperationPatternCopyWith<_FileOperationPattern> get copyWith => __$FileOperationPatternCopyWithImpl<_FileOperationPattern>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$FileOperationPatternToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _FileOperationPattern&&(identical(other.glob, glob) || other.glob == glob)&&(identical(other.options, options) || other.options == options)&&(identical(other.matches, matches) || other.matches == matches));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,glob,options,matches);

@override
String toString() {
  return 'FileOperationPattern(glob: $glob, options: $options, matches: $matches)';
}


}

/// @nodoc
abstract mixin class _$FileOperationPatternCopyWith<$Res> implements $FileOperationPatternCopyWith<$Res> {
  factory _$FileOperationPatternCopyWith(_FileOperationPattern value, $Res Function(_FileOperationPattern) _then) = __$FileOperationPatternCopyWithImpl;
@override @useResult
$Res call({
 String glob, FileOperationPatternOptions? options, FileOperationPatternKind? matches
});


@override $FileOperationPatternOptionsCopyWith<$Res>? get options;

}
/// @nodoc
class __$FileOperationPatternCopyWithImpl<$Res>
    implements _$FileOperationPatternCopyWith<$Res> {
  __$FileOperationPatternCopyWithImpl(this._self, this._then);

  final _FileOperationPattern _self;
  final $Res Function(_FileOperationPattern) _then;

/// Create a copy of FileOperationPattern
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? glob = null,Object? options = freezed,Object? matches = freezed,}) {
  return _then(_FileOperationPattern(
glob: null == glob ? _self.glob : glob // ignore: cast_nullable_to_non_nullable
as String,options: freezed == options ? _self.options : options // ignore: cast_nullable_to_non_nullable
as FileOperationPatternOptions?,matches: freezed == matches ? _self.matches : matches // ignore: cast_nullable_to_non_nullable
as FileOperationPatternKind?,
  ));
}

/// Create a copy of FileOperationPattern
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FileOperationPatternOptionsCopyWith<$Res>? get options {
    if (_self.options == null) {
    return null;
  }

  return $FileOperationPatternOptionsCopyWith<$Res>(_self.options!, (value) {
    return _then(_self.copyWith(options: value));
  });
}
}


/// @nodoc
mixin _$WorkspaceFullDocumentDiagnosticReport {

 String get kind; List<Diagnostic> get items; String get uri; dynamic get version; String? get resultId;
/// Create a copy of WorkspaceFullDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkspaceFullDocumentDiagnosticReportCopyWith<WorkspaceFullDocumentDiagnosticReport> get copyWith => _$WorkspaceFullDocumentDiagnosticReportCopyWithImpl<WorkspaceFullDocumentDiagnosticReport>(this as WorkspaceFullDocumentDiagnosticReport, _$identity);

  /// Serializes this WorkspaceFullDocumentDiagnosticReport to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkspaceFullDocumentDiagnosticReport&&(identical(other.kind, kind) || other.kind == kind)&&const DeepCollectionEquality().equals(other.items, items)&&(identical(other.uri, uri) || other.uri == uri)&&const DeepCollectionEquality().equals(other.version, version)&&(identical(other.resultId, resultId) || other.resultId == resultId));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,kind,const DeepCollectionEquality().hash(items),uri,const DeepCollectionEquality().hash(version),resultId);

@override
String toString() {
  return 'WorkspaceFullDocumentDiagnosticReport(kind: $kind, items: $items, uri: $uri, version: $version, resultId: $resultId)';
}


}

/// @nodoc
abstract mixin class $WorkspaceFullDocumentDiagnosticReportCopyWith<$Res>  {
  factory $WorkspaceFullDocumentDiagnosticReportCopyWith(WorkspaceFullDocumentDiagnosticReport value, $Res Function(WorkspaceFullDocumentDiagnosticReport) _then) = _$WorkspaceFullDocumentDiagnosticReportCopyWithImpl;
@useResult
$Res call({
 String kind, List<Diagnostic> items, String uri, dynamic version, String? resultId
});




}
/// @nodoc
class _$WorkspaceFullDocumentDiagnosticReportCopyWithImpl<$Res>
    implements $WorkspaceFullDocumentDiagnosticReportCopyWith<$Res> {
  _$WorkspaceFullDocumentDiagnosticReportCopyWithImpl(this._self, this._then);

  final WorkspaceFullDocumentDiagnosticReport _self;
  final $Res Function(WorkspaceFullDocumentDiagnosticReport) _then;

/// Create a copy of WorkspaceFullDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? kind = null,Object? items = null,Object? uri = null,Object? version = freezed,Object? resultId = freezed,}) {
  return _then(_self.copyWith(
kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as String,items: null == items ? _self.items : items // ignore: cast_nullable_to_non_nullable
as List<Diagnostic>,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,version: freezed == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as dynamic,resultId: freezed == resultId ? _self.resultId : resultId // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _WorkspaceFullDocumentDiagnosticReport implements WorkspaceFullDocumentDiagnosticReport {
  const _WorkspaceFullDocumentDiagnosticReport({required this.kind, required final  List<Diagnostic> items, required this.uri, required this.version, this.resultId}): _items = items;
  factory _WorkspaceFullDocumentDiagnosticReport.fromJson(Map<String, dynamic> json) => _$WorkspaceFullDocumentDiagnosticReportFromJson(json);

@override final  String kind;
 final  List<Diagnostic> _items;
@override List<Diagnostic> get items {
  if (_items is EqualUnmodifiableListView) return _items;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_items);
}

@override final  String uri;
@override final  dynamic version;
@override final  String? resultId;

/// Create a copy of WorkspaceFullDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkspaceFullDocumentDiagnosticReportCopyWith<_WorkspaceFullDocumentDiagnosticReport> get copyWith => __$WorkspaceFullDocumentDiagnosticReportCopyWithImpl<_WorkspaceFullDocumentDiagnosticReport>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkspaceFullDocumentDiagnosticReportToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkspaceFullDocumentDiagnosticReport&&(identical(other.kind, kind) || other.kind == kind)&&const DeepCollectionEquality().equals(other._items, _items)&&(identical(other.uri, uri) || other.uri == uri)&&const DeepCollectionEquality().equals(other.version, version)&&(identical(other.resultId, resultId) || other.resultId == resultId));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,kind,const DeepCollectionEquality().hash(_items),uri,const DeepCollectionEquality().hash(version),resultId);

@override
String toString() {
  return 'WorkspaceFullDocumentDiagnosticReport(kind: $kind, items: $items, uri: $uri, version: $version, resultId: $resultId)';
}


}

/// @nodoc
abstract mixin class _$WorkspaceFullDocumentDiagnosticReportCopyWith<$Res> implements $WorkspaceFullDocumentDiagnosticReportCopyWith<$Res> {
  factory _$WorkspaceFullDocumentDiagnosticReportCopyWith(_WorkspaceFullDocumentDiagnosticReport value, $Res Function(_WorkspaceFullDocumentDiagnosticReport) _then) = __$WorkspaceFullDocumentDiagnosticReportCopyWithImpl;
@override @useResult
$Res call({
 String kind, List<Diagnostic> items, String uri, dynamic version, String? resultId
});




}
/// @nodoc
class __$WorkspaceFullDocumentDiagnosticReportCopyWithImpl<$Res>
    implements _$WorkspaceFullDocumentDiagnosticReportCopyWith<$Res> {
  __$WorkspaceFullDocumentDiagnosticReportCopyWithImpl(this._self, this._then);

  final _WorkspaceFullDocumentDiagnosticReport _self;
  final $Res Function(_WorkspaceFullDocumentDiagnosticReport) _then;

/// Create a copy of WorkspaceFullDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? kind = null,Object? items = null,Object? uri = null,Object? version = freezed,Object? resultId = freezed,}) {
  return _then(_WorkspaceFullDocumentDiagnosticReport(
kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as String,items: null == items ? _self._items : items // ignore: cast_nullable_to_non_nullable
as List<Diagnostic>,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,version: freezed == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as dynamic,resultId: freezed == resultId ? _self.resultId : resultId // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$WorkspaceUnchangedDocumentDiagnosticReport {

 String get kind; String get resultId; String get uri; dynamic get version;
/// Create a copy of WorkspaceUnchangedDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkspaceUnchangedDocumentDiagnosticReportCopyWith<WorkspaceUnchangedDocumentDiagnosticReport> get copyWith => _$WorkspaceUnchangedDocumentDiagnosticReportCopyWithImpl<WorkspaceUnchangedDocumentDiagnosticReport>(this as WorkspaceUnchangedDocumentDiagnosticReport, _$identity);

  /// Serializes this WorkspaceUnchangedDocumentDiagnosticReport to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkspaceUnchangedDocumentDiagnosticReport&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.resultId, resultId) || other.resultId == resultId)&&(identical(other.uri, uri) || other.uri == uri)&&const DeepCollectionEquality().equals(other.version, version));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,kind,resultId,uri,const DeepCollectionEquality().hash(version));

@override
String toString() {
  return 'WorkspaceUnchangedDocumentDiagnosticReport(kind: $kind, resultId: $resultId, uri: $uri, version: $version)';
}


}

/// @nodoc
abstract mixin class $WorkspaceUnchangedDocumentDiagnosticReportCopyWith<$Res>  {
  factory $WorkspaceUnchangedDocumentDiagnosticReportCopyWith(WorkspaceUnchangedDocumentDiagnosticReport value, $Res Function(WorkspaceUnchangedDocumentDiagnosticReport) _then) = _$WorkspaceUnchangedDocumentDiagnosticReportCopyWithImpl;
@useResult
$Res call({
 String kind, String resultId, String uri, dynamic version
});




}
/// @nodoc
class _$WorkspaceUnchangedDocumentDiagnosticReportCopyWithImpl<$Res>
    implements $WorkspaceUnchangedDocumentDiagnosticReportCopyWith<$Res> {
  _$WorkspaceUnchangedDocumentDiagnosticReportCopyWithImpl(this._self, this._then);

  final WorkspaceUnchangedDocumentDiagnosticReport _self;
  final $Res Function(WorkspaceUnchangedDocumentDiagnosticReport) _then;

/// Create a copy of WorkspaceUnchangedDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? kind = null,Object? resultId = null,Object? uri = null,Object? version = freezed,}) {
  return _then(_self.copyWith(
kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as String,resultId: null == resultId ? _self.resultId : resultId // ignore: cast_nullable_to_non_nullable
as String,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,version: freezed == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as dynamic,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _WorkspaceUnchangedDocumentDiagnosticReport implements WorkspaceUnchangedDocumentDiagnosticReport {
  const _WorkspaceUnchangedDocumentDiagnosticReport({required this.kind, required this.resultId, required this.uri, required this.version});
  factory _WorkspaceUnchangedDocumentDiagnosticReport.fromJson(Map<String, dynamic> json) => _$WorkspaceUnchangedDocumentDiagnosticReportFromJson(json);

@override final  String kind;
@override final  String resultId;
@override final  String uri;
@override final  dynamic version;

/// Create a copy of WorkspaceUnchangedDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkspaceUnchangedDocumentDiagnosticReportCopyWith<_WorkspaceUnchangedDocumentDiagnosticReport> get copyWith => __$WorkspaceUnchangedDocumentDiagnosticReportCopyWithImpl<_WorkspaceUnchangedDocumentDiagnosticReport>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkspaceUnchangedDocumentDiagnosticReportToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkspaceUnchangedDocumentDiagnosticReport&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.resultId, resultId) || other.resultId == resultId)&&(identical(other.uri, uri) || other.uri == uri)&&const DeepCollectionEquality().equals(other.version, version));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,kind,resultId,uri,const DeepCollectionEquality().hash(version));

@override
String toString() {
  return 'WorkspaceUnchangedDocumentDiagnosticReport(kind: $kind, resultId: $resultId, uri: $uri, version: $version)';
}


}

/// @nodoc
abstract mixin class _$WorkspaceUnchangedDocumentDiagnosticReportCopyWith<$Res> implements $WorkspaceUnchangedDocumentDiagnosticReportCopyWith<$Res> {
  factory _$WorkspaceUnchangedDocumentDiagnosticReportCopyWith(_WorkspaceUnchangedDocumentDiagnosticReport value, $Res Function(_WorkspaceUnchangedDocumentDiagnosticReport) _then) = __$WorkspaceUnchangedDocumentDiagnosticReportCopyWithImpl;
@override @useResult
$Res call({
 String kind, String resultId, String uri, dynamic version
});




}
/// @nodoc
class __$WorkspaceUnchangedDocumentDiagnosticReportCopyWithImpl<$Res>
    implements _$WorkspaceUnchangedDocumentDiagnosticReportCopyWith<$Res> {
  __$WorkspaceUnchangedDocumentDiagnosticReportCopyWithImpl(this._self, this._then);

  final _WorkspaceUnchangedDocumentDiagnosticReport _self;
  final $Res Function(_WorkspaceUnchangedDocumentDiagnosticReport) _then;

/// Create a copy of WorkspaceUnchangedDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? kind = null,Object? resultId = null,Object? uri = null,Object? version = freezed,}) {
  return _then(_WorkspaceUnchangedDocumentDiagnosticReport(
kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as String,resultId: null == resultId ? _self.resultId : resultId // ignore: cast_nullable_to_non_nullable
as String,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,version: freezed == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as dynamic,
  ));
}


}


/// @nodoc
mixin _$NotebookCell {

 NotebookCellKind get kind; String get document; ExecutionSummary? get executionSummary; LSPObject? get metadata;
/// Create a copy of NotebookCell
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$NotebookCellCopyWith<NotebookCell> get copyWith => _$NotebookCellCopyWithImpl<NotebookCell>(this as NotebookCell, _$identity);

  /// Serializes this NotebookCell to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is NotebookCell&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.document, document) || other.document == document)&&(identical(other.executionSummary, executionSummary) || other.executionSummary == executionSummary)&&const DeepCollectionEquality().equals(other.metadata, metadata));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,kind,document,executionSummary,const DeepCollectionEquality().hash(metadata));

@override
String toString() {
  return 'NotebookCell(kind: $kind, document: $document, executionSummary: $executionSummary, metadata: $metadata)';
}


}

/// @nodoc
abstract mixin class $NotebookCellCopyWith<$Res>  {
  factory $NotebookCellCopyWith(NotebookCell value, $Res Function(NotebookCell) _then) = _$NotebookCellCopyWithImpl;
@useResult
$Res call({
 NotebookCellKind kind, String document, ExecutionSummary? executionSummary, LSPObject? metadata
});


$ExecutionSummaryCopyWith<$Res>? get executionSummary;

}
/// @nodoc
class _$NotebookCellCopyWithImpl<$Res>
    implements $NotebookCellCopyWith<$Res> {
  _$NotebookCellCopyWithImpl(this._self, this._then);

  final NotebookCell _self;
  final $Res Function(NotebookCell) _then;

/// Create a copy of NotebookCell
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? kind = null,Object? document = null,Object? executionSummary = freezed,Object? metadata = freezed,}) {
  return _then(_self.copyWith(
kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as NotebookCellKind,document: null == document ? _self.document : document // ignore: cast_nullable_to_non_nullable
as String,executionSummary: freezed == executionSummary ? _self.executionSummary : executionSummary // ignore: cast_nullable_to_non_nullable
as ExecutionSummary?,metadata: freezed == metadata ? _self.metadata : metadata // ignore: cast_nullable_to_non_nullable
as LSPObject?,
  ));
}
/// Create a copy of NotebookCell
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ExecutionSummaryCopyWith<$Res>? get executionSummary {
    if (_self.executionSummary == null) {
    return null;
  }

  return $ExecutionSummaryCopyWith<$Res>(_self.executionSummary!, (value) {
    return _then(_self.copyWith(executionSummary: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _NotebookCell implements NotebookCell {
  const _NotebookCell({required this.kind, required this.document, this.executionSummary, final  LSPObject? metadata}): _metadata = metadata;
  factory _NotebookCell.fromJson(Map<String, dynamic> json) => _$NotebookCellFromJson(json);

@override final  NotebookCellKind kind;
@override final  String document;
@override final  ExecutionSummary? executionSummary;
 final  LSPObject? _metadata;
@override LSPObject? get metadata {
  final value = _metadata;
  if (value == null) return null;
  if (_metadata is EqualUnmodifiableMapView) return _metadata;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(value);
}


/// Create a copy of NotebookCell
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$NotebookCellCopyWith<_NotebookCell> get copyWith => __$NotebookCellCopyWithImpl<_NotebookCell>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$NotebookCellToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _NotebookCell&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.document, document) || other.document == document)&&(identical(other.executionSummary, executionSummary) || other.executionSummary == executionSummary)&&const DeepCollectionEquality().equals(other._metadata, _metadata));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,kind,document,executionSummary,const DeepCollectionEquality().hash(_metadata));

@override
String toString() {
  return 'NotebookCell(kind: $kind, document: $document, executionSummary: $executionSummary, metadata: $metadata)';
}


}

/// @nodoc
abstract mixin class _$NotebookCellCopyWith<$Res> implements $NotebookCellCopyWith<$Res> {
  factory _$NotebookCellCopyWith(_NotebookCell value, $Res Function(_NotebookCell) _then) = __$NotebookCellCopyWithImpl;
@override @useResult
$Res call({
 NotebookCellKind kind, String document, ExecutionSummary? executionSummary, LSPObject? metadata
});


@override $ExecutionSummaryCopyWith<$Res>? get executionSummary;

}
/// @nodoc
class __$NotebookCellCopyWithImpl<$Res>
    implements _$NotebookCellCopyWith<$Res> {
  __$NotebookCellCopyWithImpl(this._self, this._then);

  final _NotebookCell _self;
  final $Res Function(_NotebookCell) _then;

/// Create a copy of NotebookCell
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? kind = null,Object? document = null,Object? executionSummary = freezed,Object? metadata = freezed,}) {
  return _then(_NotebookCell(
kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as NotebookCellKind,document: null == document ? _self.document : document // ignore: cast_nullable_to_non_nullable
as String,executionSummary: freezed == executionSummary ? _self.executionSummary : executionSummary // ignore: cast_nullable_to_non_nullable
as ExecutionSummary?,metadata: freezed == metadata ? _self._metadata : metadata // ignore: cast_nullable_to_non_nullable
as LSPObject?,
  ));
}

/// Create a copy of NotebookCell
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ExecutionSummaryCopyWith<$Res>? get executionSummary {
    if (_self.executionSummary == null) {
    return null;
  }

  return $ExecutionSummaryCopyWith<$Res>(_self.executionSummary!, (value) {
    return _then(_self.copyWith(executionSummary: value));
  });
}
}


/// @nodoc
mixin _$NotebookCellArrayChange {

 int get start; int get deleteCount; List<NotebookCell>? get cells;
/// Create a copy of NotebookCellArrayChange
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$NotebookCellArrayChangeCopyWith<NotebookCellArrayChange> get copyWith => _$NotebookCellArrayChangeCopyWithImpl<NotebookCellArrayChange>(this as NotebookCellArrayChange, _$identity);

  /// Serializes this NotebookCellArrayChange to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is NotebookCellArrayChange&&(identical(other.start, start) || other.start == start)&&(identical(other.deleteCount, deleteCount) || other.deleteCount == deleteCount)&&const DeepCollectionEquality().equals(other.cells, cells));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,start,deleteCount,const DeepCollectionEquality().hash(cells));

@override
String toString() {
  return 'NotebookCellArrayChange(start: $start, deleteCount: $deleteCount, cells: $cells)';
}


}

/// @nodoc
abstract mixin class $NotebookCellArrayChangeCopyWith<$Res>  {
  factory $NotebookCellArrayChangeCopyWith(NotebookCellArrayChange value, $Res Function(NotebookCellArrayChange) _then) = _$NotebookCellArrayChangeCopyWithImpl;
@useResult
$Res call({
 int start, int deleteCount, List<NotebookCell>? cells
});




}
/// @nodoc
class _$NotebookCellArrayChangeCopyWithImpl<$Res>
    implements $NotebookCellArrayChangeCopyWith<$Res> {
  _$NotebookCellArrayChangeCopyWithImpl(this._self, this._then);

  final NotebookCellArrayChange _self;
  final $Res Function(NotebookCellArrayChange) _then;

/// Create a copy of NotebookCellArrayChange
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? start = null,Object? deleteCount = null,Object? cells = freezed,}) {
  return _then(_self.copyWith(
start: null == start ? _self.start : start // ignore: cast_nullable_to_non_nullable
as int,deleteCount: null == deleteCount ? _self.deleteCount : deleteCount // ignore: cast_nullable_to_non_nullable
as int,cells: freezed == cells ? _self.cells : cells // ignore: cast_nullable_to_non_nullable
as List<NotebookCell>?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _NotebookCellArrayChange implements NotebookCellArrayChange {
  const _NotebookCellArrayChange({required this.start, required this.deleteCount, final  List<NotebookCell>? cells}): _cells = cells;
  factory _NotebookCellArrayChange.fromJson(Map<String, dynamic> json) => _$NotebookCellArrayChangeFromJson(json);

@override final  int start;
@override final  int deleteCount;
 final  List<NotebookCell>? _cells;
@override List<NotebookCell>? get cells {
  final value = _cells;
  if (value == null) return null;
  if (_cells is EqualUnmodifiableListView) return _cells;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}


/// Create a copy of NotebookCellArrayChange
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$NotebookCellArrayChangeCopyWith<_NotebookCellArrayChange> get copyWith => __$NotebookCellArrayChangeCopyWithImpl<_NotebookCellArrayChange>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$NotebookCellArrayChangeToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _NotebookCellArrayChange&&(identical(other.start, start) || other.start == start)&&(identical(other.deleteCount, deleteCount) || other.deleteCount == deleteCount)&&const DeepCollectionEquality().equals(other._cells, _cells));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,start,deleteCount,const DeepCollectionEquality().hash(_cells));

@override
String toString() {
  return 'NotebookCellArrayChange(start: $start, deleteCount: $deleteCount, cells: $cells)';
}


}

/// @nodoc
abstract mixin class _$NotebookCellArrayChangeCopyWith<$Res> implements $NotebookCellArrayChangeCopyWith<$Res> {
  factory _$NotebookCellArrayChangeCopyWith(_NotebookCellArrayChange value, $Res Function(_NotebookCellArrayChange) _then) = __$NotebookCellArrayChangeCopyWithImpl;
@override @useResult
$Res call({
 int start, int deleteCount, List<NotebookCell>? cells
});




}
/// @nodoc
class __$NotebookCellArrayChangeCopyWithImpl<$Res>
    implements _$NotebookCellArrayChangeCopyWith<$Res> {
  __$NotebookCellArrayChangeCopyWithImpl(this._self, this._then);

  final _NotebookCellArrayChange _self;
  final $Res Function(_NotebookCellArrayChange) _then;

/// Create a copy of NotebookCellArrayChange
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? start = null,Object? deleteCount = null,Object? cells = freezed,}) {
  return _then(_NotebookCellArrayChange(
start: null == start ? _self.start : start // ignore: cast_nullable_to_non_nullable
as int,deleteCount: null == deleteCount ? _self.deleteCount : deleteCount // ignore: cast_nullable_to_non_nullable
as int,cells: freezed == cells ? _self._cells : cells // ignore: cast_nullable_to_non_nullable
as List<NotebookCell>?,
  ));
}


}


/// @nodoc
mixin _$SelectedCompletionInfo {

 Range get range; String get text;
/// Create a copy of SelectedCompletionInfo
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SelectedCompletionInfoCopyWith<SelectedCompletionInfo> get copyWith => _$SelectedCompletionInfoCopyWithImpl<SelectedCompletionInfo>(this as SelectedCompletionInfo, _$identity);

  /// Serializes this SelectedCompletionInfo to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SelectedCompletionInfo&&(identical(other.range, range) || other.range == range)&&(identical(other.text, text) || other.text == text));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,range,text);

@override
String toString() {
  return 'SelectedCompletionInfo(range: $range, text: $text)';
}


}

/// @nodoc
abstract mixin class $SelectedCompletionInfoCopyWith<$Res>  {
  factory $SelectedCompletionInfoCopyWith(SelectedCompletionInfo value, $Res Function(SelectedCompletionInfo) _then) = _$SelectedCompletionInfoCopyWithImpl;
@useResult
$Res call({
 Range range, String text
});


$RangeCopyWith<$Res> get range;

}
/// @nodoc
class _$SelectedCompletionInfoCopyWithImpl<$Res>
    implements $SelectedCompletionInfoCopyWith<$Res> {
  _$SelectedCompletionInfoCopyWithImpl(this._self, this._then);

  final SelectedCompletionInfo _self;
  final $Res Function(SelectedCompletionInfo) _then;

/// Create a copy of SelectedCompletionInfo
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? range = null,Object? text = null,}) {
  return _then(_self.copyWith(
range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,text: null == text ? _self.text : text // ignore: cast_nullable_to_non_nullable
as String,
  ));
}
/// Create a copy of SelectedCompletionInfo
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _SelectedCompletionInfo implements SelectedCompletionInfo {
  const _SelectedCompletionInfo({required this.range, required this.text});
  factory _SelectedCompletionInfo.fromJson(Map<String, dynamic> json) => _$SelectedCompletionInfoFromJson(json);

@override final  Range range;
@override final  String text;

/// Create a copy of SelectedCompletionInfo
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SelectedCompletionInfoCopyWith<_SelectedCompletionInfo> get copyWith => __$SelectedCompletionInfoCopyWithImpl<_SelectedCompletionInfo>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SelectedCompletionInfoToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SelectedCompletionInfo&&(identical(other.range, range) || other.range == range)&&(identical(other.text, text) || other.text == text));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,range,text);

@override
String toString() {
  return 'SelectedCompletionInfo(range: $range, text: $text)';
}


}

/// @nodoc
abstract mixin class _$SelectedCompletionInfoCopyWith<$Res> implements $SelectedCompletionInfoCopyWith<$Res> {
  factory _$SelectedCompletionInfoCopyWith(_SelectedCompletionInfo value, $Res Function(_SelectedCompletionInfo) _then) = __$SelectedCompletionInfoCopyWithImpl;
@override @useResult
$Res call({
 Range range, String text
});


@override $RangeCopyWith<$Res> get range;

}
/// @nodoc
class __$SelectedCompletionInfoCopyWithImpl<$Res>
    implements _$SelectedCompletionInfoCopyWith<$Res> {
  __$SelectedCompletionInfoCopyWithImpl(this._self, this._then);

  final _SelectedCompletionInfo _self;
  final $Res Function(_SelectedCompletionInfo) _then;

/// Create a copy of SelectedCompletionInfo
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? range = null,Object? text = null,}) {
  return _then(_SelectedCompletionInfo(
range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,text: null == text ? _self.text : text // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

/// Create a copy of SelectedCompletionInfo
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}


/// @nodoc
mixin _$ClientCapabilities {

 LSPAny? get experimental; GeneralClientCapabilities? get general; WindowClientCapabilities? get window; NotebookDocumentClientCapabilities? get notebookDocument; TextDocumentClientCapabilities? get textDocument; WorkspaceClientCapabilities? get workspace;
/// Create a copy of ClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ClientCapabilitiesCopyWith<ClientCapabilities> get copyWith => _$ClientCapabilitiesCopyWithImpl<ClientCapabilities>(this as ClientCapabilities, _$identity);

  /// Serializes this ClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ClientCapabilities&&const DeepCollectionEquality().equals(other.experimental, experimental)&&(identical(other.general, general) || other.general == general)&&(identical(other.window, window) || other.window == window)&&(identical(other.notebookDocument, notebookDocument) || other.notebookDocument == notebookDocument)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workspace, workspace) || other.workspace == workspace));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(experimental),general,window,notebookDocument,textDocument,workspace);

@override
String toString() {
  return 'ClientCapabilities(experimental: $experimental, general: $general, window: $window, notebookDocument: $notebookDocument, textDocument: $textDocument, workspace: $workspace)';
}


}

/// @nodoc
abstract mixin class $ClientCapabilitiesCopyWith<$Res>  {
  factory $ClientCapabilitiesCopyWith(ClientCapabilities value, $Res Function(ClientCapabilities) _then) = _$ClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 LSPAny? experimental, GeneralClientCapabilities? general, WindowClientCapabilities? window, NotebookDocumentClientCapabilities? notebookDocument, TextDocumentClientCapabilities? textDocument, WorkspaceClientCapabilities? workspace
});


$GeneralClientCapabilitiesCopyWith<$Res>? get general;$WindowClientCapabilitiesCopyWith<$Res>? get window;$NotebookDocumentClientCapabilitiesCopyWith<$Res>? get notebookDocument;$TextDocumentClientCapabilitiesCopyWith<$Res>? get textDocument;$WorkspaceClientCapabilitiesCopyWith<$Res>? get workspace;

}
/// @nodoc
class _$ClientCapabilitiesCopyWithImpl<$Res>
    implements $ClientCapabilitiesCopyWith<$Res> {
  _$ClientCapabilitiesCopyWithImpl(this._self, this._then);

  final ClientCapabilities _self;
  final $Res Function(ClientCapabilities) _then;

/// Create a copy of ClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? experimental = freezed,Object? general = freezed,Object? window = freezed,Object? notebookDocument = freezed,Object? textDocument = freezed,Object? workspace = freezed,}) {
  return _then(_self.copyWith(
experimental: freezed == experimental ? _self.experimental : experimental // ignore: cast_nullable_to_non_nullable
as LSPAny?,general: freezed == general ? _self.general : general // ignore: cast_nullable_to_non_nullable
as GeneralClientCapabilities?,window: freezed == window ? _self.window : window // ignore: cast_nullable_to_non_nullable
as WindowClientCapabilities?,notebookDocument: freezed == notebookDocument ? _self.notebookDocument : notebookDocument // ignore: cast_nullable_to_non_nullable
as NotebookDocumentClientCapabilities?,textDocument: freezed == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentClientCapabilities?,workspace: freezed == workspace ? _self.workspace : workspace // ignore: cast_nullable_to_non_nullable
as WorkspaceClientCapabilities?,
  ));
}
/// Create a copy of ClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$GeneralClientCapabilitiesCopyWith<$Res>? get general {
    if (_self.general == null) {
    return null;
  }

  return $GeneralClientCapabilitiesCopyWith<$Res>(_self.general!, (value) {
    return _then(_self.copyWith(general: value));
  });
}/// Create a copy of ClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$WindowClientCapabilitiesCopyWith<$Res>? get window {
    if (_self.window == null) {
    return null;
  }

  return $WindowClientCapabilitiesCopyWith<$Res>(_self.window!, (value) {
    return _then(_self.copyWith(window: value));
  });
}/// Create a copy of ClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$NotebookDocumentClientCapabilitiesCopyWith<$Res>? get notebookDocument {
    if (_self.notebookDocument == null) {
    return null;
  }

  return $NotebookDocumentClientCapabilitiesCopyWith<$Res>(_self.notebookDocument!, (value) {
    return _then(_self.copyWith(notebookDocument: value));
  });
}/// Create a copy of ClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentClientCapabilitiesCopyWith<$Res>? get textDocument {
    if (_self.textDocument == null) {
    return null;
  }

  return $TextDocumentClientCapabilitiesCopyWith<$Res>(_self.textDocument!, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of ClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$WorkspaceClientCapabilitiesCopyWith<$Res>? get workspace {
    if (_self.workspace == null) {
    return null;
  }

  return $WorkspaceClientCapabilitiesCopyWith<$Res>(_self.workspace!, (value) {
    return _then(_self.copyWith(workspace: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _ClientCapabilities implements ClientCapabilities {
  const _ClientCapabilities({this.experimental, this.general, this.window, this.notebookDocument, this.textDocument, this.workspace});
  factory _ClientCapabilities.fromJson(Map<String, dynamic> json) => _$ClientCapabilitiesFromJson(json);

@override final  LSPAny? experimental;
@override final  GeneralClientCapabilities? general;
@override final  WindowClientCapabilities? window;
@override final  NotebookDocumentClientCapabilities? notebookDocument;
@override final  TextDocumentClientCapabilities? textDocument;
@override final  WorkspaceClientCapabilities? workspace;

/// Create a copy of ClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ClientCapabilitiesCopyWith<_ClientCapabilities> get copyWith => __$ClientCapabilitiesCopyWithImpl<_ClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ClientCapabilities&&const DeepCollectionEquality().equals(other.experimental, experimental)&&(identical(other.general, general) || other.general == general)&&(identical(other.window, window) || other.window == window)&&(identical(other.notebookDocument, notebookDocument) || other.notebookDocument == notebookDocument)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workspace, workspace) || other.workspace == workspace));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(experimental),general,window,notebookDocument,textDocument,workspace);

@override
String toString() {
  return 'ClientCapabilities(experimental: $experimental, general: $general, window: $window, notebookDocument: $notebookDocument, textDocument: $textDocument, workspace: $workspace)';
}


}

/// @nodoc
abstract mixin class _$ClientCapabilitiesCopyWith<$Res> implements $ClientCapabilitiesCopyWith<$Res> {
  factory _$ClientCapabilitiesCopyWith(_ClientCapabilities value, $Res Function(_ClientCapabilities) _then) = __$ClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 LSPAny? experimental, GeneralClientCapabilities? general, WindowClientCapabilities? window, NotebookDocumentClientCapabilities? notebookDocument, TextDocumentClientCapabilities? textDocument, WorkspaceClientCapabilities? workspace
});


@override $GeneralClientCapabilitiesCopyWith<$Res>? get general;@override $WindowClientCapabilitiesCopyWith<$Res>? get window;@override $NotebookDocumentClientCapabilitiesCopyWith<$Res>? get notebookDocument;@override $TextDocumentClientCapabilitiesCopyWith<$Res>? get textDocument;@override $WorkspaceClientCapabilitiesCopyWith<$Res>? get workspace;

}
/// @nodoc
class __$ClientCapabilitiesCopyWithImpl<$Res>
    implements _$ClientCapabilitiesCopyWith<$Res> {
  __$ClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _ClientCapabilities _self;
  final $Res Function(_ClientCapabilities) _then;

/// Create a copy of ClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? experimental = freezed,Object? general = freezed,Object? window = freezed,Object? notebookDocument = freezed,Object? textDocument = freezed,Object? workspace = freezed,}) {
  return _then(_ClientCapabilities(
experimental: freezed == experimental ? _self.experimental : experimental // ignore: cast_nullable_to_non_nullable
as LSPAny?,general: freezed == general ? _self.general : general // ignore: cast_nullable_to_non_nullable
as GeneralClientCapabilities?,window: freezed == window ? _self.window : window // ignore: cast_nullable_to_non_nullable
as WindowClientCapabilities?,notebookDocument: freezed == notebookDocument ? _self.notebookDocument : notebookDocument // ignore: cast_nullable_to_non_nullable
as NotebookDocumentClientCapabilities?,textDocument: freezed == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentClientCapabilities?,workspace: freezed == workspace ? _self.workspace : workspace // ignore: cast_nullable_to_non_nullable
as WorkspaceClientCapabilities?,
  ));
}

/// Create a copy of ClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$GeneralClientCapabilitiesCopyWith<$Res>? get general {
    if (_self.general == null) {
    return null;
  }

  return $GeneralClientCapabilitiesCopyWith<$Res>(_self.general!, (value) {
    return _then(_self.copyWith(general: value));
  });
}/// Create a copy of ClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$WindowClientCapabilitiesCopyWith<$Res>? get window {
    if (_self.window == null) {
    return null;
  }

  return $WindowClientCapabilitiesCopyWith<$Res>(_self.window!, (value) {
    return _then(_self.copyWith(window: value));
  });
}/// Create a copy of ClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$NotebookDocumentClientCapabilitiesCopyWith<$Res>? get notebookDocument {
    if (_self.notebookDocument == null) {
    return null;
  }

  return $NotebookDocumentClientCapabilitiesCopyWith<$Res>(_self.notebookDocument!, (value) {
    return _then(_self.copyWith(notebookDocument: value));
  });
}/// Create a copy of ClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentClientCapabilitiesCopyWith<$Res>? get textDocument {
    if (_self.textDocument == null) {
    return null;
  }

  return $TextDocumentClientCapabilitiesCopyWith<$Res>(_self.textDocument!, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of ClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$WorkspaceClientCapabilitiesCopyWith<$Res>? get workspace {
    if (_self.workspace == null) {
    return null;
  }

  return $WorkspaceClientCapabilitiesCopyWith<$Res>(_self.workspace!, (value) {
    return _then(_self.copyWith(workspace: value));
  });
}
}


/// @nodoc
mixin _$TextDocumentSyncOptions {

 dynamic? get save; bool? get willSaveWaitUntil; bool? get willSave; TextDocumentSyncKind? get change; bool? get openClose;
/// Create a copy of TextDocumentSyncOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TextDocumentSyncOptionsCopyWith<TextDocumentSyncOptions> get copyWith => _$TextDocumentSyncOptionsCopyWithImpl<TextDocumentSyncOptions>(this as TextDocumentSyncOptions, _$identity);

  /// Serializes this TextDocumentSyncOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TextDocumentSyncOptions&&const DeepCollectionEquality().equals(other.save, save)&&(identical(other.willSaveWaitUntil, willSaveWaitUntil) || other.willSaveWaitUntil == willSaveWaitUntil)&&(identical(other.willSave, willSave) || other.willSave == willSave)&&(identical(other.change, change) || other.change == change)&&(identical(other.openClose, openClose) || other.openClose == openClose));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(save),willSaveWaitUntil,willSave,change,openClose);

@override
String toString() {
  return 'TextDocumentSyncOptions(save: $save, willSaveWaitUntil: $willSaveWaitUntil, willSave: $willSave, change: $change, openClose: $openClose)';
}


}

/// @nodoc
abstract mixin class $TextDocumentSyncOptionsCopyWith<$Res>  {
  factory $TextDocumentSyncOptionsCopyWith(TextDocumentSyncOptions value, $Res Function(TextDocumentSyncOptions) _then) = _$TextDocumentSyncOptionsCopyWithImpl;
@useResult
$Res call({
 dynamic? save, bool? willSaveWaitUntil, bool? willSave, TextDocumentSyncKind? change, bool? openClose
});




}
/// @nodoc
class _$TextDocumentSyncOptionsCopyWithImpl<$Res>
    implements $TextDocumentSyncOptionsCopyWith<$Res> {
  _$TextDocumentSyncOptionsCopyWithImpl(this._self, this._then);

  final TextDocumentSyncOptions _self;
  final $Res Function(TextDocumentSyncOptions) _then;

/// Create a copy of TextDocumentSyncOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? save = freezed,Object? willSaveWaitUntil = freezed,Object? willSave = freezed,Object? change = freezed,Object? openClose = freezed,}) {
  return _then(_self.copyWith(
save: freezed == save ? _self.save : save // ignore: cast_nullable_to_non_nullable
as dynamic?,willSaveWaitUntil: freezed == willSaveWaitUntil ? _self.willSaveWaitUntil : willSaveWaitUntil // ignore: cast_nullable_to_non_nullable
as bool?,willSave: freezed == willSave ? _self.willSave : willSave // ignore: cast_nullable_to_non_nullable
as bool?,change: freezed == change ? _self.change : change // ignore: cast_nullable_to_non_nullable
as TextDocumentSyncKind?,openClose: freezed == openClose ? _self.openClose : openClose // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _TextDocumentSyncOptions implements TextDocumentSyncOptions {
  const _TextDocumentSyncOptions({this.save, this.willSaveWaitUntil, this.willSave, this.change, this.openClose});
  factory _TextDocumentSyncOptions.fromJson(Map<String, dynamic> json) => _$TextDocumentSyncOptionsFromJson(json);

@override final  dynamic? save;
@override final  bool? willSaveWaitUntil;
@override final  bool? willSave;
@override final  TextDocumentSyncKind? change;
@override final  bool? openClose;

/// Create a copy of TextDocumentSyncOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TextDocumentSyncOptionsCopyWith<_TextDocumentSyncOptions> get copyWith => __$TextDocumentSyncOptionsCopyWithImpl<_TextDocumentSyncOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TextDocumentSyncOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TextDocumentSyncOptions&&const DeepCollectionEquality().equals(other.save, save)&&(identical(other.willSaveWaitUntil, willSaveWaitUntil) || other.willSaveWaitUntil == willSaveWaitUntil)&&(identical(other.willSave, willSave) || other.willSave == willSave)&&(identical(other.change, change) || other.change == change)&&(identical(other.openClose, openClose) || other.openClose == openClose));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(save),willSaveWaitUntil,willSave,change,openClose);

@override
String toString() {
  return 'TextDocumentSyncOptions(save: $save, willSaveWaitUntil: $willSaveWaitUntil, willSave: $willSave, change: $change, openClose: $openClose)';
}


}

/// @nodoc
abstract mixin class _$TextDocumentSyncOptionsCopyWith<$Res> implements $TextDocumentSyncOptionsCopyWith<$Res> {
  factory _$TextDocumentSyncOptionsCopyWith(_TextDocumentSyncOptions value, $Res Function(_TextDocumentSyncOptions) _then) = __$TextDocumentSyncOptionsCopyWithImpl;
@override @useResult
$Res call({
 dynamic? save, bool? willSaveWaitUntil, bool? willSave, TextDocumentSyncKind? change, bool? openClose
});




}
/// @nodoc
class __$TextDocumentSyncOptionsCopyWithImpl<$Res>
    implements _$TextDocumentSyncOptionsCopyWith<$Res> {
  __$TextDocumentSyncOptionsCopyWithImpl(this._self, this._then);

  final _TextDocumentSyncOptions _self;
  final $Res Function(_TextDocumentSyncOptions) _then;

/// Create a copy of TextDocumentSyncOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? save = freezed,Object? willSaveWaitUntil = freezed,Object? willSave = freezed,Object? change = freezed,Object? openClose = freezed,}) {
  return _then(_TextDocumentSyncOptions(
save: freezed == save ? _self.save : save // ignore: cast_nullable_to_non_nullable
as dynamic?,willSaveWaitUntil: freezed == willSaveWaitUntil ? _self.willSaveWaitUntil : willSaveWaitUntil // ignore: cast_nullable_to_non_nullable
as bool?,willSave: freezed == willSave ? _self.willSave : willSave // ignore: cast_nullable_to_non_nullable
as bool?,change: freezed == change ? _self.change : change // ignore: cast_nullable_to_non_nullable
as TextDocumentSyncKind?,openClose: freezed == openClose ? _self.openClose : openClose // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$NotebookDocumentSyncOptions {

 List<dynamic> get notebookSelector; bool? get save;
/// Create a copy of NotebookDocumentSyncOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$NotebookDocumentSyncOptionsCopyWith<NotebookDocumentSyncOptions> get copyWith => _$NotebookDocumentSyncOptionsCopyWithImpl<NotebookDocumentSyncOptions>(this as NotebookDocumentSyncOptions, _$identity);

  /// Serializes this NotebookDocumentSyncOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is NotebookDocumentSyncOptions&&const DeepCollectionEquality().equals(other.notebookSelector, notebookSelector)&&(identical(other.save, save) || other.save == save));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(notebookSelector),save);

@override
String toString() {
  return 'NotebookDocumentSyncOptions(notebookSelector: $notebookSelector, save: $save)';
}


}

/// @nodoc
abstract mixin class $NotebookDocumentSyncOptionsCopyWith<$Res>  {
  factory $NotebookDocumentSyncOptionsCopyWith(NotebookDocumentSyncOptions value, $Res Function(NotebookDocumentSyncOptions) _then) = _$NotebookDocumentSyncOptionsCopyWithImpl;
@useResult
$Res call({
 List<dynamic> notebookSelector, bool? save
});




}
/// @nodoc
class _$NotebookDocumentSyncOptionsCopyWithImpl<$Res>
    implements $NotebookDocumentSyncOptionsCopyWith<$Res> {
  _$NotebookDocumentSyncOptionsCopyWithImpl(this._self, this._then);

  final NotebookDocumentSyncOptions _self;
  final $Res Function(NotebookDocumentSyncOptions) _then;

/// Create a copy of NotebookDocumentSyncOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? notebookSelector = null,Object? save = freezed,}) {
  return _then(_self.copyWith(
notebookSelector: null == notebookSelector ? _self.notebookSelector : notebookSelector // ignore: cast_nullable_to_non_nullable
as List<dynamic>,save: freezed == save ? _self.save : save // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _NotebookDocumentSyncOptions implements NotebookDocumentSyncOptions {
  const _NotebookDocumentSyncOptions({required final  List<dynamic> notebookSelector, this.save}): _notebookSelector = notebookSelector;
  factory _NotebookDocumentSyncOptions.fromJson(Map<String, dynamic> json) => _$NotebookDocumentSyncOptionsFromJson(json);

 final  List<dynamic> _notebookSelector;
@override List<dynamic> get notebookSelector {
  if (_notebookSelector is EqualUnmodifiableListView) return _notebookSelector;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_notebookSelector);
}

@override final  bool? save;

/// Create a copy of NotebookDocumentSyncOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$NotebookDocumentSyncOptionsCopyWith<_NotebookDocumentSyncOptions> get copyWith => __$NotebookDocumentSyncOptionsCopyWithImpl<_NotebookDocumentSyncOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$NotebookDocumentSyncOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _NotebookDocumentSyncOptions&&const DeepCollectionEquality().equals(other._notebookSelector, _notebookSelector)&&(identical(other.save, save) || other.save == save));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_notebookSelector),save);

@override
String toString() {
  return 'NotebookDocumentSyncOptions(notebookSelector: $notebookSelector, save: $save)';
}


}

/// @nodoc
abstract mixin class _$NotebookDocumentSyncOptionsCopyWith<$Res> implements $NotebookDocumentSyncOptionsCopyWith<$Res> {
  factory _$NotebookDocumentSyncOptionsCopyWith(_NotebookDocumentSyncOptions value, $Res Function(_NotebookDocumentSyncOptions) _then) = __$NotebookDocumentSyncOptionsCopyWithImpl;
@override @useResult
$Res call({
 List<dynamic> notebookSelector, bool? save
});




}
/// @nodoc
class __$NotebookDocumentSyncOptionsCopyWithImpl<$Res>
    implements _$NotebookDocumentSyncOptionsCopyWith<$Res> {
  __$NotebookDocumentSyncOptionsCopyWithImpl(this._self, this._then);

  final _NotebookDocumentSyncOptions _self;
  final $Res Function(_NotebookDocumentSyncOptions) _then;

/// Create a copy of NotebookDocumentSyncOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? notebookSelector = null,Object? save = freezed,}) {
  return _then(_NotebookDocumentSyncOptions(
notebookSelector: null == notebookSelector ? _self._notebookSelector : notebookSelector // ignore: cast_nullable_to_non_nullable
as List<dynamic>,save: freezed == save ? _self.save : save // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$NotebookDocumentSyncRegistrationOptions {

 List<dynamic> get notebookSelector; String? get id; bool? get save;
/// Create a copy of NotebookDocumentSyncRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$NotebookDocumentSyncRegistrationOptionsCopyWith<NotebookDocumentSyncRegistrationOptions> get copyWith => _$NotebookDocumentSyncRegistrationOptionsCopyWithImpl<NotebookDocumentSyncRegistrationOptions>(this as NotebookDocumentSyncRegistrationOptions, _$identity);

  /// Serializes this NotebookDocumentSyncRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is NotebookDocumentSyncRegistrationOptions&&const DeepCollectionEquality().equals(other.notebookSelector, notebookSelector)&&(identical(other.id, id) || other.id == id)&&(identical(other.save, save) || other.save == save));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(notebookSelector),id,save);

@override
String toString() {
  return 'NotebookDocumentSyncRegistrationOptions(notebookSelector: $notebookSelector, id: $id, save: $save)';
}


}

/// @nodoc
abstract mixin class $NotebookDocumentSyncRegistrationOptionsCopyWith<$Res>  {
  factory $NotebookDocumentSyncRegistrationOptionsCopyWith(NotebookDocumentSyncRegistrationOptions value, $Res Function(NotebookDocumentSyncRegistrationOptions) _then) = _$NotebookDocumentSyncRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 List<dynamic> notebookSelector, String? id, bool? save
});




}
/// @nodoc
class _$NotebookDocumentSyncRegistrationOptionsCopyWithImpl<$Res>
    implements $NotebookDocumentSyncRegistrationOptionsCopyWith<$Res> {
  _$NotebookDocumentSyncRegistrationOptionsCopyWithImpl(this._self, this._then);

  final NotebookDocumentSyncRegistrationOptions _self;
  final $Res Function(NotebookDocumentSyncRegistrationOptions) _then;

/// Create a copy of NotebookDocumentSyncRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? notebookSelector = null,Object? id = freezed,Object? save = freezed,}) {
  return _then(_self.copyWith(
notebookSelector: null == notebookSelector ? _self.notebookSelector : notebookSelector // ignore: cast_nullable_to_non_nullable
as List<dynamic>,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,save: freezed == save ? _self.save : save // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _NotebookDocumentSyncRegistrationOptions implements NotebookDocumentSyncRegistrationOptions {
  const _NotebookDocumentSyncRegistrationOptions({required final  List<dynamic> notebookSelector, this.id, this.save}): _notebookSelector = notebookSelector;
  factory _NotebookDocumentSyncRegistrationOptions.fromJson(Map<String, dynamic> json) => _$NotebookDocumentSyncRegistrationOptionsFromJson(json);

 final  List<dynamic> _notebookSelector;
@override List<dynamic> get notebookSelector {
  if (_notebookSelector is EqualUnmodifiableListView) return _notebookSelector;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_notebookSelector);
}

@override final  String? id;
@override final  bool? save;

/// Create a copy of NotebookDocumentSyncRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$NotebookDocumentSyncRegistrationOptionsCopyWith<_NotebookDocumentSyncRegistrationOptions> get copyWith => __$NotebookDocumentSyncRegistrationOptionsCopyWithImpl<_NotebookDocumentSyncRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$NotebookDocumentSyncRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _NotebookDocumentSyncRegistrationOptions&&const DeepCollectionEquality().equals(other._notebookSelector, _notebookSelector)&&(identical(other.id, id) || other.id == id)&&(identical(other.save, save) || other.save == save));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_notebookSelector),id,save);

@override
String toString() {
  return 'NotebookDocumentSyncRegistrationOptions(notebookSelector: $notebookSelector, id: $id, save: $save)';
}


}

/// @nodoc
abstract mixin class _$NotebookDocumentSyncRegistrationOptionsCopyWith<$Res> implements $NotebookDocumentSyncRegistrationOptionsCopyWith<$Res> {
  factory _$NotebookDocumentSyncRegistrationOptionsCopyWith(_NotebookDocumentSyncRegistrationOptions value, $Res Function(_NotebookDocumentSyncRegistrationOptions) _then) = __$NotebookDocumentSyncRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 List<dynamic> notebookSelector, String? id, bool? save
});




}
/// @nodoc
class __$NotebookDocumentSyncRegistrationOptionsCopyWithImpl<$Res>
    implements _$NotebookDocumentSyncRegistrationOptionsCopyWith<$Res> {
  __$NotebookDocumentSyncRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _NotebookDocumentSyncRegistrationOptions _self;
  final $Res Function(_NotebookDocumentSyncRegistrationOptions) _then;

/// Create a copy of NotebookDocumentSyncRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? notebookSelector = null,Object? id = freezed,Object? save = freezed,}) {
  return _then(_NotebookDocumentSyncRegistrationOptions(
notebookSelector: null == notebookSelector ? _self._notebookSelector : notebookSelector // ignore: cast_nullable_to_non_nullable
as List<dynamic>,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,save: freezed == save ? _self.save : save // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$WorkspaceFoldersServerCapabilities {

 dynamic? get changeNotifications; bool? get supported;
/// Create a copy of WorkspaceFoldersServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkspaceFoldersServerCapabilitiesCopyWith<WorkspaceFoldersServerCapabilities> get copyWith => _$WorkspaceFoldersServerCapabilitiesCopyWithImpl<WorkspaceFoldersServerCapabilities>(this as WorkspaceFoldersServerCapabilities, _$identity);

  /// Serializes this WorkspaceFoldersServerCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkspaceFoldersServerCapabilities&&const DeepCollectionEquality().equals(other.changeNotifications, changeNotifications)&&(identical(other.supported, supported) || other.supported == supported));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(changeNotifications),supported);

@override
String toString() {
  return 'WorkspaceFoldersServerCapabilities(changeNotifications: $changeNotifications, supported: $supported)';
}


}

/// @nodoc
abstract mixin class $WorkspaceFoldersServerCapabilitiesCopyWith<$Res>  {
  factory $WorkspaceFoldersServerCapabilitiesCopyWith(WorkspaceFoldersServerCapabilities value, $Res Function(WorkspaceFoldersServerCapabilities) _then) = _$WorkspaceFoldersServerCapabilitiesCopyWithImpl;
@useResult
$Res call({
 dynamic? changeNotifications, bool? supported
});




}
/// @nodoc
class _$WorkspaceFoldersServerCapabilitiesCopyWithImpl<$Res>
    implements $WorkspaceFoldersServerCapabilitiesCopyWith<$Res> {
  _$WorkspaceFoldersServerCapabilitiesCopyWithImpl(this._self, this._then);

  final WorkspaceFoldersServerCapabilities _self;
  final $Res Function(WorkspaceFoldersServerCapabilities) _then;

/// Create a copy of WorkspaceFoldersServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? changeNotifications = freezed,Object? supported = freezed,}) {
  return _then(_self.copyWith(
changeNotifications: freezed == changeNotifications ? _self.changeNotifications : changeNotifications // ignore: cast_nullable_to_non_nullable
as dynamic?,supported: freezed == supported ? _self.supported : supported // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _WorkspaceFoldersServerCapabilities implements WorkspaceFoldersServerCapabilities {
  const _WorkspaceFoldersServerCapabilities({this.changeNotifications, this.supported});
  factory _WorkspaceFoldersServerCapabilities.fromJson(Map<String, dynamic> json) => _$WorkspaceFoldersServerCapabilitiesFromJson(json);

@override final  dynamic? changeNotifications;
@override final  bool? supported;

/// Create a copy of WorkspaceFoldersServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkspaceFoldersServerCapabilitiesCopyWith<_WorkspaceFoldersServerCapabilities> get copyWith => __$WorkspaceFoldersServerCapabilitiesCopyWithImpl<_WorkspaceFoldersServerCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkspaceFoldersServerCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkspaceFoldersServerCapabilities&&const DeepCollectionEquality().equals(other.changeNotifications, changeNotifications)&&(identical(other.supported, supported) || other.supported == supported));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(changeNotifications),supported);

@override
String toString() {
  return 'WorkspaceFoldersServerCapabilities(changeNotifications: $changeNotifications, supported: $supported)';
}


}

/// @nodoc
abstract mixin class _$WorkspaceFoldersServerCapabilitiesCopyWith<$Res> implements $WorkspaceFoldersServerCapabilitiesCopyWith<$Res> {
  factory _$WorkspaceFoldersServerCapabilitiesCopyWith(_WorkspaceFoldersServerCapabilities value, $Res Function(_WorkspaceFoldersServerCapabilities) _then) = __$WorkspaceFoldersServerCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 dynamic? changeNotifications, bool? supported
});




}
/// @nodoc
class __$WorkspaceFoldersServerCapabilitiesCopyWithImpl<$Res>
    implements _$WorkspaceFoldersServerCapabilitiesCopyWith<$Res> {
  __$WorkspaceFoldersServerCapabilitiesCopyWithImpl(this._self, this._then);

  final _WorkspaceFoldersServerCapabilities _self;
  final $Res Function(_WorkspaceFoldersServerCapabilities) _then;

/// Create a copy of WorkspaceFoldersServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? changeNotifications = freezed,Object? supported = freezed,}) {
  return _then(_WorkspaceFoldersServerCapabilities(
changeNotifications: freezed == changeNotifications ? _self.changeNotifications : changeNotifications // ignore: cast_nullable_to_non_nullable
as dynamic?,supported: freezed == supported ? _self.supported : supported // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$FileOperationOptions {

 FileOperationRegistrationOptions? get willDelete; FileOperationRegistrationOptions? get didDelete; FileOperationRegistrationOptions? get willRename; FileOperationRegistrationOptions? get didRename; FileOperationRegistrationOptions? get willCreate; FileOperationRegistrationOptions? get didCreate;
/// Create a copy of FileOperationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FileOperationOptionsCopyWith<FileOperationOptions> get copyWith => _$FileOperationOptionsCopyWithImpl<FileOperationOptions>(this as FileOperationOptions, _$identity);

  /// Serializes this FileOperationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FileOperationOptions&&(identical(other.willDelete, willDelete) || other.willDelete == willDelete)&&(identical(other.didDelete, didDelete) || other.didDelete == didDelete)&&(identical(other.willRename, willRename) || other.willRename == willRename)&&(identical(other.didRename, didRename) || other.didRename == didRename)&&(identical(other.willCreate, willCreate) || other.willCreate == willCreate)&&(identical(other.didCreate, didCreate) || other.didCreate == didCreate));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,willDelete,didDelete,willRename,didRename,willCreate,didCreate);

@override
String toString() {
  return 'FileOperationOptions(willDelete: $willDelete, didDelete: $didDelete, willRename: $willRename, didRename: $didRename, willCreate: $willCreate, didCreate: $didCreate)';
}


}

/// @nodoc
abstract mixin class $FileOperationOptionsCopyWith<$Res>  {
  factory $FileOperationOptionsCopyWith(FileOperationOptions value, $Res Function(FileOperationOptions) _then) = _$FileOperationOptionsCopyWithImpl;
@useResult
$Res call({
 FileOperationRegistrationOptions? willDelete, FileOperationRegistrationOptions? didDelete, FileOperationRegistrationOptions? willRename, FileOperationRegistrationOptions? didRename, FileOperationRegistrationOptions? willCreate, FileOperationRegistrationOptions? didCreate
});


$FileOperationRegistrationOptionsCopyWith<$Res>? get willDelete;$FileOperationRegistrationOptionsCopyWith<$Res>? get didDelete;$FileOperationRegistrationOptionsCopyWith<$Res>? get willRename;$FileOperationRegistrationOptionsCopyWith<$Res>? get didRename;$FileOperationRegistrationOptionsCopyWith<$Res>? get willCreate;$FileOperationRegistrationOptionsCopyWith<$Res>? get didCreate;

}
/// @nodoc
class _$FileOperationOptionsCopyWithImpl<$Res>
    implements $FileOperationOptionsCopyWith<$Res> {
  _$FileOperationOptionsCopyWithImpl(this._self, this._then);

  final FileOperationOptions _self;
  final $Res Function(FileOperationOptions) _then;

/// Create a copy of FileOperationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? willDelete = freezed,Object? didDelete = freezed,Object? willRename = freezed,Object? didRename = freezed,Object? willCreate = freezed,Object? didCreate = freezed,}) {
  return _then(_self.copyWith(
willDelete: freezed == willDelete ? _self.willDelete : willDelete // ignore: cast_nullable_to_non_nullable
as FileOperationRegistrationOptions?,didDelete: freezed == didDelete ? _self.didDelete : didDelete // ignore: cast_nullable_to_non_nullable
as FileOperationRegistrationOptions?,willRename: freezed == willRename ? _self.willRename : willRename // ignore: cast_nullable_to_non_nullable
as FileOperationRegistrationOptions?,didRename: freezed == didRename ? _self.didRename : didRename // ignore: cast_nullable_to_non_nullable
as FileOperationRegistrationOptions?,willCreate: freezed == willCreate ? _self.willCreate : willCreate // ignore: cast_nullable_to_non_nullable
as FileOperationRegistrationOptions?,didCreate: freezed == didCreate ? _self.didCreate : didCreate // ignore: cast_nullable_to_non_nullable
as FileOperationRegistrationOptions?,
  ));
}
/// Create a copy of FileOperationOptions
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FileOperationRegistrationOptionsCopyWith<$Res>? get willDelete {
    if (_self.willDelete == null) {
    return null;
  }

  return $FileOperationRegistrationOptionsCopyWith<$Res>(_self.willDelete!, (value) {
    return _then(_self.copyWith(willDelete: value));
  });
}/// Create a copy of FileOperationOptions
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FileOperationRegistrationOptionsCopyWith<$Res>? get didDelete {
    if (_self.didDelete == null) {
    return null;
  }

  return $FileOperationRegistrationOptionsCopyWith<$Res>(_self.didDelete!, (value) {
    return _then(_self.copyWith(didDelete: value));
  });
}/// Create a copy of FileOperationOptions
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FileOperationRegistrationOptionsCopyWith<$Res>? get willRename {
    if (_self.willRename == null) {
    return null;
  }

  return $FileOperationRegistrationOptionsCopyWith<$Res>(_self.willRename!, (value) {
    return _then(_self.copyWith(willRename: value));
  });
}/// Create a copy of FileOperationOptions
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FileOperationRegistrationOptionsCopyWith<$Res>? get didRename {
    if (_self.didRename == null) {
    return null;
  }

  return $FileOperationRegistrationOptionsCopyWith<$Res>(_self.didRename!, (value) {
    return _then(_self.copyWith(didRename: value));
  });
}/// Create a copy of FileOperationOptions
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FileOperationRegistrationOptionsCopyWith<$Res>? get willCreate {
    if (_self.willCreate == null) {
    return null;
  }

  return $FileOperationRegistrationOptionsCopyWith<$Res>(_self.willCreate!, (value) {
    return _then(_self.copyWith(willCreate: value));
  });
}/// Create a copy of FileOperationOptions
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FileOperationRegistrationOptionsCopyWith<$Res>? get didCreate {
    if (_self.didCreate == null) {
    return null;
  }

  return $FileOperationRegistrationOptionsCopyWith<$Res>(_self.didCreate!, (value) {
    return _then(_self.copyWith(didCreate: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _FileOperationOptions implements FileOperationOptions {
  const _FileOperationOptions({this.willDelete, this.didDelete, this.willRename, this.didRename, this.willCreate, this.didCreate});
  factory _FileOperationOptions.fromJson(Map<String, dynamic> json) => _$FileOperationOptionsFromJson(json);

@override final  FileOperationRegistrationOptions? willDelete;
@override final  FileOperationRegistrationOptions? didDelete;
@override final  FileOperationRegistrationOptions? willRename;
@override final  FileOperationRegistrationOptions? didRename;
@override final  FileOperationRegistrationOptions? willCreate;
@override final  FileOperationRegistrationOptions? didCreate;

/// Create a copy of FileOperationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$FileOperationOptionsCopyWith<_FileOperationOptions> get copyWith => __$FileOperationOptionsCopyWithImpl<_FileOperationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$FileOperationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _FileOperationOptions&&(identical(other.willDelete, willDelete) || other.willDelete == willDelete)&&(identical(other.didDelete, didDelete) || other.didDelete == didDelete)&&(identical(other.willRename, willRename) || other.willRename == willRename)&&(identical(other.didRename, didRename) || other.didRename == didRename)&&(identical(other.willCreate, willCreate) || other.willCreate == willCreate)&&(identical(other.didCreate, didCreate) || other.didCreate == didCreate));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,willDelete,didDelete,willRename,didRename,willCreate,didCreate);

@override
String toString() {
  return 'FileOperationOptions(willDelete: $willDelete, didDelete: $didDelete, willRename: $willRename, didRename: $didRename, willCreate: $willCreate, didCreate: $didCreate)';
}


}

/// @nodoc
abstract mixin class _$FileOperationOptionsCopyWith<$Res> implements $FileOperationOptionsCopyWith<$Res> {
  factory _$FileOperationOptionsCopyWith(_FileOperationOptions value, $Res Function(_FileOperationOptions) _then) = __$FileOperationOptionsCopyWithImpl;
@override @useResult
$Res call({
 FileOperationRegistrationOptions? willDelete, FileOperationRegistrationOptions? didDelete, FileOperationRegistrationOptions? willRename, FileOperationRegistrationOptions? didRename, FileOperationRegistrationOptions? willCreate, FileOperationRegistrationOptions? didCreate
});


@override $FileOperationRegistrationOptionsCopyWith<$Res>? get willDelete;@override $FileOperationRegistrationOptionsCopyWith<$Res>? get didDelete;@override $FileOperationRegistrationOptionsCopyWith<$Res>? get willRename;@override $FileOperationRegistrationOptionsCopyWith<$Res>? get didRename;@override $FileOperationRegistrationOptionsCopyWith<$Res>? get willCreate;@override $FileOperationRegistrationOptionsCopyWith<$Res>? get didCreate;

}
/// @nodoc
class __$FileOperationOptionsCopyWithImpl<$Res>
    implements _$FileOperationOptionsCopyWith<$Res> {
  __$FileOperationOptionsCopyWithImpl(this._self, this._then);

  final _FileOperationOptions _self;
  final $Res Function(_FileOperationOptions) _then;

/// Create a copy of FileOperationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? willDelete = freezed,Object? didDelete = freezed,Object? willRename = freezed,Object? didRename = freezed,Object? willCreate = freezed,Object? didCreate = freezed,}) {
  return _then(_FileOperationOptions(
willDelete: freezed == willDelete ? _self.willDelete : willDelete // ignore: cast_nullable_to_non_nullable
as FileOperationRegistrationOptions?,didDelete: freezed == didDelete ? _self.didDelete : didDelete // ignore: cast_nullable_to_non_nullable
as FileOperationRegistrationOptions?,willRename: freezed == willRename ? _self.willRename : willRename // ignore: cast_nullable_to_non_nullable
as FileOperationRegistrationOptions?,didRename: freezed == didRename ? _self.didRename : didRename // ignore: cast_nullable_to_non_nullable
as FileOperationRegistrationOptions?,willCreate: freezed == willCreate ? _self.willCreate : willCreate // ignore: cast_nullable_to_non_nullable
as FileOperationRegistrationOptions?,didCreate: freezed == didCreate ? _self.didCreate : didCreate // ignore: cast_nullable_to_non_nullable
as FileOperationRegistrationOptions?,
  ));
}

/// Create a copy of FileOperationOptions
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FileOperationRegistrationOptionsCopyWith<$Res>? get willDelete {
    if (_self.willDelete == null) {
    return null;
  }

  return $FileOperationRegistrationOptionsCopyWith<$Res>(_self.willDelete!, (value) {
    return _then(_self.copyWith(willDelete: value));
  });
}/// Create a copy of FileOperationOptions
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FileOperationRegistrationOptionsCopyWith<$Res>? get didDelete {
    if (_self.didDelete == null) {
    return null;
  }

  return $FileOperationRegistrationOptionsCopyWith<$Res>(_self.didDelete!, (value) {
    return _then(_self.copyWith(didDelete: value));
  });
}/// Create a copy of FileOperationOptions
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FileOperationRegistrationOptionsCopyWith<$Res>? get willRename {
    if (_self.willRename == null) {
    return null;
  }

  return $FileOperationRegistrationOptionsCopyWith<$Res>(_self.willRename!, (value) {
    return _then(_self.copyWith(willRename: value));
  });
}/// Create a copy of FileOperationOptions
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FileOperationRegistrationOptionsCopyWith<$Res>? get didRename {
    if (_self.didRename == null) {
    return null;
  }

  return $FileOperationRegistrationOptionsCopyWith<$Res>(_self.didRename!, (value) {
    return _then(_self.copyWith(didRename: value));
  });
}/// Create a copy of FileOperationOptions
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FileOperationRegistrationOptionsCopyWith<$Res>? get willCreate {
    if (_self.willCreate == null) {
    return null;
  }

  return $FileOperationRegistrationOptionsCopyWith<$Res>(_self.willCreate!, (value) {
    return _then(_self.copyWith(willCreate: value));
  });
}/// Create a copy of FileOperationOptions
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FileOperationRegistrationOptionsCopyWith<$Res>? get didCreate {
    if (_self.didCreate == null) {
    return null;
  }

  return $FileOperationRegistrationOptionsCopyWith<$Res>(_self.didCreate!, (value) {
    return _then(_self.copyWith(didCreate: value));
  });
}
}


/// @nodoc
mixin _$CodeDescription {

 String get href;
/// Create a copy of CodeDescription
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CodeDescriptionCopyWith<CodeDescription> get copyWith => _$CodeDescriptionCopyWithImpl<CodeDescription>(this as CodeDescription, _$identity);

  /// Serializes this CodeDescription to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CodeDescription&&(identical(other.href, href) || other.href == href));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,href);

@override
String toString() {
  return 'CodeDescription(href: $href)';
}


}

/// @nodoc
abstract mixin class $CodeDescriptionCopyWith<$Res>  {
  factory $CodeDescriptionCopyWith(CodeDescription value, $Res Function(CodeDescription) _then) = _$CodeDescriptionCopyWithImpl;
@useResult
$Res call({
 String href
});




}
/// @nodoc
class _$CodeDescriptionCopyWithImpl<$Res>
    implements $CodeDescriptionCopyWith<$Res> {
  _$CodeDescriptionCopyWithImpl(this._self, this._then);

  final CodeDescription _self;
  final $Res Function(CodeDescription) _then;

/// Create a copy of CodeDescription
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? href = null,}) {
  return _then(_self.copyWith(
href: null == href ? _self.href : href // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _CodeDescription implements CodeDescription {
  const _CodeDescription({required this.href});
  factory _CodeDescription.fromJson(Map<String, dynamic> json) => _$CodeDescriptionFromJson(json);

@override final  String href;

/// Create a copy of CodeDescription
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CodeDescriptionCopyWith<_CodeDescription> get copyWith => __$CodeDescriptionCopyWithImpl<_CodeDescription>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CodeDescriptionToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CodeDescription&&(identical(other.href, href) || other.href == href));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,href);

@override
String toString() {
  return 'CodeDescription(href: $href)';
}


}

/// @nodoc
abstract mixin class _$CodeDescriptionCopyWith<$Res> implements $CodeDescriptionCopyWith<$Res> {
  factory _$CodeDescriptionCopyWith(_CodeDescription value, $Res Function(_CodeDescription) _then) = __$CodeDescriptionCopyWithImpl;
@override @useResult
$Res call({
 String href
});




}
/// @nodoc
class __$CodeDescriptionCopyWithImpl<$Res>
    implements _$CodeDescriptionCopyWith<$Res> {
  __$CodeDescriptionCopyWithImpl(this._self, this._then);

  final _CodeDescription _self;
  final $Res Function(_CodeDescription) _then;

/// Create a copy of CodeDescription
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? href = null,}) {
  return _then(_CodeDescription(
href: null == href ? _self.href : href // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}


/// @nodoc
mixin _$DiagnosticRelatedInformation {

 Location get location; String get message;
/// Create a copy of DiagnosticRelatedInformation
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DiagnosticRelatedInformationCopyWith<DiagnosticRelatedInformation> get copyWith => _$DiagnosticRelatedInformationCopyWithImpl<DiagnosticRelatedInformation>(this as DiagnosticRelatedInformation, _$identity);

  /// Serializes this DiagnosticRelatedInformation to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DiagnosticRelatedInformation&&(identical(other.location, location) || other.location == location)&&(identical(other.message, message) || other.message == message));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,location,message);

@override
String toString() {
  return 'DiagnosticRelatedInformation(location: $location, message: $message)';
}


}

/// @nodoc
abstract mixin class $DiagnosticRelatedInformationCopyWith<$Res>  {
  factory $DiagnosticRelatedInformationCopyWith(DiagnosticRelatedInformation value, $Res Function(DiagnosticRelatedInformation) _then) = _$DiagnosticRelatedInformationCopyWithImpl;
@useResult
$Res call({
 Location location, String message
});


$LocationCopyWith<$Res> get location;

}
/// @nodoc
class _$DiagnosticRelatedInformationCopyWithImpl<$Res>
    implements $DiagnosticRelatedInformationCopyWith<$Res> {
  _$DiagnosticRelatedInformationCopyWithImpl(this._self, this._then);

  final DiagnosticRelatedInformation _self;
  final $Res Function(DiagnosticRelatedInformation) _then;

/// Create a copy of DiagnosticRelatedInformation
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? location = null,Object? message = null,}) {
  return _then(_self.copyWith(
location: null == location ? _self.location : location // ignore: cast_nullable_to_non_nullable
as Location,message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,
  ));
}
/// Create a copy of DiagnosticRelatedInformation
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$LocationCopyWith<$Res> get location {
  
  return $LocationCopyWith<$Res>(_self.location, (value) {
    return _then(_self.copyWith(location: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DiagnosticRelatedInformation implements DiagnosticRelatedInformation {
  const _DiagnosticRelatedInformation({required this.location, required this.message});
  factory _DiagnosticRelatedInformation.fromJson(Map<String, dynamic> json) => _$DiagnosticRelatedInformationFromJson(json);

@override final  Location location;
@override final  String message;

/// Create a copy of DiagnosticRelatedInformation
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DiagnosticRelatedInformationCopyWith<_DiagnosticRelatedInformation> get copyWith => __$DiagnosticRelatedInformationCopyWithImpl<_DiagnosticRelatedInformation>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DiagnosticRelatedInformationToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DiagnosticRelatedInformation&&(identical(other.location, location) || other.location == location)&&(identical(other.message, message) || other.message == message));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,location,message);

@override
String toString() {
  return 'DiagnosticRelatedInformation(location: $location, message: $message)';
}


}

/// @nodoc
abstract mixin class _$DiagnosticRelatedInformationCopyWith<$Res> implements $DiagnosticRelatedInformationCopyWith<$Res> {
  factory _$DiagnosticRelatedInformationCopyWith(_DiagnosticRelatedInformation value, $Res Function(_DiagnosticRelatedInformation) _then) = __$DiagnosticRelatedInformationCopyWithImpl;
@override @useResult
$Res call({
 Location location, String message
});


@override $LocationCopyWith<$Res> get location;

}
/// @nodoc
class __$DiagnosticRelatedInformationCopyWithImpl<$Res>
    implements _$DiagnosticRelatedInformationCopyWith<$Res> {
  __$DiagnosticRelatedInformationCopyWithImpl(this._self, this._then);

  final _DiagnosticRelatedInformation _self;
  final $Res Function(_DiagnosticRelatedInformation) _then;

/// Create a copy of DiagnosticRelatedInformation
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? location = null,Object? message = null,}) {
  return _then(_DiagnosticRelatedInformation(
location: null == location ? _self.location : location // ignore: cast_nullable_to_non_nullable
as Location,message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

/// Create a copy of DiagnosticRelatedInformation
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$LocationCopyWith<$Res> get location {
  
  return $LocationCopyWith<$Res>(_self.location, (value) {
    return _then(_self.copyWith(location: value));
  });
}
}


/// @nodoc
mixin _$ParameterInformation {

 dynamic get label; dynamic? get documentation;
/// Create a copy of ParameterInformation
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ParameterInformationCopyWith<ParameterInformation> get copyWith => _$ParameterInformationCopyWithImpl<ParameterInformation>(this as ParameterInformation, _$identity);

  /// Serializes this ParameterInformation to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ParameterInformation&&const DeepCollectionEquality().equals(other.label, label)&&const DeepCollectionEquality().equals(other.documentation, documentation));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(label),const DeepCollectionEquality().hash(documentation));

@override
String toString() {
  return 'ParameterInformation(label: $label, documentation: $documentation)';
}


}

/// @nodoc
abstract mixin class $ParameterInformationCopyWith<$Res>  {
  factory $ParameterInformationCopyWith(ParameterInformation value, $Res Function(ParameterInformation) _then) = _$ParameterInformationCopyWithImpl;
@useResult
$Res call({
 dynamic label, dynamic? documentation
});




}
/// @nodoc
class _$ParameterInformationCopyWithImpl<$Res>
    implements $ParameterInformationCopyWith<$Res> {
  _$ParameterInformationCopyWithImpl(this._self, this._then);

  final ParameterInformation _self;
  final $Res Function(ParameterInformation) _then;

/// Create a copy of ParameterInformation
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? label = freezed,Object? documentation = freezed,}) {
  return _then(_self.copyWith(
label: freezed == label ? _self.label : label // ignore: cast_nullable_to_non_nullable
as dynamic,documentation: freezed == documentation ? _self.documentation : documentation // ignore: cast_nullable_to_non_nullable
as dynamic?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _ParameterInformation implements ParameterInformation {
  const _ParameterInformation({required this.label, this.documentation});
  factory _ParameterInformation.fromJson(Map<String, dynamic> json) => _$ParameterInformationFromJson(json);

@override final  dynamic label;
@override final  dynamic? documentation;

/// Create a copy of ParameterInformation
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ParameterInformationCopyWith<_ParameterInformation> get copyWith => __$ParameterInformationCopyWithImpl<_ParameterInformation>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ParameterInformationToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ParameterInformation&&const DeepCollectionEquality().equals(other.label, label)&&const DeepCollectionEquality().equals(other.documentation, documentation));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(label),const DeepCollectionEquality().hash(documentation));

@override
String toString() {
  return 'ParameterInformation(label: $label, documentation: $documentation)';
}


}

/// @nodoc
abstract mixin class _$ParameterInformationCopyWith<$Res> implements $ParameterInformationCopyWith<$Res> {
  factory _$ParameterInformationCopyWith(_ParameterInformation value, $Res Function(_ParameterInformation) _then) = __$ParameterInformationCopyWithImpl;
@override @useResult
$Res call({
 dynamic label, dynamic? documentation
});




}
/// @nodoc
class __$ParameterInformationCopyWithImpl<$Res>
    implements _$ParameterInformationCopyWith<$Res> {
  __$ParameterInformationCopyWithImpl(this._self, this._then);

  final _ParameterInformation _self;
  final $Res Function(_ParameterInformation) _then;

/// Create a copy of ParameterInformation
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? label = freezed,Object? documentation = freezed,}) {
  return _then(_ParameterInformation(
label: freezed == label ? _self.label : label // ignore: cast_nullable_to_non_nullable
as dynamic,documentation: freezed == documentation ? _self.documentation : documentation // ignore: cast_nullable_to_non_nullable
as dynamic?,
  ));
}


}


/// @nodoc
mixin _$NotebookCellTextDocumentFilter {

 dynamic get notebook; String? get language;
/// Create a copy of NotebookCellTextDocumentFilter
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$NotebookCellTextDocumentFilterCopyWith<NotebookCellTextDocumentFilter> get copyWith => _$NotebookCellTextDocumentFilterCopyWithImpl<NotebookCellTextDocumentFilter>(this as NotebookCellTextDocumentFilter, _$identity);

  /// Serializes this NotebookCellTextDocumentFilter to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is NotebookCellTextDocumentFilter&&const DeepCollectionEquality().equals(other.notebook, notebook)&&(identical(other.language, language) || other.language == language));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(notebook),language);

@override
String toString() {
  return 'NotebookCellTextDocumentFilter(notebook: $notebook, language: $language)';
}


}

/// @nodoc
abstract mixin class $NotebookCellTextDocumentFilterCopyWith<$Res>  {
  factory $NotebookCellTextDocumentFilterCopyWith(NotebookCellTextDocumentFilter value, $Res Function(NotebookCellTextDocumentFilter) _then) = _$NotebookCellTextDocumentFilterCopyWithImpl;
@useResult
$Res call({
 dynamic notebook, String? language
});




}
/// @nodoc
class _$NotebookCellTextDocumentFilterCopyWithImpl<$Res>
    implements $NotebookCellTextDocumentFilterCopyWith<$Res> {
  _$NotebookCellTextDocumentFilterCopyWithImpl(this._self, this._then);

  final NotebookCellTextDocumentFilter _self;
  final $Res Function(NotebookCellTextDocumentFilter) _then;

/// Create a copy of NotebookCellTextDocumentFilter
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? notebook = freezed,Object? language = freezed,}) {
  return _then(_self.copyWith(
notebook: freezed == notebook ? _self.notebook : notebook // ignore: cast_nullable_to_non_nullable
as dynamic,language: freezed == language ? _self.language : language // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _NotebookCellTextDocumentFilter implements NotebookCellTextDocumentFilter {
  const _NotebookCellTextDocumentFilter({required this.notebook, this.language});
  factory _NotebookCellTextDocumentFilter.fromJson(Map<String, dynamic> json) => _$NotebookCellTextDocumentFilterFromJson(json);

@override final  dynamic notebook;
@override final  String? language;

/// Create a copy of NotebookCellTextDocumentFilter
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$NotebookCellTextDocumentFilterCopyWith<_NotebookCellTextDocumentFilter> get copyWith => __$NotebookCellTextDocumentFilterCopyWithImpl<_NotebookCellTextDocumentFilter>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$NotebookCellTextDocumentFilterToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _NotebookCellTextDocumentFilter&&const DeepCollectionEquality().equals(other.notebook, notebook)&&(identical(other.language, language) || other.language == language));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(notebook),language);

@override
String toString() {
  return 'NotebookCellTextDocumentFilter(notebook: $notebook, language: $language)';
}


}

/// @nodoc
abstract mixin class _$NotebookCellTextDocumentFilterCopyWith<$Res> implements $NotebookCellTextDocumentFilterCopyWith<$Res> {
  factory _$NotebookCellTextDocumentFilterCopyWith(_NotebookCellTextDocumentFilter value, $Res Function(_NotebookCellTextDocumentFilter) _then) = __$NotebookCellTextDocumentFilterCopyWithImpl;
@override @useResult
$Res call({
 dynamic notebook, String? language
});




}
/// @nodoc
class __$NotebookCellTextDocumentFilterCopyWithImpl<$Res>
    implements _$NotebookCellTextDocumentFilterCopyWith<$Res> {
  __$NotebookCellTextDocumentFilterCopyWithImpl(this._self, this._then);

  final _NotebookCellTextDocumentFilter _self;
  final $Res Function(_NotebookCellTextDocumentFilter) _then;

/// Create a copy of NotebookCellTextDocumentFilter
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? notebook = freezed,Object? language = freezed,}) {
  return _then(_NotebookCellTextDocumentFilter(
notebook: freezed == notebook ? _self.notebook : notebook // ignore: cast_nullable_to_non_nullable
as dynamic,language: freezed == language ? _self.language : language // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$FileOperationPatternOptions {

 bool? get ignoreCase;
/// Create a copy of FileOperationPatternOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FileOperationPatternOptionsCopyWith<FileOperationPatternOptions> get copyWith => _$FileOperationPatternOptionsCopyWithImpl<FileOperationPatternOptions>(this as FileOperationPatternOptions, _$identity);

  /// Serializes this FileOperationPatternOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FileOperationPatternOptions&&(identical(other.ignoreCase, ignoreCase) || other.ignoreCase == ignoreCase));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,ignoreCase);

@override
String toString() {
  return 'FileOperationPatternOptions(ignoreCase: $ignoreCase)';
}


}

/// @nodoc
abstract mixin class $FileOperationPatternOptionsCopyWith<$Res>  {
  factory $FileOperationPatternOptionsCopyWith(FileOperationPatternOptions value, $Res Function(FileOperationPatternOptions) _then) = _$FileOperationPatternOptionsCopyWithImpl;
@useResult
$Res call({
 bool? ignoreCase
});




}
/// @nodoc
class _$FileOperationPatternOptionsCopyWithImpl<$Res>
    implements $FileOperationPatternOptionsCopyWith<$Res> {
  _$FileOperationPatternOptionsCopyWithImpl(this._self, this._then);

  final FileOperationPatternOptions _self;
  final $Res Function(FileOperationPatternOptions) _then;

/// Create a copy of FileOperationPatternOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? ignoreCase = freezed,}) {
  return _then(_self.copyWith(
ignoreCase: freezed == ignoreCase ? _self.ignoreCase : ignoreCase // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _FileOperationPatternOptions implements FileOperationPatternOptions {
  const _FileOperationPatternOptions({this.ignoreCase});
  factory _FileOperationPatternOptions.fromJson(Map<String, dynamic> json) => _$FileOperationPatternOptionsFromJson(json);

@override final  bool? ignoreCase;

/// Create a copy of FileOperationPatternOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$FileOperationPatternOptionsCopyWith<_FileOperationPatternOptions> get copyWith => __$FileOperationPatternOptionsCopyWithImpl<_FileOperationPatternOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$FileOperationPatternOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _FileOperationPatternOptions&&(identical(other.ignoreCase, ignoreCase) || other.ignoreCase == ignoreCase));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,ignoreCase);

@override
String toString() {
  return 'FileOperationPatternOptions(ignoreCase: $ignoreCase)';
}


}

/// @nodoc
abstract mixin class _$FileOperationPatternOptionsCopyWith<$Res> implements $FileOperationPatternOptionsCopyWith<$Res> {
  factory _$FileOperationPatternOptionsCopyWith(_FileOperationPatternOptions value, $Res Function(_FileOperationPatternOptions) _then) = __$FileOperationPatternOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? ignoreCase
});




}
/// @nodoc
class __$FileOperationPatternOptionsCopyWithImpl<$Res>
    implements _$FileOperationPatternOptionsCopyWith<$Res> {
  __$FileOperationPatternOptionsCopyWithImpl(this._self, this._then);

  final _FileOperationPatternOptions _self;
  final $Res Function(_FileOperationPatternOptions) _then;

/// Create a copy of FileOperationPatternOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? ignoreCase = freezed,}) {
  return _then(_FileOperationPatternOptions(
ignoreCase: freezed == ignoreCase ? _self.ignoreCase : ignoreCase // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$ExecutionSummary {

 int get executionOrder; bool? get success;
/// Create a copy of ExecutionSummary
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ExecutionSummaryCopyWith<ExecutionSummary> get copyWith => _$ExecutionSummaryCopyWithImpl<ExecutionSummary>(this as ExecutionSummary, _$identity);

  /// Serializes this ExecutionSummary to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ExecutionSummary&&(identical(other.executionOrder, executionOrder) || other.executionOrder == executionOrder)&&(identical(other.success, success) || other.success == success));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,executionOrder,success);

@override
String toString() {
  return 'ExecutionSummary(executionOrder: $executionOrder, success: $success)';
}


}

/// @nodoc
abstract mixin class $ExecutionSummaryCopyWith<$Res>  {
  factory $ExecutionSummaryCopyWith(ExecutionSummary value, $Res Function(ExecutionSummary) _then) = _$ExecutionSummaryCopyWithImpl;
@useResult
$Res call({
 int executionOrder, bool? success
});




}
/// @nodoc
class _$ExecutionSummaryCopyWithImpl<$Res>
    implements $ExecutionSummaryCopyWith<$Res> {
  _$ExecutionSummaryCopyWithImpl(this._self, this._then);

  final ExecutionSummary _self;
  final $Res Function(ExecutionSummary) _then;

/// Create a copy of ExecutionSummary
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? executionOrder = null,Object? success = freezed,}) {
  return _then(_self.copyWith(
executionOrder: null == executionOrder ? _self.executionOrder : executionOrder // ignore: cast_nullable_to_non_nullable
as int,success: freezed == success ? _self.success : success // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _ExecutionSummary implements ExecutionSummary {
  const _ExecutionSummary({required this.executionOrder, this.success});
  factory _ExecutionSummary.fromJson(Map<String, dynamic> json) => _$ExecutionSummaryFromJson(json);

@override final  int executionOrder;
@override final  bool? success;

/// Create a copy of ExecutionSummary
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ExecutionSummaryCopyWith<_ExecutionSummary> get copyWith => __$ExecutionSummaryCopyWithImpl<_ExecutionSummary>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ExecutionSummaryToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ExecutionSummary&&(identical(other.executionOrder, executionOrder) || other.executionOrder == executionOrder)&&(identical(other.success, success) || other.success == success));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,executionOrder,success);

@override
String toString() {
  return 'ExecutionSummary(executionOrder: $executionOrder, success: $success)';
}


}

/// @nodoc
abstract mixin class _$ExecutionSummaryCopyWith<$Res> implements $ExecutionSummaryCopyWith<$Res> {
  factory _$ExecutionSummaryCopyWith(_ExecutionSummary value, $Res Function(_ExecutionSummary) _then) = __$ExecutionSummaryCopyWithImpl;
@override @useResult
$Res call({
 int executionOrder, bool? success
});




}
/// @nodoc
class __$ExecutionSummaryCopyWithImpl<$Res>
    implements _$ExecutionSummaryCopyWith<$Res> {
  __$ExecutionSummaryCopyWithImpl(this._self, this._then);

  final _ExecutionSummary _self;
  final $Res Function(_ExecutionSummary) _then;

/// Create a copy of ExecutionSummary
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? executionOrder = null,Object? success = freezed,}) {
  return _then(_ExecutionSummary(
executionOrder: null == executionOrder ? _self.executionOrder : executionOrder // ignore: cast_nullable_to_non_nullable
as int,success: freezed == success ? _self.success : success // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$WorkspaceClientCapabilities {

 FoldingRangeWorkspaceClientCapabilities? get foldingRange; DiagnosticWorkspaceClientCapabilities? get diagnostics; InlayHintWorkspaceClientCapabilities? get inlayHint; InlineValueWorkspaceClientCapabilities? get inlineValue; FileOperationClientCapabilities? get fileOperations; CodeLensWorkspaceClientCapabilities? get codeLens; SemanticTokensWorkspaceClientCapabilities? get semanticTokens; bool? get configuration; bool? get workspaceFolders; ExecuteCommandClientCapabilities? get executeCommand; WorkspaceSymbolClientCapabilities? get symbol; DidChangeWatchedFilesClientCapabilities? get didChangeWatchedFiles; DidChangeConfigurationClientCapabilities? get didChangeConfiguration; WorkspaceEditClientCapabilities? get workspaceEdit; bool? get applyEdit;
/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkspaceClientCapabilitiesCopyWith<WorkspaceClientCapabilities> get copyWith => _$WorkspaceClientCapabilitiesCopyWithImpl<WorkspaceClientCapabilities>(this as WorkspaceClientCapabilities, _$identity);

  /// Serializes this WorkspaceClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkspaceClientCapabilities&&(identical(other.foldingRange, foldingRange) || other.foldingRange == foldingRange)&&(identical(other.diagnostics, diagnostics) || other.diagnostics == diagnostics)&&(identical(other.inlayHint, inlayHint) || other.inlayHint == inlayHint)&&(identical(other.inlineValue, inlineValue) || other.inlineValue == inlineValue)&&(identical(other.fileOperations, fileOperations) || other.fileOperations == fileOperations)&&(identical(other.codeLens, codeLens) || other.codeLens == codeLens)&&(identical(other.semanticTokens, semanticTokens) || other.semanticTokens == semanticTokens)&&(identical(other.configuration, configuration) || other.configuration == configuration)&&(identical(other.workspaceFolders, workspaceFolders) || other.workspaceFolders == workspaceFolders)&&(identical(other.executeCommand, executeCommand) || other.executeCommand == executeCommand)&&(identical(other.symbol, symbol) || other.symbol == symbol)&&(identical(other.didChangeWatchedFiles, didChangeWatchedFiles) || other.didChangeWatchedFiles == didChangeWatchedFiles)&&(identical(other.didChangeConfiguration, didChangeConfiguration) || other.didChangeConfiguration == didChangeConfiguration)&&(identical(other.workspaceEdit, workspaceEdit) || other.workspaceEdit == workspaceEdit)&&(identical(other.applyEdit, applyEdit) || other.applyEdit == applyEdit));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,foldingRange,diagnostics,inlayHint,inlineValue,fileOperations,codeLens,semanticTokens,configuration,workspaceFolders,executeCommand,symbol,didChangeWatchedFiles,didChangeConfiguration,workspaceEdit,applyEdit);

@override
String toString() {
  return 'WorkspaceClientCapabilities(foldingRange: $foldingRange, diagnostics: $diagnostics, inlayHint: $inlayHint, inlineValue: $inlineValue, fileOperations: $fileOperations, codeLens: $codeLens, semanticTokens: $semanticTokens, configuration: $configuration, workspaceFolders: $workspaceFolders, executeCommand: $executeCommand, symbol: $symbol, didChangeWatchedFiles: $didChangeWatchedFiles, didChangeConfiguration: $didChangeConfiguration, workspaceEdit: $workspaceEdit, applyEdit: $applyEdit)';
}


}

/// @nodoc
abstract mixin class $WorkspaceClientCapabilitiesCopyWith<$Res>  {
  factory $WorkspaceClientCapabilitiesCopyWith(WorkspaceClientCapabilities value, $Res Function(WorkspaceClientCapabilities) _then) = _$WorkspaceClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 FoldingRangeWorkspaceClientCapabilities? foldingRange, DiagnosticWorkspaceClientCapabilities? diagnostics, InlayHintWorkspaceClientCapabilities? inlayHint, InlineValueWorkspaceClientCapabilities? inlineValue, FileOperationClientCapabilities? fileOperations, CodeLensWorkspaceClientCapabilities? codeLens, SemanticTokensWorkspaceClientCapabilities? semanticTokens, bool? configuration, bool? workspaceFolders, ExecuteCommandClientCapabilities? executeCommand, WorkspaceSymbolClientCapabilities? symbol, DidChangeWatchedFilesClientCapabilities? didChangeWatchedFiles, DidChangeConfigurationClientCapabilities? didChangeConfiguration, WorkspaceEditClientCapabilities? workspaceEdit, bool? applyEdit
});


$FoldingRangeWorkspaceClientCapabilitiesCopyWith<$Res>? get foldingRange;$DiagnosticWorkspaceClientCapabilitiesCopyWith<$Res>? get diagnostics;$InlayHintWorkspaceClientCapabilitiesCopyWith<$Res>? get inlayHint;$InlineValueWorkspaceClientCapabilitiesCopyWith<$Res>? get inlineValue;$FileOperationClientCapabilitiesCopyWith<$Res>? get fileOperations;$CodeLensWorkspaceClientCapabilitiesCopyWith<$Res>? get codeLens;$SemanticTokensWorkspaceClientCapabilitiesCopyWith<$Res>? get semanticTokens;$ExecuteCommandClientCapabilitiesCopyWith<$Res>? get executeCommand;$WorkspaceSymbolClientCapabilitiesCopyWith<$Res>? get symbol;$DidChangeWatchedFilesClientCapabilitiesCopyWith<$Res>? get didChangeWatchedFiles;$DidChangeConfigurationClientCapabilitiesCopyWith<$Res>? get didChangeConfiguration;$WorkspaceEditClientCapabilitiesCopyWith<$Res>? get workspaceEdit;

}
/// @nodoc
class _$WorkspaceClientCapabilitiesCopyWithImpl<$Res>
    implements $WorkspaceClientCapabilitiesCopyWith<$Res> {
  _$WorkspaceClientCapabilitiesCopyWithImpl(this._self, this._then);

  final WorkspaceClientCapabilities _self;
  final $Res Function(WorkspaceClientCapabilities) _then;

/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? foldingRange = freezed,Object? diagnostics = freezed,Object? inlayHint = freezed,Object? inlineValue = freezed,Object? fileOperations = freezed,Object? codeLens = freezed,Object? semanticTokens = freezed,Object? configuration = freezed,Object? workspaceFolders = freezed,Object? executeCommand = freezed,Object? symbol = freezed,Object? didChangeWatchedFiles = freezed,Object? didChangeConfiguration = freezed,Object? workspaceEdit = freezed,Object? applyEdit = freezed,}) {
  return _then(_self.copyWith(
foldingRange: freezed == foldingRange ? _self.foldingRange : foldingRange // ignore: cast_nullable_to_non_nullable
as FoldingRangeWorkspaceClientCapabilities?,diagnostics: freezed == diagnostics ? _self.diagnostics : diagnostics // ignore: cast_nullable_to_non_nullable
as DiagnosticWorkspaceClientCapabilities?,inlayHint: freezed == inlayHint ? _self.inlayHint : inlayHint // ignore: cast_nullable_to_non_nullable
as InlayHintWorkspaceClientCapabilities?,inlineValue: freezed == inlineValue ? _self.inlineValue : inlineValue // ignore: cast_nullable_to_non_nullable
as InlineValueWorkspaceClientCapabilities?,fileOperations: freezed == fileOperations ? _self.fileOperations : fileOperations // ignore: cast_nullable_to_non_nullable
as FileOperationClientCapabilities?,codeLens: freezed == codeLens ? _self.codeLens : codeLens // ignore: cast_nullable_to_non_nullable
as CodeLensWorkspaceClientCapabilities?,semanticTokens: freezed == semanticTokens ? _self.semanticTokens : semanticTokens // ignore: cast_nullable_to_non_nullable
as SemanticTokensWorkspaceClientCapabilities?,configuration: freezed == configuration ? _self.configuration : configuration // ignore: cast_nullable_to_non_nullable
as bool?,workspaceFolders: freezed == workspaceFolders ? _self.workspaceFolders : workspaceFolders // ignore: cast_nullable_to_non_nullable
as bool?,executeCommand: freezed == executeCommand ? _self.executeCommand : executeCommand // ignore: cast_nullable_to_non_nullable
as ExecuteCommandClientCapabilities?,symbol: freezed == symbol ? _self.symbol : symbol // ignore: cast_nullable_to_non_nullable
as WorkspaceSymbolClientCapabilities?,didChangeWatchedFiles: freezed == didChangeWatchedFiles ? _self.didChangeWatchedFiles : didChangeWatchedFiles // ignore: cast_nullable_to_non_nullable
as DidChangeWatchedFilesClientCapabilities?,didChangeConfiguration: freezed == didChangeConfiguration ? _self.didChangeConfiguration : didChangeConfiguration // ignore: cast_nullable_to_non_nullable
as DidChangeConfigurationClientCapabilities?,workspaceEdit: freezed == workspaceEdit ? _self.workspaceEdit : workspaceEdit // ignore: cast_nullable_to_non_nullable
as WorkspaceEditClientCapabilities?,applyEdit: freezed == applyEdit ? _self.applyEdit : applyEdit // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}
/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FoldingRangeWorkspaceClientCapabilitiesCopyWith<$Res>? get foldingRange {
    if (_self.foldingRange == null) {
    return null;
  }

  return $FoldingRangeWorkspaceClientCapabilitiesCopyWith<$Res>(_self.foldingRange!, (value) {
    return _then(_self.copyWith(foldingRange: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DiagnosticWorkspaceClientCapabilitiesCopyWith<$Res>? get diagnostics {
    if (_self.diagnostics == null) {
    return null;
  }

  return $DiagnosticWorkspaceClientCapabilitiesCopyWith<$Res>(_self.diagnostics!, (value) {
    return _then(_self.copyWith(diagnostics: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$InlayHintWorkspaceClientCapabilitiesCopyWith<$Res>? get inlayHint {
    if (_self.inlayHint == null) {
    return null;
  }

  return $InlayHintWorkspaceClientCapabilitiesCopyWith<$Res>(_self.inlayHint!, (value) {
    return _then(_self.copyWith(inlayHint: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$InlineValueWorkspaceClientCapabilitiesCopyWith<$Res>? get inlineValue {
    if (_self.inlineValue == null) {
    return null;
  }

  return $InlineValueWorkspaceClientCapabilitiesCopyWith<$Res>(_self.inlineValue!, (value) {
    return _then(_self.copyWith(inlineValue: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FileOperationClientCapabilitiesCopyWith<$Res>? get fileOperations {
    if (_self.fileOperations == null) {
    return null;
  }

  return $FileOperationClientCapabilitiesCopyWith<$Res>(_self.fileOperations!, (value) {
    return _then(_self.copyWith(fileOperations: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CodeLensWorkspaceClientCapabilitiesCopyWith<$Res>? get codeLens {
    if (_self.codeLens == null) {
    return null;
  }

  return $CodeLensWorkspaceClientCapabilitiesCopyWith<$Res>(_self.codeLens!, (value) {
    return _then(_self.copyWith(codeLens: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SemanticTokensWorkspaceClientCapabilitiesCopyWith<$Res>? get semanticTokens {
    if (_self.semanticTokens == null) {
    return null;
  }

  return $SemanticTokensWorkspaceClientCapabilitiesCopyWith<$Res>(_self.semanticTokens!, (value) {
    return _then(_self.copyWith(semanticTokens: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ExecuteCommandClientCapabilitiesCopyWith<$Res>? get executeCommand {
    if (_self.executeCommand == null) {
    return null;
  }

  return $ExecuteCommandClientCapabilitiesCopyWith<$Res>(_self.executeCommand!, (value) {
    return _then(_self.copyWith(executeCommand: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$WorkspaceSymbolClientCapabilitiesCopyWith<$Res>? get symbol {
    if (_self.symbol == null) {
    return null;
  }

  return $WorkspaceSymbolClientCapabilitiesCopyWith<$Res>(_self.symbol!, (value) {
    return _then(_self.copyWith(symbol: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DidChangeWatchedFilesClientCapabilitiesCopyWith<$Res>? get didChangeWatchedFiles {
    if (_self.didChangeWatchedFiles == null) {
    return null;
  }

  return $DidChangeWatchedFilesClientCapabilitiesCopyWith<$Res>(_self.didChangeWatchedFiles!, (value) {
    return _then(_self.copyWith(didChangeWatchedFiles: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DidChangeConfigurationClientCapabilitiesCopyWith<$Res>? get didChangeConfiguration {
    if (_self.didChangeConfiguration == null) {
    return null;
  }

  return $DidChangeConfigurationClientCapabilitiesCopyWith<$Res>(_self.didChangeConfiguration!, (value) {
    return _then(_self.copyWith(didChangeConfiguration: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$WorkspaceEditClientCapabilitiesCopyWith<$Res>? get workspaceEdit {
    if (_self.workspaceEdit == null) {
    return null;
  }

  return $WorkspaceEditClientCapabilitiesCopyWith<$Res>(_self.workspaceEdit!, (value) {
    return _then(_self.copyWith(workspaceEdit: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _WorkspaceClientCapabilities implements WorkspaceClientCapabilities {
  const _WorkspaceClientCapabilities({this.foldingRange, this.diagnostics, this.inlayHint, this.inlineValue, this.fileOperations, this.codeLens, this.semanticTokens, this.configuration, this.workspaceFolders, this.executeCommand, this.symbol, this.didChangeWatchedFiles, this.didChangeConfiguration, this.workspaceEdit, this.applyEdit});
  factory _WorkspaceClientCapabilities.fromJson(Map<String, dynamic> json) => _$WorkspaceClientCapabilitiesFromJson(json);

@override final  FoldingRangeWorkspaceClientCapabilities? foldingRange;
@override final  DiagnosticWorkspaceClientCapabilities? diagnostics;
@override final  InlayHintWorkspaceClientCapabilities? inlayHint;
@override final  InlineValueWorkspaceClientCapabilities? inlineValue;
@override final  FileOperationClientCapabilities? fileOperations;
@override final  CodeLensWorkspaceClientCapabilities? codeLens;
@override final  SemanticTokensWorkspaceClientCapabilities? semanticTokens;
@override final  bool? configuration;
@override final  bool? workspaceFolders;
@override final  ExecuteCommandClientCapabilities? executeCommand;
@override final  WorkspaceSymbolClientCapabilities? symbol;
@override final  DidChangeWatchedFilesClientCapabilities? didChangeWatchedFiles;
@override final  DidChangeConfigurationClientCapabilities? didChangeConfiguration;
@override final  WorkspaceEditClientCapabilities? workspaceEdit;
@override final  bool? applyEdit;

/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkspaceClientCapabilitiesCopyWith<_WorkspaceClientCapabilities> get copyWith => __$WorkspaceClientCapabilitiesCopyWithImpl<_WorkspaceClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkspaceClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkspaceClientCapabilities&&(identical(other.foldingRange, foldingRange) || other.foldingRange == foldingRange)&&(identical(other.diagnostics, diagnostics) || other.diagnostics == diagnostics)&&(identical(other.inlayHint, inlayHint) || other.inlayHint == inlayHint)&&(identical(other.inlineValue, inlineValue) || other.inlineValue == inlineValue)&&(identical(other.fileOperations, fileOperations) || other.fileOperations == fileOperations)&&(identical(other.codeLens, codeLens) || other.codeLens == codeLens)&&(identical(other.semanticTokens, semanticTokens) || other.semanticTokens == semanticTokens)&&(identical(other.configuration, configuration) || other.configuration == configuration)&&(identical(other.workspaceFolders, workspaceFolders) || other.workspaceFolders == workspaceFolders)&&(identical(other.executeCommand, executeCommand) || other.executeCommand == executeCommand)&&(identical(other.symbol, symbol) || other.symbol == symbol)&&(identical(other.didChangeWatchedFiles, didChangeWatchedFiles) || other.didChangeWatchedFiles == didChangeWatchedFiles)&&(identical(other.didChangeConfiguration, didChangeConfiguration) || other.didChangeConfiguration == didChangeConfiguration)&&(identical(other.workspaceEdit, workspaceEdit) || other.workspaceEdit == workspaceEdit)&&(identical(other.applyEdit, applyEdit) || other.applyEdit == applyEdit));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,foldingRange,diagnostics,inlayHint,inlineValue,fileOperations,codeLens,semanticTokens,configuration,workspaceFolders,executeCommand,symbol,didChangeWatchedFiles,didChangeConfiguration,workspaceEdit,applyEdit);

@override
String toString() {
  return 'WorkspaceClientCapabilities(foldingRange: $foldingRange, diagnostics: $diagnostics, inlayHint: $inlayHint, inlineValue: $inlineValue, fileOperations: $fileOperations, codeLens: $codeLens, semanticTokens: $semanticTokens, configuration: $configuration, workspaceFolders: $workspaceFolders, executeCommand: $executeCommand, symbol: $symbol, didChangeWatchedFiles: $didChangeWatchedFiles, didChangeConfiguration: $didChangeConfiguration, workspaceEdit: $workspaceEdit, applyEdit: $applyEdit)';
}


}

/// @nodoc
abstract mixin class _$WorkspaceClientCapabilitiesCopyWith<$Res> implements $WorkspaceClientCapabilitiesCopyWith<$Res> {
  factory _$WorkspaceClientCapabilitiesCopyWith(_WorkspaceClientCapabilities value, $Res Function(_WorkspaceClientCapabilities) _then) = __$WorkspaceClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 FoldingRangeWorkspaceClientCapabilities? foldingRange, DiagnosticWorkspaceClientCapabilities? diagnostics, InlayHintWorkspaceClientCapabilities? inlayHint, InlineValueWorkspaceClientCapabilities? inlineValue, FileOperationClientCapabilities? fileOperations, CodeLensWorkspaceClientCapabilities? codeLens, SemanticTokensWorkspaceClientCapabilities? semanticTokens, bool? configuration, bool? workspaceFolders, ExecuteCommandClientCapabilities? executeCommand, WorkspaceSymbolClientCapabilities? symbol, DidChangeWatchedFilesClientCapabilities? didChangeWatchedFiles, DidChangeConfigurationClientCapabilities? didChangeConfiguration, WorkspaceEditClientCapabilities? workspaceEdit, bool? applyEdit
});


@override $FoldingRangeWorkspaceClientCapabilitiesCopyWith<$Res>? get foldingRange;@override $DiagnosticWorkspaceClientCapabilitiesCopyWith<$Res>? get diagnostics;@override $InlayHintWorkspaceClientCapabilitiesCopyWith<$Res>? get inlayHint;@override $InlineValueWorkspaceClientCapabilitiesCopyWith<$Res>? get inlineValue;@override $FileOperationClientCapabilitiesCopyWith<$Res>? get fileOperations;@override $CodeLensWorkspaceClientCapabilitiesCopyWith<$Res>? get codeLens;@override $SemanticTokensWorkspaceClientCapabilitiesCopyWith<$Res>? get semanticTokens;@override $ExecuteCommandClientCapabilitiesCopyWith<$Res>? get executeCommand;@override $WorkspaceSymbolClientCapabilitiesCopyWith<$Res>? get symbol;@override $DidChangeWatchedFilesClientCapabilitiesCopyWith<$Res>? get didChangeWatchedFiles;@override $DidChangeConfigurationClientCapabilitiesCopyWith<$Res>? get didChangeConfiguration;@override $WorkspaceEditClientCapabilitiesCopyWith<$Res>? get workspaceEdit;

}
/// @nodoc
class __$WorkspaceClientCapabilitiesCopyWithImpl<$Res>
    implements _$WorkspaceClientCapabilitiesCopyWith<$Res> {
  __$WorkspaceClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _WorkspaceClientCapabilities _self;
  final $Res Function(_WorkspaceClientCapabilities) _then;

/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? foldingRange = freezed,Object? diagnostics = freezed,Object? inlayHint = freezed,Object? inlineValue = freezed,Object? fileOperations = freezed,Object? codeLens = freezed,Object? semanticTokens = freezed,Object? configuration = freezed,Object? workspaceFolders = freezed,Object? executeCommand = freezed,Object? symbol = freezed,Object? didChangeWatchedFiles = freezed,Object? didChangeConfiguration = freezed,Object? workspaceEdit = freezed,Object? applyEdit = freezed,}) {
  return _then(_WorkspaceClientCapabilities(
foldingRange: freezed == foldingRange ? _self.foldingRange : foldingRange // ignore: cast_nullable_to_non_nullable
as FoldingRangeWorkspaceClientCapabilities?,diagnostics: freezed == diagnostics ? _self.diagnostics : diagnostics // ignore: cast_nullable_to_non_nullable
as DiagnosticWorkspaceClientCapabilities?,inlayHint: freezed == inlayHint ? _self.inlayHint : inlayHint // ignore: cast_nullable_to_non_nullable
as InlayHintWorkspaceClientCapabilities?,inlineValue: freezed == inlineValue ? _self.inlineValue : inlineValue // ignore: cast_nullable_to_non_nullable
as InlineValueWorkspaceClientCapabilities?,fileOperations: freezed == fileOperations ? _self.fileOperations : fileOperations // ignore: cast_nullable_to_non_nullable
as FileOperationClientCapabilities?,codeLens: freezed == codeLens ? _self.codeLens : codeLens // ignore: cast_nullable_to_non_nullable
as CodeLensWorkspaceClientCapabilities?,semanticTokens: freezed == semanticTokens ? _self.semanticTokens : semanticTokens // ignore: cast_nullable_to_non_nullable
as SemanticTokensWorkspaceClientCapabilities?,configuration: freezed == configuration ? _self.configuration : configuration // ignore: cast_nullable_to_non_nullable
as bool?,workspaceFolders: freezed == workspaceFolders ? _self.workspaceFolders : workspaceFolders // ignore: cast_nullable_to_non_nullable
as bool?,executeCommand: freezed == executeCommand ? _self.executeCommand : executeCommand // ignore: cast_nullable_to_non_nullable
as ExecuteCommandClientCapabilities?,symbol: freezed == symbol ? _self.symbol : symbol // ignore: cast_nullable_to_non_nullable
as WorkspaceSymbolClientCapabilities?,didChangeWatchedFiles: freezed == didChangeWatchedFiles ? _self.didChangeWatchedFiles : didChangeWatchedFiles // ignore: cast_nullable_to_non_nullable
as DidChangeWatchedFilesClientCapabilities?,didChangeConfiguration: freezed == didChangeConfiguration ? _self.didChangeConfiguration : didChangeConfiguration // ignore: cast_nullable_to_non_nullable
as DidChangeConfigurationClientCapabilities?,workspaceEdit: freezed == workspaceEdit ? _self.workspaceEdit : workspaceEdit // ignore: cast_nullable_to_non_nullable
as WorkspaceEditClientCapabilities?,applyEdit: freezed == applyEdit ? _self.applyEdit : applyEdit // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FoldingRangeWorkspaceClientCapabilitiesCopyWith<$Res>? get foldingRange {
    if (_self.foldingRange == null) {
    return null;
  }

  return $FoldingRangeWorkspaceClientCapabilitiesCopyWith<$Res>(_self.foldingRange!, (value) {
    return _then(_self.copyWith(foldingRange: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DiagnosticWorkspaceClientCapabilitiesCopyWith<$Res>? get diagnostics {
    if (_self.diagnostics == null) {
    return null;
  }

  return $DiagnosticWorkspaceClientCapabilitiesCopyWith<$Res>(_self.diagnostics!, (value) {
    return _then(_self.copyWith(diagnostics: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$InlayHintWorkspaceClientCapabilitiesCopyWith<$Res>? get inlayHint {
    if (_self.inlayHint == null) {
    return null;
  }

  return $InlayHintWorkspaceClientCapabilitiesCopyWith<$Res>(_self.inlayHint!, (value) {
    return _then(_self.copyWith(inlayHint: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$InlineValueWorkspaceClientCapabilitiesCopyWith<$Res>? get inlineValue {
    if (_self.inlineValue == null) {
    return null;
  }

  return $InlineValueWorkspaceClientCapabilitiesCopyWith<$Res>(_self.inlineValue!, (value) {
    return _then(_self.copyWith(inlineValue: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FileOperationClientCapabilitiesCopyWith<$Res>? get fileOperations {
    if (_self.fileOperations == null) {
    return null;
  }

  return $FileOperationClientCapabilitiesCopyWith<$Res>(_self.fileOperations!, (value) {
    return _then(_self.copyWith(fileOperations: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CodeLensWorkspaceClientCapabilitiesCopyWith<$Res>? get codeLens {
    if (_self.codeLens == null) {
    return null;
  }

  return $CodeLensWorkspaceClientCapabilitiesCopyWith<$Res>(_self.codeLens!, (value) {
    return _then(_self.copyWith(codeLens: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SemanticTokensWorkspaceClientCapabilitiesCopyWith<$Res>? get semanticTokens {
    if (_self.semanticTokens == null) {
    return null;
  }

  return $SemanticTokensWorkspaceClientCapabilitiesCopyWith<$Res>(_self.semanticTokens!, (value) {
    return _then(_self.copyWith(semanticTokens: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ExecuteCommandClientCapabilitiesCopyWith<$Res>? get executeCommand {
    if (_self.executeCommand == null) {
    return null;
  }

  return $ExecuteCommandClientCapabilitiesCopyWith<$Res>(_self.executeCommand!, (value) {
    return _then(_self.copyWith(executeCommand: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$WorkspaceSymbolClientCapabilitiesCopyWith<$Res>? get symbol {
    if (_self.symbol == null) {
    return null;
  }

  return $WorkspaceSymbolClientCapabilitiesCopyWith<$Res>(_self.symbol!, (value) {
    return _then(_self.copyWith(symbol: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DidChangeWatchedFilesClientCapabilitiesCopyWith<$Res>? get didChangeWatchedFiles {
    if (_self.didChangeWatchedFiles == null) {
    return null;
  }

  return $DidChangeWatchedFilesClientCapabilitiesCopyWith<$Res>(_self.didChangeWatchedFiles!, (value) {
    return _then(_self.copyWith(didChangeWatchedFiles: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DidChangeConfigurationClientCapabilitiesCopyWith<$Res>? get didChangeConfiguration {
    if (_self.didChangeConfiguration == null) {
    return null;
  }

  return $DidChangeConfigurationClientCapabilitiesCopyWith<$Res>(_self.didChangeConfiguration!, (value) {
    return _then(_self.copyWith(didChangeConfiguration: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$WorkspaceEditClientCapabilitiesCopyWith<$Res>? get workspaceEdit {
    if (_self.workspaceEdit == null) {
    return null;
  }

  return $WorkspaceEditClientCapabilitiesCopyWith<$Res>(_self.workspaceEdit!, (value) {
    return _then(_self.copyWith(workspaceEdit: value));
  });
}
}


/// @nodoc
mixin _$TextDocumentClientCapabilities {

 InlineCompletionClientCapabilities? get inlineCompletion; DiagnosticClientCapabilities? get diagnostic; InlayHintClientCapabilities? get inlayHint; InlineValueClientCapabilities? get inlineValue; TypeHierarchyClientCapabilities? get typeHierarchy; MonikerClientCapabilities? get moniker; LinkedEditingRangeClientCapabilities? get linkedEditingRange; SemanticTokensClientCapabilities? get semanticTokens; CallHierarchyClientCapabilities? get callHierarchy; PublishDiagnosticsClientCapabilities? get publishDiagnostics; SelectionRangeClientCapabilities? get selectionRange; FoldingRangeClientCapabilities? get foldingRange; RenameClientCapabilities? get rename; DocumentOnTypeFormattingClientCapabilities? get onTypeFormatting; DocumentRangeFormattingClientCapabilities? get rangeFormatting; DocumentFormattingClientCapabilities? get formatting; DocumentColorClientCapabilities? get colorProvider; DocumentLinkClientCapabilities? get documentLink; CodeLensClientCapabilities? get codeLens; CodeActionClientCapabilities? get codeAction; DocumentSymbolClientCapabilities? get documentSymbol; DocumentHighlightClientCapabilities? get documentHighlight; ReferenceClientCapabilities? get references; ImplementationClientCapabilities? get implementation; TypeDefinitionClientCapabilities? get typeDefinition; DefinitionClientCapabilities? get definition; DeclarationClientCapabilities? get declaration; SignatureHelpClientCapabilities? get signatureHelp; HoverClientCapabilities? get hover; CompletionClientCapabilities? get completion; TextDocumentSyncClientCapabilities? get synchronization;
/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TextDocumentClientCapabilitiesCopyWith<TextDocumentClientCapabilities> get copyWith => _$TextDocumentClientCapabilitiesCopyWithImpl<TextDocumentClientCapabilities>(this as TextDocumentClientCapabilities, _$identity);

  /// Serializes this TextDocumentClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TextDocumentClientCapabilities&&(identical(other.inlineCompletion, inlineCompletion) || other.inlineCompletion == inlineCompletion)&&(identical(other.diagnostic, diagnostic) || other.diagnostic == diagnostic)&&(identical(other.inlayHint, inlayHint) || other.inlayHint == inlayHint)&&(identical(other.inlineValue, inlineValue) || other.inlineValue == inlineValue)&&(identical(other.typeHierarchy, typeHierarchy) || other.typeHierarchy == typeHierarchy)&&(identical(other.moniker, moniker) || other.moniker == moniker)&&(identical(other.linkedEditingRange, linkedEditingRange) || other.linkedEditingRange == linkedEditingRange)&&(identical(other.semanticTokens, semanticTokens) || other.semanticTokens == semanticTokens)&&(identical(other.callHierarchy, callHierarchy) || other.callHierarchy == callHierarchy)&&(identical(other.publishDiagnostics, publishDiagnostics) || other.publishDiagnostics == publishDiagnostics)&&(identical(other.selectionRange, selectionRange) || other.selectionRange == selectionRange)&&(identical(other.foldingRange, foldingRange) || other.foldingRange == foldingRange)&&(identical(other.rename, rename) || other.rename == rename)&&(identical(other.onTypeFormatting, onTypeFormatting) || other.onTypeFormatting == onTypeFormatting)&&(identical(other.rangeFormatting, rangeFormatting) || other.rangeFormatting == rangeFormatting)&&(identical(other.formatting, formatting) || other.formatting == formatting)&&(identical(other.colorProvider, colorProvider) || other.colorProvider == colorProvider)&&(identical(other.documentLink, documentLink) || other.documentLink == documentLink)&&(identical(other.codeLens, codeLens) || other.codeLens == codeLens)&&(identical(other.codeAction, codeAction) || other.codeAction == codeAction)&&(identical(other.documentSymbol, documentSymbol) || other.documentSymbol == documentSymbol)&&(identical(other.documentHighlight, documentHighlight) || other.documentHighlight == documentHighlight)&&(identical(other.references, references) || other.references == references)&&(identical(other.implementation, implementation) || other.implementation == implementation)&&(identical(other.typeDefinition, typeDefinition) || other.typeDefinition == typeDefinition)&&(identical(other.definition, definition) || other.definition == definition)&&(identical(other.declaration, declaration) || other.declaration == declaration)&&(identical(other.signatureHelp, signatureHelp) || other.signatureHelp == signatureHelp)&&(identical(other.hover, hover) || other.hover == hover)&&(identical(other.completion, completion) || other.completion == completion)&&(identical(other.synchronization, synchronization) || other.synchronization == synchronization));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hashAll([runtimeType,inlineCompletion,diagnostic,inlayHint,inlineValue,typeHierarchy,moniker,linkedEditingRange,semanticTokens,callHierarchy,publishDiagnostics,selectionRange,foldingRange,rename,onTypeFormatting,rangeFormatting,formatting,colorProvider,documentLink,codeLens,codeAction,documentSymbol,documentHighlight,references,implementation,typeDefinition,definition,declaration,signatureHelp,hover,completion,synchronization]);

@override
String toString() {
  return 'TextDocumentClientCapabilities(inlineCompletion: $inlineCompletion, diagnostic: $diagnostic, inlayHint: $inlayHint, inlineValue: $inlineValue, typeHierarchy: $typeHierarchy, moniker: $moniker, linkedEditingRange: $linkedEditingRange, semanticTokens: $semanticTokens, callHierarchy: $callHierarchy, publishDiagnostics: $publishDiagnostics, selectionRange: $selectionRange, foldingRange: $foldingRange, rename: $rename, onTypeFormatting: $onTypeFormatting, rangeFormatting: $rangeFormatting, formatting: $formatting, colorProvider: $colorProvider, documentLink: $documentLink, codeLens: $codeLens, codeAction: $codeAction, documentSymbol: $documentSymbol, documentHighlight: $documentHighlight, references: $references, implementation: $implementation, typeDefinition: $typeDefinition, definition: $definition, declaration: $declaration, signatureHelp: $signatureHelp, hover: $hover, completion: $completion, synchronization: $synchronization)';
}


}

/// @nodoc
abstract mixin class $TextDocumentClientCapabilitiesCopyWith<$Res>  {
  factory $TextDocumentClientCapabilitiesCopyWith(TextDocumentClientCapabilities value, $Res Function(TextDocumentClientCapabilities) _then) = _$TextDocumentClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 InlineCompletionClientCapabilities? inlineCompletion, DiagnosticClientCapabilities? diagnostic, InlayHintClientCapabilities? inlayHint, InlineValueClientCapabilities? inlineValue, TypeHierarchyClientCapabilities? typeHierarchy, MonikerClientCapabilities? moniker, LinkedEditingRangeClientCapabilities? linkedEditingRange, SemanticTokensClientCapabilities? semanticTokens, CallHierarchyClientCapabilities? callHierarchy, PublishDiagnosticsClientCapabilities? publishDiagnostics, SelectionRangeClientCapabilities? selectionRange, FoldingRangeClientCapabilities? foldingRange, RenameClientCapabilities? rename, DocumentOnTypeFormattingClientCapabilities? onTypeFormatting, DocumentRangeFormattingClientCapabilities? rangeFormatting, DocumentFormattingClientCapabilities? formatting, DocumentColorClientCapabilities? colorProvider, DocumentLinkClientCapabilities? documentLink, CodeLensClientCapabilities? codeLens, CodeActionClientCapabilities? codeAction, DocumentSymbolClientCapabilities? documentSymbol, DocumentHighlightClientCapabilities? documentHighlight, ReferenceClientCapabilities? references, ImplementationClientCapabilities? implementation, TypeDefinitionClientCapabilities? typeDefinition, DefinitionClientCapabilities? definition, DeclarationClientCapabilities? declaration, SignatureHelpClientCapabilities? signatureHelp, HoverClientCapabilities? hover, CompletionClientCapabilities? completion, TextDocumentSyncClientCapabilities? synchronization
});


$InlineCompletionClientCapabilitiesCopyWith<$Res>? get inlineCompletion;$DiagnosticClientCapabilitiesCopyWith<$Res>? get diagnostic;$InlayHintClientCapabilitiesCopyWith<$Res>? get inlayHint;$InlineValueClientCapabilitiesCopyWith<$Res>? get inlineValue;$TypeHierarchyClientCapabilitiesCopyWith<$Res>? get typeHierarchy;$MonikerClientCapabilitiesCopyWith<$Res>? get moniker;$LinkedEditingRangeClientCapabilitiesCopyWith<$Res>? get linkedEditingRange;$SemanticTokensClientCapabilitiesCopyWith<$Res>? get semanticTokens;$CallHierarchyClientCapabilitiesCopyWith<$Res>? get callHierarchy;$PublishDiagnosticsClientCapabilitiesCopyWith<$Res>? get publishDiagnostics;$SelectionRangeClientCapabilitiesCopyWith<$Res>? get selectionRange;$FoldingRangeClientCapabilitiesCopyWith<$Res>? get foldingRange;$RenameClientCapabilitiesCopyWith<$Res>? get rename;$DocumentOnTypeFormattingClientCapabilitiesCopyWith<$Res>? get onTypeFormatting;$DocumentRangeFormattingClientCapabilitiesCopyWith<$Res>? get rangeFormatting;$DocumentFormattingClientCapabilitiesCopyWith<$Res>? get formatting;$DocumentColorClientCapabilitiesCopyWith<$Res>? get colorProvider;$DocumentLinkClientCapabilitiesCopyWith<$Res>? get documentLink;$CodeLensClientCapabilitiesCopyWith<$Res>? get codeLens;$CodeActionClientCapabilitiesCopyWith<$Res>? get codeAction;$DocumentSymbolClientCapabilitiesCopyWith<$Res>? get documentSymbol;$DocumentHighlightClientCapabilitiesCopyWith<$Res>? get documentHighlight;$ReferenceClientCapabilitiesCopyWith<$Res>? get references;$ImplementationClientCapabilitiesCopyWith<$Res>? get implementation;$TypeDefinitionClientCapabilitiesCopyWith<$Res>? get typeDefinition;$DefinitionClientCapabilitiesCopyWith<$Res>? get definition;$DeclarationClientCapabilitiesCopyWith<$Res>? get declaration;$SignatureHelpClientCapabilitiesCopyWith<$Res>? get signatureHelp;$HoverClientCapabilitiesCopyWith<$Res>? get hover;$CompletionClientCapabilitiesCopyWith<$Res>? get completion;$TextDocumentSyncClientCapabilitiesCopyWith<$Res>? get synchronization;

}
/// @nodoc
class _$TextDocumentClientCapabilitiesCopyWithImpl<$Res>
    implements $TextDocumentClientCapabilitiesCopyWith<$Res> {
  _$TextDocumentClientCapabilitiesCopyWithImpl(this._self, this._then);

  final TextDocumentClientCapabilities _self;
  final $Res Function(TextDocumentClientCapabilities) _then;

/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? inlineCompletion = freezed,Object? diagnostic = freezed,Object? inlayHint = freezed,Object? inlineValue = freezed,Object? typeHierarchy = freezed,Object? moniker = freezed,Object? linkedEditingRange = freezed,Object? semanticTokens = freezed,Object? callHierarchy = freezed,Object? publishDiagnostics = freezed,Object? selectionRange = freezed,Object? foldingRange = freezed,Object? rename = freezed,Object? onTypeFormatting = freezed,Object? rangeFormatting = freezed,Object? formatting = freezed,Object? colorProvider = freezed,Object? documentLink = freezed,Object? codeLens = freezed,Object? codeAction = freezed,Object? documentSymbol = freezed,Object? documentHighlight = freezed,Object? references = freezed,Object? implementation = freezed,Object? typeDefinition = freezed,Object? definition = freezed,Object? declaration = freezed,Object? signatureHelp = freezed,Object? hover = freezed,Object? completion = freezed,Object? synchronization = freezed,}) {
  return _then(_self.copyWith(
inlineCompletion: freezed == inlineCompletion ? _self.inlineCompletion : inlineCompletion // ignore: cast_nullable_to_non_nullable
as InlineCompletionClientCapabilities?,diagnostic: freezed == diagnostic ? _self.diagnostic : diagnostic // ignore: cast_nullable_to_non_nullable
as DiagnosticClientCapabilities?,inlayHint: freezed == inlayHint ? _self.inlayHint : inlayHint // ignore: cast_nullable_to_non_nullable
as InlayHintClientCapabilities?,inlineValue: freezed == inlineValue ? _self.inlineValue : inlineValue // ignore: cast_nullable_to_non_nullable
as InlineValueClientCapabilities?,typeHierarchy: freezed == typeHierarchy ? _self.typeHierarchy : typeHierarchy // ignore: cast_nullable_to_non_nullable
as TypeHierarchyClientCapabilities?,moniker: freezed == moniker ? _self.moniker : moniker // ignore: cast_nullable_to_non_nullable
as MonikerClientCapabilities?,linkedEditingRange: freezed == linkedEditingRange ? _self.linkedEditingRange : linkedEditingRange // ignore: cast_nullable_to_non_nullable
as LinkedEditingRangeClientCapabilities?,semanticTokens: freezed == semanticTokens ? _self.semanticTokens : semanticTokens // ignore: cast_nullable_to_non_nullable
as SemanticTokensClientCapabilities?,callHierarchy: freezed == callHierarchy ? _self.callHierarchy : callHierarchy // ignore: cast_nullable_to_non_nullable
as CallHierarchyClientCapabilities?,publishDiagnostics: freezed == publishDiagnostics ? _self.publishDiagnostics : publishDiagnostics // ignore: cast_nullable_to_non_nullable
as PublishDiagnosticsClientCapabilities?,selectionRange: freezed == selectionRange ? _self.selectionRange : selectionRange // ignore: cast_nullable_to_non_nullable
as SelectionRangeClientCapabilities?,foldingRange: freezed == foldingRange ? _self.foldingRange : foldingRange // ignore: cast_nullable_to_non_nullable
as FoldingRangeClientCapabilities?,rename: freezed == rename ? _self.rename : rename // ignore: cast_nullable_to_non_nullable
as RenameClientCapabilities?,onTypeFormatting: freezed == onTypeFormatting ? _self.onTypeFormatting : onTypeFormatting // ignore: cast_nullable_to_non_nullable
as DocumentOnTypeFormattingClientCapabilities?,rangeFormatting: freezed == rangeFormatting ? _self.rangeFormatting : rangeFormatting // ignore: cast_nullable_to_non_nullable
as DocumentRangeFormattingClientCapabilities?,formatting: freezed == formatting ? _self.formatting : formatting // ignore: cast_nullable_to_non_nullable
as DocumentFormattingClientCapabilities?,colorProvider: freezed == colorProvider ? _self.colorProvider : colorProvider // ignore: cast_nullable_to_non_nullable
as DocumentColorClientCapabilities?,documentLink: freezed == documentLink ? _self.documentLink : documentLink // ignore: cast_nullable_to_non_nullable
as DocumentLinkClientCapabilities?,codeLens: freezed == codeLens ? _self.codeLens : codeLens // ignore: cast_nullable_to_non_nullable
as CodeLensClientCapabilities?,codeAction: freezed == codeAction ? _self.codeAction : codeAction // ignore: cast_nullable_to_non_nullable
as CodeActionClientCapabilities?,documentSymbol: freezed == documentSymbol ? _self.documentSymbol : documentSymbol // ignore: cast_nullable_to_non_nullable
as DocumentSymbolClientCapabilities?,documentHighlight: freezed == documentHighlight ? _self.documentHighlight : documentHighlight // ignore: cast_nullable_to_non_nullable
as DocumentHighlightClientCapabilities?,references: freezed == references ? _self.references : references // ignore: cast_nullable_to_non_nullable
as ReferenceClientCapabilities?,implementation: freezed == implementation ? _self.implementation : implementation // ignore: cast_nullable_to_non_nullable
as ImplementationClientCapabilities?,typeDefinition: freezed == typeDefinition ? _self.typeDefinition : typeDefinition // ignore: cast_nullable_to_non_nullable
as TypeDefinitionClientCapabilities?,definition: freezed == definition ? _self.definition : definition // ignore: cast_nullable_to_non_nullable
as DefinitionClientCapabilities?,declaration: freezed == declaration ? _self.declaration : declaration // ignore: cast_nullable_to_non_nullable
as DeclarationClientCapabilities?,signatureHelp: freezed == signatureHelp ? _self.signatureHelp : signatureHelp // ignore: cast_nullable_to_non_nullable
as SignatureHelpClientCapabilities?,hover: freezed == hover ? _self.hover : hover // ignore: cast_nullable_to_non_nullable
as HoverClientCapabilities?,completion: freezed == completion ? _self.completion : completion // ignore: cast_nullable_to_non_nullable
as CompletionClientCapabilities?,synchronization: freezed == synchronization ? _self.synchronization : synchronization // ignore: cast_nullable_to_non_nullable
as TextDocumentSyncClientCapabilities?,
  ));
}
/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$InlineCompletionClientCapabilitiesCopyWith<$Res>? get inlineCompletion {
    if (_self.inlineCompletion == null) {
    return null;
  }

  return $InlineCompletionClientCapabilitiesCopyWith<$Res>(_self.inlineCompletion!, (value) {
    return _then(_self.copyWith(inlineCompletion: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DiagnosticClientCapabilitiesCopyWith<$Res>? get diagnostic {
    if (_self.diagnostic == null) {
    return null;
  }

  return $DiagnosticClientCapabilitiesCopyWith<$Res>(_self.diagnostic!, (value) {
    return _then(_self.copyWith(diagnostic: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$InlayHintClientCapabilitiesCopyWith<$Res>? get inlayHint {
    if (_self.inlayHint == null) {
    return null;
  }

  return $InlayHintClientCapabilitiesCopyWith<$Res>(_self.inlayHint!, (value) {
    return _then(_self.copyWith(inlayHint: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$InlineValueClientCapabilitiesCopyWith<$Res>? get inlineValue {
    if (_self.inlineValue == null) {
    return null;
  }

  return $InlineValueClientCapabilitiesCopyWith<$Res>(_self.inlineValue!, (value) {
    return _then(_self.copyWith(inlineValue: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TypeHierarchyClientCapabilitiesCopyWith<$Res>? get typeHierarchy {
    if (_self.typeHierarchy == null) {
    return null;
  }

  return $TypeHierarchyClientCapabilitiesCopyWith<$Res>(_self.typeHierarchy!, (value) {
    return _then(_self.copyWith(typeHierarchy: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$MonikerClientCapabilitiesCopyWith<$Res>? get moniker {
    if (_self.moniker == null) {
    return null;
  }

  return $MonikerClientCapabilitiesCopyWith<$Res>(_self.moniker!, (value) {
    return _then(_self.copyWith(moniker: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$LinkedEditingRangeClientCapabilitiesCopyWith<$Res>? get linkedEditingRange {
    if (_self.linkedEditingRange == null) {
    return null;
  }

  return $LinkedEditingRangeClientCapabilitiesCopyWith<$Res>(_self.linkedEditingRange!, (value) {
    return _then(_self.copyWith(linkedEditingRange: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SemanticTokensClientCapabilitiesCopyWith<$Res>? get semanticTokens {
    if (_self.semanticTokens == null) {
    return null;
  }

  return $SemanticTokensClientCapabilitiesCopyWith<$Res>(_self.semanticTokens!, (value) {
    return _then(_self.copyWith(semanticTokens: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CallHierarchyClientCapabilitiesCopyWith<$Res>? get callHierarchy {
    if (_self.callHierarchy == null) {
    return null;
  }

  return $CallHierarchyClientCapabilitiesCopyWith<$Res>(_self.callHierarchy!, (value) {
    return _then(_self.copyWith(callHierarchy: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PublishDiagnosticsClientCapabilitiesCopyWith<$Res>? get publishDiagnostics {
    if (_self.publishDiagnostics == null) {
    return null;
  }

  return $PublishDiagnosticsClientCapabilitiesCopyWith<$Res>(_self.publishDiagnostics!, (value) {
    return _then(_self.copyWith(publishDiagnostics: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SelectionRangeClientCapabilitiesCopyWith<$Res>? get selectionRange {
    if (_self.selectionRange == null) {
    return null;
  }

  return $SelectionRangeClientCapabilitiesCopyWith<$Res>(_self.selectionRange!, (value) {
    return _then(_self.copyWith(selectionRange: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FoldingRangeClientCapabilitiesCopyWith<$Res>? get foldingRange {
    if (_self.foldingRange == null) {
    return null;
  }

  return $FoldingRangeClientCapabilitiesCopyWith<$Res>(_self.foldingRange!, (value) {
    return _then(_self.copyWith(foldingRange: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RenameClientCapabilitiesCopyWith<$Res>? get rename {
    if (_self.rename == null) {
    return null;
  }

  return $RenameClientCapabilitiesCopyWith<$Res>(_self.rename!, (value) {
    return _then(_self.copyWith(rename: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DocumentOnTypeFormattingClientCapabilitiesCopyWith<$Res>? get onTypeFormatting {
    if (_self.onTypeFormatting == null) {
    return null;
  }

  return $DocumentOnTypeFormattingClientCapabilitiesCopyWith<$Res>(_self.onTypeFormatting!, (value) {
    return _then(_self.copyWith(onTypeFormatting: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DocumentRangeFormattingClientCapabilitiesCopyWith<$Res>? get rangeFormatting {
    if (_self.rangeFormatting == null) {
    return null;
  }

  return $DocumentRangeFormattingClientCapabilitiesCopyWith<$Res>(_self.rangeFormatting!, (value) {
    return _then(_self.copyWith(rangeFormatting: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DocumentFormattingClientCapabilitiesCopyWith<$Res>? get formatting {
    if (_self.formatting == null) {
    return null;
  }

  return $DocumentFormattingClientCapabilitiesCopyWith<$Res>(_self.formatting!, (value) {
    return _then(_self.copyWith(formatting: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DocumentColorClientCapabilitiesCopyWith<$Res>? get colorProvider {
    if (_self.colorProvider == null) {
    return null;
  }

  return $DocumentColorClientCapabilitiesCopyWith<$Res>(_self.colorProvider!, (value) {
    return _then(_self.copyWith(colorProvider: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DocumentLinkClientCapabilitiesCopyWith<$Res>? get documentLink {
    if (_self.documentLink == null) {
    return null;
  }

  return $DocumentLinkClientCapabilitiesCopyWith<$Res>(_self.documentLink!, (value) {
    return _then(_self.copyWith(documentLink: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CodeLensClientCapabilitiesCopyWith<$Res>? get codeLens {
    if (_self.codeLens == null) {
    return null;
  }

  return $CodeLensClientCapabilitiesCopyWith<$Res>(_self.codeLens!, (value) {
    return _then(_self.copyWith(codeLens: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CodeActionClientCapabilitiesCopyWith<$Res>? get codeAction {
    if (_self.codeAction == null) {
    return null;
  }

  return $CodeActionClientCapabilitiesCopyWith<$Res>(_self.codeAction!, (value) {
    return _then(_self.copyWith(codeAction: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DocumentSymbolClientCapabilitiesCopyWith<$Res>? get documentSymbol {
    if (_self.documentSymbol == null) {
    return null;
  }

  return $DocumentSymbolClientCapabilitiesCopyWith<$Res>(_self.documentSymbol!, (value) {
    return _then(_self.copyWith(documentSymbol: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DocumentHighlightClientCapabilitiesCopyWith<$Res>? get documentHighlight {
    if (_self.documentHighlight == null) {
    return null;
  }

  return $DocumentHighlightClientCapabilitiesCopyWith<$Res>(_self.documentHighlight!, (value) {
    return _then(_self.copyWith(documentHighlight: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ReferenceClientCapabilitiesCopyWith<$Res>? get references {
    if (_self.references == null) {
    return null;
  }

  return $ReferenceClientCapabilitiesCopyWith<$Res>(_self.references!, (value) {
    return _then(_self.copyWith(references: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ImplementationClientCapabilitiesCopyWith<$Res>? get implementation {
    if (_self.implementation == null) {
    return null;
  }

  return $ImplementationClientCapabilitiesCopyWith<$Res>(_self.implementation!, (value) {
    return _then(_self.copyWith(implementation: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TypeDefinitionClientCapabilitiesCopyWith<$Res>? get typeDefinition {
    if (_self.typeDefinition == null) {
    return null;
  }

  return $TypeDefinitionClientCapabilitiesCopyWith<$Res>(_self.typeDefinition!, (value) {
    return _then(_self.copyWith(typeDefinition: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DefinitionClientCapabilitiesCopyWith<$Res>? get definition {
    if (_self.definition == null) {
    return null;
  }

  return $DefinitionClientCapabilitiesCopyWith<$Res>(_self.definition!, (value) {
    return _then(_self.copyWith(definition: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DeclarationClientCapabilitiesCopyWith<$Res>? get declaration {
    if (_self.declaration == null) {
    return null;
  }

  return $DeclarationClientCapabilitiesCopyWith<$Res>(_self.declaration!, (value) {
    return _then(_self.copyWith(declaration: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SignatureHelpClientCapabilitiesCopyWith<$Res>? get signatureHelp {
    if (_self.signatureHelp == null) {
    return null;
  }

  return $SignatureHelpClientCapabilitiesCopyWith<$Res>(_self.signatureHelp!, (value) {
    return _then(_self.copyWith(signatureHelp: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$HoverClientCapabilitiesCopyWith<$Res>? get hover {
    if (_self.hover == null) {
    return null;
  }

  return $HoverClientCapabilitiesCopyWith<$Res>(_self.hover!, (value) {
    return _then(_self.copyWith(hover: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CompletionClientCapabilitiesCopyWith<$Res>? get completion {
    if (_self.completion == null) {
    return null;
  }

  return $CompletionClientCapabilitiesCopyWith<$Res>(_self.completion!, (value) {
    return _then(_self.copyWith(completion: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentSyncClientCapabilitiesCopyWith<$Res>? get synchronization {
    if (_self.synchronization == null) {
    return null;
  }

  return $TextDocumentSyncClientCapabilitiesCopyWith<$Res>(_self.synchronization!, (value) {
    return _then(_self.copyWith(synchronization: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _TextDocumentClientCapabilities implements TextDocumentClientCapabilities {
  const _TextDocumentClientCapabilities({this.inlineCompletion, this.diagnostic, this.inlayHint, this.inlineValue, this.typeHierarchy, this.moniker, this.linkedEditingRange, this.semanticTokens, this.callHierarchy, this.publishDiagnostics, this.selectionRange, this.foldingRange, this.rename, this.onTypeFormatting, this.rangeFormatting, this.formatting, this.colorProvider, this.documentLink, this.codeLens, this.codeAction, this.documentSymbol, this.documentHighlight, this.references, this.implementation, this.typeDefinition, this.definition, this.declaration, this.signatureHelp, this.hover, this.completion, this.synchronization});
  factory _TextDocumentClientCapabilities.fromJson(Map<String, dynamic> json) => _$TextDocumentClientCapabilitiesFromJson(json);

@override final  InlineCompletionClientCapabilities? inlineCompletion;
@override final  DiagnosticClientCapabilities? diagnostic;
@override final  InlayHintClientCapabilities? inlayHint;
@override final  InlineValueClientCapabilities? inlineValue;
@override final  TypeHierarchyClientCapabilities? typeHierarchy;
@override final  MonikerClientCapabilities? moniker;
@override final  LinkedEditingRangeClientCapabilities? linkedEditingRange;
@override final  SemanticTokensClientCapabilities? semanticTokens;
@override final  CallHierarchyClientCapabilities? callHierarchy;
@override final  PublishDiagnosticsClientCapabilities? publishDiagnostics;
@override final  SelectionRangeClientCapabilities? selectionRange;
@override final  FoldingRangeClientCapabilities? foldingRange;
@override final  RenameClientCapabilities? rename;
@override final  DocumentOnTypeFormattingClientCapabilities? onTypeFormatting;
@override final  DocumentRangeFormattingClientCapabilities? rangeFormatting;
@override final  DocumentFormattingClientCapabilities? formatting;
@override final  DocumentColorClientCapabilities? colorProvider;
@override final  DocumentLinkClientCapabilities? documentLink;
@override final  CodeLensClientCapabilities? codeLens;
@override final  CodeActionClientCapabilities? codeAction;
@override final  DocumentSymbolClientCapabilities? documentSymbol;
@override final  DocumentHighlightClientCapabilities? documentHighlight;
@override final  ReferenceClientCapabilities? references;
@override final  ImplementationClientCapabilities? implementation;
@override final  TypeDefinitionClientCapabilities? typeDefinition;
@override final  DefinitionClientCapabilities? definition;
@override final  DeclarationClientCapabilities? declaration;
@override final  SignatureHelpClientCapabilities? signatureHelp;
@override final  HoverClientCapabilities? hover;
@override final  CompletionClientCapabilities? completion;
@override final  TextDocumentSyncClientCapabilities? synchronization;

/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TextDocumentClientCapabilitiesCopyWith<_TextDocumentClientCapabilities> get copyWith => __$TextDocumentClientCapabilitiesCopyWithImpl<_TextDocumentClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TextDocumentClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TextDocumentClientCapabilities&&(identical(other.inlineCompletion, inlineCompletion) || other.inlineCompletion == inlineCompletion)&&(identical(other.diagnostic, diagnostic) || other.diagnostic == diagnostic)&&(identical(other.inlayHint, inlayHint) || other.inlayHint == inlayHint)&&(identical(other.inlineValue, inlineValue) || other.inlineValue == inlineValue)&&(identical(other.typeHierarchy, typeHierarchy) || other.typeHierarchy == typeHierarchy)&&(identical(other.moniker, moniker) || other.moniker == moniker)&&(identical(other.linkedEditingRange, linkedEditingRange) || other.linkedEditingRange == linkedEditingRange)&&(identical(other.semanticTokens, semanticTokens) || other.semanticTokens == semanticTokens)&&(identical(other.callHierarchy, callHierarchy) || other.callHierarchy == callHierarchy)&&(identical(other.publishDiagnostics, publishDiagnostics) || other.publishDiagnostics == publishDiagnostics)&&(identical(other.selectionRange, selectionRange) || other.selectionRange == selectionRange)&&(identical(other.foldingRange, foldingRange) || other.foldingRange == foldingRange)&&(identical(other.rename, rename) || other.rename == rename)&&(identical(other.onTypeFormatting, onTypeFormatting) || other.onTypeFormatting == onTypeFormatting)&&(identical(other.rangeFormatting, rangeFormatting) || other.rangeFormatting == rangeFormatting)&&(identical(other.formatting, formatting) || other.formatting == formatting)&&(identical(other.colorProvider, colorProvider) || other.colorProvider == colorProvider)&&(identical(other.documentLink, documentLink) || other.documentLink == documentLink)&&(identical(other.codeLens, codeLens) || other.codeLens == codeLens)&&(identical(other.codeAction, codeAction) || other.codeAction == codeAction)&&(identical(other.documentSymbol, documentSymbol) || other.documentSymbol == documentSymbol)&&(identical(other.documentHighlight, documentHighlight) || other.documentHighlight == documentHighlight)&&(identical(other.references, references) || other.references == references)&&(identical(other.implementation, implementation) || other.implementation == implementation)&&(identical(other.typeDefinition, typeDefinition) || other.typeDefinition == typeDefinition)&&(identical(other.definition, definition) || other.definition == definition)&&(identical(other.declaration, declaration) || other.declaration == declaration)&&(identical(other.signatureHelp, signatureHelp) || other.signatureHelp == signatureHelp)&&(identical(other.hover, hover) || other.hover == hover)&&(identical(other.completion, completion) || other.completion == completion)&&(identical(other.synchronization, synchronization) || other.synchronization == synchronization));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hashAll([runtimeType,inlineCompletion,diagnostic,inlayHint,inlineValue,typeHierarchy,moniker,linkedEditingRange,semanticTokens,callHierarchy,publishDiagnostics,selectionRange,foldingRange,rename,onTypeFormatting,rangeFormatting,formatting,colorProvider,documentLink,codeLens,codeAction,documentSymbol,documentHighlight,references,implementation,typeDefinition,definition,declaration,signatureHelp,hover,completion,synchronization]);

@override
String toString() {
  return 'TextDocumentClientCapabilities(inlineCompletion: $inlineCompletion, diagnostic: $diagnostic, inlayHint: $inlayHint, inlineValue: $inlineValue, typeHierarchy: $typeHierarchy, moniker: $moniker, linkedEditingRange: $linkedEditingRange, semanticTokens: $semanticTokens, callHierarchy: $callHierarchy, publishDiagnostics: $publishDiagnostics, selectionRange: $selectionRange, foldingRange: $foldingRange, rename: $rename, onTypeFormatting: $onTypeFormatting, rangeFormatting: $rangeFormatting, formatting: $formatting, colorProvider: $colorProvider, documentLink: $documentLink, codeLens: $codeLens, codeAction: $codeAction, documentSymbol: $documentSymbol, documentHighlight: $documentHighlight, references: $references, implementation: $implementation, typeDefinition: $typeDefinition, definition: $definition, declaration: $declaration, signatureHelp: $signatureHelp, hover: $hover, completion: $completion, synchronization: $synchronization)';
}


}

/// @nodoc
abstract mixin class _$TextDocumentClientCapabilitiesCopyWith<$Res> implements $TextDocumentClientCapabilitiesCopyWith<$Res> {
  factory _$TextDocumentClientCapabilitiesCopyWith(_TextDocumentClientCapabilities value, $Res Function(_TextDocumentClientCapabilities) _then) = __$TextDocumentClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 InlineCompletionClientCapabilities? inlineCompletion, DiagnosticClientCapabilities? diagnostic, InlayHintClientCapabilities? inlayHint, InlineValueClientCapabilities? inlineValue, TypeHierarchyClientCapabilities? typeHierarchy, MonikerClientCapabilities? moniker, LinkedEditingRangeClientCapabilities? linkedEditingRange, SemanticTokensClientCapabilities? semanticTokens, CallHierarchyClientCapabilities? callHierarchy, PublishDiagnosticsClientCapabilities? publishDiagnostics, SelectionRangeClientCapabilities? selectionRange, FoldingRangeClientCapabilities? foldingRange, RenameClientCapabilities? rename, DocumentOnTypeFormattingClientCapabilities? onTypeFormatting, DocumentRangeFormattingClientCapabilities? rangeFormatting, DocumentFormattingClientCapabilities? formatting, DocumentColorClientCapabilities? colorProvider, DocumentLinkClientCapabilities? documentLink, CodeLensClientCapabilities? codeLens, CodeActionClientCapabilities? codeAction, DocumentSymbolClientCapabilities? documentSymbol, DocumentHighlightClientCapabilities? documentHighlight, ReferenceClientCapabilities? references, ImplementationClientCapabilities? implementation, TypeDefinitionClientCapabilities? typeDefinition, DefinitionClientCapabilities? definition, DeclarationClientCapabilities? declaration, SignatureHelpClientCapabilities? signatureHelp, HoverClientCapabilities? hover, CompletionClientCapabilities? completion, TextDocumentSyncClientCapabilities? synchronization
});


@override $InlineCompletionClientCapabilitiesCopyWith<$Res>? get inlineCompletion;@override $DiagnosticClientCapabilitiesCopyWith<$Res>? get diagnostic;@override $InlayHintClientCapabilitiesCopyWith<$Res>? get inlayHint;@override $InlineValueClientCapabilitiesCopyWith<$Res>? get inlineValue;@override $TypeHierarchyClientCapabilitiesCopyWith<$Res>? get typeHierarchy;@override $MonikerClientCapabilitiesCopyWith<$Res>? get moniker;@override $LinkedEditingRangeClientCapabilitiesCopyWith<$Res>? get linkedEditingRange;@override $SemanticTokensClientCapabilitiesCopyWith<$Res>? get semanticTokens;@override $CallHierarchyClientCapabilitiesCopyWith<$Res>? get callHierarchy;@override $PublishDiagnosticsClientCapabilitiesCopyWith<$Res>? get publishDiagnostics;@override $SelectionRangeClientCapabilitiesCopyWith<$Res>? get selectionRange;@override $FoldingRangeClientCapabilitiesCopyWith<$Res>? get foldingRange;@override $RenameClientCapabilitiesCopyWith<$Res>? get rename;@override $DocumentOnTypeFormattingClientCapabilitiesCopyWith<$Res>? get onTypeFormatting;@override $DocumentRangeFormattingClientCapabilitiesCopyWith<$Res>? get rangeFormatting;@override $DocumentFormattingClientCapabilitiesCopyWith<$Res>? get formatting;@override $DocumentColorClientCapabilitiesCopyWith<$Res>? get colorProvider;@override $DocumentLinkClientCapabilitiesCopyWith<$Res>? get documentLink;@override $CodeLensClientCapabilitiesCopyWith<$Res>? get codeLens;@override $CodeActionClientCapabilitiesCopyWith<$Res>? get codeAction;@override $DocumentSymbolClientCapabilitiesCopyWith<$Res>? get documentSymbol;@override $DocumentHighlightClientCapabilitiesCopyWith<$Res>? get documentHighlight;@override $ReferenceClientCapabilitiesCopyWith<$Res>? get references;@override $ImplementationClientCapabilitiesCopyWith<$Res>? get implementation;@override $TypeDefinitionClientCapabilitiesCopyWith<$Res>? get typeDefinition;@override $DefinitionClientCapabilitiesCopyWith<$Res>? get definition;@override $DeclarationClientCapabilitiesCopyWith<$Res>? get declaration;@override $SignatureHelpClientCapabilitiesCopyWith<$Res>? get signatureHelp;@override $HoverClientCapabilitiesCopyWith<$Res>? get hover;@override $CompletionClientCapabilitiesCopyWith<$Res>? get completion;@override $TextDocumentSyncClientCapabilitiesCopyWith<$Res>? get synchronization;

}
/// @nodoc
class __$TextDocumentClientCapabilitiesCopyWithImpl<$Res>
    implements _$TextDocumentClientCapabilitiesCopyWith<$Res> {
  __$TextDocumentClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _TextDocumentClientCapabilities _self;
  final $Res Function(_TextDocumentClientCapabilities) _then;

/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? inlineCompletion = freezed,Object? diagnostic = freezed,Object? inlayHint = freezed,Object? inlineValue = freezed,Object? typeHierarchy = freezed,Object? moniker = freezed,Object? linkedEditingRange = freezed,Object? semanticTokens = freezed,Object? callHierarchy = freezed,Object? publishDiagnostics = freezed,Object? selectionRange = freezed,Object? foldingRange = freezed,Object? rename = freezed,Object? onTypeFormatting = freezed,Object? rangeFormatting = freezed,Object? formatting = freezed,Object? colorProvider = freezed,Object? documentLink = freezed,Object? codeLens = freezed,Object? codeAction = freezed,Object? documentSymbol = freezed,Object? documentHighlight = freezed,Object? references = freezed,Object? implementation = freezed,Object? typeDefinition = freezed,Object? definition = freezed,Object? declaration = freezed,Object? signatureHelp = freezed,Object? hover = freezed,Object? completion = freezed,Object? synchronization = freezed,}) {
  return _then(_TextDocumentClientCapabilities(
inlineCompletion: freezed == inlineCompletion ? _self.inlineCompletion : inlineCompletion // ignore: cast_nullable_to_non_nullable
as InlineCompletionClientCapabilities?,diagnostic: freezed == diagnostic ? _self.diagnostic : diagnostic // ignore: cast_nullable_to_non_nullable
as DiagnosticClientCapabilities?,inlayHint: freezed == inlayHint ? _self.inlayHint : inlayHint // ignore: cast_nullable_to_non_nullable
as InlayHintClientCapabilities?,inlineValue: freezed == inlineValue ? _self.inlineValue : inlineValue // ignore: cast_nullable_to_non_nullable
as InlineValueClientCapabilities?,typeHierarchy: freezed == typeHierarchy ? _self.typeHierarchy : typeHierarchy // ignore: cast_nullable_to_non_nullable
as TypeHierarchyClientCapabilities?,moniker: freezed == moniker ? _self.moniker : moniker // ignore: cast_nullable_to_non_nullable
as MonikerClientCapabilities?,linkedEditingRange: freezed == linkedEditingRange ? _self.linkedEditingRange : linkedEditingRange // ignore: cast_nullable_to_non_nullable
as LinkedEditingRangeClientCapabilities?,semanticTokens: freezed == semanticTokens ? _self.semanticTokens : semanticTokens // ignore: cast_nullable_to_non_nullable
as SemanticTokensClientCapabilities?,callHierarchy: freezed == callHierarchy ? _self.callHierarchy : callHierarchy // ignore: cast_nullable_to_non_nullable
as CallHierarchyClientCapabilities?,publishDiagnostics: freezed == publishDiagnostics ? _self.publishDiagnostics : publishDiagnostics // ignore: cast_nullable_to_non_nullable
as PublishDiagnosticsClientCapabilities?,selectionRange: freezed == selectionRange ? _self.selectionRange : selectionRange // ignore: cast_nullable_to_non_nullable
as SelectionRangeClientCapabilities?,foldingRange: freezed == foldingRange ? _self.foldingRange : foldingRange // ignore: cast_nullable_to_non_nullable
as FoldingRangeClientCapabilities?,rename: freezed == rename ? _self.rename : rename // ignore: cast_nullable_to_non_nullable
as RenameClientCapabilities?,onTypeFormatting: freezed == onTypeFormatting ? _self.onTypeFormatting : onTypeFormatting // ignore: cast_nullable_to_non_nullable
as DocumentOnTypeFormattingClientCapabilities?,rangeFormatting: freezed == rangeFormatting ? _self.rangeFormatting : rangeFormatting // ignore: cast_nullable_to_non_nullable
as DocumentRangeFormattingClientCapabilities?,formatting: freezed == formatting ? _self.formatting : formatting // ignore: cast_nullable_to_non_nullable
as DocumentFormattingClientCapabilities?,colorProvider: freezed == colorProvider ? _self.colorProvider : colorProvider // ignore: cast_nullable_to_non_nullable
as DocumentColorClientCapabilities?,documentLink: freezed == documentLink ? _self.documentLink : documentLink // ignore: cast_nullable_to_non_nullable
as DocumentLinkClientCapabilities?,codeLens: freezed == codeLens ? _self.codeLens : codeLens // ignore: cast_nullable_to_non_nullable
as CodeLensClientCapabilities?,codeAction: freezed == codeAction ? _self.codeAction : codeAction // ignore: cast_nullable_to_non_nullable
as CodeActionClientCapabilities?,documentSymbol: freezed == documentSymbol ? _self.documentSymbol : documentSymbol // ignore: cast_nullable_to_non_nullable
as DocumentSymbolClientCapabilities?,documentHighlight: freezed == documentHighlight ? _self.documentHighlight : documentHighlight // ignore: cast_nullable_to_non_nullable
as DocumentHighlightClientCapabilities?,references: freezed == references ? _self.references : references // ignore: cast_nullable_to_non_nullable
as ReferenceClientCapabilities?,implementation: freezed == implementation ? _self.implementation : implementation // ignore: cast_nullable_to_non_nullable
as ImplementationClientCapabilities?,typeDefinition: freezed == typeDefinition ? _self.typeDefinition : typeDefinition // ignore: cast_nullable_to_non_nullable
as TypeDefinitionClientCapabilities?,definition: freezed == definition ? _self.definition : definition // ignore: cast_nullable_to_non_nullable
as DefinitionClientCapabilities?,declaration: freezed == declaration ? _self.declaration : declaration // ignore: cast_nullable_to_non_nullable
as DeclarationClientCapabilities?,signatureHelp: freezed == signatureHelp ? _self.signatureHelp : signatureHelp // ignore: cast_nullable_to_non_nullable
as SignatureHelpClientCapabilities?,hover: freezed == hover ? _self.hover : hover // ignore: cast_nullable_to_non_nullable
as HoverClientCapabilities?,completion: freezed == completion ? _self.completion : completion // ignore: cast_nullable_to_non_nullable
as CompletionClientCapabilities?,synchronization: freezed == synchronization ? _self.synchronization : synchronization // ignore: cast_nullable_to_non_nullable
as TextDocumentSyncClientCapabilities?,
  ));
}

/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$InlineCompletionClientCapabilitiesCopyWith<$Res>? get inlineCompletion {
    if (_self.inlineCompletion == null) {
    return null;
  }

  return $InlineCompletionClientCapabilitiesCopyWith<$Res>(_self.inlineCompletion!, (value) {
    return _then(_self.copyWith(inlineCompletion: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DiagnosticClientCapabilitiesCopyWith<$Res>? get diagnostic {
    if (_self.diagnostic == null) {
    return null;
  }

  return $DiagnosticClientCapabilitiesCopyWith<$Res>(_self.diagnostic!, (value) {
    return _then(_self.copyWith(diagnostic: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$InlayHintClientCapabilitiesCopyWith<$Res>? get inlayHint {
    if (_self.inlayHint == null) {
    return null;
  }

  return $InlayHintClientCapabilitiesCopyWith<$Res>(_self.inlayHint!, (value) {
    return _then(_self.copyWith(inlayHint: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$InlineValueClientCapabilitiesCopyWith<$Res>? get inlineValue {
    if (_self.inlineValue == null) {
    return null;
  }

  return $InlineValueClientCapabilitiesCopyWith<$Res>(_self.inlineValue!, (value) {
    return _then(_self.copyWith(inlineValue: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TypeHierarchyClientCapabilitiesCopyWith<$Res>? get typeHierarchy {
    if (_self.typeHierarchy == null) {
    return null;
  }

  return $TypeHierarchyClientCapabilitiesCopyWith<$Res>(_self.typeHierarchy!, (value) {
    return _then(_self.copyWith(typeHierarchy: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$MonikerClientCapabilitiesCopyWith<$Res>? get moniker {
    if (_self.moniker == null) {
    return null;
  }

  return $MonikerClientCapabilitiesCopyWith<$Res>(_self.moniker!, (value) {
    return _then(_self.copyWith(moniker: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$LinkedEditingRangeClientCapabilitiesCopyWith<$Res>? get linkedEditingRange {
    if (_self.linkedEditingRange == null) {
    return null;
  }

  return $LinkedEditingRangeClientCapabilitiesCopyWith<$Res>(_self.linkedEditingRange!, (value) {
    return _then(_self.copyWith(linkedEditingRange: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SemanticTokensClientCapabilitiesCopyWith<$Res>? get semanticTokens {
    if (_self.semanticTokens == null) {
    return null;
  }

  return $SemanticTokensClientCapabilitiesCopyWith<$Res>(_self.semanticTokens!, (value) {
    return _then(_self.copyWith(semanticTokens: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CallHierarchyClientCapabilitiesCopyWith<$Res>? get callHierarchy {
    if (_self.callHierarchy == null) {
    return null;
  }

  return $CallHierarchyClientCapabilitiesCopyWith<$Res>(_self.callHierarchy!, (value) {
    return _then(_self.copyWith(callHierarchy: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PublishDiagnosticsClientCapabilitiesCopyWith<$Res>? get publishDiagnostics {
    if (_self.publishDiagnostics == null) {
    return null;
  }

  return $PublishDiagnosticsClientCapabilitiesCopyWith<$Res>(_self.publishDiagnostics!, (value) {
    return _then(_self.copyWith(publishDiagnostics: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SelectionRangeClientCapabilitiesCopyWith<$Res>? get selectionRange {
    if (_self.selectionRange == null) {
    return null;
  }

  return $SelectionRangeClientCapabilitiesCopyWith<$Res>(_self.selectionRange!, (value) {
    return _then(_self.copyWith(selectionRange: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FoldingRangeClientCapabilitiesCopyWith<$Res>? get foldingRange {
    if (_self.foldingRange == null) {
    return null;
  }

  return $FoldingRangeClientCapabilitiesCopyWith<$Res>(_self.foldingRange!, (value) {
    return _then(_self.copyWith(foldingRange: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RenameClientCapabilitiesCopyWith<$Res>? get rename {
    if (_self.rename == null) {
    return null;
  }

  return $RenameClientCapabilitiesCopyWith<$Res>(_self.rename!, (value) {
    return _then(_self.copyWith(rename: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DocumentOnTypeFormattingClientCapabilitiesCopyWith<$Res>? get onTypeFormatting {
    if (_self.onTypeFormatting == null) {
    return null;
  }

  return $DocumentOnTypeFormattingClientCapabilitiesCopyWith<$Res>(_self.onTypeFormatting!, (value) {
    return _then(_self.copyWith(onTypeFormatting: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DocumentRangeFormattingClientCapabilitiesCopyWith<$Res>? get rangeFormatting {
    if (_self.rangeFormatting == null) {
    return null;
  }

  return $DocumentRangeFormattingClientCapabilitiesCopyWith<$Res>(_self.rangeFormatting!, (value) {
    return _then(_self.copyWith(rangeFormatting: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DocumentFormattingClientCapabilitiesCopyWith<$Res>? get formatting {
    if (_self.formatting == null) {
    return null;
  }

  return $DocumentFormattingClientCapabilitiesCopyWith<$Res>(_self.formatting!, (value) {
    return _then(_self.copyWith(formatting: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DocumentColorClientCapabilitiesCopyWith<$Res>? get colorProvider {
    if (_self.colorProvider == null) {
    return null;
  }

  return $DocumentColorClientCapabilitiesCopyWith<$Res>(_self.colorProvider!, (value) {
    return _then(_self.copyWith(colorProvider: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DocumentLinkClientCapabilitiesCopyWith<$Res>? get documentLink {
    if (_self.documentLink == null) {
    return null;
  }

  return $DocumentLinkClientCapabilitiesCopyWith<$Res>(_self.documentLink!, (value) {
    return _then(_self.copyWith(documentLink: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CodeLensClientCapabilitiesCopyWith<$Res>? get codeLens {
    if (_self.codeLens == null) {
    return null;
  }

  return $CodeLensClientCapabilitiesCopyWith<$Res>(_self.codeLens!, (value) {
    return _then(_self.copyWith(codeLens: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CodeActionClientCapabilitiesCopyWith<$Res>? get codeAction {
    if (_self.codeAction == null) {
    return null;
  }

  return $CodeActionClientCapabilitiesCopyWith<$Res>(_self.codeAction!, (value) {
    return _then(_self.copyWith(codeAction: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DocumentSymbolClientCapabilitiesCopyWith<$Res>? get documentSymbol {
    if (_self.documentSymbol == null) {
    return null;
  }

  return $DocumentSymbolClientCapabilitiesCopyWith<$Res>(_self.documentSymbol!, (value) {
    return _then(_self.copyWith(documentSymbol: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DocumentHighlightClientCapabilitiesCopyWith<$Res>? get documentHighlight {
    if (_self.documentHighlight == null) {
    return null;
  }

  return $DocumentHighlightClientCapabilitiesCopyWith<$Res>(_self.documentHighlight!, (value) {
    return _then(_self.copyWith(documentHighlight: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ReferenceClientCapabilitiesCopyWith<$Res>? get references {
    if (_self.references == null) {
    return null;
  }

  return $ReferenceClientCapabilitiesCopyWith<$Res>(_self.references!, (value) {
    return _then(_self.copyWith(references: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ImplementationClientCapabilitiesCopyWith<$Res>? get implementation {
    if (_self.implementation == null) {
    return null;
  }

  return $ImplementationClientCapabilitiesCopyWith<$Res>(_self.implementation!, (value) {
    return _then(_self.copyWith(implementation: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TypeDefinitionClientCapabilitiesCopyWith<$Res>? get typeDefinition {
    if (_self.typeDefinition == null) {
    return null;
  }

  return $TypeDefinitionClientCapabilitiesCopyWith<$Res>(_self.typeDefinition!, (value) {
    return _then(_self.copyWith(typeDefinition: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DefinitionClientCapabilitiesCopyWith<$Res>? get definition {
    if (_self.definition == null) {
    return null;
  }

  return $DefinitionClientCapabilitiesCopyWith<$Res>(_self.definition!, (value) {
    return _then(_self.copyWith(definition: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DeclarationClientCapabilitiesCopyWith<$Res>? get declaration {
    if (_self.declaration == null) {
    return null;
  }

  return $DeclarationClientCapabilitiesCopyWith<$Res>(_self.declaration!, (value) {
    return _then(_self.copyWith(declaration: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SignatureHelpClientCapabilitiesCopyWith<$Res>? get signatureHelp {
    if (_self.signatureHelp == null) {
    return null;
  }

  return $SignatureHelpClientCapabilitiesCopyWith<$Res>(_self.signatureHelp!, (value) {
    return _then(_self.copyWith(signatureHelp: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$HoverClientCapabilitiesCopyWith<$Res>? get hover {
    if (_self.hover == null) {
    return null;
  }

  return $HoverClientCapabilitiesCopyWith<$Res>(_self.hover!, (value) {
    return _then(_self.copyWith(hover: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CompletionClientCapabilitiesCopyWith<$Res>? get completion {
    if (_self.completion == null) {
    return null;
  }

  return $CompletionClientCapabilitiesCopyWith<$Res>(_self.completion!, (value) {
    return _then(_self.copyWith(completion: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentSyncClientCapabilitiesCopyWith<$Res>? get synchronization {
    if (_self.synchronization == null) {
    return null;
  }

  return $TextDocumentSyncClientCapabilitiesCopyWith<$Res>(_self.synchronization!, (value) {
    return _then(_self.copyWith(synchronization: value));
  });
}
}


/// @nodoc
mixin _$NotebookDocumentClientCapabilities {

 NotebookDocumentSyncClientCapabilities get synchronization;
/// Create a copy of NotebookDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$NotebookDocumentClientCapabilitiesCopyWith<NotebookDocumentClientCapabilities> get copyWith => _$NotebookDocumentClientCapabilitiesCopyWithImpl<NotebookDocumentClientCapabilities>(this as NotebookDocumentClientCapabilities, _$identity);

  /// Serializes this NotebookDocumentClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is NotebookDocumentClientCapabilities&&(identical(other.synchronization, synchronization) || other.synchronization == synchronization));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,synchronization);

@override
String toString() {
  return 'NotebookDocumentClientCapabilities(synchronization: $synchronization)';
}


}

/// @nodoc
abstract mixin class $NotebookDocumentClientCapabilitiesCopyWith<$Res>  {
  factory $NotebookDocumentClientCapabilitiesCopyWith(NotebookDocumentClientCapabilities value, $Res Function(NotebookDocumentClientCapabilities) _then) = _$NotebookDocumentClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 NotebookDocumentSyncClientCapabilities synchronization
});


$NotebookDocumentSyncClientCapabilitiesCopyWith<$Res> get synchronization;

}
/// @nodoc
class _$NotebookDocumentClientCapabilitiesCopyWithImpl<$Res>
    implements $NotebookDocumentClientCapabilitiesCopyWith<$Res> {
  _$NotebookDocumentClientCapabilitiesCopyWithImpl(this._self, this._then);

  final NotebookDocumentClientCapabilities _self;
  final $Res Function(NotebookDocumentClientCapabilities) _then;

/// Create a copy of NotebookDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? synchronization = null,}) {
  return _then(_self.copyWith(
synchronization: null == synchronization ? _self.synchronization : synchronization // ignore: cast_nullable_to_non_nullable
as NotebookDocumentSyncClientCapabilities,
  ));
}
/// Create a copy of NotebookDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$NotebookDocumentSyncClientCapabilitiesCopyWith<$Res> get synchronization {
  
  return $NotebookDocumentSyncClientCapabilitiesCopyWith<$Res>(_self.synchronization, (value) {
    return _then(_self.copyWith(synchronization: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _NotebookDocumentClientCapabilities implements NotebookDocumentClientCapabilities {
  const _NotebookDocumentClientCapabilities({required this.synchronization});
  factory _NotebookDocumentClientCapabilities.fromJson(Map<String, dynamic> json) => _$NotebookDocumentClientCapabilitiesFromJson(json);

@override final  NotebookDocumentSyncClientCapabilities synchronization;

/// Create a copy of NotebookDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$NotebookDocumentClientCapabilitiesCopyWith<_NotebookDocumentClientCapabilities> get copyWith => __$NotebookDocumentClientCapabilitiesCopyWithImpl<_NotebookDocumentClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$NotebookDocumentClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _NotebookDocumentClientCapabilities&&(identical(other.synchronization, synchronization) || other.synchronization == synchronization));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,synchronization);

@override
String toString() {
  return 'NotebookDocumentClientCapabilities(synchronization: $synchronization)';
}


}

/// @nodoc
abstract mixin class _$NotebookDocumentClientCapabilitiesCopyWith<$Res> implements $NotebookDocumentClientCapabilitiesCopyWith<$Res> {
  factory _$NotebookDocumentClientCapabilitiesCopyWith(_NotebookDocumentClientCapabilities value, $Res Function(_NotebookDocumentClientCapabilities) _then) = __$NotebookDocumentClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 NotebookDocumentSyncClientCapabilities synchronization
});


@override $NotebookDocumentSyncClientCapabilitiesCopyWith<$Res> get synchronization;

}
/// @nodoc
class __$NotebookDocumentClientCapabilitiesCopyWithImpl<$Res>
    implements _$NotebookDocumentClientCapabilitiesCopyWith<$Res> {
  __$NotebookDocumentClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _NotebookDocumentClientCapabilities _self;
  final $Res Function(_NotebookDocumentClientCapabilities) _then;

/// Create a copy of NotebookDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? synchronization = null,}) {
  return _then(_NotebookDocumentClientCapabilities(
synchronization: null == synchronization ? _self.synchronization : synchronization // ignore: cast_nullable_to_non_nullable
as NotebookDocumentSyncClientCapabilities,
  ));
}

/// Create a copy of NotebookDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$NotebookDocumentSyncClientCapabilitiesCopyWith<$Res> get synchronization {
  
  return $NotebookDocumentSyncClientCapabilitiesCopyWith<$Res>(_self.synchronization, (value) {
    return _then(_self.copyWith(synchronization: value));
  });
}
}


/// @nodoc
mixin _$WindowClientCapabilities {

 ShowDocumentClientCapabilities? get showDocument; ShowMessageRequestClientCapabilities? get showMessage; bool? get workDoneProgress;
/// Create a copy of WindowClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WindowClientCapabilitiesCopyWith<WindowClientCapabilities> get copyWith => _$WindowClientCapabilitiesCopyWithImpl<WindowClientCapabilities>(this as WindowClientCapabilities, _$identity);

  /// Serializes this WindowClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WindowClientCapabilities&&(identical(other.showDocument, showDocument) || other.showDocument == showDocument)&&(identical(other.showMessage, showMessage) || other.showMessage == showMessage)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,showDocument,showMessage,workDoneProgress);

@override
String toString() {
  return 'WindowClientCapabilities(showDocument: $showDocument, showMessage: $showMessage, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $WindowClientCapabilitiesCopyWith<$Res>  {
  factory $WindowClientCapabilitiesCopyWith(WindowClientCapabilities value, $Res Function(WindowClientCapabilities) _then) = _$WindowClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 ShowDocumentClientCapabilities? showDocument, ShowMessageRequestClientCapabilities? showMessage, bool? workDoneProgress
});


$ShowDocumentClientCapabilitiesCopyWith<$Res>? get showDocument;$ShowMessageRequestClientCapabilitiesCopyWith<$Res>? get showMessage;

}
/// @nodoc
class _$WindowClientCapabilitiesCopyWithImpl<$Res>
    implements $WindowClientCapabilitiesCopyWith<$Res> {
  _$WindowClientCapabilitiesCopyWithImpl(this._self, this._then);

  final WindowClientCapabilities _self;
  final $Res Function(WindowClientCapabilities) _then;

/// Create a copy of WindowClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? showDocument = freezed,Object? showMessage = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
showDocument: freezed == showDocument ? _self.showDocument : showDocument // ignore: cast_nullable_to_non_nullable
as ShowDocumentClientCapabilities?,showMessage: freezed == showMessage ? _self.showMessage : showMessage // ignore: cast_nullable_to_non_nullable
as ShowMessageRequestClientCapabilities?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}
/// Create a copy of WindowClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ShowDocumentClientCapabilitiesCopyWith<$Res>? get showDocument {
    if (_self.showDocument == null) {
    return null;
  }

  return $ShowDocumentClientCapabilitiesCopyWith<$Res>(_self.showDocument!, (value) {
    return _then(_self.copyWith(showDocument: value));
  });
}/// Create a copy of WindowClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ShowMessageRequestClientCapabilitiesCopyWith<$Res>? get showMessage {
    if (_self.showMessage == null) {
    return null;
  }

  return $ShowMessageRequestClientCapabilitiesCopyWith<$Res>(_self.showMessage!, (value) {
    return _then(_self.copyWith(showMessage: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _WindowClientCapabilities implements WindowClientCapabilities {
  const _WindowClientCapabilities({this.showDocument, this.showMessage, this.workDoneProgress});
  factory _WindowClientCapabilities.fromJson(Map<String, dynamic> json) => _$WindowClientCapabilitiesFromJson(json);

@override final  ShowDocumentClientCapabilities? showDocument;
@override final  ShowMessageRequestClientCapabilities? showMessage;
@override final  bool? workDoneProgress;

/// Create a copy of WindowClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WindowClientCapabilitiesCopyWith<_WindowClientCapabilities> get copyWith => __$WindowClientCapabilitiesCopyWithImpl<_WindowClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WindowClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WindowClientCapabilities&&(identical(other.showDocument, showDocument) || other.showDocument == showDocument)&&(identical(other.showMessage, showMessage) || other.showMessage == showMessage)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,showDocument,showMessage,workDoneProgress);

@override
String toString() {
  return 'WindowClientCapabilities(showDocument: $showDocument, showMessage: $showMessage, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$WindowClientCapabilitiesCopyWith<$Res> implements $WindowClientCapabilitiesCopyWith<$Res> {
  factory _$WindowClientCapabilitiesCopyWith(_WindowClientCapabilities value, $Res Function(_WindowClientCapabilities) _then) = __$WindowClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 ShowDocumentClientCapabilities? showDocument, ShowMessageRequestClientCapabilities? showMessage, bool? workDoneProgress
});


@override $ShowDocumentClientCapabilitiesCopyWith<$Res>? get showDocument;@override $ShowMessageRequestClientCapabilitiesCopyWith<$Res>? get showMessage;

}
/// @nodoc
class __$WindowClientCapabilitiesCopyWithImpl<$Res>
    implements _$WindowClientCapabilitiesCopyWith<$Res> {
  __$WindowClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _WindowClientCapabilities _self;
  final $Res Function(_WindowClientCapabilities) _then;

/// Create a copy of WindowClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? showDocument = freezed,Object? showMessage = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_WindowClientCapabilities(
showDocument: freezed == showDocument ? _self.showDocument : showDocument // ignore: cast_nullable_to_non_nullable
as ShowDocumentClientCapabilities?,showMessage: freezed == showMessage ? _self.showMessage : showMessage // ignore: cast_nullable_to_non_nullable
as ShowMessageRequestClientCapabilities?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

/// Create a copy of WindowClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ShowDocumentClientCapabilitiesCopyWith<$Res>? get showDocument {
    if (_self.showDocument == null) {
    return null;
  }

  return $ShowDocumentClientCapabilitiesCopyWith<$Res>(_self.showDocument!, (value) {
    return _then(_self.copyWith(showDocument: value));
  });
}/// Create a copy of WindowClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ShowMessageRequestClientCapabilitiesCopyWith<$Res>? get showMessage {
    if (_self.showMessage == null) {
    return null;
  }

  return $ShowMessageRequestClientCapabilitiesCopyWith<$Res>(_self.showMessage!, (value) {
    return _then(_self.copyWith(showMessage: value));
  });
}
}


/// @nodoc
mixin _$GeneralClientCapabilities {

 List<PositionEncodingKind>? get positionEncodings; MarkdownClientCapabilities? get markdown; RegularExpressionsClientCapabilities? get regularExpressions; ({bool cancel, List<String> retryOnContentModified})? get staleRequestSupport;
/// Create a copy of GeneralClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$GeneralClientCapabilitiesCopyWith<GeneralClientCapabilities> get copyWith => _$GeneralClientCapabilitiesCopyWithImpl<GeneralClientCapabilities>(this as GeneralClientCapabilities, _$identity);

  /// Serializes this GeneralClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is GeneralClientCapabilities&&const DeepCollectionEquality().equals(other.positionEncodings, positionEncodings)&&(identical(other.markdown, markdown) || other.markdown == markdown)&&(identical(other.regularExpressions, regularExpressions) || other.regularExpressions == regularExpressions)&&(identical(other.staleRequestSupport, staleRequestSupport) || other.staleRequestSupport == staleRequestSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(positionEncodings),markdown,regularExpressions,staleRequestSupport);

@override
String toString() {
  return 'GeneralClientCapabilities(positionEncodings: $positionEncodings, markdown: $markdown, regularExpressions: $regularExpressions, staleRequestSupport: $staleRequestSupport)';
}


}

/// @nodoc
abstract mixin class $GeneralClientCapabilitiesCopyWith<$Res>  {
  factory $GeneralClientCapabilitiesCopyWith(GeneralClientCapabilities value, $Res Function(GeneralClientCapabilities) _then) = _$GeneralClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 List<PositionEncodingKind>? positionEncodings, MarkdownClientCapabilities? markdown, RegularExpressionsClientCapabilities? regularExpressions, ({bool cancel, List<String> retryOnContentModified})? staleRequestSupport
});


$MarkdownClientCapabilitiesCopyWith<$Res>? get markdown;$RegularExpressionsClientCapabilitiesCopyWith<$Res>? get regularExpressions;

}
/// @nodoc
class _$GeneralClientCapabilitiesCopyWithImpl<$Res>
    implements $GeneralClientCapabilitiesCopyWith<$Res> {
  _$GeneralClientCapabilitiesCopyWithImpl(this._self, this._then);

  final GeneralClientCapabilities _self;
  final $Res Function(GeneralClientCapabilities) _then;

/// Create a copy of GeneralClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? positionEncodings = freezed,Object? markdown = freezed,Object? regularExpressions = freezed,Object? staleRequestSupport = freezed,}) {
  return _then(_self.copyWith(
positionEncodings: freezed == positionEncodings ? _self.positionEncodings : positionEncodings // ignore: cast_nullable_to_non_nullable
as List<PositionEncodingKind>?,markdown: freezed == markdown ? _self.markdown : markdown // ignore: cast_nullable_to_non_nullable
as MarkdownClientCapabilities?,regularExpressions: freezed == regularExpressions ? _self.regularExpressions : regularExpressions // ignore: cast_nullable_to_non_nullable
as RegularExpressionsClientCapabilities?,staleRequestSupport: freezed == staleRequestSupport ? _self.staleRequestSupport : staleRequestSupport // ignore: cast_nullable_to_non_nullable
as ({bool cancel, List<String> retryOnContentModified})?,
  ));
}
/// Create a copy of GeneralClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$MarkdownClientCapabilitiesCopyWith<$Res>? get markdown {
    if (_self.markdown == null) {
    return null;
  }

  return $MarkdownClientCapabilitiesCopyWith<$Res>(_self.markdown!, (value) {
    return _then(_self.copyWith(markdown: value));
  });
}/// Create a copy of GeneralClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RegularExpressionsClientCapabilitiesCopyWith<$Res>? get regularExpressions {
    if (_self.regularExpressions == null) {
    return null;
  }

  return $RegularExpressionsClientCapabilitiesCopyWith<$Res>(_self.regularExpressions!, (value) {
    return _then(_self.copyWith(regularExpressions: value));
  });
}
}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _GeneralClientCapabilities implements GeneralClientCapabilities {
  const _GeneralClientCapabilities({final  List<PositionEncodingKind>? positionEncodings, this.markdown, this.regularExpressions, this.staleRequestSupport}): _positionEncodings = positionEncodings;
  factory _GeneralClientCapabilities.fromJson(Map<String, dynamic> json) => _$GeneralClientCapabilitiesFromJson(json);

 final  List<PositionEncodingKind>? _positionEncodings;
@override List<PositionEncodingKind>? get positionEncodings {
  final value = _positionEncodings;
  if (value == null) return null;
  if (_positionEncodings is EqualUnmodifiableListView) return _positionEncodings;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

@override final  MarkdownClientCapabilities? markdown;
@override final  RegularExpressionsClientCapabilities? regularExpressions;
@override final  ({bool cancel, List<String> retryOnContentModified})? staleRequestSupport;

/// Create a copy of GeneralClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$GeneralClientCapabilitiesCopyWith<_GeneralClientCapabilities> get copyWith => __$GeneralClientCapabilitiesCopyWithImpl<_GeneralClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$GeneralClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _GeneralClientCapabilities&&const DeepCollectionEquality().equals(other._positionEncodings, _positionEncodings)&&(identical(other.markdown, markdown) || other.markdown == markdown)&&(identical(other.regularExpressions, regularExpressions) || other.regularExpressions == regularExpressions)&&(identical(other.staleRequestSupport, staleRequestSupport) || other.staleRequestSupport == staleRequestSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_positionEncodings),markdown,regularExpressions,staleRequestSupport);

@override
String toString() {
  return 'GeneralClientCapabilities(positionEncodings: $positionEncodings, markdown: $markdown, regularExpressions: $regularExpressions, staleRequestSupport: $staleRequestSupport)';
}


}

/// @nodoc
abstract mixin class _$GeneralClientCapabilitiesCopyWith<$Res> implements $GeneralClientCapabilitiesCopyWith<$Res> {
  factory _$GeneralClientCapabilitiesCopyWith(_GeneralClientCapabilities value, $Res Function(_GeneralClientCapabilities) _then) = __$GeneralClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 List<PositionEncodingKind>? positionEncodings, MarkdownClientCapabilities? markdown, RegularExpressionsClientCapabilities? regularExpressions, ({bool cancel, List<String> retryOnContentModified})? staleRequestSupport
});


@override $MarkdownClientCapabilitiesCopyWith<$Res>? get markdown;@override $RegularExpressionsClientCapabilitiesCopyWith<$Res>? get regularExpressions;

}
/// @nodoc
class __$GeneralClientCapabilitiesCopyWithImpl<$Res>
    implements _$GeneralClientCapabilitiesCopyWith<$Res> {
  __$GeneralClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _GeneralClientCapabilities _self;
  final $Res Function(_GeneralClientCapabilities) _then;

/// Create a copy of GeneralClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? positionEncodings = freezed,Object? markdown = freezed,Object? regularExpressions = freezed,Object? staleRequestSupport = freezed,}) {
  return _then(_GeneralClientCapabilities(
positionEncodings: freezed == positionEncodings ? _self._positionEncodings : positionEncodings // ignore: cast_nullable_to_non_nullable
as List<PositionEncodingKind>?,markdown: freezed == markdown ? _self.markdown : markdown // ignore: cast_nullable_to_non_nullable
as MarkdownClientCapabilities?,regularExpressions: freezed == regularExpressions ? _self.regularExpressions : regularExpressions // ignore: cast_nullable_to_non_nullable
as RegularExpressionsClientCapabilities?,staleRequestSupport: freezed == staleRequestSupport ? _self.staleRequestSupport : staleRequestSupport // ignore: cast_nullable_to_non_nullable
as ({bool cancel, List<String> retryOnContentModified})?,
  ));
}

/// Create a copy of GeneralClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$MarkdownClientCapabilitiesCopyWith<$Res>? get markdown {
    if (_self.markdown == null) {
    return null;
  }

  return $MarkdownClientCapabilitiesCopyWith<$Res>(_self.markdown!, (value) {
    return _then(_self.copyWith(markdown: value));
  });
}/// Create a copy of GeneralClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RegularExpressionsClientCapabilitiesCopyWith<$Res>? get regularExpressions {
    if (_self.regularExpressions == null) {
    return null;
  }

  return $RegularExpressionsClientCapabilitiesCopyWith<$Res>(_self.regularExpressions!, (value) {
    return _then(_self.copyWith(regularExpressions: value));
  });
}
}


/// @nodoc
mixin _$RelativePattern {

 dynamic get baseUri; Pattern get pattern;
/// Create a copy of RelativePattern
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RelativePatternCopyWith<RelativePattern> get copyWith => _$RelativePatternCopyWithImpl<RelativePattern>(this as RelativePattern, _$identity);

  /// Serializes this RelativePattern to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RelativePattern&&const DeepCollectionEquality().equals(other.baseUri, baseUri)&&(identical(other.pattern, pattern) || other.pattern == pattern));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(baseUri),pattern);

@override
String toString() {
  return 'RelativePattern(baseUri: $baseUri, pattern: $pattern)';
}


}

/// @nodoc
abstract mixin class $RelativePatternCopyWith<$Res>  {
  factory $RelativePatternCopyWith(RelativePattern value, $Res Function(RelativePattern) _then) = _$RelativePatternCopyWithImpl;
@useResult
$Res call({
 dynamic baseUri, Pattern pattern
});




}
/// @nodoc
class _$RelativePatternCopyWithImpl<$Res>
    implements $RelativePatternCopyWith<$Res> {
  _$RelativePatternCopyWithImpl(this._self, this._then);

  final RelativePattern _self;
  final $Res Function(RelativePattern) _then;

/// Create a copy of RelativePattern
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? baseUri = freezed,Object? pattern = null,}) {
  return _then(_self.copyWith(
baseUri: freezed == baseUri ? _self.baseUri : baseUri // ignore: cast_nullable_to_non_nullable
as dynamic,pattern: null == pattern ? _self.pattern : pattern // ignore: cast_nullable_to_non_nullable
as Pattern,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _RelativePattern implements RelativePattern {
  const _RelativePattern({required this.baseUri, required this.pattern});
  factory _RelativePattern.fromJson(Map<String, dynamic> json) => _$RelativePatternFromJson(json);

@override final  dynamic baseUri;
@override final  Pattern pattern;

/// Create a copy of RelativePattern
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RelativePatternCopyWith<_RelativePattern> get copyWith => __$RelativePatternCopyWithImpl<_RelativePattern>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$RelativePatternToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _RelativePattern&&const DeepCollectionEquality().equals(other.baseUri, baseUri)&&(identical(other.pattern, pattern) || other.pattern == pattern));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(baseUri),pattern);

@override
String toString() {
  return 'RelativePattern(baseUri: $baseUri, pattern: $pattern)';
}


}

/// @nodoc
abstract mixin class _$RelativePatternCopyWith<$Res> implements $RelativePatternCopyWith<$Res> {
  factory _$RelativePatternCopyWith(_RelativePattern value, $Res Function(_RelativePattern) _then) = __$RelativePatternCopyWithImpl;
@override @useResult
$Res call({
 dynamic baseUri, Pattern pattern
});




}
/// @nodoc
class __$RelativePatternCopyWithImpl<$Res>
    implements _$RelativePatternCopyWith<$Res> {
  __$RelativePatternCopyWithImpl(this._self, this._then);

  final _RelativePattern _self;
  final $Res Function(_RelativePattern) _then;

/// Create a copy of RelativePattern
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? baseUri = freezed,Object? pattern = null,}) {
  return _then(_RelativePattern(
baseUri: freezed == baseUri ? _self.baseUri : baseUri // ignore: cast_nullable_to_non_nullable
as dynamic,pattern: null == pattern ? _self.pattern : pattern // ignore: cast_nullable_to_non_nullable
as Pattern,
  ));
}


}


/// @nodoc
mixin _$WorkspaceEditClientCapabilities {

 ({bool? groupsOnLabel})? get changeAnnotationSupport; bool? get normalizesLineEndings; FailureHandlingKind? get failureHandling; List<ResourceOperationKind>? get resourceOperations; bool? get documentChanges;
/// Create a copy of WorkspaceEditClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkspaceEditClientCapabilitiesCopyWith<WorkspaceEditClientCapabilities> get copyWith => _$WorkspaceEditClientCapabilitiesCopyWithImpl<WorkspaceEditClientCapabilities>(this as WorkspaceEditClientCapabilities, _$identity);

  /// Serializes this WorkspaceEditClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkspaceEditClientCapabilities&&(identical(other.changeAnnotationSupport, changeAnnotationSupport) || other.changeAnnotationSupport == changeAnnotationSupport)&&(identical(other.normalizesLineEndings, normalizesLineEndings) || other.normalizesLineEndings == normalizesLineEndings)&&(identical(other.failureHandling, failureHandling) || other.failureHandling == failureHandling)&&const DeepCollectionEquality().equals(other.resourceOperations, resourceOperations)&&(identical(other.documentChanges, documentChanges) || other.documentChanges == documentChanges));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,changeAnnotationSupport,normalizesLineEndings,failureHandling,const DeepCollectionEquality().hash(resourceOperations),documentChanges);

@override
String toString() {
  return 'WorkspaceEditClientCapabilities(changeAnnotationSupport: $changeAnnotationSupport, normalizesLineEndings: $normalizesLineEndings, failureHandling: $failureHandling, resourceOperations: $resourceOperations, documentChanges: $documentChanges)';
}


}

/// @nodoc
abstract mixin class $WorkspaceEditClientCapabilitiesCopyWith<$Res>  {
  factory $WorkspaceEditClientCapabilitiesCopyWith(WorkspaceEditClientCapabilities value, $Res Function(WorkspaceEditClientCapabilities) _then) = _$WorkspaceEditClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 ({bool? groupsOnLabel})? changeAnnotationSupport, bool? normalizesLineEndings, FailureHandlingKind? failureHandling, List<ResourceOperationKind>? resourceOperations, bool? documentChanges
});




}
/// @nodoc
class _$WorkspaceEditClientCapabilitiesCopyWithImpl<$Res>
    implements $WorkspaceEditClientCapabilitiesCopyWith<$Res> {
  _$WorkspaceEditClientCapabilitiesCopyWithImpl(this._self, this._then);

  final WorkspaceEditClientCapabilities _self;
  final $Res Function(WorkspaceEditClientCapabilities) _then;

/// Create a copy of WorkspaceEditClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? changeAnnotationSupport = freezed,Object? normalizesLineEndings = freezed,Object? failureHandling = freezed,Object? resourceOperations = freezed,Object? documentChanges = freezed,}) {
  return _then(_self.copyWith(
changeAnnotationSupport: freezed == changeAnnotationSupport ? _self.changeAnnotationSupport : changeAnnotationSupport // ignore: cast_nullable_to_non_nullable
as ({bool? groupsOnLabel})?,normalizesLineEndings: freezed == normalizesLineEndings ? _self.normalizesLineEndings : normalizesLineEndings // ignore: cast_nullable_to_non_nullable
as bool?,failureHandling: freezed == failureHandling ? _self.failureHandling : failureHandling // ignore: cast_nullable_to_non_nullable
as FailureHandlingKind?,resourceOperations: freezed == resourceOperations ? _self.resourceOperations : resourceOperations // ignore: cast_nullable_to_non_nullable
as List<ResourceOperationKind>?,documentChanges: freezed == documentChanges ? _self.documentChanges : documentChanges // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _WorkspaceEditClientCapabilities implements WorkspaceEditClientCapabilities {
  const _WorkspaceEditClientCapabilities({this.changeAnnotationSupport, this.normalizesLineEndings, this.failureHandling, final  List<ResourceOperationKind>? resourceOperations, this.documentChanges}): _resourceOperations = resourceOperations;
  factory _WorkspaceEditClientCapabilities.fromJson(Map<String, dynamic> json) => _$WorkspaceEditClientCapabilitiesFromJson(json);

@override final  ({bool? groupsOnLabel})? changeAnnotationSupport;
@override final  bool? normalizesLineEndings;
@override final  FailureHandlingKind? failureHandling;
 final  List<ResourceOperationKind>? _resourceOperations;
@override List<ResourceOperationKind>? get resourceOperations {
  final value = _resourceOperations;
  if (value == null) return null;
  if (_resourceOperations is EqualUnmodifiableListView) return _resourceOperations;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

@override final  bool? documentChanges;

/// Create a copy of WorkspaceEditClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkspaceEditClientCapabilitiesCopyWith<_WorkspaceEditClientCapabilities> get copyWith => __$WorkspaceEditClientCapabilitiesCopyWithImpl<_WorkspaceEditClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkspaceEditClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkspaceEditClientCapabilities&&(identical(other.changeAnnotationSupport, changeAnnotationSupport) || other.changeAnnotationSupport == changeAnnotationSupport)&&(identical(other.normalizesLineEndings, normalizesLineEndings) || other.normalizesLineEndings == normalizesLineEndings)&&(identical(other.failureHandling, failureHandling) || other.failureHandling == failureHandling)&&const DeepCollectionEquality().equals(other._resourceOperations, _resourceOperations)&&(identical(other.documentChanges, documentChanges) || other.documentChanges == documentChanges));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,changeAnnotationSupport,normalizesLineEndings,failureHandling,const DeepCollectionEquality().hash(_resourceOperations),documentChanges);

@override
String toString() {
  return 'WorkspaceEditClientCapabilities(changeAnnotationSupport: $changeAnnotationSupport, normalizesLineEndings: $normalizesLineEndings, failureHandling: $failureHandling, resourceOperations: $resourceOperations, documentChanges: $documentChanges)';
}


}

/// @nodoc
abstract mixin class _$WorkspaceEditClientCapabilitiesCopyWith<$Res> implements $WorkspaceEditClientCapabilitiesCopyWith<$Res> {
  factory _$WorkspaceEditClientCapabilitiesCopyWith(_WorkspaceEditClientCapabilities value, $Res Function(_WorkspaceEditClientCapabilities) _then) = __$WorkspaceEditClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 ({bool? groupsOnLabel})? changeAnnotationSupport, bool? normalizesLineEndings, FailureHandlingKind? failureHandling, List<ResourceOperationKind>? resourceOperations, bool? documentChanges
});




}
/// @nodoc
class __$WorkspaceEditClientCapabilitiesCopyWithImpl<$Res>
    implements _$WorkspaceEditClientCapabilitiesCopyWith<$Res> {
  __$WorkspaceEditClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _WorkspaceEditClientCapabilities _self;
  final $Res Function(_WorkspaceEditClientCapabilities) _then;

/// Create a copy of WorkspaceEditClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? changeAnnotationSupport = freezed,Object? normalizesLineEndings = freezed,Object? failureHandling = freezed,Object? resourceOperations = freezed,Object? documentChanges = freezed,}) {
  return _then(_WorkspaceEditClientCapabilities(
changeAnnotationSupport: freezed == changeAnnotationSupport ? _self.changeAnnotationSupport : changeAnnotationSupport // ignore: cast_nullable_to_non_nullable
as ({bool? groupsOnLabel})?,normalizesLineEndings: freezed == normalizesLineEndings ? _self.normalizesLineEndings : normalizesLineEndings // ignore: cast_nullable_to_non_nullable
as bool?,failureHandling: freezed == failureHandling ? _self.failureHandling : failureHandling // ignore: cast_nullable_to_non_nullable
as FailureHandlingKind?,resourceOperations: freezed == resourceOperations ? _self._resourceOperations : resourceOperations // ignore: cast_nullable_to_non_nullable
as List<ResourceOperationKind>?,documentChanges: freezed == documentChanges ? _self.documentChanges : documentChanges // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DidChangeConfigurationClientCapabilities {

 bool? get dynamicRegistration;
/// Create a copy of DidChangeConfigurationClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DidChangeConfigurationClientCapabilitiesCopyWith<DidChangeConfigurationClientCapabilities> get copyWith => _$DidChangeConfigurationClientCapabilitiesCopyWithImpl<DidChangeConfigurationClientCapabilities>(this as DidChangeConfigurationClientCapabilities, _$identity);

  /// Serializes this DidChangeConfigurationClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DidChangeConfigurationClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'DidChangeConfigurationClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $DidChangeConfigurationClientCapabilitiesCopyWith<$Res>  {
  factory $DidChangeConfigurationClientCapabilitiesCopyWith(DidChangeConfigurationClientCapabilities value, $Res Function(DidChangeConfigurationClientCapabilities) _then) = _$DidChangeConfigurationClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class _$DidChangeConfigurationClientCapabilitiesCopyWithImpl<$Res>
    implements $DidChangeConfigurationClientCapabilitiesCopyWith<$Res> {
  _$DidChangeConfigurationClientCapabilitiesCopyWithImpl(this._self, this._then);

  final DidChangeConfigurationClientCapabilities _self;
  final $Res Function(DidChangeConfigurationClientCapabilities) _then;

/// Create a copy of DidChangeConfigurationClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DidChangeConfigurationClientCapabilities implements DidChangeConfigurationClientCapabilities {
  const _DidChangeConfigurationClientCapabilities({this.dynamicRegistration});
  factory _DidChangeConfigurationClientCapabilities.fromJson(Map<String, dynamic> json) => _$DidChangeConfigurationClientCapabilitiesFromJson(json);

@override final  bool? dynamicRegistration;

/// Create a copy of DidChangeConfigurationClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DidChangeConfigurationClientCapabilitiesCopyWith<_DidChangeConfigurationClientCapabilities> get copyWith => __$DidChangeConfigurationClientCapabilitiesCopyWithImpl<_DidChangeConfigurationClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DidChangeConfigurationClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DidChangeConfigurationClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'DidChangeConfigurationClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$DidChangeConfigurationClientCapabilitiesCopyWith<$Res> implements $DidChangeConfigurationClientCapabilitiesCopyWith<$Res> {
  factory _$DidChangeConfigurationClientCapabilitiesCopyWith(_DidChangeConfigurationClientCapabilities value, $Res Function(_DidChangeConfigurationClientCapabilities) _then) = __$DidChangeConfigurationClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class __$DidChangeConfigurationClientCapabilitiesCopyWithImpl<$Res>
    implements _$DidChangeConfigurationClientCapabilitiesCopyWith<$Res> {
  __$DidChangeConfigurationClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _DidChangeConfigurationClientCapabilities _self;
  final $Res Function(_DidChangeConfigurationClientCapabilities) _then;

/// Create a copy of DidChangeConfigurationClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_DidChangeConfigurationClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DidChangeWatchedFilesClientCapabilities {

 bool? get relativePatternSupport; bool? get dynamicRegistration;
/// Create a copy of DidChangeWatchedFilesClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DidChangeWatchedFilesClientCapabilitiesCopyWith<DidChangeWatchedFilesClientCapabilities> get copyWith => _$DidChangeWatchedFilesClientCapabilitiesCopyWithImpl<DidChangeWatchedFilesClientCapabilities>(this as DidChangeWatchedFilesClientCapabilities, _$identity);

  /// Serializes this DidChangeWatchedFilesClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DidChangeWatchedFilesClientCapabilities&&(identical(other.relativePatternSupport, relativePatternSupport) || other.relativePatternSupport == relativePatternSupport)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,relativePatternSupport,dynamicRegistration);

@override
String toString() {
  return 'DidChangeWatchedFilesClientCapabilities(relativePatternSupport: $relativePatternSupport, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $DidChangeWatchedFilesClientCapabilitiesCopyWith<$Res>  {
  factory $DidChangeWatchedFilesClientCapabilitiesCopyWith(DidChangeWatchedFilesClientCapabilities value, $Res Function(DidChangeWatchedFilesClientCapabilities) _then) = _$DidChangeWatchedFilesClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? relativePatternSupport, bool? dynamicRegistration
});




}
/// @nodoc
class _$DidChangeWatchedFilesClientCapabilitiesCopyWithImpl<$Res>
    implements $DidChangeWatchedFilesClientCapabilitiesCopyWith<$Res> {
  _$DidChangeWatchedFilesClientCapabilitiesCopyWithImpl(this._self, this._then);

  final DidChangeWatchedFilesClientCapabilities _self;
  final $Res Function(DidChangeWatchedFilesClientCapabilities) _then;

/// Create a copy of DidChangeWatchedFilesClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? relativePatternSupport = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
relativePatternSupport: freezed == relativePatternSupport ? _self.relativePatternSupport : relativePatternSupport // ignore: cast_nullable_to_non_nullable
as bool?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DidChangeWatchedFilesClientCapabilities implements DidChangeWatchedFilesClientCapabilities {
  const _DidChangeWatchedFilesClientCapabilities({this.relativePatternSupport, this.dynamicRegistration});
  factory _DidChangeWatchedFilesClientCapabilities.fromJson(Map<String, dynamic> json) => _$DidChangeWatchedFilesClientCapabilitiesFromJson(json);

@override final  bool? relativePatternSupport;
@override final  bool? dynamicRegistration;

/// Create a copy of DidChangeWatchedFilesClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DidChangeWatchedFilesClientCapabilitiesCopyWith<_DidChangeWatchedFilesClientCapabilities> get copyWith => __$DidChangeWatchedFilesClientCapabilitiesCopyWithImpl<_DidChangeWatchedFilesClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DidChangeWatchedFilesClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DidChangeWatchedFilesClientCapabilities&&(identical(other.relativePatternSupport, relativePatternSupport) || other.relativePatternSupport == relativePatternSupport)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,relativePatternSupport,dynamicRegistration);

@override
String toString() {
  return 'DidChangeWatchedFilesClientCapabilities(relativePatternSupport: $relativePatternSupport, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$DidChangeWatchedFilesClientCapabilitiesCopyWith<$Res> implements $DidChangeWatchedFilesClientCapabilitiesCopyWith<$Res> {
  factory _$DidChangeWatchedFilesClientCapabilitiesCopyWith(_DidChangeWatchedFilesClientCapabilities value, $Res Function(_DidChangeWatchedFilesClientCapabilities) _then) = __$DidChangeWatchedFilesClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? relativePatternSupport, bool? dynamicRegistration
});




}
/// @nodoc
class __$DidChangeWatchedFilesClientCapabilitiesCopyWithImpl<$Res>
    implements _$DidChangeWatchedFilesClientCapabilitiesCopyWith<$Res> {
  __$DidChangeWatchedFilesClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _DidChangeWatchedFilesClientCapabilities _self;
  final $Res Function(_DidChangeWatchedFilesClientCapabilities) _then;

/// Create a copy of DidChangeWatchedFilesClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? relativePatternSupport = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_DidChangeWatchedFilesClientCapabilities(
relativePatternSupport: freezed == relativePatternSupport ? _self.relativePatternSupport : relativePatternSupport // ignore: cast_nullable_to_non_nullable
as bool?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$WorkspaceSymbolClientCapabilities {

 ({List<String> properties})? get resolveSupport; ({List<SymbolTag> valueSet})? get tagSupport; ({List<SymbolKind>? valueSet})? get symbolKind; bool? get dynamicRegistration;
/// Create a copy of WorkspaceSymbolClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkspaceSymbolClientCapabilitiesCopyWith<WorkspaceSymbolClientCapabilities> get copyWith => _$WorkspaceSymbolClientCapabilitiesCopyWithImpl<WorkspaceSymbolClientCapabilities>(this as WorkspaceSymbolClientCapabilities, _$identity);

  /// Serializes this WorkspaceSymbolClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkspaceSymbolClientCapabilities&&(identical(other.resolveSupport, resolveSupport) || other.resolveSupport == resolveSupport)&&(identical(other.tagSupport, tagSupport) || other.tagSupport == tagSupport)&&(identical(other.symbolKind, symbolKind) || other.symbolKind == symbolKind)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,resolveSupport,tagSupport,symbolKind,dynamicRegistration);

@override
String toString() {
  return 'WorkspaceSymbolClientCapabilities(resolveSupport: $resolveSupport, tagSupport: $tagSupport, symbolKind: $symbolKind, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $WorkspaceSymbolClientCapabilitiesCopyWith<$Res>  {
  factory $WorkspaceSymbolClientCapabilitiesCopyWith(WorkspaceSymbolClientCapabilities value, $Res Function(WorkspaceSymbolClientCapabilities) _then) = _$WorkspaceSymbolClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 ({List<String> properties})? resolveSupport, ({List<SymbolTag> valueSet})? tagSupport, ({List<SymbolKind>? valueSet})? symbolKind, bool? dynamicRegistration
});




}
/// @nodoc
class _$WorkspaceSymbolClientCapabilitiesCopyWithImpl<$Res>
    implements $WorkspaceSymbolClientCapabilitiesCopyWith<$Res> {
  _$WorkspaceSymbolClientCapabilitiesCopyWithImpl(this._self, this._then);

  final WorkspaceSymbolClientCapabilities _self;
  final $Res Function(WorkspaceSymbolClientCapabilities) _then;

/// Create a copy of WorkspaceSymbolClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? resolveSupport = freezed,Object? tagSupport = freezed,Object? symbolKind = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
resolveSupport: freezed == resolveSupport ? _self.resolveSupport : resolveSupport // ignore: cast_nullable_to_non_nullable
as ({List<String> properties})?,tagSupport: freezed == tagSupport ? _self.tagSupport : tagSupport // ignore: cast_nullable_to_non_nullable
as ({List<SymbolTag> valueSet})?,symbolKind: freezed == symbolKind ? _self.symbolKind : symbolKind // ignore: cast_nullable_to_non_nullable
as ({List<SymbolKind>? valueSet})?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _WorkspaceSymbolClientCapabilities implements WorkspaceSymbolClientCapabilities {
  const _WorkspaceSymbolClientCapabilities({this.resolveSupport, this.tagSupport, this.symbolKind, this.dynamicRegistration});
  factory _WorkspaceSymbolClientCapabilities.fromJson(Map<String, dynamic> json) => _$WorkspaceSymbolClientCapabilitiesFromJson(json);

@override final  ({List<String> properties})? resolveSupport;
@override final  ({List<SymbolTag> valueSet})? tagSupport;
@override final  ({List<SymbolKind>? valueSet})? symbolKind;
@override final  bool? dynamicRegistration;

/// Create a copy of WorkspaceSymbolClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkspaceSymbolClientCapabilitiesCopyWith<_WorkspaceSymbolClientCapabilities> get copyWith => __$WorkspaceSymbolClientCapabilitiesCopyWithImpl<_WorkspaceSymbolClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkspaceSymbolClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkspaceSymbolClientCapabilities&&(identical(other.resolveSupport, resolveSupport) || other.resolveSupport == resolveSupport)&&(identical(other.tagSupport, tagSupport) || other.tagSupport == tagSupport)&&(identical(other.symbolKind, symbolKind) || other.symbolKind == symbolKind)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,resolveSupport,tagSupport,symbolKind,dynamicRegistration);

@override
String toString() {
  return 'WorkspaceSymbolClientCapabilities(resolveSupport: $resolveSupport, tagSupport: $tagSupport, symbolKind: $symbolKind, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$WorkspaceSymbolClientCapabilitiesCopyWith<$Res> implements $WorkspaceSymbolClientCapabilitiesCopyWith<$Res> {
  factory _$WorkspaceSymbolClientCapabilitiesCopyWith(_WorkspaceSymbolClientCapabilities value, $Res Function(_WorkspaceSymbolClientCapabilities) _then) = __$WorkspaceSymbolClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 ({List<String> properties})? resolveSupport, ({List<SymbolTag> valueSet})? tagSupport, ({List<SymbolKind>? valueSet})? symbolKind, bool? dynamicRegistration
});




}
/// @nodoc
class __$WorkspaceSymbolClientCapabilitiesCopyWithImpl<$Res>
    implements _$WorkspaceSymbolClientCapabilitiesCopyWith<$Res> {
  __$WorkspaceSymbolClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _WorkspaceSymbolClientCapabilities _self;
  final $Res Function(_WorkspaceSymbolClientCapabilities) _then;

/// Create a copy of WorkspaceSymbolClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? resolveSupport = freezed,Object? tagSupport = freezed,Object? symbolKind = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_WorkspaceSymbolClientCapabilities(
resolveSupport: freezed == resolveSupport ? _self.resolveSupport : resolveSupport // ignore: cast_nullable_to_non_nullable
as ({List<String> properties})?,tagSupport: freezed == tagSupport ? _self.tagSupport : tagSupport // ignore: cast_nullable_to_non_nullable
as ({List<SymbolTag> valueSet})?,symbolKind: freezed == symbolKind ? _self.symbolKind : symbolKind // ignore: cast_nullable_to_non_nullable
as ({List<SymbolKind>? valueSet})?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$ExecuteCommandClientCapabilities {

 bool? get dynamicRegistration;
/// Create a copy of ExecuteCommandClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ExecuteCommandClientCapabilitiesCopyWith<ExecuteCommandClientCapabilities> get copyWith => _$ExecuteCommandClientCapabilitiesCopyWithImpl<ExecuteCommandClientCapabilities>(this as ExecuteCommandClientCapabilities, _$identity);

  /// Serializes this ExecuteCommandClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ExecuteCommandClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'ExecuteCommandClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $ExecuteCommandClientCapabilitiesCopyWith<$Res>  {
  factory $ExecuteCommandClientCapabilitiesCopyWith(ExecuteCommandClientCapabilities value, $Res Function(ExecuteCommandClientCapabilities) _then) = _$ExecuteCommandClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class _$ExecuteCommandClientCapabilitiesCopyWithImpl<$Res>
    implements $ExecuteCommandClientCapabilitiesCopyWith<$Res> {
  _$ExecuteCommandClientCapabilitiesCopyWithImpl(this._self, this._then);

  final ExecuteCommandClientCapabilities _self;
  final $Res Function(ExecuteCommandClientCapabilities) _then;

/// Create a copy of ExecuteCommandClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _ExecuteCommandClientCapabilities implements ExecuteCommandClientCapabilities {
  const _ExecuteCommandClientCapabilities({this.dynamicRegistration});
  factory _ExecuteCommandClientCapabilities.fromJson(Map<String, dynamic> json) => _$ExecuteCommandClientCapabilitiesFromJson(json);

@override final  bool? dynamicRegistration;

/// Create a copy of ExecuteCommandClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ExecuteCommandClientCapabilitiesCopyWith<_ExecuteCommandClientCapabilities> get copyWith => __$ExecuteCommandClientCapabilitiesCopyWithImpl<_ExecuteCommandClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ExecuteCommandClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ExecuteCommandClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'ExecuteCommandClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$ExecuteCommandClientCapabilitiesCopyWith<$Res> implements $ExecuteCommandClientCapabilitiesCopyWith<$Res> {
  factory _$ExecuteCommandClientCapabilitiesCopyWith(_ExecuteCommandClientCapabilities value, $Res Function(_ExecuteCommandClientCapabilities) _then) = __$ExecuteCommandClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class __$ExecuteCommandClientCapabilitiesCopyWithImpl<$Res>
    implements _$ExecuteCommandClientCapabilitiesCopyWith<$Res> {
  __$ExecuteCommandClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _ExecuteCommandClientCapabilities _self;
  final $Res Function(_ExecuteCommandClientCapabilities) _then;

/// Create a copy of ExecuteCommandClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_ExecuteCommandClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$SemanticTokensWorkspaceClientCapabilities {

 bool? get refreshSupport;
/// Create a copy of SemanticTokensWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SemanticTokensWorkspaceClientCapabilitiesCopyWith<SemanticTokensWorkspaceClientCapabilities> get copyWith => _$SemanticTokensWorkspaceClientCapabilitiesCopyWithImpl<SemanticTokensWorkspaceClientCapabilities>(this as SemanticTokensWorkspaceClientCapabilities, _$identity);

  /// Serializes this SemanticTokensWorkspaceClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SemanticTokensWorkspaceClientCapabilities&&(identical(other.refreshSupport, refreshSupport) || other.refreshSupport == refreshSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,refreshSupport);

@override
String toString() {
  return 'SemanticTokensWorkspaceClientCapabilities(refreshSupport: $refreshSupport)';
}


}

/// @nodoc
abstract mixin class $SemanticTokensWorkspaceClientCapabilitiesCopyWith<$Res>  {
  factory $SemanticTokensWorkspaceClientCapabilitiesCopyWith(SemanticTokensWorkspaceClientCapabilities value, $Res Function(SemanticTokensWorkspaceClientCapabilities) _then) = _$SemanticTokensWorkspaceClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? refreshSupport
});




}
/// @nodoc
class _$SemanticTokensWorkspaceClientCapabilitiesCopyWithImpl<$Res>
    implements $SemanticTokensWorkspaceClientCapabilitiesCopyWith<$Res> {
  _$SemanticTokensWorkspaceClientCapabilitiesCopyWithImpl(this._self, this._then);

  final SemanticTokensWorkspaceClientCapabilities _self;
  final $Res Function(SemanticTokensWorkspaceClientCapabilities) _then;

/// Create a copy of SemanticTokensWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? refreshSupport = freezed,}) {
  return _then(_self.copyWith(
refreshSupport: freezed == refreshSupport ? _self.refreshSupport : refreshSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _SemanticTokensWorkspaceClientCapabilities implements SemanticTokensWorkspaceClientCapabilities {
  const _SemanticTokensWorkspaceClientCapabilities({this.refreshSupport});
  factory _SemanticTokensWorkspaceClientCapabilities.fromJson(Map<String, dynamic> json) => _$SemanticTokensWorkspaceClientCapabilitiesFromJson(json);

@override final  bool? refreshSupport;

/// Create a copy of SemanticTokensWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SemanticTokensWorkspaceClientCapabilitiesCopyWith<_SemanticTokensWorkspaceClientCapabilities> get copyWith => __$SemanticTokensWorkspaceClientCapabilitiesCopyWithImpl<_SemanticTokensWorkspaceClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SemanticTokensWorkspaceClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SemanticTokensWorkspaceClientCapabilities&&(identical(other.refreshSupport, refreshSupport) || other.refreshSupport == refreshSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,refreshSupport);

@override
String toString() {
  return 'SemanticTokensWorkspaceClientCapabilities(refreshSupport: $refreshSupport)';
}


}

/// @nodoc
abstract mixin class _$SemanticTokensWorkspaceClientCapabilitiesCopyWith<$Res> implements $SemanticTokensWorkspaceClientCapabilitiesCopyWith<$Res> {
  factory _$SemanticTokensWorkspaceClientCapabilitiesCopyWith(_SemanticTokensWorkspaceClientCapabilities value, $Res Function(_SemanticTokensWorkspaceClientCapabilities) _then) = __$SemanticTokensWorkspaceClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? refreshSupport
});




}
/// @nodoc
class __$SemanticTokensWorkspaceClientCapabilitiesCopyWithImpl<$Res>
    implements _$SemanticTokensWorkspaceClientCapabilitiesCopyWith<$Res> {
  __$SemanticTokensWorkspaceClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _SemanticTokensWorkspaceClientCapabilities _self;
  final $Res Function(_SemanticTokensWorkspaceClientCapabilities) _then;

/// Create a copy of SemanticTokensWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? refreshSupport = freezed,}) {
  return _then(_SemanticTokensWorkspaceClientCapabilities(
refreshSupport: freezed == refreshSupport ? _self.refreshSupport : refreshSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$CodeLensWorkspaceClientCapabilities {

 bool? get refreshSupport;
/// Create a copy of CodeLensWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CodeLensWorkspaceClientCapabilitiesCopyWith<CodeLensWorkspaceClientCapabilities> get copyWith => _$CodeLensWorkspaceClientCapabilitiesCopyWithImpl<CodeLensWorkspaceClientCapabilities>(this as CodeLensWorkspaceClientCapabilities, _$identity);

  /// Serializes this CodeLensWorkspaceClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CodeLensWorkspaceClientCapabilities&&(identical(other.refreshSupport, refreshSupport) || other.refreshSupport == refreshSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,refreshSupport);

@override
String toString() {
  return 'CodeLensWorkspaceClientCapabilities(refreshSupport: $refreshSupport)';
}


}

/// @nodoc
abstract mixin class $CodeLensWorkspaceClientCapabilitiesCopyWith<$Res>  {
  factory $CodeLensWorkspaceClientCapabilitiesCopyWith(CodeLensWorkspaceClientCapabilities value, $Res Function(CodeLensWorkspaceClientCapabilities) _then) = _$CodeLensWorkspaceClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? refreshSupport
});




}
/// @nodoc
class _$CodeLensWorkspaceClientCapabilitiesCopyWithImpl<$Res>
    implements $CodeLensWorkspaceClientCapabilitiesCopyWith<$Res> {
  _$CodeLensWorkspaceClientCapabilitiesCopyWithImpl(this._self, this._then);

  final CodeLensWorkspaceClientCapabilities _self;
  final $Res Function(CodeLensWorkspaceClientCapabilities) _then;

/// Create a copy of CodeLensWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? refreshSupport = freezed,}) {
  return _then(_self.copyWith(
refreshSupport: freezed == refreshSupport ? _self.refreshSupport : refreshSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _CodeLensWorkspaceClientCapabilities implements CodeLensWorkspaceClientCapabilities {
  const _CodeLensWorkspaceClientCapabilities({this.refreshSupport});
  factory _CodeLensWorkspaceClientCapabilities.fromJson(Map<String, dynamic> json) => _$CodeLensWorkspaceClientCapabilitiesFromJson(json);

@override final  bool? refreshSupport;

/// Create a copy of CodeLensWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CodeLensWorkspaceClientCapabilitiesCopyWith<_CodeLensWorkspaceClientCapabilities> get copyWith => __$CodeLensWorkspaceClientCapabilitiesCopyWithImpl<_CodeLensWorkspaceClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CodeLensWorkspaceClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CodeLensWorkspaceClientCapabilities&&(identical(other.refreshSupport, refreshSupport) || other.refreshSupport == refreshSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,refreshSupport);

@override
String toString() {
  return 'CodeLensWorkspaceClientCapabilities(refreshSupport: $refreshSupport)';
}


}

/// @nodoc
abstract mixin class _$CodeLensWorkspaceClientCapabilitiesCopyWith<$Res> implements $CodeLensWorkspaceClientCapabilitiesCopyWith<$Res> {
  factory _$CodeLensWorkspaceClientCapabilitiesCopyWith(_CodeLensWorkspaceClientCapabilities value, $Res Function(_CodeLensWorkspaceClientCapabilities) _then) = __$CodeLensWorkspaceClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? refreshSupport
});




}
/// @nodoc
class __$CodeLensWorkspaceClientCapabilitiesCopyWithImpl<$Res>
    implements _$CodeLensWorkspaceClientCapabilitiesCopyWith<$Res> {
  __$CodeLensWorkspaceClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _CodeLensWorkspaceClientCapabilities _self;
  final $Res Function(_CodeLensWorkspaceClientCapabilities) _then;

/// Create a copy of CodeLensWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? refreshSupport = freezed,}) {
  return _then(_CodeLensWorkspaceClientCapabilities(
refreshSupport: freezed == refreshSupport ? _self.refreshSupport : refreshSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$FileOperationClientCapabilities {

 bool? get willDelete; bool? get didDelete; bool? get willRename; bool? get didRename; bool? get willCreate; bool? get didCreate; bool? get dynamicRegistration;
/// Create a copy of FileOperationClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FileOperationClientCapabilitiesCopyWith<FileOperationClientCapabilities> get copyWith => _$FileOperationClientCapabilitiesCopyWithImpl<FileOperationClientCapabilities>(this as FileOperationClientCapabilities, _$identity);

  /// Serializes this FileOperationClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FileOperationClientCapabilities&&(identical(other.willDelete, willDelete) || other.willDelete == willDelete)&&(identical(other.didDelete, didDelete) || other.didDelete == didDelete)&&(identical(other.willRename, willRename) || other.willRename == willRename)&&(identical(other.didRename, didRename) || other.didRename == didRename)&&(identical(other.willCreate, willCreate) || other.willCreate == willCreate)&&(identical(other.didCreate, didCreate) || other.didCreate == didCreate)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,willDelete,didDelete,willRename,didRename,willCreate,didCreate,dynamicRegistration);

@override
String toString() {
  return 'FileOperationClientCapabilities(willDelete: $willDelete, didDelete: $didDelete, willRename: $willRename, didRename: $didRename, willCreate: $willCreate, didCreate: $didCreate, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $FileOperationClientCapabilitiesCopyWith<$Res>  {
  factory $FileOperationClientCapabilitiesCopyWith(FileOperationClientCapabilities value, $Res Function(FileOperationClientCapabilities) _then) = _$FileOperationClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? willDelete, bool? didDelete, bool? willRename, bool? didRename, bool? willCreate, bool? didCreate, bool? dynamicRegistration
});




}
/// @nodoc
class _$FileOperationClientCapabilitiesCopyWithImpl<$Res>
    implements $FileOperationClientCapabilitiesCopyWith<$Res> {
  _$FileOperationClientCapabilitiesCopyWithImpl(this._self, this._then);

  final FileOperationClientCapabilities _self;
  final $Res Function(FileOperationClientCapabilities) _then;

/// Create a copy of FileOperationClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? willDelete = freezed,Object? didDelete = freezed,Object? willRename = freezed,Object? didRename = freezed,Object? willCreate = freezed,Object? didCreate = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
willDelete: freezed == willDelete ? _self.willDelete : willDelete // ignore: cast_nullable_to_non_nullable
as bool?,didDelete: freezed == didDelete ? _self.didDelete : didDelete // ignore: cast_nullable_to_non_nullable
as bool?,willRename: freezed == willRename ? _self.willRename : willRename // ignore: cast_nullable_to_non_nullable
as bool?,didRename: freezed == didRename ? _self.didRename : didRename // ignore: cast_nullable_to_non_nullable
as bool?,willCreate: freezed == willCreate ? _self.willCreate : willCreate // ignore: cast_nullable_to_non_nullable
as bool?,didCreate: freezed == didCreate ? _self.didCreate : didCreate // ignore: cast_nullable_to_non_nullable
as bool?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _FileOperationClientCapabilities implements FileOperationClientCapabilities {
  const _FileOperationClientCapabilities({this.willDelete, this.didDelete, this.willRename, this.didRename, this.willCreate, this.didCreate, this.dynamicRegistration});
  factory _FileOperationClientCapabilities.fromJson(Map<String, dynamic> json) => _$FileOperationClientCapabilitiesFromJson(json);

@override final  bool? willDelete;
@override final  bool? didDelete;
@override final  bool? willRename;
@override final  bool? didRename;
@override final  bool? willCreate;
@override final  bool? didCreate;
@override final  bool? dynamicRegistration;

/// Create a copy of FileOperationClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$FileOperationClientCapabilitiesCopyWith<_FileOperationClientCapabilities> get copyWith => __$FileOperationClientCapabilitiesCopyWithImpl<_FileOperationClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$FileOperationClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _FileOperationClientCapabilities&&(identical(other.willDelete, willDelete) || other.willDelete == willDelete)&&(identical(other.didDelete, didDelete) || other.didDelete == didDelete)&&(identical(other.willRename, willRename) || other.willRename == willRename)&&(identical(other.didRename, didRename) || other.didRename == didRename)&&(identical(other.willCreate, willCreate) || other.willCreate == willCreate)&&(identical(other.didCreate, didCreate) || other.didCreate == didCreate)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,willDelete,didDelete,willRename,didRename,willCreate,didCreate,dynamicRegistration);

@override
String toString() {
  return 'FileOperationClientCapabilities(willDelete: $willDelete, didDelete: $didDelete, willRename: $willRename, didRename: $didRename, willCreate: $willCreate, didCreate: $didCreate, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$FileOperationClientCapabilitiesCopyWith<$Res> implements $FileOperationClientCapabilitiesCopyWith<$Res> {
  factory _$FileOperationClientCapabilitiesCopyWith(_FileOperationClientCapabilities value, $Res Function(_FileOperationClientCapabilities) _then) = __$FileOperationClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? willDelete, bool? didDelete, bool? willRename, bool? didRename, bool? willCreate, bool? didCreate, bool? dynamicRegistration
});




}
/// @nodoc
class __$FileOperationClientCapabilitiesCopyWithImpl<$Res>
    implements _$FileOperationClientCapabilitiesCopyWith<$Res> {
  __$FileOperationClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _FileOperationClientCapabilities _self;
  final $Res Function(_FileOperationClientCapabilities) _then;

/// Create a copy of FileOperationClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? willDelete = freezed,Object? didDelete = freezed,Object? willRename = freezed,Object? didRename = freezed,Object? willCreate = freezed,Object? didCreate = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_FileOperationClientCapabilities(
willDelete: freezed == willDelete ? _self.willDelete : willDelete // ignore: cast_nullable_to_non_nullable
as bool?,didDelete: freezed == didDelete ? _self.didDelete : didDelete // ignore: cast_nullable_to_non_nullable
as bool?,willRename: freezed == willRename ? _self.willRename : willRename // ignore: cast_nullable_to_non_nullable
as bool?,didRename: freezed == didRename ? _self.didRename : didRename // ignore: cast_nullable_to_non_nullable
as bool?,willCreate: freezed == willCreate ? _self.willCreate : willCreate // ignore: cast_nullable_to_non_nullable
as bool?,didCreate: freezed == didCreate ? _self.didCreate : didCreate // ignore: cast_nullable_to_non_nullable
as bool?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$InlineValueWorkspaceClientCapabilities {

 bool? get refreshSupport;
/// Create a copy of InlineValueWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlineValueWorkspaceClientCapabilitiesCopyWith<InlineValueWorkspaceClientCapabilities> get copyWith => _$InlineValueWorkspaceClientCapabilitiesCopyWithImpl<InlineValueWorkspaceClientCapabilities>(this as InlineValueWorkspaceClientCapabilities, _$identity);

  /// Serializes this InlineValueWorkspaceClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlineValueWorkspaceClientCapabilities&&(identical(other.refreshSupport, refreshSupport) || other.refreshSupport == refreshSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,refreshSupport);

@override
String toString() {
  return 'InlineValueWorkspaceClientCapabilities(refreshSupport: $refreshSupport)';
}


}

/// @nodoc
abstract mixin class $InlineValueWorkspaceClientCapabilitiesCopyWith<$Res>  {
  factory $InlineValueWorkspaceClientCapabilitiesCopyWith(InlineValueWorkspaceClientCapabilities value, $Res Function(InlineValueWorkspaceClientCapabilities) _then) = _$InlineValueWorkspaceClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? refreshSupport
});




}
/// @nodoc
class _$InlineValueWorkspaceClientCapabilitiesCopyWithImpl<$Res>
    implements $InlineValueWorkspaceClientCapabilitiesCopyWith<$Res> {
  _$InlineValueWorkspaceClientCapabilitiesCopyWithImpl(this._self, this._then);

  final InlineValueWorkspaceClientCapabilities _self;
  final $Res Function(InlineValueWorkspaceClientCapabilities) _then;

/// Create a copy of InlineValueWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? refreshSupport = freezed,}) {
  return _then(_self.copyWith(
refreshSupport: freezed == refreshSupport ? _self.refreshSupport : refreshSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _InlineValueWorkspaceClientCapabilities implements InlineValueWorkspaceClientCapabilities {
  const _InlineValueWorkspaceClientCapabilities({this.refreshSupport});
  factory _InlineValueWorkspaceClientCapabilities.fromJson(Map<String, dynamic> json) => _$InlineValueWorkspaceClientCapabilitiesFromJson(json);

@override final  bool? refreshSupport;

/// Create a copy of InlineValueWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlineValueWorkspaceClientCapabilitiesCopyWith<_InlineValueWorkspaceClientCapabilities> get copyWith => __$InlineValueWorkspaceClientCapabilitiesCopyWithImpl<_InlineValueWorkspaceClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlineValueWorkspaceClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlineValueWorkspaceClientCapabilities&&(identical(other.refreshSupport, refreshSupport) || other.refreshSupport == refreshSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,refreshSupport);

@override
String toString() {
  return 'InlineValueWorkspaceClientCapabilities(refreshSupport: $refreshSupport)';
}


}

/// @nodoc
abstract mixin class _$InlineValueWorkspaceClientCapabilitiesCopyWith<$Res> implements $InlineValueWorkspaceClientCapabilitiesCopyWith<$Res> {
  factory _$InlineValueWorkspaceClientCapabilitiesCopyWith(_InlineValueWorkspaceClientCapabilities value, $Res Function(_InlineValueWorkspaceClientCapabilities) _then) = __$InlineValueWorkspaceClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? refreshSupport
});




}
/// @nodoc
class __$InlineValueWorkspaceClientCapabilitiesCopyWithImpl<$Res>
    implements _$InlineValueWorkspaceClientCapabilitiesCopyWith<$Res> {
  __$InlineValueWorkspaceClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _InlineValueWorkspaceClientCapabilities _self;
  final $Res Function(_InlineValueWorkspaceClientCapabilities) _then;

/// Create a copy of InlineValueWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? refreshSupport = freezed,}) {
  return _then(_InlineValueWorkspaceClientCapabilities(
refreshSupport: freezed == refreshSupport ? _self.refreshSupport : refreshSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$InlayHintWorkspaceClientCapabilities {

 bool? get refreshSupport;
/// Create a copy of InlayHintWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlayHintWorkspaceClientCapabilitiesCopyWith<InlayHintWorkspaceClientCapabilities> get copyWith => _$InlayHintWorkspaceClientCapabilitiesCopyWithImpl<InlayHintWorkspaceClientCapabilities>(this as InlayHintWorkspaceClientCapabilities, _$identity);

  /// Serializes this InlayHintWorkspaceClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlayHintWorkspaceClientCapabilities&&(identical(other.refreshSupport, refreshSupport) || other.refreshSupport == refreshSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,refreshSupport);

@override
String toString() {
  return 'InlayHintWorkspaceClientCapabilities(refreshSupport: $refreshSupport)';
}


}

/// @nodoc
abstract mixin class $InlayHintWorkspaceClientCapabilitiesCopyWith<$Res>  {
  factory $InlayHintWorkspaceClientCapabilitiesCopyWith(InlayHintWorkspaceClientCapabilities value, $Res Function(InlayHintWorkspaceClientCapabilities) _then) = _$InlayHintWorkspaceClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? refreshSupport
});




}
/// @nodoc
class _$InlayHintWorkspaceClientCapabilitiesCopyWithImpl<$Res>
    implements $InlayHintWorkspaceClientCapabilitiesCopyWith<$Res> {
  _$InlayHintWorkspaceClientCapabilitiesCopyWithImpl(this._self, this._then);

  final InlayHintWorkspaceClientCapabilities _self;
  final $Res Function(InlayHintWorkspaceClientCapabilities) _then;

/// Create a copy of InlayHintWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? refreshSupport = freezed,}) {
  return _then(_self.copyWith(
refreshSupport: freezed == refreshSupport ? _self.refreshSupport : refreshSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _InlayHintWorkspaceClientCapabilities implements InlayHintWorkspaceClientCapabilities {
  const _InlayHintWorkspaceClientCapabilities({this.refreshSupport});
  factory _InlayHintWorkspaceClientCapabilities.fromJson(Map<String, dynamic> json) => _$InlayHintWorkspaceClientCapabilitiesFromJson(json);

@override final  bool? refreshSupport;

/// Create a copy of InlayHintWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlayHintWorkspaceClientCapabilitiesCopyWith<_InlayHintWorkspaceClientCapabilities> get copyWith => __$InlayHintWorkspaceClientCapabilitiesCopyWithImpl<_InlayHintWorkspaceClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlayHintWorkspaceClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlayHintWorkspaceClientCapabilities&&(identical(other.refreshSupport, refreshSupport) || other.refreshSupport == refreshSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,refreshSupport);

@override
String toString() {
  return 'InlayHintWorkspaceClientCapabilities(refreshSupport: $refreshSupport)';
}


}

/// @nodoc
abstract mixin class _$InlayHintWorkspaceClientCapabilitiesCopyWith<$Res> implements $InlayHintWorkspaceClientCapabilitiesCopyWith<$Res> {
  factory _$InlayHintWorkspaceClientCapabilitiesCopyWith(_InlayHintWorkspaceClientCapabilities value, $Res Function(_InlayHintWorkspaceClientCapabilities) _then) = __$InlayHintWorkspaceClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? refreshSupport
});




}
/// @nodoc
class __$InlayHintWorkspaceClientCapabilitiesCopyWithImpl<$Res>
    implements _$InlayHintWorkspaceClientCapabilitiesCopyWith<$Res> {
  __$InlayHintWorkspaceClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _InlayHintWorkspaceClientCapabilities _self;
  final $Res Function(_InlayHintWorkspaceClientCapabilities) _then;

/// Create a copy of InlayHintWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? refreshSupport = freezed,}) {
  return _then(_InlayHintWorkspaceClientCapabilities(
refreshSupport: freezed == refreshSupport ? _self.refreshSupport : refreshSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DiagnosticWorkspaceClientCapabilities {

 bool? get refreshSupport;
/// Create a copy of DiagnosticWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DiagnosticWorkspaceClientCapabilitiesCopyWith<DiagnosticWorkspaceClientCapabilities> get copyWith => _$DiagnosticWorkspaceClientCapabilitiesCopyWithImpl<DiagnosticWorkspaceClientCapabilities>(this as DiagnosticWorkspaceClientCapabilities, _$identity);

  /// Serializes this DiagnosticWorkspaceClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DiagnosticWorkspaceClientCapabilities&&(identical(other.refreshSupport, refreshSupport) || other.refreshSupport == refreshSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,refreshSupport);

@override
String toString() {
  return 'DiagnosticWorkspaceClientCapabilities(refreshSupport: $refreshSupport)';
}


}

/// @nodoc
abstract mixin class $DiagnosticWorkspaceClientCapabilitiesCopyWith<$Res>  {
  factory $DiagnosticWorkspaceClientCapabilitiesCopyWith(DiagnosticWorkspaceClientCapabilities value, $Res Function(DiagnosticWorkspaceClientCapabilities) _then) = _$DiagnosticWorkspaceClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? refreshSupport
});




}
/// @nodoc
class _$DiagnosticWorkspaceClientCapabilitiesCopyWithImpl<$Res>
    implements $DiagnosticWorkspaceClientCapabilitiesCopyWith<$Res> {
  _$DiagnosticWorkspaceClientCapabilitiesCopyWithImpl(this._self, this._then);

  final DiagnosticWorkspaceClientCapabilities _self;
  final $Res Function(DiagnosticWorkspaceClientCapabilities) _then;

/// Create a copy of DiagnosticWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? refreshSupport = freezed,}) {
  return _then(_self.copyWith(
refreshSupport: freezed == refreshSupport ? _self.refreshSupport : refreshSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DiagnosticWorkspaceClientCapabilities implements DiagnosticWorkspaceClientCapabilities {
  const _DiagnosticWorkspaceClientCapabilities({this.refreshSupport});
  factory _DiagnosticWorkspaceClientCapabilities.fromJson(Map<String, dynamic> json) => _$DiagnosticWorkspaceClientCapabilitiesFromJson(json);

@override final  bool? refreshSupport;

/// Create a copy of DiagnosticWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DiagnosticWorkspaceClientCapabilitiesCopyWith<_DiagnosticWorkspaceClientCapabilities> get copyWith => __$DiagnosticWorkspaceClientCapabilitiesCopyWithImpl<_DiagnosticWorkspaceClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DiagnosticWorkspaceClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DiagnosticWorkspaceClientCapabilities&&(identical(other.refreshSupport, refreshSupport) || other.refreshSupport == refreshSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,refreshSupport);

@override
String toString() {
  return 'DiagnosticWorkspaceClientCapabilities(refreshSupport: $refreshSupport)';
}


}

/// @nodoc
abstract mixin class _$DiagnosticWorkspaceClientCapabilitiesCopyWith<$Res> implements $DiagnosticWorkspaceClientCapabilitiesCopyWith<$Res> {
  factory _$DiagnosticWorkspaceClientCapabilitiesCopyWith(_DiagnosticWorkspaceClientCapabilities value, $Res Function(_DiagnosticWorkspaceClientCapabilities) _then) = __$DiagnosticWorkspaceClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? refreshSupport
});




}
/// @nodoc
class __$DiagnosticWorkspaceClientCapabilitiesCopyWithImpl<$Res>
    implements _$DiagnosticWorkspaceClientCapabilitiesCopyWith<$Res> {
  __$DiagnosticWorkspaceClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _DiagnosticWorkspaceClientCapabilities _self;
  final $Res Function(_DiagnosticWorkspaceClientCapabilities) _then;

/// Create a copy of DiagnosticWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? refreshSupport = freezed,}) {
  return _then(_DiagnosticWorkspaceClientCapabilities(
refreshSupport: freezed == refreshSupport ? _self.refreshSupport : refreshSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$FoldingRangeWorkspaceClientCapabilities {

 bool? get refreshSupport;
/// Create a copy of FoldingRangeWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FoldingRangeWorkspaceClientCapabilitiesCopyWith<FoldingRangeWorkspaceClientCapabilities> get copyWith => _$FoldingRangeWorkspaceClientCapabilitiesCopyWithImpl<FoldingRangeWorkspaceClientCapabilities>(this as FoldingRangeWorkspaceClientCapabilities, _$identity);

  /// Serializes this FoldingRangeWorkspaceClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FoldingRangeWorkspaceClientCapabilities&&(identical(other.refreshSupport, refreshSupport) || other.refreshSupport == refreshSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,refreshSupport);

@override
String toString() {
  return 'FoldingRangeWorkspaceClientCapabilities(refreshSupport: $refreshSupport)';
}


}

/// @nodoc
abstract mixin class $FoldingRangeWorkspaceClientCapabilitiesCopyWith<$Res>  {
  factory $FoldingRangeWorkspaceClientCapabilitiesCopyWith(FoldingRangeWorkspaceClientCapabilities value, $Res Function(FoldingRangeWorkspaceClientCapabilities) _then) = _$FoldingRangeWorkspaceClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? refreshSupport
});




}
/// @nodoc
class _$FoldingRangeWorkspaceClientCapabilitiesCopyWithImpl<$Res>
    implements $FoldingRangeWorkspaceClientCapabilitiesCopyWith<$Res> {
  _$FoldingRangeWorkspaceClientCapabilitiesCopyWithImpl(this._self, this._then);

  final FoldingRangeWorkspaceClientCapabilities _self;
  final $Res Function(FoldingRangeWorkspaceClientCapabilities) _then;

/// Create a copy of FoldingRangeWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? refreshSupport = freezed,}) {
  return _then(_self.copyWith(
refreshSupport: freezed == refreshSupport ? _self.refreshSupport : refreshSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _FoldingRangeWorkspaceClientCapabilities implements FoldingRangeWorkspaceClientCapabilities {
  const _FoldingRangeWorkspaceClientCapabilities({this.refreshSupport});
  factory _FoldingRangeWorkspaceClientCapabilities.fromJson(Map<String, dynamic> json) => _$FoldingRangeWorkspaceClientCapabilitiesFromJson(json);

@override final  bool? refreshSupport;

/// Create a copy of FoldingRangeWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$FoldingRangeWorkspaceClientCapabilitiesCopyWith<_FoldingRangeWorkspaceClientCapabilities> get copyWith => __$FoldingRangeWorkspaceClientCapabilitiesCopyWithImpl<_FoldingRangeWorkspaceClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$FoldingRangeWorkspaceClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _FoldingRangeWorkspaceClientCapabilities&&(identical(other.refreshSupport, refreshSupport) || other.refreshSupport == refreshSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,refreshSupport);

@override
String toString() {
  return 'FoldingRangeWorkspaceClientCapabilities(refreshSupport: $refreshSupport)';
}


}

/// @nodoc
abstract mixin class _$FoldingRangeWorkspaceClientCapabilitiesCopyWith<$Res> implements $FoldingRangeWorkspaceClientCapabilitiesCopyWith<$Res> {
  factory _$FoldingRangeWorkspaceClientCapabilitiesCopyWith(_FoldingRangeWorkspaceClientCapabilities value, $Res Function(_FoldingRangeWorkspaceClientCapabilities) _then) = __$FoldingRangeWorkspaceClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? refreshSupport
});




}
/// @nodoc
class __$FoldingRangeWorkspaceClientCapabilitiesCopyWithImpl<$Res>
    implements _$FoldingRangeWorkspaceClientCapabilitiesCopyWith<$Res> {
  __$FoldingRangeWorkspaceClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _FoldingRangeWorkspaceClientCapabilities _self;
  final $Res Function(_FoldingRangeWorkspaceClientCapabilities) _then;

/// Create a copy of FoldingRangeWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? refreshSupport = freezed,}) {
  return _then(_FoldingRangeWorkspaceClientCapabilities(
refreshSupport: freezed == refreshSupport ? _self.refreshSupport : refreshSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$TextDocumentSyncClientCapabilities {

 bool? get didSave; bool? get willSaveWaitUntil; bool? get willSave; bool? get dynamicRegistration;
/// Create a copy of TextDocumentSyncClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TextDocumentSyncClientCapabilitiesCopyWith<TextDocumentSyncClientCapabilities> get copyWith => _$TextDocumentSyncClientCapabilitiesCopyWithImpl<TextDocumentSyncClientCapabilities>(this as TextDocumentSyncClientCapabilities, _$identity);

  /// Serializes this TextDocumentSyncClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TextDocumentSyncClientCapabilities&&(identical(other.didSave, didSave) || other.didSave == didSave)&&(identical(other.willSaveWaitUntil, willSaveWaitUntil) || other.willSaveWaitUntil == willSaveWaitUntil)&&(identical(other.willSave, willSave) || other.willSave == willSave)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,didSave,willSaveWaitUntil,willSave,dynamicRegistration);

@override
String toString() {
  return 'TextDocumentSyncClientCapabilities(didSave: $didSave, willSaveWaitUntil: $willSaveWaitUntil, willSave: $willSave, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $TextDocumentSyncClientCapabilitiesCopyWith<$Res>  {
  factory $TextDocumentSyncClientCapabilitiesCopyWith(TextDocumentSyncClientCapabilities value, $Res Function(TextDocumentSyncClientCapabilities) _then) = _$TextDocumentSyncClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? didSave, bool? willSaveWaitUntil, bool? willSave, bool? dynamicRegistration
});




}
/// @nodoc
class _$TextDocumentSyncClientCapabilitiesCopyWithImpl<$Res>
    implements $TextDocumentSyncClientCapabilitiesCopyWith<$Res> {
  _$TextDocumentSyncClientCapabilitiesCopyWithImpl(this._self, this._then);

  final TextDocumentSyncClientCapabilities _self;
  final $Res Function(TextDocumentSyncClientCapabilities) _then;

/// Create a copy of TextDocumentSyncClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? didSave = freezed,Object? willSaveWaitUntil = freezed,Object? willSave = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
didSave: freezed == didSave ? _self.didSave : didSave // ignore: cast_nullable_to_non_nullable
as bool?,willSaveWaitUntil: freezed == willSaveWaitUntil ? _self.willSaveWaitUntil : willSaveWaitUntil // ignore: cast_nullable_to_non_nullable
as bool?,willSave: freezed == willSave ? _self.willSave : willSave // ignore: cast_nullable_to_non_nullable
as bool?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _TextDocumentSyncClientCapabilities implements TextDocumentSyncClientCapabilities {
  const _TextDocumentSyncClientCapabilities({this.didSave, this.willSaveWaitUntil, this.willSave, this.dynamicRegistration});
  factory _TextDocumentSyncClientCapabilities.fromJson(Map<String, dynamic> json) => _$TextDocumentSyncClientCapabilitiesFromJson(json);

@override final  bool? didSave;
@override final  bool? willSaveWaitUntil;
@override final  bool? willSave;
@override final  bool? dynamicRegistration;

/// Create a copy of TextDocumentSyncClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TextDocumentSyncClientCapabilitiesCopyWith<_TextDocumentSyncClientCapabilities> get copyWith => __$TextDocumentSyncClientCapabilitiesCopyWithImpl<_TextDocumentSyncClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TextDocumentSyncClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TextDocumentSyncClientCapabilities&&(identical(other.didSave, didSave) || other.didSave == didSave)&&(identical(other.willSaveWaitUntil, willSaveWaitUntil) || other.willSaveWaitUntil == willSaveWaitUntil)&&(identical(other.willSave, willSave) || other.willSave == willSave)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,didSave,willSaveWaitUntil,willSave,dynamicRegistration);

@override
String toString() {
  return 'TextDocumentSyncClientCapabilities(didSave: $didSave, willSaveWaitUntil: $willSaveWaitUntil, willSave: $willSave, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$TextDocumentSyncClientCapabilitiesCopyWith<$Res> implements $TextDocumentSyncClientCapabilitiesCopyWith<$Res> {
  factory _$TextDocumentSyncClientCapabilitiesCopyWith(_TextDocumentSyncClientCapabilities value, $Res Function(_TextDocumentSyncClientCapabilities) _then) = __$TextDocumentSyncClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? didSave, bool? willSaveWaitUntil, bool? willSave, bool? dynamicRegistration
});




}
/// @nodoc
class __$TextDocumentSyncClientCapabilitiesCopyWithImpl<$Res>
    implements _$TextDocumentSyncClientCapabilitiesCopyWith<$Res> {
  __$TextDocumentSyncClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _TextDocumentSyncClientCapabilities _self;
  final $Res Function(_TextDocumentSyncClientCapabilities) _then;

/// Create a copy of TextDocumentSyncClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? didSave = freezed,Object? willSaveWaitUntil = freezed,Object? willSave = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_TextDocumentSyncClientCapabilities(
didSave: freezed == didSave ? _self.didSave : didSave // ignore: cast_nullable_to_non_nullable
as bool?,willSaveWaitUntil: freezed == willSaveWaitUntil ? _self.willSaveWaitUntil : willSaveWaitUntil // ignore: cast_nullable_to_non_nullable
as bool?,willSave: freezed == willSave ? _self.willSave : willSave // ignore: cast_nullable_to_non_nullable
as bool?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$CompletionClientCapabilities {

 ({List<String>? itemDefaults})? get completionList; bool? get contextSupport; InsertTextMode? get insertTextMode; ({List<CompletionItemKind>? valueSet})? get completionItemKind; ({bool? snippetSupport, bool? commitCharactersSupport, List<MarkupKind>? documentationFormat, bool? deprecatedSupport, bool? preselectSupport, ({List<CompletionItemTag> valueSet})? tagSupport, bool? insertReplaceSupport, ({List<String> properties})? resolveSupport, ({List<InsertTextMode> valueSet})? insertTextModeSupport, bool? labelDetailsSupport})? get completionItem; bool? get dynamicRegistration;
/// Create a copy of CompletionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CompletionClientCapabilitiesCopyWith<CompletionClientCapabilities> get copyWith => _$CompletionClientCapabilitiesCopyWithImpl<CompletionClientCapabilities>(this as CompletionClientCapabilities, _$identity);

  /// Serializes this CompletionClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CompletionClientCapabilities&&(identical(other.completionList, completionList) || other.completionList == completionList)&&(identical(other.contextSupport, contextSupport) || other.contextSupport == contextSupport)&&(identical(other.insertTextMode, insertTextMode) || other.insertTextMode == insertTextMode)&&(identical(other.completionItemKind, completionItemKind) || other.completionItemKind == completionItemKind)&&(identical(other.completionItem, completionItem) || other.completionItem == completionItem)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,completionList,contextSupport,insertTextMode,completionItemKind,completionItem,dynamicRegistration);

@override
String toString() {
  return 'CompletionClientCapabilities(completionList: $completionList, contextSupport: $contextSupport, insertTextMode: $insertTextMode, completionItemKind: $completionItemKind, completionItem: $completionItem, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $CompletionClientCapabilitiesCopyWith<$Res>  {
  factory $CompletionClientCapabilitiesCopyWith(CompletionClientCapabilities value, $Res Function(CompletionClientCapabilities) _then) = _$CompletionClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 ({List<String>? itemDefaults})? completionList, bool? contextSupport, InsertTextMode? insertTextMode, ({List<CompletionItemKind>? valueSet})? completionItemKind, ({bool? snippetSupport, bool? commitCharactersSupport, List<MarkupKind>? documentationFormat, bool? deprecatedSupport, bool? preselectSupport, ({List<CompletionItemTag> valueSet})? tagSupport, bool? insertReplaceSupport, ({List<String> properties})? resolveSupport, ({List<InsertTextMode> valueSet})? insertTextModeSupport, bool? labelDetailsSupport})? completionItem, bool? dynamicRegistration
});




}
/// @nodoc
class _$CompletionClientCapabilitiesCopyWithImpl<$Res>
    implements $CompletionClientCapabilitiesCopyWith<$Res> {
  _$CompletionClientCapabilitiesCopyWithImpl(this._self, this._then);

  final CompletionClientCapabilities _self;
  final $Res Function(CompletionClientCapabilities) _then;

/// Create a copy of CompletionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? completionList = freezed,Object? contextSupport = freezed,Object? insertTextMode = freezed,Object? completionItemKind = freezed,Object? completionItem = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
completionList: freezed == completionList ? _self.completionList : completionList // ignore: cast_nullable_to_non_nullable
as ({List<String>? itemDefaults})?,contextSupport: freezed == contextSupport ? _self.contextSupport : contextSupport // ignore: cast_nullable_to_non_nullable
as bool?,insertTextMode: freezed == insertTextMode ? _self.insertTextMode : insertTextMode // ignore: cast_nullable_to_non_nullable
as InsertTextMode?,completionItemKind: freezed == completionItemKind ? _self.completionItemKind : completionItemKind // ignore: cast_nullable_to_non_nullable
as ({List<CompletionItemKind>? valueSet})?,completionItem: freezed == completionItem ? _self.completionItem : completionItem // ignore: cast_nullable_to_non_nullable
as ({bool? snippetSupport, bool? commitCharactersSupport, List<MarkupKind>? documentationFormat, bool? deprecatedSupport, bool? preselectSupport, ({List<CompletionItemTag> valueSet})? tagSupport, bool? insertReplaceSupport, ({List<String> properties})? resolveSupport, ({List<InsertTextMode> valueSet})? insertTextModeSupport, bool? labelDetailsSupport})?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _CompletionClientCapabilities implements CompletionClientCapabilities {
  const _CompletionClientCapabilities({this.completionList, this.contextSupport, this.insertTextMode, this.completionItemKind, this.completionItem, this.dynamicRegistration});
  factory _CompletionClientCapabilities.fromJson(Map<String, dynamic> json) => _$CompletionClientCapabilitiesFromJson(json);

@override final  ({List<String>? itemDefaults})? completionList;
@override final  bool? contextSupport;
@override final  InsertTextMode? insertTextMode;
@override final  ({List<CompletionItemKind>? valueSet})? completionItemKind;
@override final  ({bool? snippetSupport, bool? commitCharactersSupport, List<MarkupKind>? documentationFormat, bool? deprecatedSupport, bool? preselectSupport, ({List<CompletionItemTag> valueSet})? tagSupport, bool? insertReplaceSupport, ({List<String> properties})? resolveSupport, ({List<InsertTextMode> valueSet})? insertTextModeSupport, bool? labelDetailsSupport})? completionItem;
@override final  bool? dynamicRegistration;

/// Create a copy of CompletionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CompletionClientCapabilitiesCopyWith<_CompletionClientCapabilities> get copyWith => __$CompletionClientCapabilitiesCopyWithImpl<_CompletionClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CompletionClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CompletionClientCapabilities&&(identical(other.completionList, completionList) || other.completionList == completionList)&&(identical(other.contextSupport, contextSupport) || other.contextSupport == contextSupport)&&(identical(other.insertTextMode, insertTextMode) || other.insertTextMode == insertTextMode)&&(identical(other.completionItemKind, completionItemKind) || other.completionItemKind == completionItemKind)&&(identical(other.completionItem, completionItem) || other.completionItem == completionItem)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,completionList,contextSupport,insertTextMode,completionItemKind,completionItem,dynamicRegistration);

@override
String toString() {
  return 'CompletionClientCapabilities(completionList: $completionList, contextSupport: $contextSupport, insertTextMode: $insertTextMode, completionItemKind: $completionItemKind, completionItem: $completionItem, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$CompletionClientCapabilitiesCopyWith<$Res> implements $CompletionClientCapabilitiesCopyWith<$Res> {
  factory _$CompletionClientCapabilitiesCopyWith(_CompletionClientCapabilities value, $Res Function(_CompletionClientCapabilities) _then) = __$CompletionClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 ({List<String>? itemDefaults})? completionList, bool? contextSupport, InsertTextMode? insertTextMode, ({List<CompletionItemKind>? valueSet})? completionItemKind, ({bool? snippetSupport, bool? commitCharactersSupport, List<MarkupKind>? documentationFormat, bool? deprecatedSupport, bool? preselectSupport, ({List<CompletionItemTag> valueSet})? tagSupport, bool? insertReplaceSupport, ({List<String> properties})? resolveSupport, ({List<InsertTextMode> valueSet})? insertTextModeSupport, bool? labelDetailsSupport})? completionItem, bool? dynamicRegistration
});




}
/// @nodoc
class __$CompletionClientCapabilitiesCopyWithImpl<$Res>
    implements _$CompletionClientCapabilitiesCopyWith<$Res> {
  __$CompletionClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _CompletionClientCapabilities _self;
  final $Res Function(_CompletionClientCapabilities) _then;

/// Create a copy of CompletionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? completionList = freezed,Object? contextSupport = freezed,Object? insertTextMode = freezed,Object? completionItemKind = freezed,Object? completionItem = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_CompletionClientCapabilities(
completionList: freezed == completionList ? _self.completionList : completionList // ignore: cast_nullable_to_non_nullable
as ({List<String>? itemDefaults})?,contextSupport: freezed == contextSupport ? _self.contextSupport : contextSupport // ignore: cast_nullable_to_non_nullable
as bool?,insertTextMode: freezed == insertTextMode ? _self.insertTextMode : insertTextMode // ignore: cast_nullable_to_non_nullable
as InsertTextMode?,completionItemKind: freezed == completionItemKind ? _self.completionItemKind : completionItemKind // ignore: cast_nullable_to_non_nullable
as ({List<CompletionItemKind>? valueSet})?,completionItem: freezed == completionItem ? _self.completionItem : completionItem // ignore: cast_nullable_to_non_nullable
as ({bool? snippetSupport, bool? commitCharactersSupport, List<MarkupKind>? documentationFormat, bool? deprecatedSupport, bool? preselectSupport, ({List<CompletionItemTag> valueSet})? tagSupport, bool? insertReplaceSupport, ({List<String> properties})? resolveSupport, ({List<InsertTextMode> valueSet})? insertTextModeSupport, bool? labelDetailsSupport})?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$HoverClientCapabilities {

 List<MarkupKind>? get contentFormat; bool? get dynamicRegistration;
/// Create a copy of HoverClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$HoverClientCapabilitiesCopyWith<HoverClientCapabilities> get copyWith => _$HoverClientCapabilitiesCopyWithImpl<HoverClientCapabilities>(this as HoverClientCapabilities, _$identity);

  /// Serializes this HoverClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is HoverClientCapabilities&&const DeepCollectionEquality().equals(other.contentFormat, contentFormat)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(contentFormat),dynamicRegistration);

@override
String toString() {
  return 'HoverClientCapabilities(contentFormat: $contentFormat, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $HoverClientCapabilitiesCopyWith<$Res>  {
  factory $HoverClientCapabilitiesCopyWith(HoverClientCapabilities value, $Res Function(HoverClientCapabilities) _then) = _$HoverClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 List<MarkupKind>? contentFormat, bool? dynamicRegistration
});




}
/// @nodoc
class _$HoverClientCapabilitiesCopyWithImpl<$Res>
    implements $HoverClientCapabilitiesCopyWith<$Res> {
  _$HoverClientCapabilitiesCopyWithImpl(this._self, this._then);

  final HoverClientCapabilities _self;
  final $Res Function(HoverClientCapabilities) _then;

/// Create a copy of HoverClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? contentFormat = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
contentFormat: freezed == contentFormat ? _self.contentFormat : contentFormat // ignore: cast_nullable_to_non_nullable
as List<MarkupKind>?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _HoverClientCapabilities implements HoverClientCapabilities {
  const _HoverClientCapabilities({final  List<MarkupKind>? contentFormat, this.dynamicRegistration}): _contentFormat = contentFormat;
  factory _HoverClientCapabilities.fromJson(Map<String, dynamic> json) => _$HoverClientCapabilitiesFromJson(json);

 final  List<MarkupKind>? _contentFormat;
@override List<MarkupKind>? get contentFormat {
  final value = _contentFormat;
  if (value == null) return null;
  if (_contentFormat is EqualUnmodifiableListView) return _contentFormat;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

@override final  bool? dynamicRegistration;

/// Create a copy of HoverClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$HoverClientCapabilitiesCopyWith<_HoverClientCapabilities> get copyWith => __$HoverClientCapabilitiesCopyWithImpl<_HoverClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$HoverClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _HoverClientCapabilities&&const DeepCollectionEquality().equals(other._contentFormat, _contentFormat)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_contentFormat),dynamicRegistration);

@override
String toString() {
  return 'HoverClientCapabilities(contentFormat: $contentFormat, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$HoverClientCapabilitiesCopyWith<$Res> implements $HoverClientCapabilitiesCopyWith<$Res> {
  factory _$HoverClientCapabilitiesCopyWith(_HoverClientCapabilities value, $Res Function(_HoverClientCapabilities) _then) = __$HoverClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 List<MarkupKind>? contentFormat, bool? dynamicRegistration
});




}
/// @nodoc
class __$HoverClientCapabilitiesCopyWithImpl<$Res>
    implements _$HoverClientCapabilitiesCopyWith<$Res> {
  __$HoverClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _HoverClientCapabilities _self;
  final $Res Function(_HoverClientCapabilities) _then;

/// Create a copy of HoverClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? contentFormat = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_HoverClientCapabilities(
contentFormat: freezed == contentFormat ? _self._contentFormat : contentFormat // ignore: cast_nullable_to_non_nullable
as List<MarkupKind>?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$SignatureHelpClientCapabilities {

 bool? get contextSupport; ({List<MarkupKind>? documentationFormat, ({bool? labelOffsetSupport})? parameterInformation, bool? activeParameterSupport})? get signatureInformation; bool? get dynamicRegistration;
/// Create a copy of SignatureHelpClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SignatureHelpClientCapabilitiesCopyWith<SignatureHelpClientCapabilities> get copyWith => _$SignatureHelpClientCapabilitiesCopyWithImpl<SignatureHelpClientCapabilities>(this as SignatureHelpClientCapabilities, _$identity);

  /// Serializes this SignatureHelpClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SignatureHelpClientCapabilities&&(identical(other.contextSupport, contextSupport) || other.contextSupport == contextSupport)&&(identical(other.signatureInformation, signatureInformation) || other.signatureInformation == signatureInformation)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,contextSupport,signatureInformation,dynamicRegistration);

@override
String toString() {
  return 'SignatureHelpClientCapabilities(contextSupport: $contextSupport, signatureInformation: $signatureInformation, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $SignatureHelpClientCapabilitiesCopyWith<$Res>  {
  factory $SignatureHelpClientCapabilitiesCopyWith(SignatureHelpClientCapabilities value, $Res Function(SignatureHelpClientCapabilities) _then) = _$SignatureHelpClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? contextSupport, ({List<MarkupKind>? documentationFormat, ({bool? labelOffsetSupport})? parameterInformation, bool? activeParameterSupport})? signatureInformation, bool? dynamicRegistration
});




}
/// @nodoc
class _$SignatureHelpClientCapabilitiesCopyWithImpl<$Res>
    implements $SignatureHelpClientCapabilitiesCopyWith<$Res> {
  _$SignatureHelpClientCapabilitiesCopyWithImpl(this._self, this._then);

  final SignatureHelpClientCapabilities _self;
  final $Res Function(SignatureHelpClientCapabilities) _then;

/// Create a copy of SignatureHelpClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? contextSupport = freezed,Object? signatureInformation = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
contextSupport: freezed == contextSupport ? _self.contextSupport : contextSupport // ignore: cast_nullable_to_non_nullable
as bool?,signatureInformation: freezed == signatureInformation ? _self.signatureInformation : signatureInformation // ignore: cast_nullable_to_non_nullable
as ({List<MarkupKind>? documentationFormat, ({bool? labelOffsetSupport})? parameterInformation, bool? activeParameterSupport})?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _SignatureHelpClientCapabilities implements SignatureHelpClientCapabilities {
  const _SignatureHelpClientCapabilities({this.contextSupport, this.signatureInformation, this.dynamicRegistration});
  factory _SignatureHelpClientCapabilities.fromJson(Map<String, dynamic> json) => _$SignatureHelpClientCapabilitiesFromJson(json);

@override final  bool? contextSupport;
@override final  ({List<MarkupKind>? documentationFormat, ({bool? labelOffsetSupport})? parameterInformation, bool? activeParameterSupport})? signatureInformation;
@override final  bool? dynamicRegistration;

/// Create a copy of SignatureHelpClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SignatureHelpClientCapabilitiesCopyWith<_SignatureHelpClientCapabilities> get copyWith => __$SignatureHelpClientCapabilitiesCopyWithImpl<_SignatureHelpClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SignatureHelpClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SignatureHelpClientCapabilities&&(identical(other.contextSupport, contextSupport) || other.contextSupport == contextSupport)&&(identical(other.signatureInformation, signatureInformation) || other.signatureInformation == signatureInformation)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,contextSupport,signatureInformation,dynamicRegistration);

@override
String toString() {
  return 'SignatureHelpClientCapabilities(contextSupport: $contextSupport, signatureInformation: $signatureInformation, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$SignatureHelpClientCapabilitiesCopyWith<$Res> implements $SignatureHelpClientCapabilitiesCopyWith<$Res> {
  factory _$SignatureHelpClientCapabilitiesCopyWith(_SignatureHelpClientCapabilities value, $Res Function(_SignatureHelpClientCapabilities) _then) = __$SignatureHelpClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? contextSupport, ({List<MarkupKind>? documentationFormat, ({bool? labelOffsetSupport})? parameterInformation, bool? activeParameterSupport})? signatureInformation, bool? dynamicRegistration
});




}
/// @nodoc
class __$SignatureHelpClientCapabilitiesCopyWithImpl<$Res>
    implements _$SignatureHelpClientCapabilitiesCopyWith<$Res> {
  __$SignatureHelpClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _SignatureHelpClientCapabilities _self;
  final $Res Function(_SignatureHelpClientCapabilities) _then;

/// Create a copy of SignatureHelpClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? contextSupport = freezed,Object? signatureInformation = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_SignatureHelpClientCapabilities(
contextSupport: freezed == contextSupport ? _self.contextSupport : contextSupport // ignore: cast_nullable_to_non_nullable
as bool?,signatureInformation: freezed == signatureInformation ? _self.signatureInformation : signatureInformation // ignore: cast_nullable_to_non_nullable
as ({List<MarkupKind>? documentationFormat, ({bool? labelOffsetSupport})? parameterInformation, bool? activeParameterSupport})?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DeclarationClientCapabilities {

 bool? get linkSupport; bool? get dynamicRegistration;
/// Create a copy of DeclarationClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DeclarationClientCapabilitiesCopyWith<DeclarationClientCapabilities> get copyWith => _$DeclarationClientCapabilitiesCopyWithImpl<DeclarationClientCapabilities>(this as DeclarationClientCapabilities, _$identity);

  /// Serializes this DeclarationClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DeclarationClientCapabilities&&(identical(other.linkSupport, linkSupport) || other.linkSupport == linkSupport)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,linkSupport,dynamicRegistration);

@override
String toString() {
  return 'DeclarationClientCapabilities(linkSupport: $linkSupport, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $DeclarationClientCapabilitiesCopyWith<$Res>  {
  factory $DeclarationClientCapabilitiesCopyWith(DeclarationClientCapabilities value, $Res Function(DeclarationClientCapabilities) _then) = _$DeclarationClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? linkSupport, bool? dynamicRegistration
});




}
/// @nodoc
class _$DeclarationClientCapabilitiesCopyWithImpl<$Res>
    implements $DeclarationClientCapabilitiesCopyWith<$Res> {
  _$DeclarationClientCapabilitiesCopyWithImpl(this._self, this._then);

  final DeclarationClientCapabilities _self;
  final $Res Function(DeclarationClientCapabilities) _then;

/// Create a copy of DeclarationClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? linkSupport = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
linkSupport: freezed == linkSupport ? _self.linkSupport : linkSupport // ignore: cast_nullable_to_non_nullable
as bool?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DeclarationClientCapabilities implements DeclarationClientCapabilities {
  const _DeclarationClientCapabilities({this.linkSupport, this.dynamicRegistration});
  factory _DeclarationClientCapabilities.fromJson(Map<String, dynamic> json) => _$DeclarationClientCapabilitiesFromJson(json);

@override final  bool? linkSupport;
@override final  bool? dynamicRegistration;

/// Create a copy of DeclarationClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DeclarationClientCapabilitiesCopyWith<_DeclarationClientCapabilities> get copyWith => __$DeclarationClientCapabilitiesCopyWithImpl<_DeclarationClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DeclarationClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DeclarationClientCapabilities&&(identical(other.linkSupport, linkSupport) || other.linkSupport == linkSupport)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,linkSupport,dynamicRegistration);

@override
String toString() {
  return 'DeclarationClientCapabilities(linkSupport: $linkSupport, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$DeclarationClientCapabilitiesCopyWith<$Res> implements $DeclarationClientCapabilitiesCopyWith<$Res> {
  factory _$DeclarationClientCapabilitiesCopyWith(_DeclarationClientCapabilities value, $Res Function(_DeclarationClientCapabilities) _then) = __$DeclarationClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? linkSupport, bool? dynamicRegistration
});




}
/// @nodoc
class __$DeclarationClientCapabilitiesCopyWithImpl<$Res>
    implements _$DeclarationClientCapabilitiesCopyWith<$Res> {
  __$DeclarationClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _DeclarationClientCapabilities _self;
  final $Res Function(_DeclarationClientCapabilities) _then;

/// Create a copy of DeclarationClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? linkSupport = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_DeclarationClientCapabilities(
linkSupport: freezed == linkSupport ? _self.linkSupport : linkSupport // ignore: cast_nullable_to_non_nullable
as bool?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DefinitionClientCapabilities {

 bool? get linkSupport; bool? get dynamicRegistration;
/// Create a copy of DefinitionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DefinitionClientCapabilitiesCopyWith<DefinitionClientCapabilities> get copyWith => _$DefinitionClientCapabilitiesCopyWithImpl<DefinitionClientCapabilities>(this as DefinitionClientCapabilities, _$identity);

  /// Serializes this DefinitionClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DefinitionClientCapabilities&&(identical(other.linkSupport, linkSupport) || other.linkSupport == linkSupport)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,linkSupport,dynamicRegistration);

@override
String toString() {
  return 'DefinitionClientCapabilities(linkSupport: $linkSupport, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $DefinitionClientCapabilitiesCopyWith<$Res>  {
  factory $DefinitionClientCapabilitiesCopyWith(DefinitionClientCapabilities value, $Res Function(DefinitionClientCapabilities) _then) = _$DefinitionClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? linkSupport, bool? dynamicRegistration
});




}
/// @nodoc
class _$DefinitionClientCapabilitiesCopyWithImpl<$Res>
    implements $DefinitionClientCapabilitiesCopyWith<$Res> {
  _$DefinitionClientCapabilitiesCopyWithImpl(this._self, this._then);

  final DefinitionClientCapabilities _self;
  final $Res Function(DefinitionClientCapabilities) _then;

/// Create a copy of DefinitionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? linkSupport = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
linkSupport: freezed == linkSupport ? _self.linkSupport : linkSupport // ignore: cast_nullable_to_non_nullable
as bool?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DefinitionClientCapabilities implements DefinitionClientCapabilities {
  const _DefinitionClientCapabilities({this.linkSupport, this.dynamicRegistration});
  factory _DefinitionClientCapabilities.fromJson(Map<String, dynamic> json) => _$DefinitionClientCapabilitiesFromJson(json);

@override final  bool? linkSupport;
@override final  bool? dynamicRegistration;

/// Create a copy of DefinitionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DefinitionClientCapabilitiesCopyWith<_DefinitionClientCapabilities> get copyWith => __$DefinitionClientCapabilitiesCopyWithImpl<_DefinitionClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DefinitionClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DefinitionClientCapabilities&&(identical(other.linkSupport, linkSupport) || other.linkSupport == linkSupport)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,linkSupport,dynamicRegistration);

@override
String toString() {
  return 'DefinitionClientCapabilities(linkSupport: $linkSupport, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$DefinitionClientCapabilitiesCopyWith<$Res> implements $DefinitionClientCapabilitiesCopyWith<$Res> {
  factory _$DefinitionClientCapabilitiesCopyWith(_DefinitionClientCapabilities value, $Res Function(_DefinitionClientCapabilities) _then) = __$DefinitionClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? linkSupport, bool? dynamicRegistration
});




}
/// @nodoc
class __$DefinitionClientCapabilitiesCopyWithImpl<$Res>
    implements _$DefinitionClientCapabilitiesCopyWith<$Res> {
  __$DefinitionClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _DefinitionClientCapabilities _self;
  final $Res Function(_DefinitionClientCapabilities) _then;

/// Create a copy of DefinitionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? linkSupport = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_DefinitionClientCapabilities(
linkSupport: freezed == linkSupport ? _self.linkSupport : linkSupport // ignore: cast_nullable_to_non_nullable
as bool?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$TypeDefinitionClientCapabilities {

 bool? get linkSupport; bool? get dynamicRegistration;
/// Create a copy of TypeDefinitionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TypeDefinitionClientCapabilitiesCopyWith<TypeDefinitionClientCapabilities> get copyWith => _$TypeDefinitionClientCapabilitiesCopyWithImpl<TypeDefinitionClientCapabilities>(this as TypeDefinitionClientCapabilities, _$identity);

  /// Serializes this TypeDefinitionClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TypeDefinitionClientCapabilities&&(identical(other.linkSupport, linkSupport) || other.linkSupport == linkSupport)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,linkSupport,dynamicRegistration);

@override
String toString() {
  return 'TypeDefinitionClientCapabilities(linkSupport: $linkSupport, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $TypeDefinitionClientCapabilitiesCopyWith<$Res>  {
  factory $TypeDefinitionClientCapabilitiesCopyWith(TypeDefinitionClientCapabilities value, $Res Function(TypeDefinitionClientCapabilities) _then) = _$TypeDefinitionClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? linkSupport, bool? dynamicRegistration
});




}
/// @nodoc
class _$TypeDefinitionClientCapabilitiesCopyWithImpl<$Res>
    implements $TypeDefinitionClientCapabilitiesCopyWith<$Res> {
  _$TypeDefinitionClientCapabilitiesCopyWithImpl(this._self, this._then);

  final TypeDefinitionClientCapabilities _self;
  final $Res Function(TypeDefinitionClientCapabilities) _then;

/// Create a copy of TypeDefinitionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? linkSupport = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
linkSupport: freezed == linkSupport ? _self.linkSupport : linkSupport // ignore: cast_nullable_to_non_nullable
as bool?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _TypeDefinitionClientCapabilities implements TypeDefinitionClientCapabilities {
  const _TypeDefinitionClientCapabilities({this.linkSupport, this.dynamicRegistration});
  factory _TypeDefinitionClientCapabilities.fromJson(Map<String, dynamic> json) => _$TypeDefinitionClientCapabilitiesFromJson(json);

@override final  bool? linkSupport;
@override final  bool? dynamicRegistration;

/// Create a copy of TypeDefinitionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TypeDefinitionClientCapabilitiesCopyWith<_TypeDefinitionClientCapabilities> get copyWith => __$TypeDefinitionClientCapabilitiesCopyWithImpl<_TypeDefinitionClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TypeDefinitionClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TypeDefinitionClientCapabilities&&(identical(other.linkSupport, linkSupport) || other.linkSupport == linkSupport)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,linkSupport,dynamicRegistration);

@override
String toString() {
  return 'TypeDefinitionClientCapabilities(linkSupport: $linkSupport, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$TypeDefinitionClientCapabilitiesCopyWith<$Res> implements $TypeDefinitionClientCapabilitiesCopyWith<$Res> {
  factory _$TypeDefinitionClientCapabilitiesCopyWith(_TypeDefinitionClientCapabilities value, $Res Function(_TypeDefinitionClientCapabilities) _then) = __$TypeDefinitionClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? linkSupport, bool? dynamicRegistration
});




}
/// @nodoc
class __$TypeDefinitionClientCapabilitiesCopyWithImpl<$Res>
    implements _$TypeDefinitionClientCapabilitiesCopyWith<$Res> {
  __$TypeDefinitionClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _TypeDefinitionClientCapabilities _self;
  final $Res Function(_TypeDefinitionClientCapabilities) _then;

/// Create a copy of TypeDefinitionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? linkSupport = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_TypeDefinitionClientCapabilities(
linkSupport: freezed == linkSupport ? _self.linkSupport : linkSupport // ignore: cast_nullable_to_non_nullable
as bool?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$ImplementationClientCapabilities {

 bool? get linkSupport; bool? get dynamicRegistration;
/// Create a copy of ImplementationClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ImplementationClientCapabilitiesCopyWith<ImplementationClientCapabilities> get copyWith => _$ImplementationClientCapabilitiesCopyWithImpl<ImplementationClientCapabilities>(this as ImplementationClientCapabilities, _$identity);

  /// Serializes this ImplementationClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ImplementationClientCapabilities&&(identical(other.linkSupport, linkSupport) || other.linkSupport == linkSupport)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,linkSupport,dynamicRegistration);

@override
String toString() {
  return 'ImplementationClientCapabilities(linkSupport: $linkSupport, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $ImplementationClientCapabilitiesCopyWith<$Res>  {
  factory $ImplementationClientCapabilitiesCopyWith(ImplementationClientCapabilities value, $Res Function(ImplementationClientCapabilities) _then) = _$ImplementationClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? linkSupport, bool? dynamicRegistration
});




}
/// @nodoc
class _$ImplementationClientCapabilitiesCopyWithImpl<$Res>
    implements $ImplementationClientCapabilitiesCopyWith<$Res> {
  _$ImplementationClientCapabilitiesCopyWithImpl(this._self, this._then);

  final ImplementationClientCapabilities _self;
  final $Res Function(ImplementationClientCapabilities) _then;

/// Create a copy of ImplementationClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? linkSupport = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
linkSupport: freezed == linkSupport ? _self.linkSupport : linkSupport // ignore: cast_nullable_to_non_nullable
as bool?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _ImplementationClientCapabilities implements ImplementationClientCapabilities {
  const _ImplementationClientCapabilities({this.linkSupport, this.dynamicRegistration});
  factory _ImplementationClientCapabilities.fromJson(Map<String, dynamic> json) => _$ImplementationClientCapabilitiesFromJson(json);

@override final  bool? linkSupport;
@override final  bool? dynamicRegistration;

/// Create a copy of ImplementationClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ImplementationClientCapabilitiesCopyWith<_ImplementationClientCapabilities> get copyWith => __$ImplementationClientCapabilitiesCopyWithImpl<_ImplementationClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ImplementationClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ImplementationClientCapabilities&&(identical(other.linkSupport, linkSupport) || other.linkSupport == linkSupport)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,linkSupport,dynamicRegistration);

@override
String toString() {
  return 'ImplementationClientCapabilities(linkSupport: $linkSupport, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$ImplementationClientCapabilitiesCopyWith<$Res> implements $ImplementationClientCapabilitiesCopyWith<$Res> {
  factory _$ImplementationClientCapabilitiesCopyWith(_ImplementationClientCapabilities value, $Res Function(_ImplementationClientCapabilities) _then) = __$ImplementationClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? linkSupport, bool? dynamicRegistration
});




}
/// @nodoc
class __$ImplementationClientCapabilitiesCopyWithImpl<$Res>
    implements _$ImplementationClientCapabilitiesCopyWith<$Res> {
  __$ImplementationClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _ImplementationClientCapabilities _self;
  final $Res Function(_ImplementationClientCapabilities) _then;

/// Create a copy of ImplementationClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? linkSupport = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_ImplementationClientCapabilities(
linkSupport: freezed == linkSupport ? _self.linkSupport : linkSupport // ignore: cast_nullable_to_non_nullable
as bool?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$ReferenceClientCapabilities {

 bool? get dynamicRegistration;
/// Create a copy of ReferenceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ReferenceClientCapabilitiesCopyWith<ReferenceClientCapabilities> get copyWith => _$ReferenceClientCapabilitiesCopyWithImpl<ReferenceClientCapabilities>(this as ReferenceClientCapabilities, _$identity);

  /// Serializes this ReferenceClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ReferenceClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'ReferenceClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $ReferenceClientCapabilitiesCopyWith<$Res>  {
  factory $ReferenceClientCapabilitiesCopyWith(ReferenceClientCapabilities value, $Res Function(ReferenceClientCapabilities) _then) = _$ReferenceClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class _$ReferenceClientCapabilitiesCopyWithImpl<$Res>
    implements $ReferenceClientCapabilitiesCopyWith<$Res> {
  _$ReferenceClientCapabilitiesCopyWithImpl(this._self, this._then);

  final ReferenceClientCapabilities _self;
  final $Res Function(ReferenceClientCapabilities) _then;

/// Create a copy of ReferenceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _ReferenceClientCapabilities implements ReferenceClientCapabilities {
  const _ReferenceClientCapabilities({this.dynamicRegistration});
  factory _ReferenceClientCapabilities.fromJson(Map<String, dynamic> json) => _$ReferenceClientCapabilitiesFromJson(json);

@override final  bool? dynamicRegistration;

/// Create a copy of ReferenceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ReferenceClientCapabilitiesCopyWith<_ReferenceClientCapabilities> get copyWith => __$ReferenceClientCapabilitiesCopyWithImpl<_ReferenceClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ReferenceClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ReferenceClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'ReferenceClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$ReferenceClientCapabilitiesCopyWith<$Res> implements $ReferenceClientCapabilitiesCopyWith<$Res> {
  factory _$ReferenceClientCapabilitiesCopyWith(_ReferenceClientCapabilities value, $Res Function(_ReferenceClientCapabilities) _then) = __$ReferenceClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class __$ReferenceClientCapabilitiesCopyWithImpl<$Res>
    implements _$ReferenceClientCapabilitiesCopyWith<$Res> {
  __$ReferenceClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _ReferenceClientCapabilities _self;
  final $Res Function(_ReferenceClientCapabilities) _then;

/// Create a copy of ReferenceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_ReferenceClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DocumentHighlightClientCapabilities {

 bool? get dynamicRegistration;
/// Create a copy of DocumentHighlightClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentHighlightClientCapabilitiesCopyWith<DocumentHighlightClientCapabilities> get copyWith => _$DocumentHighlightClientCapabilitiesCopyWithImpl<DocumentHighlightClientCapabilities>(this as DocumentHighlightClientCapabilities, _$identity);

  /// Serializes this DocumentHighlightClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentHighlightClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'DocumentHighlightClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $DocumentHighlightClientCapabilitiesCopyWith<$Res>  {
  factory $DocumentHighlightClientCapabilitiesCopyWith(DocumentHighlightClientCapabilities value, $Res Function(DocumentHighlightClientCapabilities) _then) = _$DocumentHighlightClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class _$DocumentHighlightClientCapabilitiesCopyWithImpl<$Res>
    implements $DocumentHighlightClientCapabilitiesCopyWith<$Res> {
  _$DocumentHighlightClientCapabilitiesCopyWithImpl(this._self, this._then);

  final DocumentHighlightClientCapabilities _self;
  final $Res Function(DocumentHighlightClientCapabilities) _then;

/// Create a copy of DocumentHighlightClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DocumentHighlightClientCapabilities implements DocumentHighlightClientCapabilities {
  const _DocumentHighlightClientCapabilities({this.dynamicRegistration});
  factory _DocumentHighlightClientCapabilities.fromJson(Map<String, dynamic> json) => _$DocumentHighlightClientCapabilitiesFromJson(json);

@override final  bool? dynamicRegistration;

/// Create a copy of DocumentHighlightClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentHighlightClientCapabilitiesCopyWith<_DocumentHighlightClientCapabilities> get copyWith => __$DocumentHighlightClientCapabilitiesCopyWithImpl<_DocumentHighlightClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentHighlightClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentHighlightClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'DocumentHighlightClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$DocumentHighlightClientCapabilitiesCopyWith<$Res> implements $DocumentHighlightClientCapabilitiesCopyWith<$Res> {
  factory _$DocumentHighlightClientCapabilitiesCopyWith(_DocumentHighlightClientCapabilities value, $Res Function(_DocumentHighlightClientCapabilities) _then) = __$DocumentHighlightClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class __$DocumentHighlightClientCapabilitiesCopyWithImpl<$Res>
    implements _$DocumentHighlightClientCapabilitiesCopyWith<$Res> {
  __$DocumentHighlightClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _DocumentHighlightClientCapabilities _self;
  final $Res Function(_DocumentHighlightClientCapabilities) _then;

/// Create a copy of DocumentHighlightClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_DocumentHighlightClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DocumentSymbolClientCapabilities {

 bool? get labelSupport; ({List<SymbolTag> valueSet})? get tagSupport; bool? get hierarchicalDocumentSymbolSupport; ({List<SymbolKind>? valueSet})? get symbolKind; bool? get dynamicRegistration;
/// Create a copy of DocumentSymbolClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentSymbolClientCapabilitiesCopyWith<DocumentSymbolClientCapabilities> get copyWith => _$DocumentSymbolClientCapabilitiesCopyWithImpl<DocumentSymbolClientCapabilities>(this as DocumentSymbolClientCapabilities, _$identity);

  /// Serializes this DocumentSymbolClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentSymbolClientCapabilities&&(identical(other.labelSupport, labelSupport) || other.labelSupport == labelSupport)&&(identical(other.tagSupport, tagSupport) || other.tagSupport == tagSupport)&&(identical(other.hierarchicalDocumentSymbolSupport, hierarchicalDocumentSymbolSupport) || other.hierarchicalDocumentSymbolSupport == hierarchicalDocumentSymbolSupport)&&(identical(other.symbolKind, symbolKind) || other.symbolKind == symbolKind)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,labelSupport,tagSupport,hierarchicalDocumentSymbolSupport,symbolKind,dynamicRegistration);

@override
String toString() {
  return 'DocumentSymbolClientCapabilities(labelSupport: $labelSupport, tagSupport: $tagSupport, hierarchicalDocumentSymbolSupport: $hierarchicalDocumentSymbolSupport, symbolKind: $symbolKind, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $DocumentSymbolClientCapabilitiesCopyWith<$Res>  {
  factory $DocumentSymbolClientCapabilitiesCopyWith(DocumentSymbolClientCapabilities value, $Res Function(DocumentSymbolClientCapabilities) _then) = _$DocumentSymbolClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? labelSupport, ({List<SymbolTag> valueSet})? tagSupport, bool? hierarchicalDocumentSymbolSupport, ({List<SymbolKind>? valueSet})? symbolKind, bool? dynamicRegistration
});




}
/// @nodoc
class _$DocumentSymbolClientCapabilitiesCopyWithImpl<$Res>
    implements $DocumentSymbolClientCapabilitiesCopyWith<$Res> {
  _$DocumentSymbolClientCapabilitiesCopyWithImpl(this._self, this._then);

  final DocumentSymbolClientCapabilities _self;
  final $Res Function(DocumentSymbolClientCapabilities) _then;

/// Create a copy of DocumentSymbolClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? labelSupport = freezed,Object? tagSupport = freezed,Object? hierarchicalDocumentSymbolSupport = freezed,Object? symbolKind = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
labelSupport: freezed == labelSupport ? _self.labelSupport : labelSupport // ignore: cast_nullable_to_non_nullable
as bool?,tagSupport: freezed == tagSupport ? _self.tagSupport : tagSupport // ignore: cast_nullable_to_non_nullable
as ({List<SymbolTag> valueSet})?,hierarchicalDocumentSymbolSupport: freezed == hierarchicalDocumentSymbolSupport ? _self.hierarchicalDocumentSymbolSupport : hierarchicalDocumentSymbolSupport // ignore: cast_nullable_to_non_nullable
as bool?,symbolKind: freezed == symbolKind ? _self.symbolKind : symbolKind // ignore: cast_nullable_to_non_nullable
as ({List<SymbolKind>? valueSet})?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DocumentSymbolClientCapabilities implements DocumentSymbolClientCapabilities {
  const _DocumentSymbolClientCapabilities({this.labelSupport, this.tagSupport, this.hierarchicalDocumentSymbolSupport, this.symbolKind, this.dynamicRegistration});
  factory _DocumentSymbolClientCapabilities.fromJson(Map<String, dynamic> json) => _$DocumentSymbolClientCapabilitiesFromJson(json);

@override final  bool? labelSupport;
@override final  ({List<SymbolTag> valueSet})? tagSupport;
@override final  bool? hierarchicalDocumentSymbolSupport;
@override final  ({List<SymbolKind>? valueSet})? symbolKind;
@override final  bool? dynamicRegistration;

/// Create a copy of DocumentSymbolClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentSymbolClientCapabilitiesCopyWith<_DocumentSymbolClientCapabilities> get copyWith => __$DocumentSymbolClientCapabilitiesCopyWithImpl<_DocumentSymbolClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentSymbolClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentSymbolClientCapabilities&&(identical(other.labelSupport, labelSupport) || other.labelSupport == labelSupport)&&(identical(other.tagSupport, tagSupport) || other.tagSupport == tagSupport)&&(identical(other.hierarchicalDocumentSymbolSupport, hierarchicalDocumentSymbolSupport) || other.hierarchicalDocumentSymbolSupport == hierarchicalDocumentSymbolSupport)&&(identical(other.symbolKind, symbolKind) || other.symbolKind == symbolKind)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,labelSupport,tagSupport,hierarchicalDocumentSymbolSupport,symbolKind,dynamicRegistration);

@override
String toString() {
  return 'DocumentSymbolClientCapabilities(labelSupport: $labelSupport, tagSupport: $tagSupport, hierarchicalDocumentSymbolSupport: $hierarchicalDocumentSymbolSupport, symbolKind: $symbolKind, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$DocumentSymbolClientCapabilitiesCopyWith<$Res> implements $DocumentSymbolClientCapabilitiesCopyWith<$Res> {
  factory _$DocumentSymbolClientCapabilitiesCopyWith(_DocumentSymbolClientCapabilities value, $Res Function(_DocumentSymbolClientCapabilities) _then) = __$DocumentSymbolClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? labelSupport, ({List<SymbolTag> valueSet})? tagSupport, bool? hierarchicalDocumentSymbolSupport, ({List<SymbolKind>? valueSet})? symbolKind, bool? dynamicRegistration
});




}
/// @nodoc
class __$DocumentSymbolClientCapabilitiesCopyWithImpl<$Res>
    implements _$DocumentSymbolClientCapabilitiesCopyWith<$Res> {
  __$DocumentSymbolClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _DocumentSymbolClientCapabilities _self;
  final $Res Function(_DocumentSymbolClientCapabilities) _then;

/// Create a copy of DocumentSymbolClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? labelSupport = freezed,Object? tagSupport = freezed,Object? hierarchicalDocumentSymbolSupport = freezed,Object? symbolKind = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_DocumentSymbolClientCapabilities(
labelSupport: freezed == labelSupport ? _self.labelSupport : labelSupport // ignore: cast_nullable_to_non_nullable
as bool?,tagSupport: freezed == tagSupport ? _self.tagSupport : tagSupport // ignore: cast_nullable_to_non_nullable
as ({List<SymbolTag> valueSet})?,hierarchicalDocumentSymbolSupport: freezed == hierarchicalDocumentSymbolSupport ? _self.hierarchicalDocumentSymbolSupport : hierarchicalDocumentSymbolSupport // ignore: cast_nullable_to_non_nullable
as bool?,symbolKind: freezed == symbolKind ? _self.symbolKind : symbolKind // ignore: cast_nullable_to_non_nullable
as ({List<SymbolKind>? valueSet})?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$CodeActionClientCapabilities {

 bool? get honorsChangeAnnotations; ({List<String> properties})? get resolveSupport; bool? get dataSupport; bool? get disabledSupport; bool? get isPreferredSupport; ({({List<CodeActionKind> valueSet}) codeActionKind})? get codeActionLiteralSupport; bool? get dynamicRegistration;
/// Create a copy of CodeActionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CodeActionClientCapabilitiesCopyWith<CodeActionClientCapabilities> get copyWith => _$CodeActionClientCapabilitiesCopyWithImpl<CodeActionClientCapabilities>(this as CodeActionClientCapabilities, _$identity);

  /// Serializes this CodeActionClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CodeActionClientCapabilities&&(identical(other.honorsChangeAnnotations, honorsChangeAnnotations) || other.honorsChangeAnnotations == honorsChangeAnnotations)&&(identical(other.resolveSupport, resolveSupport) || other.resolveSupport == resolveSupport)&&(identical(other.dataSupport, dataSupport) || other.dataSupport == dataSupport)&&(identical(other.disabledSupport, disabledSupport) || other.disabledSupport == disabledSupport)&&(identical(other.isPreferredSupport, isPreferredSupport) || other.isPreferredSupport == isPreferredSupport)&&(identical(other.codeActionLiteralSupport, codeActionLiteralSupport) || other.codeActionLiteralSupport == codeActionLiteralSupport)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,honorsChangeAnnotations,resolveSupport,dataSupport,disabledSupport,isPreferredSupport,codeActionLiteralSupport,dynamicRegistration);

@override
String toString() {
  return 'CodeActionClientCapabilities(honorsChangeAnnotations: $honorsChangeAnnotations, resolveSupport: $resolveSupport, dataSupport: $dataSupport, disabledSupport: $disabledSupport, isPreferredSupport: $isPreferredSupport, codeActionLiteralSupport: $codeActionLiteralSupport, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $CodeActionClientCapabilitiesCopyWith<$Res>  {
  factory $CodeActionClientCapabilitiesCopyWith(CodeActionClientCapabilities value, $Res Function(CodeActionClientCapabilities) _then) = _$CodeActionClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? honorsChangeAnnotations, ({List<String> properties})? resolveSupport, bool? dataSupport, bool? disabledSupport, bool? isPreferredSupport, ({({List<CodeActionKind> valueSet}) codeActionKind})? codeActionLiteralSupport, bool? dynamicRegistration
});




}
/// @nodoc
class _$CodeActionClientCapabilitiesCopyWithImpl<$Res>
    implements $CodeActionClientCapabilitiesCopyWith<$Res> {
  _$CodeActionClientCapabilitiesCopyWithImpl(this._self, this._then);

  final CodeActionClientCapabilities _self;
  final $Res Function(CodeActionClientCapabilities) _then;

/// Create a copy of CodeActionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? honorsChangeAnnotations = freezed,Object? resolveSupport = freezed,Object? dataSupport = freezed,Object? disabledSupport = freezed,Object? isPreferredSupport = freezed,Object? codeActionLiteralSupport = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
honorsChangeAnnotations: freezed == honorsChangeAnnotations ? _self.honorsChangeAnnotations : honorsChangeAnnotations // ignore: cast_nullable_to_non_nullable
as bool?,resolveSupport: freezed == resolveSupport ? _self.resolveSupport : resolveSupport // ignore: cast_nullable_to_non_nullable
as ({List<String> properties})?,dataSupport: freezed == dataSupport ? _self.dataSupport : dataSupport // ignore: cast_nullable_to_non_nullable
as bool?,disabledSupport: freezed == disabledSupport ? _self.disabledSupport : disabledSupport // ignore: cast_nullable_to_non_nullable
as bool?,isPreferredSupport: freezed == isPreferredSupport ? _self.isPreferredSupport : isPreferredSupport // ignore: cast_nullable_to_non_nullable
as bool?,codeActionLiteralSupport: freezed == codeActionLiteralSupport ? _self.codeActionLiteralSupport : codeActionLiteralSupport // ignore: cast_nullable_to_non_nullable
as ({({List<CodeActionKind> valueSet}) codeActionKind})?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _CodeActionClientCapabilities implements CodeActionClientCapabilities {
  const _CodeActionClientCapabilities({this.honorsChangeAnnotations, this.resolveSupport, this.dataSupport, this.disabledSupport, this.isPreferredSupport, this.codeActionLiteralSupport, this.dynamicRegistration});
  factory _CodeActionClientCapabilities.fromJson(Map<String, dynamic> json) => _$CodeActionClientCapabilitiesFromJson(json);

@override final  bool? honorsChangeAnnotations;
@override final  ({List<String> properties})? resolveSupport;
@override final  bool? dataSupport;
@override final  bool? disabledSupport;
@override final  bool? isPreferredSupport;
@override final  ({({List<CodeActionKind> valueSet}) codeActionKind})? codeActionLiteralSupport;
@override final  bool? dynamicRegistration;

/// Create a copy of CodeActionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CodeActionClientCapabilitiesCopyWith<_CodeActionClientCapabilities> get copyWith => __$CodeActionClientCapabilitiesCopyWithImpl<_CodeActionClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CodeActionClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CodeActionClientCapabilities&&(identical(other.honorsChangeAnnotations, honorsChangeAnnotations) || other.honorsChangeAnnotations == honorsChangeAnnotations)&&(identical(other.resolveSupport, resolveSupport) || other.resolveSupport == resolveSupport)&&(identical(other.dataSupport, dataSupport) || other.dataSupport == dataSupport)&&(identical(other.disabledSupport, disabledSupport) || other.disabledSupport == disabledSupport)&&(identical(other.isPreferredSupport, isPreferredSupport) || other.isPreferredSupport == isPreferredSupport)&&(identical(other.codeActionLiteralSupport, codeActionLiteralSupport) || other.codeActionLiteralSupport == codeActionLiteralSupport)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,honorsChangeAnnotations,resolveSupport,dataSupport,disabledSupport,isPreferredSupport,codeActionLiteralSupport,dynamicRegistration);

@override
String toString() {
  return 'CodeActionClientCapabilities(honorsChangeAnnotations: $honorsChangeAnnotations, resolveSupport: $resolveSupport, dataSupport: $dataSupport, disabledSupport: $disabledSupport, isPreferredSupport: $isPreferredSupport, codeActionLiteralSupport: $codeActionLiteralSupport, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$CodeActionClientCapabilitiesCopyWith<$Res> implements $CodeActionClientCapabilitiesCopyWith<$Res> {
  factory _$CodeActionClientCapabilitiesCopyWith(_CodeActionClientCapabilities value, $Res Function(_CodeActionClientCapabilities) _then) = __$CodeActionClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? honorsChangeAnnotations, ({List<String> properties})? resolveSupport, bool? dataSupport, bool? disabledSupport, bool? isPreferredSupport, ({({List<CodeActionKind> valueSet}) codeActionKind})? codeActionLiteralSupport, bool? dynamicRegistration
});




}
/// @nodoc
class __$CodeActionClientCapabilitiesCopyWithImpl<$Res>
    implements _$CodeActionClientCapabilitiesCopyWith<$Res> {
  __$CodeActionClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _CodeActionClientCapabilities _self;
  final $Res Function(_CodeActionClientCapabilities) _then;

/// Create a copy of CodeActionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? honorsChangeAnnotations = freezed,Object? resolveSupport = freezed,Object? dataSupport = freezed,Object? disabledSupport = freezed,Object? isPreferredSupport = freezed,Object? codeActionLiteralSupport = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_CodeActionClientCapabilities(
honorsChangeAnnotations: freezed == honorsChangeAnnotations ? _self.honorsChangeAnnotations : honorsChangeAnnotations // ignore: cast_nullable_to_non_nullable
as bool?,resolveSupport: freezed == resolveSupport ? _self.resolveSupport : resolveSupport // ignore: cast_nullable_to_non_nullable
as ({List<String> properties})?,dataSupport: freezed == dataSupport ? _self.dataSupport : dataSupport // ignore: cast_nullable_to_non_nullable
as bool?,disabledSupport: freezed == disabledSupport ? _self.disabledSupport : disabledSupport // ignore: cast_nullable_to_non_nullable
as bool?,isPreferredSupport: freezed == isPreferredSupport ? _self.isPreferredSupport : isPreferredSupport // ignore: cast_nullable_to_non_nullable
as bool?,codeActionLiteralSupport: freezed == codeActionLiteralSupport ? _self.codeActionLiteralSupport : codeActionLiteralSupport // ignore: cast_nullable_to_non_nullable
as ({({List<CodeActionKind> valueSet}) codeActionKind})?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$CodeLensClientCapabilities {

 bool? get dynamicRegistration;
/// Create a copy of CodeLensClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CodeLensClientCapabilitiesCopyWith<CodeLensClientCapabilities> get copyWith => _$CodeLensClientCapabilitiesCopyWithImpl<CodeLensClientCapabilities>(this as CodeLensClientCapabilities, _$identity);

  /// Serializes this CodeLensClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CodeLensClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'CodeLensClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $CodeLensClientCapabilitiesCopyWith<$Res>  {
  factory $CodeLensClientCapabilitiesCopyWith(CodeLensClientCapabilities value, $Res Function(CodeLensClientCapabilities) _then) = _$CodeLensClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class _$CodeLensClientCapabilitiesCopyWithImpl<$Res>
    implements $CodeLensClientCapabilitiesCopyWith<$Res> {
  _$CodeLensClientCapabilitiesCopyWithImpl(this._self, this._then);

  final CodeLensClientCapabilities _self;
  final $Res Function(CodeLensClientCapabilities) _then;

/// Create a copy of CodeLensClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _CodeLensClientCapabilities implements CodeLensClientCapabilities {
  const _CodeLensClientCapabilities({this.dynamicRegistration});
  factory _CodeLensClientCapabilities.fromJson(Map<String, dynamic> json) => _$CodeLensClientCapabilitiesFromJson(json);

@override final  bool? dynamicRegistration;

/// Create a copy of CodeLensClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CodeLensClientCapabilitiesCopyWith<_CodeLensClientCapabilities> get copyWith => __$CodeLensClientCapabilitiesCopyWithImpl<_CodeLensClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CodeLensClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CodeLensClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'CodeLensClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$CodeLensClientCapabilitiesCopyWith<$Res> implements $CodeLensClientCapabilitiesCopyWith<$Res> {
  factory _$CodeLensClientCapabilitiesCopyWith(_CodeLensClientCapabilities value, $Res Function(_CodeLensClientCapabilities) _then) = __$CodeLensClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class __$CodeLensClientCapabilitiesCopyWithImpl<$Res>
    implements _$CodeLensClientCapabilitiesCopyWith<$Res> {
  __$CodeLensClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _CodeLensClientCapabilities _self;
  final $Res Function(_CodeLensClientCapabilities) _then;

/// Create a copy of CodeLensClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_CodeLensClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DocumentLinkClientCapabilities {

 bool? get tooltipSupport; bool? get dynamicRegistration;
/// Create a copy of DocumentLinkClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentLinkClientCapabilitiesCopyWith<DocumentLinkClientCapabilities> get copyWith => _$DocumentLinkClientCapabilitiesCopyWithImpl<DocumentLinkClientCapabilities>(this as DocumentLinkClientCapabilities, _$identity);

  /// Serializes this DocumentLinkClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentLinkClientCapabilities&&(identical(other.tooltipSupport, tooltipSupport) || other.tooltipSupport == tooltipSupport)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,tooltipSupport,dynamicRegistration);

@override
String toString() {
  return 'DocumentLinkClientCapabilities(tooltipSupport: $tooltipSupport, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $DocumentLinkClientCapabilitiesCopyWith<$Res>  {
  factory $DocumentLinkClientCapabilitiesCopyWith(DocumentLinkClientCapabilities value, $Res Function(DocumentLinkClientCapabilities) _then) = _$DocumentLinkClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? tooltipSupport, bool? dynamicRegistration
});




}
/// @nodoc
class _$DocumentLinkClientCapabilitiesCopyWithImpl<$Res>
    implements $DocumentLinkClientCapabilitiesCopyWith<$Res> {
  _$DocumentLinkClientCapabilitiesCopyWithImpl(this._self, this._then);

  final DocumentLinkClientCapabilities _self;
  final $Res Function(DocumentLinkClientCapabilities) _then;

/// Create a copy of DocumentLinkClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? tooltipSupport = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
tooltipSupport: freezed == tooltipSupport ? _self.tooltipSupport : tooltipSupport // ignore: cast_nullable_to_non_nullable
as bool?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DocumentLinkClientCapabilities implements DocumentLinkClientCapabilities {
  const _DocumentLinkClientCapabilities({this.tooltipSupport, this.dynamicRegistration});
  factory _DocumentLinkClientCapabilities.fromJson(Map<String, dynamic> json) => _$DocumentLinkClientCapabilitiesFromJson(json);

@override final  bool? tooltipSupport;
@override final  bool? dynamicRegistration;

/// Create a copy of DocumentLinkClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentLinkClientCapabilitiesCopyWith<_DocumentLinkClientCapabilities> get copyWith => __$DocumentLinkClientCapabilitiesCopyWithImpl<_DocumentLinkClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentLinkClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentLinkClientCapabilities&&(identical(other.tooltipSupport, tooltipSupport) || other.tooltipSupport == tooltipSupport)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,tooltipSupport,dynamicRegistration);

@override
String toString() {
  return 'DocumentLinkClientCapabilities(tooltipSupport: $tooltipSupport, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$DocumentLinkClientCapabilitiesCopyWith<$Res> implements $DocumentLinkClientCapabilitiesCopyWith<$Res> {
  factory _$DocumentLinkClientCapabilitiesCopyWith(_DocumentLinkClientCapabilities value, $Res Function(_DocumentLinkClientCapabilities) _then) = __$DocumentLinkClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? tooltipSupport, bool? dynamicRegistration
});




}
/// @nodoc
class __$DocumentLinkClientCapabilitiesCopyWithImpl<$Res>
    implements _$DocumentLinkClientCapabilitiesCopyWith<$Res> {
  __$DocumentLinkClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _DocumentLinkClientCapabilities _self;
  final $Res Function(_DocumentLinkClientCapabilities) _then;

/// Create a copy of DocumentLinkClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? tooltipSupport = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_DocumentLinkClientCapabilities(
tooltipSupport: freezed == tooltipSupport ? _self.tooltipSupport : tooltipSupport // ignore: cast_nullable_to_non_nullable
as bool?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DocumentColorClientCapabilities {

 bool? get dynamicRegistration;
/// Create a copy of DocumentColorClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentColorClientCapabilitiesCopyWith<DocumentColorClientCapabilities> get copyWith => _$DocumentColorClientCapabilitiesCopyWithImpl<DocumentColorClientCapabilities>(this as DocumentColorClientCapabilities, _$identity);

  /// Serializes this DocumentColorClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentColorClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'DocumentColorClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $DocumentColorClientCapabilitiesCopyWith<$Res>  {
  factory $DocumentColorClientCapabilitiesCopyWith(DocumentColorClientCapabilities value, $Res Function(DocumentColorClientCapabilities) _then) = _$DocumentColorClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class _$DocumentColorClientCapabilitiesCopyWithImpl<$Res>
    implements $DocumentColorClientCapabilitiesCopyWith<$Res> {
  _$DocumentColorClientCapabilitiesCopyWithImpl(this._self, this._then);

  final DocumentColorClientCapabilities _self;
  final $Res Function(DocumentColorClientCapabilities) _then;

/// Create a copy of DocumentColorClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DocumentColorClientCapabilities implements DocumentColorClientCapabilities {
  const _DocumentColorClientCapabilities({this.dynamicRegistration});
  factory _DocumentColorClientCapabilities.fromJson(Map<String, dynamic> json) => _$DocumentColorClientCapabilitiesFromJson(json);

@override final  bool? dynamicRegistration;

/// Create a copy of DocumentColorClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentColorClientCapabilitiesCopyWith<_DocumentColorClientCapabilities> get copyWith => __$DocumentColorClientCapabilitiesCopyWithImpl<_DocumentColorClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentColorClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentColorClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'DocumentColorClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$DocumentColorClientCapabilitiesCopyWith<$Res> implements $DocumentColorClientCapabilitiesCopyWith<$Res> {
  factory _$DocumentColorClientCapabilitiesCopyWith(_DocumentColorClientCapabilities value, $Res Function(_DocumentColorClientCapabilities) _then) = __$DocumentColorClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class __$DocumentColorClientCapabilitiesCopyWithImpl<$Res>
    implements _$DocumentColorClientCapabilitiesCopyWith<$Res> {
  __$DocumentColorClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _DocumentColorClientCapabilities _self;
  final $Res Function(_DocumentColorClientCapabilities) _then;

/// Create a copy of DocumentColorClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_DocumentColorClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DocumentFormattingClientCapabilities {

 bool? get dynamicRegistration;
/// Create a copy of DocumentFormattingClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentFormattingClientCapabilitiesCopyWith<DocumentFormattingClientCapabilities> get copyWith => _$DocumentFormattingClientCapabilitiesCopyWithImpl<DocumentFormattingClientCapabilities>(this as DocumentFormattingClientCapabilities, _$identity);

  /// Serializes this DocumentFormattingClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentFormattingClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'DocumentFormattingClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $DocumentFormattingClientCapabilitiesCopyWith<$Res>  {
  factory $DocumentFormattingClientCapabilitiesCopyWith(DocumentFormattingClientCapabilities value, $Res Function(DocumentFormattingClientCapabilities) _then) = _$DocumentFormattingClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class _$DocumentFormattingClientCapabilitiesCopyWithImpl<$Res>
    implements $DocumentFormattingClientCapabilitiesCopyWith<$Res> {
  _$DocumentFormattingClientCapabilitiesCopyWithImpl(this._self, this._then);

  final DocumentFormattingClientCapabilities _self;
  final $Res Function(DocumentFormattingClientCapabilities) _then;

/// Create a copy of DocumentFormattingClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DocumentFormattingClientCapabilities implements DocumentFormattingClientCapabilities {
  const _DocumentFormattingClientCapabilities({this.dynamicRegistration});
  factory _DocumentFormattingClientCapabilities.fromJson(Map<String, dynamic> json) => _$DocumentFormattingClientCapabilitiesFromJson(json);

@override final  bool? dynamicRegistration;

/// Create a copy of DocumentFormattingClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentFormattingClientCapabilitiesCopyWith<_DocumentFormattingClientCapabilities> get copyWith => __$DocumentFormattingClientCapabilitiesCopyWithImpl<_DocumentFormattingClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentFormattingClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentFormattingClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'DocumentFormattingClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$DocumentFormattingClientCapabilitiesCopyWith<$Res> implements $DocumentFormattingClientCapabilitiesCopyWith<$Res> {
  factory _$DocumentFormattingClientCapabilitiesCopyWith(_DocumentFormattingClientCapabilities value, $Res Function(_DocumentFormattingClientCapabilities) _then) = __$DocumentFormattingClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class __$DocumentFormattingClientCapabilitiesCopyWithImpl<$Res>
    implements _$DocumentFormattingClientCapabilitiesCopyWith<$Res> {
  __$DocumentFormattingClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _DocumentFormattingClientCapabilities _self;
  final $Res Function(_DocumentFormattingClientCapabilities) _then;

/// Create a copy of DocumentFormattingClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_DocumentFormattingClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DocumentRangeFormattingClientCapabilities {

 bool? get rangesSupport; bool? get dynamicRegistration;
/// Create a copy of DocumentRangeFormattingClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentRangeFormattingClientCapabilitiesCopyWith<DocumentRangeFormattingClientCapabilities> get copyWith => _$DocumentRangeFormattingClientCapabilitiesCopyWithImpl<DocumentRangeFormattingClientCapabilities>(this as DocumentRangeFormattingClientCapabilities, _$identity);

  /// Serializes this DocumentRangeFormattingClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentRangeFormattingClientCapabilities&&(identical(other.rangesSupport, rangesSupport) || other.rangesSupport == rangesSupport)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,rangesSupport,dynamicRegistration);

@override
String toString() {
  return 'DocumentRangeFormattingClientCapabilities(rangesSupport: $rangesSupport, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $DocumentRangeFormattingClientCapabilitiesCopyWith<$Res>  {
  factory $DocumentRangeFormattingClientCapabilitiesCopyWith(DocumentRangeFormattingClientCapabilities value, $Res Function(DocumentRangeFormattingClientCapabilities) _then) = _$DocumentRangeFormattingClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? rangesSupport, bool? dynamicRegistration
});




}
/// @nodoc
class _$DocumentRangeFormattingClientCapabilitiesCopyWithImpl<$Res>
    implements $DocumentRangeFormattingClientCapabilitiesCopyWith<$Res> {
  _$DocumentRangeFormattingClientCapabilitiesCopyWithImpl(this._self, this._then);

  final DocumentRangeFormattingClientCapabilities _self;
  final $Res Function(DocumentRangeFormattingClientCapabilities) _then;

/// Create a copy of DocumentRangeFormattingClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? rangesSupport = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
rangesSupport: freezed == rangesSupport ? _self.rangesSupport : rangesSupport // ignore: cast_nullable_to_non_nullable
as bool?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DocumentRangeFormattingClientCapabilities implements DocumentRangeFormattingClientCapabilities {
  const _DocumentRangeFormattingClientCapabilities({this.rangesSupport, this.dynamicRegistration});
  factory _DocumentRangeFormattingClientCapabilities.fromJson(Map<String, dynamic> json) => _$DocumentRangeFormattingClientCapabilitiesFromJson(json);

@override final  bool? rangesSupport;
@override final  bool? dynamicRegistration;

/// Create a copy of DocumentRangeFormattingClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentRangeFormattingClientCapabilitiesCopyWith<_DocumentRangeFormattingClientCapabilities> get copyWith => __$DocumentRangeFormattingClientCapabilitiesCopyWithImpl<_DocumentRangeFormattingClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentRangeFormattingClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentRangeFormattingClientCapabilities&&(identical(other.rangesSupport, rangesSupport) || other.rangesSupport == rangesSupport)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,rangesSupport,dynamicRegistration);

@override
String toString() {
  return 'DocumentRangeFormattingClientCapabilities(rangesSupport: $rangesSupport, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$DocumentRangeFormattingClientCapabilitiesCopyWith<$Res> implements $DocumentRangeFormattingClientCapabilitiesCopyWith<$Res> {
  factory _$DocumentRangeFormattingClientCapabilitiesCopyWith(_DocumentRangeFormattingClientCapabilities value, $Res Function(_DocumentRangeFormattingClientCapabilities) _then) = __$DocumentRangeFormattingClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? rangesSupport, bool? dynamicRegistration
});




}
/// @nodoc
class __$DocumentRangeFormattingClientCapabilitiesCopyWithImpl<$Res>
    implements _$DocumentRangeFormattingClientCapabilitiesCopyWith<$Res> {
  __$DocumentRangeFormattingClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _DocumentRangeFormattingClientCapabilities _self;
  final $Res Function(_DocumentRangeFormattingClientCapabilities) _then;

/// Create a copy of DocumentRangeFormattingClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? rangesSupport = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_DocumentRangeFormattingClientCapabilities(
rangesSupport: freezed == rangesSupport ? _self.rangesSupport : rangesSupport // ignore: cast_nullable_to_non_nullable
as bool?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DocumentOnTypeFormattingClientCapabilities {

 bool? get dynamicRegistration;
/// Create a copy of DocumentOnTypeFormattingClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentOnTypeFormattingClientCapabilitiesCopyWith<DocumentOnTypeFormattingClientCapabilities> get copyWith => _$DocumentOnTypeFormattingClientCapabilitiesCopyWithImpl<DocumentOnTypeFormattingClientCapabilities>(this as DocumentOnTypeFormattingClientCapabilities, _$identity);

  /// Serializes this DocumentOnTypeFormattingClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentOnTypeFormattingClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'DocumentOnTypeFormattingClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $DocumentOnTypeFormattingClientCapabilitiesCopyWith<$Res>  {
  factory $DocumentOnTypeFormattingClientCapabilitiesCopyWith(DocumentOnTypeFormattingClientCapabilities value, $Res Function(DocumentOnTypeFormattingClientCapabilities) _then) = _$DocumentOnTypeFormattingClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class _$DocumentOnTypeFormattingClientCapabilitiesCopyWithImpl<$Res>
    implements $DocumentOnTypeFormattingClientCapabilitiesCopyWith<$Res> {
  _$DocumentOnTypeFormattingClientCapabilitiesCopyWithImpl(this._self, this._then);

  final DocumentOnTypeFormattingClientCapabilities _self;
  final $Res Function(DocumentOnTypeFormattingClientCapabilities) _then;

/// Create a copy of DocumentOnTypeFormattingClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DocumentOnTypeFormattingClientCapabilities implements DocumentOnTypeFormattingClientCapabilities {
  const _DocumentOnTypeFormattingClientCapabilities({this.dynamicRegistration});
  factory _DocumentOnTypeFormattingClientCapabilities.fromJson(Map<String, dynamic> json) => _$DocumentOnTypeFormattingClientCapabilitiesFromJson(json);

@override final  bool? dynamicRegistration;

/// Create a copy of DocumentOnTypeFormattingClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentOnTypeFormattingClientCapabilitiesCopyWith<_DocumentOnTypeFormattingClientCapabilities> get copyWith => __$DocumentOnTypeFormattingClientCapabilitiesCopyWithImpl<_DocumentOnTypeFormattingClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentOnTypeFormattingClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentOnTypeFormattingClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'DocumentOnTypeFormattingClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$DocumentOnTypeFormattingClientCapabilitiesCopyWith<$Res> implements $DocumentOnTypeFormattingClientCapabilitiesCopyWith<$Res> {
  factory _$DocumentOnTypeFormattingClientCapabilitiesCopyWith(_DocumentOnTypeFormattingClientCapabilities value, $Res Function(_DocumentOnTypeFormattingClientCapabilities) _then) = __$DocumentOnTypeFormattingClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class __$DocumentOnTypeFormattingClientCapabilitiesCopyWithImpl<$Res>
    implements _$DocumentOnTypeFormattingClientCapabilitiesCopyWith<$Res> {
  __$DocumentOnTypeFormattingClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _DocumentOnTypeFormattingClientCapabilities _self;
  final $Res Function(_DocumentOnTypeFormattingClientCapabilities) _then;

/// Create a copy of DocumentOnTypeFormattingClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_DocumentOnTypeFormattingClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$RenameClientCapabilities {

 bool? get honorsChangeAnnotations; PrepareSupportDefaultBehavior? get prepareSupportDefaultBehavior; bool? get prepareSupport; bool? get dynamicRegistration;
/// Create a copy of RenameClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RenameClientCapabilitiesCopyWith<RenameClientCapabilities> get copyWith => _$RenameClientCapabilitiesCopyWithImpl<RenameClientCapabilities>(this as RenameClientCapabilities, _$identity);

  /// Serializes this RenameClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RenameClientCapabilities&&(identical(other.honorsChangeAnnotations, honorsChangeAnnotations) || other.honorsChangeAnnotations == honorsChangeAnnotations)&&(identical(other.prepareSupportDefaultBehavior, prepareSupportDefaultBehavior) || other.prepareSupportDefaultBehavior == prepareSupportDefaultBehavior)&&(identical(other.prepareSupport, prepareSupport) || other.prepareSupport == prepareSupport)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,honorsChangeAnnotations,prepareSupportDefaultBehavior,prepareSupport,dynamicRegistration);

@override
String toString() {
  return 'RenameClientCapabilities(honorsChangeAnnotations: $honorsChangeAnnotations, prepareSupportDefaultBehavior: $prepareSupportDefaultBehavior, prepareSupport: $prepareSupport, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $RenameClientCapabilitiesCopyWith<$Res>  {
  factory $RenameClientCapabilitiesCopyWith(RenameClientCapabilities value, $Res Function(RenameClientCapabilities) _then) = _$RenameClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? honorsChangeAnnotations, PrepareSupportDefaultBehavior? prepareSupportDefaultBehavior, bool? prepareSupport, bool? dynamicRegistration
});




}
/// @nodoc
class _$RenameClientCapabilitiesCopyWithImpl<$Res>
    implements $RenameClientCapabilitiesCopyWith<$Res> {
  _$RenameClientCapabilitiesCopyWithImpl(this._self, this._then);

  final RenameClientCapabilities _self;
  final $Res Function(RenameClientCapabilities) _then;

/// Create a copy of RenameClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? honorsChangeAnnotations = freezed,Object? prepareSupportDefaultBehavior = freezed,Object? prepareSupport = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
honorsChangeAnnotations: freezed == honorsChangeAnnotations ? _self.honorsChangeAnnotations : honorsChangeAnnotations // ignore: cast_nullable_to_non_nullable
as bool?,prepareSupportDefaultBehavior: freezed == prepareSupportDefaultBehavior ? _self.prepareSupportDefaultBehavior : prepareSupportDefaultBehavior // ignore: cast_nullable_to_non_nullable
as PrepareSupportDefaultBehavior?,prepareSupport: freezed == prepareSupport ? _self.prepareSupport : prepareSupport // ignore: cast_nullable_to_non_nullable
as bool?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _RenameClientCapabilities implements RenameClientCapabilities {
  const _RenameClientCapabilities({this.honorsChangeAnnotations, this.prepareSupportDefaultBehavior, this.prepareSupport, this.dynamicRegistration});
  factory _RenameClientCapabilities.fromJson(Map<String, dynamic> json) => _$RenameClientCapabilitiesFromJson(json);

@override final  bool? honorsChangeAnnotations;
@override final  PrepareSupportDefaultBehavior? prepareSupportDefaultBehavior;
@override final  bool? prepareSupport;
@override final  bool? dynamicRegistration;

/// Create a copy of RenameClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RenameClientCapabilitiesCopyWith<_RenameClientCapabilities> get copyWith => __$RenameClientCapabilitiesCopyWithImpl<_RenameClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$RenameClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _RenameClientCapabilities&&(identical(other.honorsChangeAnnotations, honorsChangeAnnotations) || other.honorsChangeAnnotations == honorsChangeAnnotations)&&(identical(other.prepareSupportDefaultBehavior, prepareSupportDefaultBehavior) || other.prepareSupportDefaultBehavior == prepareSupportDefaultBehavior)&&(identical(other.prepareSupport, prepareSupport) || other.prepareSupport == prepareSupport)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,honorsChangeAnnotations,prepareSupportDefaultBehavior,prepareSupport,dynamicRegistration);

@override
String toString() {
  return 'RenameClientCapabilities(honorsChangeAnnotations: $honorsChangeAnnotations, prepareSupportDefaultBehavior: $prepareSupportDefaultBehavior, prepareSupport: $prepareSupport, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$RenameClientCapabilitiesCopyWith<$Res> implements $RenameClientCapabilitiesCopyWith<$Res> {
  factory _$RenameClientCapabilitiesCopyWith(_RenameClientCapabilities value, $Res Function(_RenameClientCapabilities) _then) = __$RenameClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? honorsChangeAnnotations, PrepareSupportDefaultBehavior? prepareSupportDefaultBehavior, bool? prepareSupport, bool? dynamicRegistration
});




}
/// @nodoc
class __$RenameClientCapabilitiesCopyWithImpl<$Res>
    implements _$RenameClientCapabilitiesCopyWith<$Res> {
  __$RenameClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _RenameClientCapabilities _self;
  final $Res Function(_RenameClientCapabilities) _then;

/// Create a copy of RenameClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? honorsChangeAnnotations = freezed,Object? prepareSupportDefaultBehavior = freezed,Object? prepareSupport = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_RenameClientCapabilities(
honorsChangeAnnotations: freezed == honorsChangeAnnotations ? _self.honorsChangeAnnotations : honorsChangeAnnotations // ignore: cast_nullable_to_non_nullable
as bool?,prepareSupportDefaultBehavior: freezed == prepareSupportDefaultBehavior ? _self.prepareSupportDefaultBehavior : prepareSupportDefaultBehavior // ignore: cast_nullable_to_non_nullable
as PrepareSupportDefaultBehavior?,prepareSupport: freezed == prepareSupport ? _self.prepareSupport : prepareSupport // ignore: cast_nullable_to_non_nullable
as bool?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$FoldingRangeClientCapabilities {

 ({bool? collapsedText})? get foldingRange; ({List<FoldingRangeKind>? valueSet})? get foldingRangeKind; bool? get lineFoldingOnly; int? get rangeLimit; bool? get dynamicRegistration;
/// Create a copy of FoldingRangeClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FoldingRangeClientCapabilitiesCopyWith<FoldingRangeClientCapabilities> get copyWith => _$FoldingRangeClientCapabilitiesCopyWithImpl<FoldingRangeClientCapabilities>(this as FoldingRangeClientCapabilities, _$identity);

  /// Serializes this FoldingRangeClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FoldingRangeClientCapabilities&&(identical(other.foldingRange, foldingRange) || other.foldingRange == foldingRange)&&(identical(other.foldingRangeKind, foldingRangeKind) || other.foldingRangeKind == foldingRangeKind)&&(identical(other.lineFoldingOnly, lineFoldingOnly) || other.lineFoldingOnly == lineFoldingOnly)&&(identical(other.rangeLimit, rangeLimit) || other.rangeLimit == rangeLimit)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,foldingRange,foldingRangeKind,lineFoldingOnly,rangeLimit,dynamicRegistration);

@override
String toString() {
  return 'FoldingRangeClientCapabilities(foldingRange: $foldingRange, foldingRangeKind: $foldingRangeKind, lineFoldingOnly: $lineFoldingOnly, rangeLimit: $rangeLimit, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $FoldingRangeClientCapabilitiesCopyWith<$Res>  {
  factory $FoldingRangeClientCapabilitiesCopyWith(FoldingRangeClientCapabilities value, $Res Function(FoldingRangeClientCapabilities) _then) = _$FoldingRangeClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 ({bool? collapsedText})? foldingRange, ({List<FoldingRangeKind>? valueSet})? foldingRangeKind, bool? lineFoldingOnly, int? rangeLimit, bool? dynamicRegistration
});




}
/// @nodoc
class _$FoldingRangeClientCapabilitiesCopyWithImpl<$Res>
    implements $FoldingRangeClientCapabilitiesCopyWith<$Res> {
  _$FoldingRangeClientCapabilitiesCopyWithImpl(this._self, this._then);

  final FoldingRangeClientCapabilities _self;
  final $Res Function(FoldingRangeClientCapabilities) _then;

/// Create a copy of FoldingRangeClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? foldingRange = freezed,Object? foldingRangeKind = freezed,Object? lineFoldingOnly = freezed,Object? rangeLimit = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
foldingRange: freezed == foldingRange ? _self.foldingRange : foldingRange // ignore: cast_nullable_to_non_nullable
as ({bool? collapsedText})?,foldingRangeKind: freezed == foldingRangeKind ? _self.foldingRangeKind : foldingRangeKind // ignore: cast_nullable_to_non_nullable
as ({List<FoldingRangeKind>? valueSet})?,lineFoldingOnly: freezed == lineFoldingOnly ? _self.lineFoldingOnly : lineFoldingOnly // ignore: cast_nullable_to_non_nullable
as bool?,rangeLimit: freezed == rangeLimit ? _self.rangeLimit : rangeLimit // ignore: cast_nullable_to_non_nullable
as int?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _FoldingRangeClientCapabilities implements FoldingRangeClientCapabilities {
  const _FoldingRangeClientCapabilities({this.foldingRange, this.foldingRangeKind, this.lineFoldingOnly, this.rangeLimit, this.dynamicRegistration});
  factory _FoldingRangeClientCapabilities.fromJson(Map<String, dynamic> json) => _$FoldingRangeClientCapabilitiesFromJson(json);

@override final  ({bool? collapsedText})? foldingRange;
@override final  ({List<FoldingRangeKind>? valueSet})? foldingRangeKind;
@override final  bool? lineFoldingOnly;
@override final  int? rangeLimit;
@override final  bool? dynamicRegistration;

/// Create a copy of FoldingRangeClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$FoldingRangeClientCapabilitiesCopyWith<_FoldingRangeClientCapabilities> get copyWith => __$FoldingRangeClientCapabilitiesCopyWithImpl<_FoldingRangeClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$FoldingRangeClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _FoldingRangeClientCapabilities&&(identical(other.foldingRange, foldingRange) || other.foldingRange == foldingRange)&&(identical(other.foldingRangeKind, foldingRangeKind) || other.foldingRangeKind == foldingRangeKind)&&(identical(other.lineFoldingOnly, lineFoldingOnly) || other.lineFoldingOnly == lineFoldingOnly)&&(identical(other.rangeLimit, rangeLimit) || other.rangeLimit == rangeLimit)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,foldingRange,foldingRangeKind,lineFoldingOnly,rangeLimit,dynamicRegistration);

@override
String toString() {
  return 'FoldingRangeClientCapabilities(foldingRange: $foldingRange, foldingRangeKind: $foldingRangeKind, lineFoldingOnly: $lineFoldingOnly, rangeLimit: $rangeLimit, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$FoldingRangeClientCapabilitiesCopyWith<$Res> implements $FoldingRangeClientCapabilitiesCopyWith<$Res> {
  factory _$FoldingRangeClientCapabilitiesCopyWith(_FoldingRangeClientCapabilities value, $Res Function(_FoldingRangeClientCapabilities) _then) = __$FoldingRangeClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 ({bool? collapsedText})? foldingRange, ({List<FoldingRangeKind>? valueSet})? foldingRangeKind, bool? lineFoldingOnly, int? rangeLimit, bool? dynamicRegistration
});




}
/// @nodoc
class __$FoldingRangeClientCapabilitiesCopyWithImpl<$Res>
    implements _$FoldingRangeClientCapabilitiesCopyWith<$Res> {
  __$FoldingRangeClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _FoldingRangeClientCapabilities _self;
  final $Res Function(_FoldingRangeClientCapabilities) _then;

/// Create a copy of FoldingRangeClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? foldingRange = freezed,Object? foldingRangeKind = freezed,Object? lineFoldingOnly = freezed,Object? rangeLimit = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_FoldingRangeClientCapabilities(
foldingRange: freezed == foldingRange ? _self.foldingRange : foldingRange // ignore: cast_nullable_to_non_nullable
as ({bool? collapsedText})?,foldingRangeKind: freezed == foldingRangeKind ? _self.foldingRangeKind : foldingRangeKind // ignore: cast_nullable_to_non_nullable
as ({List<FoldingRangeKind>? valueSet})?,lineFoldingOnly: freezed == lineFoldingOnly ? _self.lineFoldingOnly : lineFoldingOnly // ignore: cast_nullable_to_non_nullable
as bool?,rangeLimit: freezed == rangeLimit ? _self.rangeLimit : rangeLimit // ignore: cast_nullable_to_non_nullable
as int?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$SelectionRangeClientCapabilities {

 bool? get dynamicRegistration;
/// Create a copy of SelectionRangeClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SelectionRangeClientCapabilitiesCopyWith<SelectionRangeClientCapabilities> get copyWith => _$SelectionRangeClientCapabilitiesCopyWithImpl<SelectionRangeClientCapabilities>(this as SelectionRangeClientCapabilities, _$identity);

  /// Serializes this SelectionRangeClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SelectionRangeClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'SelectionRangeClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $SelectionRangeClientCapabilitiesCopyWith<$Res>  {
  factory $SelectionRangeClientCapabilitiesCopyWith(SelectionRangeClientCapabilities value, $Res Function(SelectionRangeClientCapabilities) _then) = _$SelectionRangeClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class _$SelectionRangeClientCapabilitiesCopyWithImpl<$Res>
    implements $SelectionRangeClientCapabilitiesCopyWith<$Res> {
  _$SelectionRangeClientCapabilitiesCopyWithImpl(this._self, this._then);

  final SelectionRangeClientCapabilities _self;
  final $Res Function(SelectionRangeClientCapabilities) _then;

/// Create a copy of SelectionRangeClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _SelectionRangeClientCapabilities implements SelectionRangeClientCapabilities {
  const _SelectionRangeClientCapabilities({this.dynamicRegistration});
  factory _SelectionRangeClientCapabilities.fromJson(Map<String, dynamic> json) => _$SelectionRangeClientCapabilitiesFromJson(json);

@override final  bool? dynamicRegistration;

/// Create a copy of SelectionRangeClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SelectionRangeClientCapabilitiesCopyWith<_SelectionRangeClientCapabilities> get copyWith => __$SelectionRangeClientCapabilitiesCopyWithImpl<_SelectionRangeClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SelectionRangeClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SelectionRangeClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'SelectionRangeClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$SelectionRangeClientCapabilitiesCopyWith<$Res> implements $SelectionRangeClientCapabilitiesCopyWith<$Res> {
  factory _$SelectionRangeClientCapabilitiesCopyWith(_SelectionRangeClientCapabilities value, $Res Function(_SelectionRangeClientCapabilities) _then) = __$SelectionRangeClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class __$SelectionRangeClientCapabilitiesCopyWithImpl<$Res>
    implements _$SelectionRangeClientCapabilitiesCopyWith<$Res> {
  __$SelectionRangeClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _SelectionRangeClientCapabilities _self;
  final $Res Function(_SelectionRangeClientCapabilities) _then;

/// Create a copy of SelectionRangeClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_SelectionRangeClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$PublishDiagnosticsClientCapabilities {

 bool? get dataSupport; bool? get codeDescriptionSupport; bool? get versionSupport; ({List<DiagnosticTag> valueSet})? get tagSupport; bool? get relatedInformation;
/// Create a copy of PublishDiagnosticsClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$PublishDiagnosticsClientCapabilitiesCopyWith<PublishDiagnosticsClientCapabilities> get copyWith => _$PublishDiagnosticsClientCapabilitiesCopyWithImpl<PublishDiagnosticsClientCapabilities>(this as PublishDiagnosticsClientCapabilities, _$identity);

  /// Serializes this PublishDiagnosticsClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is PublishDiagnosticsClientCapabilities&&(identical(other.dataSupport, dataSupport) || other.dataSupport == dataSupport)&&(identical(other.codeDescriptionSupport, codeDescriptionSupport) || other.codeDescriptionSupport == codeDescriptionSupport)&&(identical(other.versionSupport, versionSupport) || other.versionSupport == versionSupport)&&(identical(other.tagSupport, tagSupport) || other.tagSupport == tagSupport)&&(identical(other.relatedInformation, relatedInformation) || other.relatedInformation == relatedInformation));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dataSupport,codeDescriptionSupport,versionSupport,tagSupport,relatedInformation);

@override
String toString() {
  return 'PublishDiagnosticsClientCapabilities(dataSupport: $dataSupport, codeDescriptionSupport: $codeDescriptionSupport, versionSupport: $versionSupport, tagSupport: $tagSupport, relatedInformation: $relatedInformation)';
}


}

/// @nodoc
abstract mixin class $PublishDiagnosticsClientCapabilitiesCopyWith<$Res>  {
  factory $PublishDiagnosticsClientCapabilitiesCopyWith(PublishDiagnosticsClientCapabilities value, $Res Function(PublishDiagnosticsClientCapabilities) _then) = _$PublishDiagnosticsClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dataSupport, bool? codeDescriptionSupport, bool? versionSupport, ({List<DiagnosticTag> valueSet})? tagSupport, bool? relatedInformation
});




}
/// @nodoc
class _$PublishDiagnosticsClientCapabilitiesCopyWithImpl<$Res>
    implements $PublishDiagnosticsClientCapabilitiesCopyWith<$Res> {
  _$PublishDiagnosticsClientCapabilitiesCopyWithImpl(this._self, this._then);

  final PublishDiagnosticsClientCapabilities _self;
  final $Res Function(PublishDiagnosticsClientCapabilities) _then;

/// Create a copy of PublishDiagnosticsClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dataSupport = freezed,Object? codeDescriptionSupport = freezed,Object? versionSupport = freezed,Object? tagSupport = freezed,Object? relatedInformation = freezed,}) {
  return _then(_self.copyWith(
dataSupport: freezed == dataSupport ? _self.dataSupport : dataSupport // ignore: cast_nullable_to_non_nullable
as bool?,codeDescriptionSupport: freezed == codeDescriptionSupport ? _self.codeDescriptionSupport : codeDescriptionSupport // ignore: cast_nullable_to_non_nullable
as bool?,versionSupport: freezed == versionSupport ? _self.versionSupport : versionSupport // ignore: cast_nullable_to_non_nullable
as bool?,tagSupport: freezed == tagSupport ? _self.tagSupport : tagSupport // ignore: cast_nullable_to_non_nullable
as ({List<DiagnosticTag> valueSet})?,relatedInformation: freezed == relatedInformation ? _self.relatedInformation : relatedInformation // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _PublishDiagnosticsClientCapabilities implements PublishDiagnosticsClientCapabilities {
  const _PublishDiagnosticsClientCapabilities({this.dataSupport, this.codeDescriptionSupport, this.versionSupport, this.tagSupport, this.relatedInformation});
  factory _PublishDiagnosticsClientCapabilities.fromJson(Map<String, dynamic> json) => _$PublishDiagnosticsClientCapabilitiesFromJson(json);

@override final  bool? dataSupport;
@override final  bool? codeDescriptionSupport;
@override final  bool? versionSupport;
@override final  ({List<DiagnosticTag> valueSet})? tagSupport;
@override final  bool? relatedInformation;

/// Create a copy of PublishDiagnosticsClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$PublishDiagnosticsClientCapabilitiesCopyWith<_PublishDiagnosticsClientCapabilities> get copyWith => __$PublishDiagnosticsClientCapabilitiesCopyWithImpl<_PublishDiagnosticsClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$PublishDiagnosticsClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _PublishDiagnosticsClientCapabilities&&(identical(other.dataSupport, dataSupport) || other.dataSupport == dataSupport)&&(identical(other.codeDescriptionSupport, codeDescriptionSupport) || other.codeDescriptionSupport == codeDescriptionSupport)&&(identical(other.versionSupport, versionSupport) || other.versionSupport == versionSupport)&&(identical(other.tagSupport, tagSupport) || other.tagSupport == tagSupport)&&(identical(other.relatedInformation, relatedInformation) || other.relatedInformation == relatedInformation));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dataSupport,codeDescriptionSupport,versionSupport,tagSupport,relatedInformation);

@override
String toString() {
  return 'PublishDiagnosticsClientCapabilities(dataSupport: $dataSupport, codeDescriptionSupport: $codeDescriptionSupport, versionSupport: $versionSupport, tagSupport: $tagSupport, relatedInformation: $relatedInformation)';
}


}

/// @nodoc
abstract mixin class _$PublishDiagnosticsClientCapabilitiesCopyWith<$Res> implements $PublishDiagnosticsClientCapabilitiesCopyWith<$Res> {
  factory _$PublishDiagnosticsClientCapabilitiesCopyWith(_PublishDiagnosticsClientCapabilities value, $Res Function(_PublishDiagnosticsClientCapabilities) _then) = __$PublishDiagnosticsClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dataSupport, bool? codeDescriptionSupport, bool? versionSupport, ({List<DiagnosticTag> valueSet})? tagSupport, bool? relatedInformation
});




}
/// @nodoc
class __$PublishDiagnosticsClientCapabilitiesCopyWithImpl<$Res>
    implements _$PublishDiagnosticsClientCapabilitiesCopyWith<$Res> {
  __$PublishDiagnosticsClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _PublishDiagnosticsClientCapabilities _self;
  final $Res Function(_PublishDiagnosticsClientCapabilities) _then;

/// Create a copy of PublishDiagnosticsClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dataSupport = freezed,Object? codeDescriptionSupport = freezed,Object? versionSupport = freezed,Object? tagSupport = freezed,Object? relatedInformation = freezed,}) {
  return _then(_PublishDiagnosticsClientCapabilities(
dataSupport: freezed == dataSupport ? _self.dataSupport : dataSupport // ignore: cast_nullable_to_non_nullable
as bool?,codeDescriptionSupport: freezed == codeDescriptionSupport ? _self.codeDescriptionSupport : codeDescriptionSupport // ignore: cast_nullable_to_non_nullable
as bool?,versionSupport: freezed == versionSupport ? _self.versionSupport : versionSupport // ignore: cast_nullable_to_non_nullable
as bool?,tagSupport: freezed == tagSupport ? _self.tagSupport : tagSupport // ignore: cast_nullable_to_non_nullable
as ({List<DiagnosticTag> valueSet})?,relatedInformation: freezed == relatedInformation ? _self.relatedInformation : relatedInformation // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$CallHierarchyClientCapabilities {

 bool? get dynamicRegistration;
/// Create a copy of CallHierarchyClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CallHierarchyClientCapabilitiesCopyWith<CallHierarchyClientCapabilities> get copyWith => _$CallHierarchyClientCapabilitiesCopyWithImpl<CallHierarchyClientCapabilities>(this as CallHierarchyClientCapabilities, _$identity);

  /// Serializes this CallHierarchyClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CallHierarchyClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'CallHierarchyClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $CallHierarchyClientCapabilitiesCopyWith<$Res>  {
  factory $CallHierarchyClientCapabilitiesCopyWith(CallHierarchyClientCapabilities value, $Res Function(CallHierarchyClientCapabilities) _then) = _$CallHierarchyClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class _$CallHierarchyClientCapabilitiesCopyWithImpl<$Res>
    implements $CallHierarchyClientCapabilitiesCopyWith<$Res> {
  _$CallHierarchyClientCapabilitiesCopyWithImpl(this._self, this._then);

  final CallHierarchyClientCapabilities _self;
  final $Res Function(CallHierarchyClientCapabilities) _then;

/// Create a copy of CallHierarchyClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _CallHierarchyClientCapabilities implements CallHierarchyClientCapabilities {
  const _CallHierarchyClientCapabilities({this.dynamicRegistration});
  factory _CallHierarchyClientCapabilities.fromJson(Map<String, dynamic> json) => _$CallHierarchyClientCapabilitiesFromJson(json);

@override final  bool? dynamicRegistration;

/// Create a copy of CallHierarchyClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CallHierarchyClientCapabilitiesCopyWith<_CallHierarchyClientCapabilities> get copyWith => __$CallHierarchyClientCapabilitiesCopyWithImpl<_CallHierarchyClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CallHierarchyClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CallHierarchyClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'CallHierarchyClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$CallHierarchyClientCapabilitiesCopyWith<$Res> implements $CallHierarchyClientCapabilitiesCopyWith<$Res> {
  factory _$CallHierarchyClientCapabilitiesCopyWith(_CallHierarchyClientCapabilities value, $Res Function(_CallHierarchyClientCapabilities) _then) = __$CallHierarchyClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class __$CallHierarchyClientCapabilitiesCopyWithImpl<$Res>
    implements _$CallHierarchyClientCapabilitiesCopyWith<$Res> {
  __$CallHierarchyClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _CallHierarchyClientCapabilities _self;
  final $Res Function(_CallHierarchyClientCapabilities) _then;

/// Create a copy of CallHierarchyClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_CallHierarchyClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$SemanticTokensClientCapabilities {

 ({dynamic? range, dynamic? full}) get requests; List<String> get tokenTypes; List<String> get tokenModifiers; List<TokenFormat> get formats; bool? get augmentsSyntaxTokens; bool? get serverCancelSupport; bool? get multilineTokenSupport; bool? get overlappingTokenSupport; bool? get dynamicRegistration;
/// Create a copy of SemanticTokensClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SemanticTokensClientCapabilitiesCopyWith<SemanticTokensClientCapabilities> get copyWith => _$SemanticTokensClientCapabilitiesCopyWithImpl<SemanticTokensClientCapabilities>(this as SemanticTokensClientCapabilities, _$identity);

  /// Serializes this SemanticTokensClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SemanticTokensClientCapabilities&&(identical(other.requests, requests) || other.requests == requests)&&const DeepCollectionEquality().equals(other.tokenTypes, tokenTypes)&&const DeepCollectionEquality().equals(other.tokenModifiers, tokenModifiers)&&const DeepCollectionEquality().equals(other.formats, formats)&&(identical(other.augmentsSyntaxTokens, augmentsSyntaxTokens) || other.augmentsSyntaxTokens == augmentsSyntaxTokens)&&(identical(other.serverCancelSupport, serverCancelSupport) || other.serverCancelSupport == serverCancelSupport)&&(identical(other.multilineTokenSupport, multilineTokenSupport) || other.multilineTokenSupport == multilineTokenSupport)&&(identical(other.overlappingTokenSupport, overlappingTokenSupport) || other.overlappingTokenSupport == overlappingTokenSupport)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,requests,const DeepCollectionEquality().hash(tokenTypes),const DeepCollectionEquality().hash(tokenModifiers),const DeepCollectionEquality().hash(formats),augmentsSyntaxTokens,serverCancelSupport,multilineTokenSupport,overlappingTokenSupport,dynamicRegistration);

@override
String toString() {
  return 'SemanticTokensClientCapabilities(requests: $requests, tokenTypes: $tokenTypes, tokenModifiers: $tokenModifiers, formats: $formats, augmentsSyntaxTokens: $augmentsSyntaxTokens, serverCancelSupport: $serverCancelSupport, multilineTokenSupport: $multilineTokenSupport, overlappingTokenSupport: $overlappingTokenSupport, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $SemanticTokensClientCapabilitiesCopyWith<$Res>  {
  factory $SemanticTokensClientCapabilitiesCopyWith(SemanticTokensClientCapabilities value, $Res Function(SemanticTokensClientCapabilities) _then) = _$SemanticTokensClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 ({dynamic? range, dynamic? full}) requests, List<String> tokenTypes, List<String> tokenModifiers, List<TokenFormat> formats, bool? augmentsSyntaxTokens, bool? serverCancelSupport, bool? multilineTokenSupport, bool? overlappingTokenSupport, bool? dynamicRegistration
});




}
/// @nodoc
class _$SemanticTokensClientCapabilitiesCopyWithImpl<$Res>
    implements $SemanticTokensClientCapabilitiesCopyWith<$Res> {
  _$SemanticTokensClientCapabilitiesCopyWithImpl(this._self, this._then);

  final SemanticTokensClientCapabilities _self;
  final $Res Function(SemanticTokensClientCapabilities) _then;

/// Create a copy of SemanticTokensClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? requests = null,Object? tokenTypes = null,Object? tokenModifiers = null,Object? formats = null,Object? augmentsSyntaxTokens = freezed,Object? serverCancelSupport = freezed,Object? multilineTokenSupport = freezed,Object? overlappingTokenSupport = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
requests: null == requests ? _self.requests : requests // ignore: cast_nullable_to_non_nullable
as ({dynamic? range, dynamic? full}),tokenTypes: null == tokenTypes ? _self.tokenTypes : tokenTypes // ignore: cast_nullable_to_non_nullable
as List<String>,tokenModifiers: null == tokenModifiers ? _self.tokenModifiers : tokenModifiers // ignore: cast_nullable_to_non_nullable
as List<String>,formats: null == formats ? _self.formats : formats // ignore: cast_nullable_to_non_nullable
as List<TokenFormat>,augmentsSyntaxTokens: freezed == augmentsSyntaxTokens ? _self.augmentsSyntaxTokens : augmentsSyntaxTokens // ignore: cast_nullable_to_non_nullable
as bool?,serverCancelSupport: freezed == serverCancelSupport ? _self.serverCancelSupport : serverCancelSupport // ignore: cast_nullable_to_non_nullable
as bool?,multilineTokenSupport: freezed == multilineTokenSupport ? _self.multilineTokenSupport : multilineTokenSupport // ignore: cast_nullable_to_non_nullable
as bool?,overlappingTokenSupport: freezed == overlappingTokenSupport ? _self.overlappingTokenSupport : overlappingTokenSupport // ignore: cast_nullable_to_non_nullable
as bool?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _SemanticTokensClientCapabilities implements SemanticTokensClientCapabilities {
  const _SemanticTokensClientCapabilities({required this.requests, required final  List<String> tokenTypes, required final  List<String> tokenModifiers, required final  List<TokenFormat> formats, this.augmentsSyntaxTokens, this.serverCancelSupport, this.multilineTokenSupport, this.overlappingTokenSupport, this.dynamicRegistration}): _tokenTypes = tokenTypes,_tokenModifiers = tokenModifiers,_formats = formats;
  factory _SemanticTokensClientCapabilities.fromJson(Map<String, dynamic> json) => _$SemanticTokensClientCapabilitiesFromJson(json);

@override final  ({dynamic? range, dynamic? full}) requests;
 final  List<String> _tokenTypes;
@override List<String> get tokenTypes {
  if (_tokenTypes is EqualUnmodifiableListView) return _tokenTypes;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_tokenTypes);
}

 final  List<String> _tokenModifiers;
@override List<String> get tokenModifiers {
  if (_tokenModifiers is EqualUnmodifiableListView) return _tokenModifiers;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_tokenModifiers);
}

 final  List<TokenFormat> _formats;
@override List<TokenFormat> get formats {
  if (_formats is EqualUnmodifiableListView) return _formats;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_formats);
}

@override final  bool? augmentsSyntaxTokens;
@override final  bool? serverCancelSupport;
@override final  bool? multilineTokenSupport;
@override final  bool? overlappingTokenSupport;
@override final  bool? dynamicRegistration;

/// Create a copy of SemanticTokensClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SemanticTokensClientCapabilitiesCopyWith<_SemanticTokensClientCapabilities> get copyWith => __$SemanticTokensClientCapabilitiesCopyWithImpl<_SemanticTokensClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SemanticTokensClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SemanticTokensClientCapabilities&&(identical(other.requests, requests) || other.requests == requests)&&const DeepCollectionEquality().equals(other._tokenTypes, _tokenTypes)&&const DeepCollectionEquality().equals(other._tokenModifiers, _tokenModifiers)&&const DeepCollectionEquality().equals(other._formats, _formats)&&(identical(other.augmentsSyntaxTokens, augmentsSyntaxTokens) || other.augmentsSyntaxTokens == augmentsSyntaxTokens)&&(identical(other.serverCancelSupport, serverCancelSupport) || other.serverCancelSupport == serverCancelSupport)&&(identical(other.multilineTokenSupport, multilineTokenSupport) || other.multilineTokenSupport == multilineTokenSupport)&&(identical(other.overlappingTokenSupport, overlappingTokenSupport) || other.overlappingTokenSupport == overlappingTokenSupport)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,requests,const DeepCollectionEquality().hash(_tokenTypes),const DeepCollectionEquality().hash(_tokenModifiers),const DeepCollectionEquality().hash(_formats),augmentsSyntaxTokens,serverCancelSupport,multilineTokenSupport,overlappingTokenSupport,dynamicRegistration);

@override
String toString() {
  return 'SemanticTokensClientCapabilities(requests: $requests, tokenTypes: $tokenTypes, tokenModifiers: $tokenModifiers, formats: $formats, augmentsSyntaxTokens: $augmentsSyntaxTokens, serverCancelSupport: $serverCancelSupport, multilineTokenSupport: $multilineTokenSupport, overlappingTokenSupport: $overlappingTokenSupport, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$SemanticTokensClientCapabilitiesCopyWith<$Res> implements $SemanticTokensClientCapabilitiesCopyWith<$Res> {
  factory _$SemanticTokensClientCapabilitiesCopyWith(_SemanticTokensClientCapabilities value, $Res Function(_SemanticTokensClientCapabilities) _then) = __$SemanticTokensClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 ({dynamic? range, dynamic? full}) requests, List<String> tokenTypes, List<String> tokenModifiers, List<TokenFormat> formats, bool? augmentsSyntaxTokens, bool? serverCancelSupport, bool? multilineTokenSupport, bool? overlappingTokenSupport, bool? dynamicRegistration
});




}
/// @nodoc
class __$SemanticTokensClientCapabilitiesCopyWithImpl<$Res>
    implements _$SemanticTokensClientCapabilitiesCopyWith<$Res> {
  __$SemanticTokensClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _SemanticTokensClientCapabilities _self;
  final $Res Function(_SemanticTokensClientCapabilities) _then;

/// Create a copy of SemanticTokensClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? requests = null,Object? tokenTypes = null,Object? tokenModifiers = null,Object? formats = null,Object? augmentsSyntaxTokens = freezed,Object? serverCancelSupport = freezed,Object? multilineTokenSupport = freezed,Object? overlappingTokenSupport = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_SemanticTokensClientCapabilities(
requests: null == requests ? _self.requests : requests // ignore: cast_nullable_to_non_nullable
as ({dynamic? range, dynamic? full}),tokenTypes: null == tokenTypes ? _self._tokenTypes : tokenTypes // ignore: cast_nullable_to_non_nullable
as List<String>,tokenModifiers: null == tokenModifiers ? _self._tokenModifiers : tokenModifiers // ignore: cast_nullable_to_non_nullable
as List<String>,formats: null == formats ? _self._formats : formats // ignore: cast_nullable_to_non_nullable
as List<TokenFormat>,augmentsSyntaxTokens: freezed == augmentsSyntaxTokens ? _self.augmentsSyntaxTokens : augmentsSyntaxTokens // ignore: cast_nullable_to_non_nullable
as bool?,serverCancelSupport: freezed == serverCancelSupport ? _self.serverCancelSupport : serverCancelSupport // ignore: cast_nullable_to_non_nullable
as bool?,multilineTokenSupport: freezed == multilineTokenSupport ? _self.multilineTokenSupport : multilineTokenSupport // ignore: cast_nullable_to_non_nullable
as bool?,overlappingTokenSupport: freezed == overlappingTokenSupport ? _self.overlappingTokenSupport : overlappingTokenSupport // ignore: cast_nullable_to_non_nullable
as bool?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$LinkedEditingRangeClientCapabilities {

 bool? get dynamicRegistration;
/// Create a copy of LinkedEditingRangeClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LinkedEditingRangeClientCapabilitiesCopyWith<LinkedEditingRangeClientCapabilities> get copyWith => _$LinkedEditingRangeClientCapabilitiesCopyWithImpl<LinkedEditingRangeClientCapabilities>(this as LinkedEditingRangeClientCapabilities, _$identity);

  /// Serializes this LinkedEditingRangeClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LinkedEditingRangeClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'LinkedEditingRangeClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $LinkedEditingRangeClientCapabilitiesCopyWith<$Res>  {
  factory $LinkedEditingRangeClientCapabilitiesCopyWith(LinkedEditingRangeClientCapabilities value, $Res Function(LinkedEditingRangeClientCapabilities) _then) = _$LinkedEditingRangeClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class _$LinkedEditingRangeClientCapabilitiesCopyWithImpl<$Res>
    implements $LinkedEditingRangeClientCapabilitiesCopyWith<$Res> {
  _$LinkedEditingRangeClientCapabilitiesCopyWithImpl(this._self, this._then);

  final LinkedEditingRangeClientCapabilities _self;
  final $Res Function(LinkedEditingRangeClientCapabilities) _then;

/// Create a copy of LinkedEditingRangeClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _LinkedEditingRangeClientCapabilities implements LinkedEditingRangeClientCapabilities {
  const _LinkedEditingRangeClientCapabilities({this.dynamicRegistration});
  factory _LinkedEditingRangeClientCapabilities.fromJson(Map<String, dynamic> json) => _$LinkedEditingRangeClientCapabilitiesFromJson(json);

@override final  bool? dynamicRegistration;

/// Create a copy of LinkedEditingRangeClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$LinkedEditingRangeClientCapabilitiesCopyWith<_LinkedEditingRangeClientCapabilities> get copyWith => __$LinkedEditingRangeClientCapabilitiesCopyWithImpl<_LinkedEditingRangeClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$LinkedEditingRangeClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _LinkedEditingRangeClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'LinkedEditingRangeClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$LinkedEditingRangeClientCapabilitiesCopyWith<$Res> implements $LinkedEditingRangeClientCapabilitiesCopyWith<$Res> {
  factory _$LinkedEditingRangeClientCapabilitiesCopyWith(_LinkedEditingRangeClientCapabilities value, $Res Function(_LinkedEditingRangeClientCapabilities) _then) = __$LinkedEditingRangeClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class __$LinkedEditingRangeClientCapabilitiesCopyWithImpl<$Res>
    implements _$LinkedEditingRangeClientCapabilitiesCopyWith<$Res> {
  __$LinkedEditingRangeClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _LinkedEditingRangeClientCapabilities _self;
  final $Res Function(_LinkedEditingRangeClientCapabilities) _then;

/// Create a copy of LinkedEditingRangeClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_LinkedEditingRangeClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$MonikerClientCapabilities {

 bool? get dynamicRegistration;
/// Create a copy of MonikerClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$MonikerClientCapabilitiesCopyWith<MonikerClientCapabilities> get copyWith => _$MonikerClientCapabilitiesCopyWithImpl<MonikerClientCapabilities>(this as MonikerClientCapabilities, _$identity);

  /// Serializes this MonikerClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is MonikerClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'MonikerClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $MonikerClientCapabilitiesCopyWith<$Res>  {
  factory $MonikerClientCapabilitiesCopyWith(MonikerClientCapabilities value, $Res Function(MonikerClientCapabilities) _then) = _$MonikerClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class _$MonikerClientCapabilitiesCopyWithImpl<$Res>
    implements $MonikerClientCapabilitiesCopyWith<$Res> {
  _$MonikerClientCapabilitiesCopyWithImpl(this._self, this._then);

  final MonikerClientCapabilities _self;
  final $Res Function(MonikerClientCapabilities) _then;

/// Create a copy of MonikerClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _MonikerClientCapabilities implements MonikerClientCapabilities {
  const _MonikerClientCapabilities({this.dynamicRegistration});
  factory _MonikerClientCapabilities.fromJson(Map<String, dynamic> json) => _$MonikerClientCapabilitiesFromJson(json);

@override final  bool? dynamicRegistration;

/// Create a copy of MonikerClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$MonikerClientCapabilitiesCopyWith<_MonikerClientCapabilities> get copyWith => __$MonikerClientCapabilitiesCopyWithImpl<_MonikerClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$MonikerClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _MonikerClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'MonikerClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$MonikerClientCapabilitiesCopyWith<$Res> implements $MonikerClientCapabilitiesCopyWith<$Res> {
  factory _$MonikerClientCapabilitiesCopyWith(_MonikerClientCapabilities value, $Res Function(_MonikerClientCapabilities) _then) = __$MonikerClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class __$MonikerClientCapabilitiesCopyWithImpl<$Res>
    implements _$MonikerClientCapabilitiesCopyWith<$Res> {
  __$MonikerClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _MonikerClientCapabilities _self;
  final $Res Function(_MonikerClientCapabilities) _then;

/// Create a copy of MonikerClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_MonikerClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$TypeHierarchyClientCapabilities {

 bool? get dynamicRegistration;
/// Create a copy of TypeHierarchyClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TypeHierarchyClientCapabilitiesCopyWith<TypeHierarchyClientCapabilities> get copyWith => _$TypeHierarchyClientCapabilitiesCopyWithImpl<TypeHierarchyClientCapabilities>(this as TypeHierarchyClientCapabilities, _$identity);

  /// Serializes this TypeHierarchyClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TypeHierarchyClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'TypeHierarchyClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $TypeHierarchyClientCapabilitiesCopyWith<$Res>  {
  factory $TypeHierarchyClientCapabilitiesCopyWith(TypeHierarchyClientCapabilities value, $Res Function(TypeHierarchyClientCapabilities) _then) = _$TypeHierarchyClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class _$TypeHierarchyClientCapabilitiesCopyWithImpl<$Res>
    implements $TypeHierarchyClientCapabilitiesCopyWith<$Res> {
  _$TypeHierarchyClientCapabilitiesCopyWithImpl(this._self, this._then);

  final TypeHierarchyClientCapabilities _self;
  final $Res Function(TypeHierarchyClientCapabilities) _then;

/// Create a copy of TypeHierarchyClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _TypeHierarchyClientCapabilities implements TypeHierarchyClientCapabilities {
  const _TypeHierarchyClientCapabilities({this.dynamicRegistration});
  factory _TypeHierarchyClientCapabilities.fromJson(Map<String, dynamic> json) => _$TypeHierarchyClientCapabilitiesFromJson(json);

@override final  bool? dynamicRegistration;

/// Create a copy of TypeHierarchyClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TypeHierarchyClientCapabilitiesCopyWith<_TypeHierarchyClientCapabilities> get copyWith => __$TypeHierarchyClientCapabilitiesCopyWithImpl<_TypeHierarchyClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TypeHierarchyClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TypeHierarchyClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'TypeHierarchyClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$TypeHierarchyClientCapabilitiesCopyWith<$Res> implements $TypeHierarchyClientCapabilitiesCopyWith<$Res> {
  factory _$TypeHierarchyClientCapabilitiesCopyWith(_TypeHierarchyClientCapabilities value, $Res Function(_TypeHierarchyClientCapabilities) _then) = __$TypeHierarchyClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class __$TypeHierarchyClientCapabilitiesCopyWithImpl<$Res>
    implements _$TypeHierarchyClientCapabilitiesCopyWith<$Res> {
  __$TypeHierarchyClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _TypeHierarchyClientCapabilities _self;
  final $Res Function(_TypeHierarchyClientCapabilities) _then;

/// Create a copy of TypeHierarchyClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_TypeHierarchyClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$InlineValueClientCapabilities {

 bool? get dynamicRegistration;
/// Create a copy of InlineValueClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlineValueClientCapabilitiesCopyWith<InlineValueClientCapabilities> get copyWith => _$InlineValueClientCapabilitiesCopyWithImpl<InlineValueClientCapabilities>(this as InlineValueClientCapabilities, _$identity);

  /// Serializes this InlineValueClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlineValueClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'InlineValueClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $InlineValueClientCapabilitiesCopyWith<$Res>  {
  factory $InlineValueClientCapabilitiesCopyWith(InlineValueClientCapabilities value, $Res Function(InlineValueClientCapabilities) _then) = _$InlineValueClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class _$InlineValueClientCapabilitiesCopyWithImpl<$Res>
    implements $InlineValueClientCapabilitiesCopyWith<$Res> {
  _$InlineValueClientCapabilitiesCopyWithImpl(this._self, this._then);

  final InlineValueClientCapabilities _self;
  final $Res Function(InlineValueClientCapabilities) _then;

/// Create a copy of InlineValueClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _InlineValueClientCapabilities implements InlineValueClientCapabilities {
  const _InlineValueClientCapabilities({this.dynamicRegistration});
  factory _InlineValueClientCapabilities.fromJson(Map<String, dynamic> json) => _$InlineValueClientCapabilitiesFromJson(json);

@override final  bool? dynamicRegistration;

/// Create a copy of InlineValueClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlineValueClientCapabilitiesCopyWith<_InlineValueClientCapabilities> get copyWith => __$InlineValueClientCapabilitiesCopyWithImpl<_InlineValueClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlineValueClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlineValueClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'InlineValueClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$InlineValueClientCapabilitiesCopyWith<$Res> implements $InlineValueClientCapabilitiesCopyWith<$Res> {
  factory _$InlineValueClientCapabilitiesCopyWith(_InlineValueClientCapabilities value, $Res Function(_InlineValueClientCapabilities) _then) = __$InlineValueClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class __$InlineValueClientCapabilitiesCopyWithImpl<$Res>
    implements _$InlineValueClientCapabilitiesCopyWith<$Res> {
  __$InlineValueClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _InlineValueClientCapabilities _self;
  final $Res Function(_InlineValueClientCapabilities) _then;

/// Create a copy of InlineValueClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_InlineValueClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$InlayHintClientCapabilities {

 ({List<String> properties})? get resolveSupport; bool? get dynamicRegistration;
/// Create a copy of InlayHintClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlayHintClientCapabilitiesCopyWith<InlayHintClientCapabilities> get copyWith => _$InlayHintClientCapabilitiesCopyWithImpl<InlayHintClientCapabilities>(this as InlayHintClientCapabilities, _$identity);

  /// Serializes this InlayHintClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlayHintClientCapabilities&&(identical(other.resolveSupport, resolveSupport) || other.resolveSupport == resolveSupport)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,resolveSupport,dynamicRegistration);

@override
String toString() {
  return 'InlayHintClientCapabilities(resolveSupport: $resolveSupport, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $InlayHintClientCapabilitiesCopyWith<$Res>  {
  factory $InlayHintClientCapabilitiesCopyWith(InlayHintClientCapabilities value, $Res Function(InlayHintClientCapabilities) _then) = _$InlayHintClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 ({List<String> properties})? resolveSupport, bool? dynamicRegistration
});




}
/// @nodoc
class _$InlayHintClientCapabilitiesCopyWithImpl<$Res>
    implements $InlayHintClientCapabilitiesCopyWith<$Res> {
  _$InlayHintClientCapabilitiesCopyWithImpl(this._self, this._then);

  final InlayHintClientCapabilities _self;
  final $Res Function(InlayHintClientCapabilities) _then;

/// Create a copy of InlayHintClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? resolveSupport = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
resolveSupport: freezed == resolveSupport ? _self.resolveSupport : resolveSupport // ignore: cast_nullable_to_non_nullable
as ({List<String> properties})?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _InlayHintClientCapabilities implements InlayHintClientCapabilities {
  const _InlayHintClientCapabilities({this.resolveSupport, this.dynamicRegistration});
  factory _InlayHintClientCapabilities.fromJson(Map<String, dynamic> json) => _$InlayHintClientCapabilitiesFromJson(json);

@override final  ({List<String> properties})? resolveSupport;
@override final  bool? dynamicRegistration;

/// Create a copy of InlayHintClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlayHintClientCapabilitiesCopyWith<_InlayHintClientCapabilities> get copyWith => __$InlayHintClientCapabilitiesCopyWithImpl<_InlayHintClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlayHintClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlayHintClientCapabilities&&(identical(other.resolveSupport, resolveSupport) || other.resolveSupport == resolveSupport)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,resolveSupport,dynamicRegistration);

@override
String toString() {
  return 'InlayHintClientCapabilities(resolveSupport: $resolveSupport, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$InlayHintClientCapabilitiesCopyWith<$Res> implements $InlayHintClientCapabilitiesCopyWith<$Res> {
  factory _$InlayHintClientCapabilitiesCopyWith(_InlayHintClientCapabilities value, $Res Function(_InlayHintClientCapabilities) _then) = __$InlayHintClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 ({List<String> properties})? resolveSupport, bool? dynamicRegistration
});




}
/// @nodoc
class __$InlayHintClientCapabilitiesCopyWithImpl<$Res>
    implements _$InlayHintClientCapabilitiesCopyWith<$Res> {
  __$InlayHintClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _InlayHintClientCapabilities _self;
  final $Res Function(_InlayHintClientCapabilities) _then;

/// Create a copy of InlayHintClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? resolveSupport = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_InlayHintClientCapabilities(
resolveSupport: freezed == resolveSupport ? _self.resolveSupport : resolveSupport // ignore: cast_nullable_to_non_nullable
as ({List<String> properties})?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DiagnosticClientCapabilities {

 bool? get relatedDocumentSupport; bool? get dynamicRegistration;
/// Create a copy of DiagnosticClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DiagnosticClientCapabilitiesCopyWith<DiagnosticClientCapabilities> get copyWith => _$DiagnosticClientCapabilitiesCopyWithImpl<DiagnosticClientCapabilities>(this as DiagnosticClientCapabilities, _$identity);

  /// Serializes this DiagnosticClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DiagnosticClientCapabilities&&(identical(other.relatedDocumentSupport, relatedDocumentSupport) || other.relatedDocumentSupport == relatedDocumentSupport)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,relatedDocumentSupport,dynamicRegistration);

@override
String toString() {
  return 'DiagnosticClientCapabilities(relatedDocumentSupport: $relatedDocumentSupport, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $DiagnosticClientCapabilitiesCopyWith<$Res>  {
  factory $DiagnosticClientCapabilitiesCopyWith(DiagnosticClientCapabilities value, $Res Function(DiagnosticClientCapabilities) _then) = _$DiagnosticClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? relatedDocumentSupport, bool? dynamicRegistration
});




}
/// @nodoc
class _$DiagnosticClientCapabilitiesCopyWithImpl<$Res>
    implements $DiagnosticClientCapabilitiesCopyWith<$Res> {
  _$DiagnosticClientCapabilitiesCopyWithImpl(this._self, this._then);

  final DiagnosticClientCapabilities _self;
  final $Res Function(DiagnosticClientCapabilities) _then;

/// Create a copy of DiagnosticClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? relatedDocumentSupport = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
relatedDocumentSupport: freezed == relatedDocumentSupport ? _self.relatedDocumentSupport : relatedDocumentSupport // ignore: cast_nullable_to_non_nullable
as bool?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _DiagnosticClientCapabilities implements DiagnosticClientCapabilities {
  const _DiagnosticClientCapabilities({this.relatedDocumentSupport, this.dynamicRegistration});
  factory _DiagnosticClientCapabilities.fromJson(Map<String, dynamic> json) => _$DiagnosticClientCapabilitiesFromJson(json);

@override final  bool? relatedDocumentSupport;
@override final  bool? dynamicRegistration;

/// Create a copy of DiagnosticClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DiagnosticClientCapabilitiesCopyWith<_DiagnosticClientCapabilities> get copyWith => __$DiagnosticClientCapabilitiesCopyWithImpl<_DiagnosticClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DiagnosticClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DiagnosticClientCapabilities&&(identical(other.relatedDocumentSupport, relatedDocumentSupport) || other.relatedDocumentSupport == relatedDocumentSupport)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,relatedDocumentSupport,dynamicRegistration);

@override
String toString() {
  return 'DiagnosticClientCapabilities(relatedDocumentSupport: $relatedDocumentSupport, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$DiagnosticClientCapabilitiesCopyWith<$Res> implements $DiagnosticClientCapabilitiesCopyWith<$Res> {
  factory _$DiagnosticClientCapabilitiesCopyWith(_DiagnosticClientCapabilities value, $Res Function(_DiagnosticClientCapabilities) _then) = __$DiagnosticClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? relatedDocumentSupport, bool? dynamicRegistration
});




}
/// @nodoc
class __$DiagnosticClientCapabilitiesCopyWithImpl<$Res>
    implements _$DiagnosticClientCapabilitiesCopyWith<$Res> {
  __$DiagnosticClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _DiagnosticClientCapabilities _self;
  final $Res Function(_DiagnosticClientCapabilities) _then;

/// Create a copy of DiagnosticClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? relatedDocumentSupport = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_DiagnosticClientCapabilities(
relatedDocumentSupport: freezed == relatedDocumentSupport ? _self.relatedDocumentSupport : relatedDocumentSupport // ignore: cast_nullable_to_non_nullable
as bool?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$InlineCompletionClientCapabilities {

 bool? get dynamicRegistration;
/// Create a copy of InlineCompletionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlineCompletionClientCapabilitiesCopyWith<InlineCompletionClientCapabilities> get copyWith => _$InlineCompletionClientCapabilitiesCopyWithImpl<InlineCompletionClientCapabilities>(this as InlineCompletionClientCapabilities, _$identity);

  /// Serializes this InlineCompletionClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlineCompletionClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'InlineCompletionClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $InlineCompletionClientCapabilitiesCopyWith<$Res>  {
  factory $InlineCompletionClientCapabilitiesCopyWith(InlineCompletionClientCapabilities value, $Res Function(InlineCompletionClientCapabilities) _then) = _$InlineCompletionClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class _$InlineCompletionClientCapabilitiesCopyWithImpl<$Res>
    implements $InlineCompletionClientCapabilitiesCopyWith<$Res> {
  _$InlineCompletionClientCapabilitiesCopyWithImpl(this._self, this._then);

  final InlineCompletionClientCapabilities _self;
  final $Res Function(InlineCompletionClientCapabilities) _then;

/// Create a copy of InlineCompletionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _InlineCompletionClientCapabilities implements InlineCompletionClientCapabilities {
  const _InlineCompletionClientCapabilities({this.dynamicRegistration});
  factory _InlineCompletionClientCapabilities.fromJson(Map<String, dynamic> json) => _$InlineCompletionClientCapabilitiesFromJson(json);

@override final  bool? dynamicRegistration;

/// Create a copy of InlineCompletionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlineCompletionClientCapabilitiesCopyWith<_InlineCompletionClientCapabilities> get copyWith => __$InlineCompletionClientCapabilitiesCopyWithImpl<_InlineCompletionClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlineCompletionClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlineCompletionClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'InlineCompletionClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$InlineCompletionClientCapabilitiesCopyWith<$Res> implements $InlineCompletionClientCapabilitiesCopyWith<$Res> {
  factory _$InlineCompletionClientCapabilitiesCopyWith(_InlineCompletionClientCapabilities value, $Res Function(_InlineCompletionClientCapabilities) _then) = __$InlineCompletionClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class __$InlineCompletionClientCapabilitiesCopyWithImpl<$Res>
    implements _$InlineCompletionClientCapabilitiesCopyWith<$Res> {
  __$InlineCompletionClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _InlineCompletionClientCapabilities _self;
  final $Res Function(_InlineCompletionClientCapabilities) _then;

/// Create a copy of InlineCompletionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_InlineCompletionClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$NotebookDocumentSyncClientCapabilities {

 bool? get executionSummarySupport; bool? get dynamicRegistration;
/// Create a copy of NotebookDocumentSyncClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$NotebookDocumentSyncClientCapabilitiesCopyWith<NotebookDocumentSyncClientCapabilities> get copyWith => _$NotebookDocumentSyncClientCapabilitiesCopyWithImpl<NotebookDocumentSyncClientCapabilities>(this as NotebookDocumentSyncClientCapabilities, _$identity);

  /// Serializes this NotebookDocumentSyncClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is NotebookDocumentSyncClientCapabilities&&(identical(other.executionSummarySupport, executionSummarySupport) || other.executionSummarySupport == executionSummarySupport)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,executionSummarySupport,dynamicRegistration);

@override
String toString() {
  return 'NotebookDocumentSyncClientCapabilities(executionSummarySupport: $executionSummarySupport, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $NotebookDocumentSyncClientCapabilitiesCopyWith<$Res>  {
  factory $NotebookDocumentSyncClientCapabilitiesCopyWith(NotebookDocumentSyncClientCapabilities value, $Res Function(NotebookDocumentSyncClientCapabilities) _then) = _$NotebookDocumentSyncClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? executionSummarySupport, bool? dynamicRegistration
});




}
/// @nodoc
class _$NotebookDocumentSyncClientCapabilitiesCopyWithImpl<$Res>
    implements $NotebookDocumentSyncClientCapabilitiesCopyWith<$Res> {
  _$NotebookDocumentSyncClientCapabilitiesCopyWithImpl(this._self, this._then);

  final NotebookDocumentSyncClientCapabilities _self;
  final $Res Function(NotebookDocumentSyncClientCapabilities) _then;

/// Create a copy of NotebookDocumentSyncClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? executionSummarySupport = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
executionSummarySupport: freezed == executionSummarySupport ? _self.executionSummarySupport : executionSummarySupport // ignore: cast_nullable_to_non_nullable
as bool?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _NotebookDocumentSyncClientCapabilities implements NotebookDocumentSyncClientCapabilities {
  const _NotebookDocumentSyncClientCapabilities({this.executionSummarySupport, this.dynamicRegistration});
  factory _NotebookDocumentSyncClientCapabilities.fromJson(Map<String, dynamic> json) => _$NotebookDocumentSyncClientCapabilitiesFromJson(json);

@override final  bool? executionSummarySupport;
@override final  bool? dynamicRegistration;

/// Create a copy of NotebookDocumentSyncClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$NotebookDocumentSyncClientCapabilitiesCopyWith<_NotebookDocumentSyncClientCapabilities> get copyWith => __$NotebookDocumentSyncClientCapabilitiesCopyWithImpl<_NotebookDocumentSyncClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$NotebookDocumentSyncClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _NotebookDocumentSyncClientCapabilities&&(identical(other.executionSummarySupport, executionSummarySupport) || other.executionSummarySupport == executionSummarySupport)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,executionSummarySupport,dynamicRegistration);

@override
String toString() {
  return 'NotebookDocumentSyncClientCapabilities(executionSummarySupport: $executionSummarySupport, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$NotebookDocumentSyncClientCapabilitiesCopyWith<$Res> implements $NotebookDocumentSyncClientCapabilitiesCopyWith<$Res> {
  factory _$NotebookDocumentSyncClientCapabilitiesCopyWith(_NotebookDocumentSyncClientCapabilities value, $Res Function(_NotebookDocumentSyncClientCapabilities) _then) = __$NotebookDocumentSyncClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? executionSummarySupport, bool? dynamicRegistration
});




}
/// @nodoc
class __$NotebookDocumentSyncClientCapabilitiesCopyWithImpl<$Res>
    implements _$NotebookDocumentSyncClientCapabilitiesCopyWith<$Res> {
  __$NotebookDocumentSyncClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _NotebookDocumentSyncClientCapabilities _self;
  final $Res Function(_NotebookDocumentSyncClientCapabilities) _then;

/// Create a copy of NotebookDocumentSyncClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? executionSummarySupport = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_NotebookDocumentSyncClientCapabilities(
executionSummarySupport: freezed == executionSummarySupport ? _self.executionSummarySupport : executionSummarySupport // ignore: cast_nullable_to_non_nullable
as bool?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$ShowMessageRequestClientCapabilities {

 ({bool? additionalPropertiesSupport})? get messageActionItem;
/// Create a copy of ShowMessageRequestClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ShowMessageRequestClientCapabilitiesCopyWith<ShowMessageRequestClientCapabilities> get copyWith => _$ShowMessageRequestClientCapabilitiesCopyWithImpl<ShowMessageRequestClientCapabilities>(this as ShowMessageRequestClientCapabilities, _$identity);

  /// Serializes this ShowMessageRequestClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ShowMessageRequestClientCapabilities&&(identical(other.messageActionItem, messageActionItem) || other.messageActionItem == messageActionItem));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,messageActionItem);

@override
String toString() {
  return 'ShowMessageRequestClientCapabilities(messageActionItem: $messageActionItem)';
}


}

/// @nodoc
abstract mixin class $ShowMessageRequestClientCapabilitiesCopyWith<$Res>  {
  factory $ShowMessageRequestClientCapabilitiesCopyWith(ShowMessageRequestClientCapabilities value, $Res Function(ShowMessageRequestClientCapabilities) _then) = _$ShowMessageRequestClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 ({bool? additionalPropertiesSupport})? messageActionItem
});




}
/// @nodoc
class _$ShowMessageRequestClientCapabilitiesCopyWithImpl<$Res>
    implements $ShowMessageRequestClientCapabilitiesCopyWith<$Res> {
  _$ShowMessageRequestClientCapabilitiesCopyWithImpl(this._self, this._then);

  final ShowMessageRequestClientCapabilities _self;
  final $Res Function(ShowMessageRequestClientCapabilities) _then;

/// Create a copy of ShowMessageRequestClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? messageActionItem = freezed,}) {
  return _then(_self.copyWith(
messageActionItem: freezed == messageActionItem ? _self.messageActionItem : messageActionItem // ignore: cast_nullable_to_non_nullable
as ({bool? additionalPropertiesSupport})?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _ShowMessageRequestClientCapabilities implements ShowMessageRequestClientCapabilities {
  const _ShowMessageRequestClientCapabilities({this.messageActionItem});
  factory _ShowMessageRequestClientCapabilities.fromJson(Map<String, dynamic> json) => _$ShowMessageRequestClientCapabilitiesFromJson(json);

@override final  ({bool? additionalPropertiesSupport})? messageActionItem;

/// Create a copy of ShowMessageRequestClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ShowMessageRequestClientCapabilitiesCopyWith<_ShowMessageRequestClientCapabilities> get copyWith => __$ShowMessageRequestClientCapabilitiesCopyWithImpl<_ShowMessageRequestClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ShowMessageRequestClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ShowMessageRequestClientCapabilities&&(identical(other.messageActionItem, messageActionItem) || other.messageActionItem == messageActionItem));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,messageActionItem);

@override
String toString() {
  return 'ShowMessageRequestClientCapabilities(messageActionItem: $messageActionItem)';
}


}

/// @nodoc
abstract mixin class _$ShowMessageRequestClientCapabilitiesCopyWith<$Res> implements $ShowMessageRequestClientCapabilitiesCopyWith<$Res> {
  factory _$ShowMessageRequestClientCapabilitiesCopyWith(_ShowMessageRequestClientCapabilities value, $Res Function(_ShowMessageRequestClientCapabilities) _then) = __$ShowMessageRequestClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 ({bool? additionalPropertiesSupport})? messageActionItem
});




}
/// @nodoc
class __$ShowMessageRequestClientCapabilitiesCopyWithImpl<$Res>
    implements _$ShowMessageRequestClientCapabilitiesCopyWith<$Res> {
  __$ShowMessageRequestClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _ShowMessageRequestClientCapabilities _self;
  final $Res Function(_ShowMessageRequestClientCapabilities) _then;

/// Create a copy of ShowMessageRequestClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? messageActionItem = freezed,}) {
  return _then(_ShowMessageRequestClientCapabilities(
messageActionItem: freezed == messageActionItem ? _self.messageActionItem : messageActionItem // ignore: cast_nullable_to_non_nullable
as ({bool? additionalPropertiesSupport})?,
  ));
}


}


/// @nodoc
mixin _$ShowDocumentClientCapabilities {

 bool get support;
/// Create a copy of ShowDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ShowDocumentClientCapabilitiesCopyWith<ShowDocumentClientCapabilities> get copyWith => _$ShowDocumentClientCapabilitiesCopyWithImpl<ShowDocumentClientCapabilities>(this as ShowDocumentClientCapabilities, _$identity);

  /// Serializes this ShowDocumentClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ShowDocumentClientCapabilities&&(identical(other.support, support) || other.support == support));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,support);

@override
String toString() {
  return 'ShowDocumentClientCapabilities(support: $support)';
}


}

/// @nodoc
abstract mixin class $ShowDocumentClientCapabilitiesCopyWith<$Res>  {
  factory $ShowDocumentClientCapabilitiesCopyWith(ShowDocumentClientCapabilities value, $Res Function(ShowDocumentClientCapabilities) _then) = _$ShowDocumentClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool support
});




}
/// @nodoc
class _$ShowDocumentClientCapabilitiesCopyWithImpl<$Res>
    implements $ShowDocumentClientCapabilitiesCopyWith<$Res> {
  _$ShowDocumentClientCapabilitiesCopyWithImpl(this._self, this._then);

  final ShowDocumentClientCapabilities _self;
  final $Res Function(ShowDocumentClientCapabilities) _then;

/// Create a copy of ShowDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? support = null,}) {
  return _then(_self.copyWith(
support: null == support ? _self.support : support // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _ShowDocumentClientCapabilities implements ShowDocumentClientCapabilities {
  const _ShowDocumentClientCapabilities({required this.support});
  factory _ShowDocumentClientCapabilities.fromJson(Map<String, dynamic> json) => _$ShowDocumentClientCapabilitiesFromJson(json);

@override final  bool support;

/// Create a copy of ShowDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ShowDocumentClientCapabilitiesCopyWith<_ShowDocumentClientCapabilities> get copyWith => __$ShowDocumentClientCapabilitiesCopyWithImpl<_ShowDocumentClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ShowDocumentClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ShowDocumentClientCapabilities&&(identical(other.support, support) || other.support == support));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,support);

@override
String toString() {
  return 'ShowDocumentClientCapabilities(support: $support)';
}


}

/// @nodoc
abstract mixin class _$ShowDocumentClientCapabilitiesCopyWith<$Res> implements $ShowDocumentClientCapabilitiesCopyWith<$Res> {
  factory _$ShowDocumentClientCapabilitiesCopyWith(_ShowDocumentClientCapabilities value, $Res Function(_ShowDocumentClientCapabilities) _then) = __$ShowDocumentClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool support
});




}
/// @nodoc
class __$ShowDocumentClientCapabilitiesCopyWithImpl<$Res>
    implements _$ShowDocumentClientCapabilitiesCopyWith<$Res> {
  __$ShowDocumentClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _ShowDocumentClientCapabilities _self;
  final $Res Function(_ShowDocumentClientCapabilities) _then;

/// Create a copy of ShowDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? support = null,}) {
  return _then(_ShowDocumentClientCapabilities(
support: null == support ? _self.support : support // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}


}


/// @nodoc
mixin _$RegularExpressionsClientCapabilities {

 String get engine; String? get version;
/// Create a copy of RegularExpressionsClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RegularExpressionsClientCapabilitiesCopyWith<RegularExpressionsClientCapabilities> get copyWith => _$RegularExpressionsClientCapabilitiesCopyWithImpl<RegularExpressionsClientCapabilities>(this as RegularExpressionsClientCapabilities, _$identity);

  /// Serializes this RegularExpressionsClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RegularExpressionsClientCapabilities&&(identical(other.engine, engine) || other.engine == engine)&&(identical(other.version, version) || other.version == version));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,engine,version);

@override
String toString() {
  return 'RegularExpressionsClientCapabilities(engine: $engine, version: $version)';
}


}

/// @nodoc
abstract mixin class $RegularExpressionsClientCapabilitiesCopyWith<$Res>  {
  factory $RegularExpressionsClientCapabilitiesCopyWith(RegularExpressionsClientCapabilities value, $Res Function(RegularExpressionsClientCapabilities) _then) = _$RegularExpressionsClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 String engine, String? version
});




}
/// @nodoc
class _$RegularExpressionsClientCapabilitiesCopyWithImpl<$Res>
    implements $RegularExpressionsClientCapabilitiesCopyWith<$Res> {
  _$RegularExpressionsClientCapabilitiesCopyWithImpl(this._self, this._then);

  final RegularExpressionsClientCapabilities _self;
  final $Res Function(RegularExpressionsClientCapabilities) _then;

/// Create a copy of RegularExpressionsClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? engine = null,Object? version = freezed,}) {
  return _then(_self.copyWith(
engine: null == engine ? _self.engine : engine // ignore: cast_nullable_to_non_nullable
as String,version: freezed == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _RegularExpressionsClientCapabilities implements RegularExpressionsClientCapabilities {
  const _RegularExpressionsClientCapabilities({required this.engine, this.version});
  factory _RegularExpressionsClientCapabilities.fromJson(Map<String, dynamic> json) => _$RegularExpressionsClientCapabilitiesFromJson(json);

@override final  String engine;
@override final  String? version;

/// Create a copy of RegularExpressionsClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RegularExpressionsClientCapabilitiesCopyWith<_RegularExpressionsClientCapabilities> get copyWith => __$RegularExpressionsClientCapabilitiesCopyWithImpl<_RegularExpressionsClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$RegularExpressionsClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _RegularExpressionsClientCapabilities&&(identical(other.engine, engine) || other.engine == engine)&&(identical(other.version, version) || other.version == version));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,engine,version);

@override
String toString() {
  return 'RegularExpressionsClientCapabilities(engine: $engine, version: $version)';
}


}

/// @nodoc
abstract mixin class _$RegularExpressionsClientCapabilitiesCopyWith<$Res> implements $RegularExpressionsClientCapabilitiesCopyWith<$Res> {
  factory _$RegularExpressionsClientCapabilitiesCopyWith(_RegularExpressionsClientCapabilities value, $Res Function(_RegularExpressionsClientCapabilities) _then) = __$RegularExpressionsClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 String engine, String? version
});




}
/// @nodoc
class __$RegularExpressionsClientCapabilitiesCopyWithImpl<$Res>
    implements _$RegularExpressionsClientCapabilitiesCopyWith<$Res> {
  __$RegularExpressionsClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _RegularExpressionsClientCapabilities _self;
  final $Res Function(_RegularExpressionsClientCapabilities) _then;

/// Create a copy of RegularExpressionsClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? engine = null,Object? version = freezed,}) {
  return _then(_RegularExpressionsClientCapabilities(
engine: null == engine ? _self.engine : engine // ignore: cast_nullable_to_non_nullable
as String,version: freezed == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$MarkdownClientCapabilities {

 String get parser; List<String>? get allowedTags; String? get version;
/// Create a copy of MarkdownClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$MarkdownClientCapabilitiesCopyWith<MarkdownClientCapabilities> get copyWith => _$MarkdownClientCapabilitiesCopyWithImpl<MarkdownClientCapabilities>(this as MarkdownClientCapabilities, _$identity);

  /// Serializes this MarkdownClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is MarkdownClientCapabilities&&(identical(other.parser, parser) || other.parser == parser)&&const DeepCollectionEquality().equals(other.allowedTags, allowedTags)&&(identical(other.version, version) || other.version == version));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,parser,const DeepCollectionEquality().hash(allowedTags),version);

@override
String toString() {
  return 'MarkdownClientCapabilities(parser: $parser, allowedTags: $allowedTags, version: $version)';
}


}

/// @nodoc
abstract mixin class $MarkdownClientCapabilitiesCopyWith<$Res>  {
  factory $MarkdownClientCapabilitiesCopyWith(MarkdownClientCapabilities value, $Res Function(MarkdownClientCapabilities) _then) = _$MarkdownClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 String parser, List<String>? allowedTags, String? version
});




}
/// @nodoc
class _$MarkdownClientCapabilitiesCopyWithImpl<$Res>
    implements $MarkdownClientCapabilitiesCopyWith<$Res> {
  _$MarkdownClientCapabilitiesCopyWithImpl(this._self, this._then);

  final MarkdownClientCapabilities _self;
  final $Res Function(MarkdownClientCapabilities) _then;

/// Create a copy of MarkdownClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? parser = null,Object? allowedTags = freezed,Object? version = freezed,}) {
  return _then(_self.copyWith(
parser: null == parser ? _self.parser : parser // ignore: cast_nullable_to_non_nullable
as String,allowedTags: freezed == allowedTags ? _self.allowedTags : allowedTags // ignore: cast_nullable_to_non_nullable
as List<String>?,version: freezed == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc

@JsonSerializable(disallowUnrecognizedKeys: true, includeIfNull: false)
class _MarkdownClientCapabilities implements MarkdownClientCapabilities {
  const _MarkdownClientCapabilities({required this.parser, final  List<String>? allowedTags, this.version}): _allowedTags = allowedTags;
  factory _MarkdownClientCapabilities.fromJson(Map<String, dynamic> json) => _$MarkdownClientCapabilitiesFromJson(json);

@override final  String parser;
 final  List<String>? _allowedTags;
@override List<String>? get allowedTags {
  final value = _allowedTags;
  if (value == null) return null;
  if (_allowedTags is EqualUnmodifiableListView) return _allowedTags;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

@override final  String? version;

/// Create a copy of MarkdownClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$MarkdownClientCapabilitiesCopyWith<_MarkdownClientCapabilities> get copyWith => __$MarkdownClientCapabilitiesCopyWithImpl<_MarkdownClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$MarkdownClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _MarkdownClientCapabilities&&(identical(other.parser, parser) || other.parser == parser)&&const DeepCollectionEquality().equals(other._allowedTags, _allowedTags)&&(identical(other.version, version) || other.version == version));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,parser,const DeepCollectionEquality().hash(_allowedTags),version);

@override
String toString() {
  return 'MarkdownClientCapabilities(parser: $parser, allowedTags: $allowedTags, version: $version)';
}


}

/// @nodoc
abstract mixin class _$MarkdownClientCapabilitiesCopyWith<$Res> implements $MarkdownClientCapabilitiesCopyWith<$Res> {
  factory _$MarkdownClientCapabilitiesCopyWith(_MarkdownClientCapabilities value, $Res Function(_MarkdownClientCapabilities) _then) = __$MarkdownClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 String parser, List<String>? allowedTags, String? version
});




}
/// @nodoc
class __$MarkdownClientCapabilitiesCopyWithImpl<$Res>
    implements _$MarkdownClientCapabilitiesCopyWith<$Res> {
  __$MarkdownClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _MarkdownClientCapabilities _self;
  final $Res Function(_MarkdownClientCapabilities) _then;

/// Create a copy of MarkdownClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? parser = null,Object? allowedTags = freezed,Object? version = freezed,}) {
  return _then(_MarkdownClientCapabilities(
parser: null == parser ? _self.parser : parser // ignore: cast_nullable_to_non_nullable
as String,allowedTags: freezed == allowedTags ? _self._allowedTags : allowedTags // ignore: cast_nullable_to_non_nullable
as List<String>?,version: freezed == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}

// dart format on
