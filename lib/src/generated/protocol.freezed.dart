// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'protocol.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$ImplementationParams {

/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
 ProgressToken? get partialResultToken;/// The position inside the text document.
 Position get position;/// The text document.
 TextDocumentIdentifier get textDocument;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of ImplementationParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ImplementationParamsCopyWith<ImplementationParams> get copyWith => _$ImplementationParamsCopyWithImpl<ImplementationParams>(this as ImplementationParams, _$identity);

  /// Serializes this ImplementationParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ImplementationParams&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.position, position) || other.position == position)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,partialResultToken,position,textDocument,workDoneToken);

@override
String toString() {
  return 'ImplementationParams(partialResultToken: $partialResultToken, position: $position, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $ImplementationParamsCopyWith<$Res>  {
  factory $ImplementationParamsCopyWith(ImplementationParams value, $Res Function(ImplementationParams) _then) = _$ImplementationParamsCopyWithImpl;
@useResult
$Res call({
 ProgressToken? partialResultToken, Position position, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


$PositionCopyWith<$Res> get position;$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$ImplementationParamsCopyWithImpl<$Res>
    implements $ImplementationParamsCopyWith<$Res> {
  _$ImplementationParamsCopyWithImpl(this._self, this._then);

  final ImplementationParams _self;
  final $Res Function(ImplementationParams) _then;

/// Create a copy of ImplementationParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? partialResultToken = freezed,Object? position = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of ImplementationParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of ImplementationParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _ImplementationParams implements ImplementationParams {
  const _ImplementationParams({this.partialResultToken, required this.position, required this.textDocument, this.workDoneToken});
  factory _ImplementationParams.fromJson(Map<String, dynamic> json) => _$ImplementationParamsFromJson(json);

/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
@override final  ProgressToken? partialResultToken;
/// The position inside the text document.
@override final  Position position;
/// The text document.
@override final  TextDocumentIdentifier textDocument;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of ImplementationParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ImplementationParamsCopyWith<_ImplementationParams> get copyWith => __$ImplementationParamsCopyWithImpl<_ImplementationParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ImplementationParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ImplementationParams&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.position, position) || other.position == position)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,partialResultToken,position,textDocument,workDoneToken);

@override
String toString() {
  return 'ImplementationParams(partialResultToken: $partialResultToken, position: $position, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$ImplementationParamsCopyWith<$Res> implements $ImplementationParamsCopyWith<$Res> {
  factory _$ImplementationParamsCopyWith(_ImplementationParams value, $Res Function(_ImplementationParams) _then) = __$ImplementationParamsCopyWithImpl;
@override @useResult
$Res call({
 ProgressToken? partialResultToken, Position position, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


@override $PositionCopyWith<$Res> get position;@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$ImplementationParamsCopyWithImpl<$Res>
    implements _$ImplementationParamsCopyWith<$Res> {
  __$ImplementationParamsCopyWithImpl(this._self, this._then);

  final _ImplementationParams _self;
  final $Res Function(_ImplementationParams) _then;

/// Create a copy of ImplementationParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? partialResultToken = freezed,Object? position = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_ImplementationParams(
partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of ImplementationParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of ImplementationParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$Location {

 Range get range; String get uri;
/// Create a copy of Location
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LocationCopyWith<Location> get copyWith => _$LocationCopyWithImpl<Location>(this as Location, _$identity);

  /// Serializes this Location to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Location&&(identical(other.range, range) || other.range == range)&&(identical(other.uri, uri) || other.uri == uri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,range,uri);

@override
String toString() {
  return 'Location(range: $range, uri: $uri)';
}


}

/// @nodoc
abstract mixin class $LocationCopyWith<$Res>  {
  factory $LocationCopyWith(Location value, $Res Function(Location) _then) = _$LocationCopyWithImpl;
@useResult
$Res call({
 Range range, String uri
});


$RangeCopyWith<$Res> get range;

}
/// @nodoc
class _$LocationCopyWithImpl<$Res>
    implements $LocationCopyWith<$Res> {
  _$LocationCopyWithImpl(this._self, this._then);

  final Location _self;
  final $Res Function(Location) _then;

/// Create a copy of Location
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? range = null,Object? uri = null,}) {
  return _then(_self.copyWith(
range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}
/// Create a copy of Location
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _Location implements Location {
  const _Location({required this.range, required this.uri});
  factory _Location.fromJson(Map<String, dynamic> json) => _$LocationFromJson(json);

@override final  Range range;
@override final  String uri;

/// Create a copy of Location
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$LocationCopyWith<_Location> get copyWith => __$LocationCopyWithImpl<_Location>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$LocationToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _Location&&(identical(other.range, range) || other.range == range)&&(identical(other.uri, uri) || other.uri == uri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,range,uri);

@override
String toString() {
  return 'Location(range: $range, uri: $uri)';
}


}

/// @nodoc
abstract mixin class _$LocationCopyWith<$Res> implements $LocationCopyWith<$Res> {
  factory _$LocationCopyWith(_Location value, $Res Function(_Location) _then) = __$LocationCopyWithImpl;
@override @useResult
$Res call({
 Range range, String uri
});


@override $RangeCopyWith<$Res> get range;

}
/// @nodoc
class __$LocationCopyWithImpl<$Res>
    implements _$LocationCopyWith<$Res> {
  __$LocationCopyWithImpl(this._self, this._then);

  final _Location _self;
  final $Res Function(_Location) _then;

/// Create a copy of Location
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? range = null,Object? uri = null,}) {
  return _then(_Location(
range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

/// Create a copy of Location
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}


/// @nodoc
mixin _$ImplementationRegistrationOptions {

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
 Sealed14 get documentSelector;/// The id used to register the request. The id can be used to deregister
/// the request again. See also Registration#id.
 String? get id;
/// Create a copy of ImplementationRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ImplementationRegistrationOptionsCopyWith<ImplementationRegistrationOptions> get copyWith => _$ImplementationRegistrationOptionsCopyWithImpl<ImplementationRegistrationOptions>(this as ImplementationRegistrationOptions, _$identity);

  /// Serializes this ImplementationRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ImplementationRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.id, id) || other.id == id));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,id);

@override
String toString() {
  return 'ImplementationRegistrationOptions(documentSelector: $documentSelector, id: $id)';
}


}

/// @nodoc
abstract mixin class $ImplementationRegistrationOptionsCopyWith<$Res>  {
  factory $ImplementationRegistrationOptionsCopyWith(ImplementationRegistrationOptions value, $Res Function(ImplementationRegistrationOptions) _then) = _$ImplementationRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 Sealed14 documentSelector, String? id
});




}
/// @nodoc
class _$ImplementationRegistrationOptionsCopyWithImpl<$Res>
    implements $ImplementationRegistrationOptionsCopyWith<$Res> {
  _$ImplementationRegistrationOptionsCopyWithImpl(this._self, this._then);

  final ImplementationRegistrationOptions _self;
  final $Res Function(ImplementationRegistrationOptions) _then;

/// Create a copy of ImplementationRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = null,Object? id = freezed,}) {
  return _then(_self.copyWith(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _ImplementationRegistrationOptions implements ImplementationRegistrationOptions {
  const _ImplementationRegistrationOptions({required this.documentSelector, this.id});
  factory _ImplementationRegistrationOptions.fromJson(Map<String, dynamic> json) => _$ImplementationRegistrationOptionsFromJson(json);

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
@override final  Sealed14 documentSelector;
/// The id used to register the request. The id can be used to deregister
/// the request again. See also Registration#id.
@override final  String? id;

/// Create a copy of ImplementationRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ImplementationRegistrationOptionsCopyWith<_ImplementationRegistrationOptions> get copyWith => __$ImplementationRegistrationOptionsCopyWithImpl<_ImplementationRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ImplementationRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ImplementationRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.id, id) || other.id == id));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,id);

@override
String toString() {
  return 'ImplementationRegistrationOptions(documentSelector: $documentSelector, id: $id)';
}


}

/// @nodoc
abstract mixin class _$ImplementationRegistrationOptionsCopyWith<$Res> implements $ImplementationRegistrationOptionsCopyWith<$Res> {
  factory _$ImplementationRegistrationOptionsCopyWith(_ImplementationRegistrationOptions value, $Res Function(_ImplementationRegistrationOptions) _then) = __$ImplementationRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 Sealed14 documentSelector, String? id
});




}
/// @nodoc
class __$ImplementationRegistrationOptionsCopyWithImpl<$Res>
    implements _$ImplementationRegistrationOptionsCopyWith<$Res> {
  __$ImplementationRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _ImplementationRegistrationOptions _self;
  final $Res Function(_ImplementationRegistrationOptions) _then;

/// Create a copy of ImplementationRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = null,Object? id = freezed,}) {
  return _then(_ImplementationRegistrationOptions(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$TypeDefinitionParams {

/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
 ProgressToken? get partialResultToken;/// The position inside the text document.
 Position get position;/// The text document.
 TextDocumentIdentifier get textDocument;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of TypeDefinitionParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TypeDefinitionParamsCopyWith<TypeDefinitionParams> get copyWith => _$TypeDefinitionParamsCopyWithImpl<TypeDefinitionParams>(this as TypeDefinitionParams, _$identity);

  /// Serializes this TypeDefinitionParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TypeDefinitionParams&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.position, position) || other.position == position)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,partialResultToken,position,textDocument,workDoneToken);

@override
String toString() {
  return 'TypeDefinitionParams(partialResultToken: $partialResultToken, position: $position, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $TypeDefinitionParamsCopyWith<$Res>  {
  factory $TypeDefinitionParamsCopyWith(TypeDefinitionParams value, $Res Function(TypeDefinitionParams) _then) = _$TypeDefinitionParamsCopyWithImpl;
@useResult
$Res call({
 ProgressToken? partialResultToken, Position position, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


$PositionCopyWith<$Res> get position;$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$TypeDefinitionParamsCopyWithImpl<$Res>
    implements $TypeDefinitionParamsCopyWith<$Res> {
  _$TypeDefinitionParamsCopyWithImpl(this._self, this._then);

  final TypeDefinitionParams _self;
  final $Res Function(TypeDefinitionParams) _then;

/// Create a copy of TypeDefinitionParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? partialResultToken = freezed,Object? position = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of TypeDefinitionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of TypeDefinitionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _TypeDefinitionParams implements TypeDefinitionParams {
  const _TypeDefinitionParams({this.partialResultToken, required this.position, required this.textDocument, this.workDoneToken});
  factory _TypeDefinitionParams.fromJson(Map<String, dynamic> json) => _$TypeDefinitionParamsFromJson(json);

/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
@override final  ProgressToken? partialResultToken;
/// The position inside the text document.
@override final  Position position;
/// The text document.
@override final  TextDocumentIdentifier textDocument;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of TypeDefinitionParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TypeDefinitionParamsCopyWith<_TypeDefinitionParams> get copyWith => __$TypeDefinitionParamsCopyWithImpl<_TypeDefinitionParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TypeDefinitionParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TypeDefinitionParams&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.position, position) || other.position == position)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,partialResultToken,position,textDocument,workDoneToken);

@override
String toString() {
  return 'TypeDefinitionParams(partialResultToken: $partialResultToken, position: $position, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$TypeDefinitionParamsCopyWith<$Res> implements $TypeDefinitionParamsCopyWith<$Res> {
  factory _$TypeDefinitionParamsCopyWith(_TypeDefinitionParams value, $Res Function(_TypeDefinitionParams) _then) = __$TypeDefinitionParamsCopyWithImpl;
@override @useResult
$Res call({
 ProgressToken? partialResultToken, Position position, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


@override $PositionCopyWith<$Res> get position;@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$TypeDefinitionParamsCopyWithImpl<$Res>
    implements _$TypeDefinitionParamsCopyWith<$Res> {
  __$TypeDefinitionParamsCopyWithImpl(this._self, this._then);

  final _TypeDefinitionParams _self;
  final $Res Function(_TypeDefinitionParams) _then;

/// Create a copy of TypeDefinitionParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? partialResultToken = freezed,Object? position = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_TypeDefinitionParams(
partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of TypeDefinitionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of TypeDefinitionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$TypeDefinitionRegistrationOptions {

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
 Sealed14 get documentSelector;/// The id used to register the request. The id can be used to deregister
/// the request again. See also Registration#id.
 String? get id;
/// Create a copy of TypeDefinitionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TypeDefinitionRegistrationOptionsCopyWith<TypeDefinitionRegistrationOptions> get copyWith => _$TypeDefinitionRegistrationOptionsCopyWithImpl<TypeDefinitionRegistrationOptions>(this as TypeDefinitionRegistrationOptions, _$identity);

  /// Serializes this TypeDefinitionRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TypeDefinitionRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.id, id) || other.id == id));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,id);

@override
String toString() {
  return 'TypeDefinitionRegistrationOptions(documentSelector: $documentSelector, id: $id)';
}


}

/// @nodoc
abstract mixin class $TypeDefinitionRegistrationOptionsCopyWith<$Res>  {
  factory $TypeDefinitionRegistrationOptionsCopyWith(TypeDefinitionRegistrationOptions value, $Res Function(TypeDefinitionRegistrationOptions) _then) = _$TypeDefinitionRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 Sealed14 documentSelector, String? id
});




}
/// @nodoc
class _$TypeDefinitionRegistrationOptionsCopyWithImpl<$Res>
    implements $TypeDefinitionRegistrationOptionsCopyWith<$Res> {
  _$TypeDefinitionRegistrationOptionsCopyWithImpl(this._self, this._then);

  final TypeDefinitionRegistrationOptions _self;
  final $Res Function(TypeDefinitionRegistrationOptions) _then;

/// Create a copy of TypeDefinitionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = null,Object? id = freezed,}) {
  return _then(_self.copyWith(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _TypeDefinitionRegistrationOptions implements TypeDefinitionRegistrationOptions {
  const _TypeDefinitionRegistrationOptions({required this.documentSelector, this.id});
  factory _TypeDefinitionRegistrationOptions.fromJson(Map<String, dynamic> json) => _$TypeDefinitionRegistrationOptionsFromJson(json);

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
@override final  Sealed14 documentSelector;
/// The id used to register the request. The id can be used to deregister
/// the request again. See also Registration#id.
@override final  String? id;

/// Create a copy of TypeDefinitionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TypeDefinitionRegistrationOptionsCopyWith<_TypeDefinitionRegistrationOptions> get copyWith => __$TypeDefinitionRegistrationOptionsCopyWithImpl<_TypeDefinitionRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TypeDefinitionRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TypeDefinitionRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.id, id) || other.id == id));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,id);

@override
String toString() {
  return 'TypeDefinitionRegistrationOptions(documentSelector: $documentSelector, id: $id)';
}


}

/// @nodoc
abstract mixin class _$TypeDefinitionRegistrationOptionsCopyWith<$Res> implements $TypeDefinitionRegistrationOptionsCopyWith<$Res> {
  factory _$TypeDefinitionRegistrationOptionsCopyWith(_TypeDefinitionRegistrationOptions value, $Res Function(_TypeDefinitionRegistrationOptions) _then) = __$TypeDefinitionRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 Sealed14 documentSelector, String? id
});




}
/// @nodoc
class __$TypeDefinitionRegistrationOptionsCopyWithImpl<$Res>
    implements _$TypeDefinitionRegistrationOptionsCopyWith<$Res> {
  __$TypeDefinitionRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _TypeDefinitionRegistrationOptions _self;
  final $Res Function(_TypeDefinitionRegistrationOptions) _then;

/// Create a copy of TypeDefinitionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = null,Object? id = freezed,}) {
  return _then(_TypeDefinitionRegistrationOptions(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$WorkspaceFolder {

/// The name of the workspace folder. Used to refer to this workspace
/// folder in the user interface.
 String get name;/// The associated URI for this workspace folder.
 String get uri;
/// Create a copy of WorkspaceFolder
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkspaceFolderCopyWith<WorkspaceFolder> get copyWith => _$WorkspaceFolderCopyWithImpl<WorkspaceFolder>(this as WorkspaceFolder, _$identity);

  /// Serializes this WorkspaceFolder to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkspaceFolder&&(identical(other.name, name) || other.name == name)&&(identical(other.uri, uri) || other.uri == uri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,name,uri);

@override
String toString() {
  return 'WorkspaceFolder(name: $name, uri: $uri)';
}


}

/// @nodoc
abstract mixin class $WorkspaceFolderCopyWith<$Res>  {
  factory $WorkspaceFolderCopyWith(WorkspaceFolder value, $Res Function(WorkspaceFolder) _then) = _$WorkspaceFolderCopyWithImpl;
@useResult
$Res call({
 String name, String uri
});




}
/// @nodoc
class _$WorkspaceFolderCopyWithImpl<$Res>
    implements $WorkspaceFolderCopyWith<$Res> {
  _$WorkspaceFolderCopyWithImpl(this._self, this._then);

  final WorkspaceFolder _self;
  final $Res Function(WorkspaceFolder) _then;

/// Create a copy of WorkspaceFolder
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? name = null,Object? uri = null,}) {
  return _then(_self.copyWith(
name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _WorkspaceFolder implements WorkspaceFolder {
  const _WorkspaceFolder({required this.name, required this.uri});
  factory _WorkspaceFolder.fromJson(Map<String, dynamic> json) => _$WorkspaceFolderFromJson(json);

/// The name of the workspace folder. Used to refer to this workspace
/// folder in the user interface.
@override final  String name;
/// The associated URI for this workspace folder.
@override final  String uri;

/// Create a copy of WorkspaceFolder
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkspaceFolderCopyWith<_WorkspaceFolder> get copyWith => __$WorkspaceFolderCopyWithImpl<_WorkspaceFolder>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkspaceFolderToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkspaceFolder&&(identical(other.name, name) || other.name == name)&&(identical(other.uri, uri) || other.uri == uri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,name,uri);

@override
String toString() {
  return 'WorkspaceFolder(name: $name, uri: $uri)';
}


}

/// @nodoc
abstract mixin class _$WorkspaceFolderCopyWith<$Res> implements $WorkspaceFolderCopyWith<$Res> {
  factory _$WorkspaceFolderCopyWith(_WorkspaceFolder value, $Res Function(_WorkspaceFolder) _then) = __$WorkspaceFolderCopyWithImpl;
@override @useResult
$Res call({
 String name, String uri
});




}
/// @nodoc
class __$WorkspaceFolderCopyWithImpl<$Res>
    implements _$WorkspaceFolderCopyWith<$Res> {
  __$WorkspaceFolderCopyWithImpl(this._self, this._then);

  final _WorkspaceFolder _self;
  final $Res Function(_WorkspaceFolder) _then;

/// Create a copy of WorkspaceFolder
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? name = null,Object? uri = null,}) {
  return _then(_WorkspaceFolder(
name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}


/// @nodoc
mixin _$DidChangeWorkspaceFoldersParams {

/// The actual workspace folder change event.
 WorkspaceFoldersChangeEvent get event;
/// Create a copy of DidChangeWorkspaceFoldersParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DidChangeWorkspaceFoldersParamsCopyWith<DidChangeWorkspaceFoldersParams> get copyWith => _$DidChangeWorkspaceFoldersParamsCopyWithImpl<DidChangeWorkspaceFoldersParams>(this as DidChangeWorkspaceFoldersParams, _$identity);

  /// Serializes this DidChangeWorkspaceFoldersParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DidChangeWorkspaceFoldersParams&&(identical(other.event, event) || other.event == event));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,event);

@override
String toString() {
  return 'DidChangeWorkspaceFoldersParams(event: $event)';
}


}

/// @nodoc
abstract mixin class $DidChangeWorkspaceFoldersParamsCopyWith<$Res>  {
  factory $DidChangeWorkspaceFoldersParamsCopyWith(DidChangeWorkspaceFoldersParams value, $Res Function(DidChangeWorkspaceFoldersParams) _then) = _$DidChangeWorkspaceFoldersParamsCopyWithImpl;
@useResult
$Res call({
 WorkspaceFoldersChangeEvent event
});


$WorkspaceFoldersChangeEventCopyWith<$Res> get event;

}
/// @nodoc
class _$DidChangeWorkspaceFoldersParamsCopyWithImpl<$Res>
    implements $DidChangeWorkspaceFoldersParamsCopyWith<$Res> {
  _$DidChangeWorkspaceFoldersParamsCopyWithImpl(this._self, this._then);

  final DidChangeWorkspaceFoldersParams _self;
  final $Res Function(DidChangeWorkspaceFoldersParams) _then;

/// Create a copy of DidChangeWorkspaceFoldersParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? event = null,}) {
  return _then(_self.copyWith(
event: null == event ? _self.event : event // ignore: cast_nullable_to_non_nullable
as WorkspaceFoldersChangeEvent,
  ));
}
/// Create a copy of DidChangeWorkspaceFoldersParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$WorkspaceFoldersChangeEventCopyWith<$Res> get event {
  
  return $WorkspaceFoldersChangeEventCopyWith<$Res>(_self.event, (value) {
    return _then(_self.copyWith(event: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _DidChangeWorkspaceFoldersParams implements DidChangeWorkspaceFoldersParams {
  const _DidChangeWorkspaceFoldersParams({required this.event});
  factory _DidChangeWorkspaceFoldersParams.fromJson(Map<String, dynamic> json) => _$DidChangeWorkspaceFoldersParamsFromJson(json);

/// The actual workspace folder change event.
@override final  WorkspaceFoldersChangeEvent event;

/// Create a copy of DidChangeWorkspaceFoldersParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DidChangeWorkspaceFoldersParamsCopyWith<_DidChangeWorkspaceFoldersParams> get copyWith => __$DidChangeWorkspaceFoldersParamsCopyWithImpl<_DidChangeWorkspaceFoldersParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DidChangeWorkspaceFoldersParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DidChangeWorkspaceFoldersParams&&(identical(other.event, event) || other.event == event));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,event);

@override
String toString() {
  return 'DidChangeWorkspaceFoldersParams(event: $event)';
}


}

/// @nodoc
abstract mixin class _$DidChangeWorkspaceFoldersParamsCopyWith<$Res> implements $DidChangeWorkspaceFoldersParamsCopyWith<$Res> {
  factory _$DidChangeWorkspaceFoldersParamsCopyWith(_DidChangeWorkspaceFoldersParams value, $Res Function(_DidChangeWorkspaceFoldersParams) _then) = __$DidChangeWorkspaceFoldersParamsCopyWithImpl;
@override @useResult
$Res call({
 WorkspaceFoldersChangeEvent event
});


@override $WorkspaceFoldersChangeEventCopyWith<$Res> get event;

}
/// @nodoc
class __$DidChangeWorkspaceFoldersParamsCopyWithImpl<$Res>
    implements _$DidChangeWorkspaceFoldersParamsCopyWith<$Res> {
  __$DidChangeWorkspaceFoldersParamsCopyWithImpl(this._self, this._then);

  final _DidChangeWorkspaceFoldersParams _self;
  final $Res Function(_DidChangeWorkspaceFoldersParams) _then;

/// Create a copy of DidChangeWorkspaceFoldersParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? event = null,}) {
  return _then(_DidChangeWorkspaceFoldersParams(
event: null == event ? _self.event : event // ignore: cast_nullable_to_non_nullable
as WorkspaceFoldersChangeEvent,
  ));
}

/// Create a copy of DidChangeWorkspaceFoldersParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$WorkspaceFoldersChangeEventCopyWith<$Res> get event {
  
  return $WorkspaceFoldersChangeEventCopyWith<$Res>(_self.event, (value) {
    return _then(_self.copyWith(event: value));
  });
}
}


/// @nodoc
mixin _$ConfigurationParams {

 List<ConfigurationItem> get items;
/// Create a copy of ConfigurationParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ConfigurationParamsCopyWith<ConfigurationParams> get copyWith => _$ConfigurationParamsCopyWithImpl<ConfigurationParams>(this as ConfigurationParams, _$identity);

  /// Serializes this ConfigurationParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ConfigurationParams&&const DeepCollectionEquality().equals(other.items, items));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(items));

@override
String toString() {
  return 'ConfigurationParams(items: $items)';
}


}

/// @nodoc
abstract mixin class $ConfigurationParamsCopyWith<$Res>  {
  factory $ConfigurationParamsCopyWith(ConfigurationParams value, $Res Function(ConfigurationParams) _then) = _$ConfigurationParamsCopyWithImpl;
@useResult
$Res call({
 List<ConfigurationItem> items
});




}
/// @nodoc
class _$ConfigurationParamsCopyWithImpl<$Res>
    implements $ConfigurationParamsCopyWith<$Res> {
  _$ConfigurationParamsCopyWithImpl(this._self, this._then);

  final ConfigurationParams _self;
  final $Res Function(ConfigurationParams) _then;

/// Create a copy of ConfigurationParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? items = null,}) {
  return _then(_self.copyWith(
items: null == items ? _self.items : items // ignore: cast_nullable_to_non_nullable
as List<ConfigurationItem>,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _ConfigurationParams implements ConfigurationParams {
  const _ConfigurationParams({required final  List<ConfigurationItem> items}): _items = items;
  factory _ConfigurationParams.fromJson(Map<String, dynamic> json) => _$ConfigurationParamsFromJson(json);

 final  List<ConfigurationItem> _items;
@override List<ConfigurationItem> get items {
  if (_items is EqualUnmodifiableListView) return _items;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_items);
}


/// Create a copy of ConfigurationParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ConfigurationParamsCopyWith<_ConfigurationParams> get copyWith => __$ConfigurationParamsCopyWithImpl<_ConfigurationParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ConfigurationParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ConfigurationParams&&const DeepCollectionEquality().equals(other._items, _items));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_items));

@override
String toString() {
  return 'ConfigurationParams(items: $items)';
}


}

/// @nodoc
abstract mixin class _$ConfigurationParamsCopyWith<$Res> implements $ConfigurationParamsCopyWith<$Res> {
  factory _$ConfigurationParamsCopyWith(_ConfigurationParams value, $Res Function(_ConfigurationParams) _then) = __$ConfigurationParamsCopyWithImpl;
@override @useResult
$Res call({
 List<ConfigurationItem> items
});




}
/// @nodoc
class __$ConfigurationParamsCopyWithImpl<$Res>
    implements _$ConfigurationParamsCopyWith<$Res> {
  __$ConfigurationParamsCopyWithImpl(this._self, this._then);

  final _ConfigurationParams _self;
  final $Res Function(_ConfigurationParams) _then;

/// Create a copy of ConfigurationParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? items = null,}) {
  return _then(_ConfigurationParams(
items: null == items ? _self._items : items // ignore: cast_nullable_to_non_nullable
as List<ConfigurationItem>,
  ));
}


}


/// @nodoc
mixin _$DocumentColorParams {

/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
 ProgressToken? get partialResultToken;/// The text document.
 TextDocumentIdentifier get textDocument;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of DocumentColorParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentColorParamsCopyWith<DocumentColorParams> get copyWith => _$DocumentColorParamsCopyWithImpl<DocumentColorParams>(this as DocumentColorParams, _$identity);

  /// Serializes this DocumentColorParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentColorParams&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,partialResultToken,textDocument,workDoneToken);

@override
String toString() {
  return 'DocumentColorParams(partialResultToken: $partialResultToken, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $DocumentColorParamsCopyWith<$Res>  {
  factory $DocumentColorParamsCopyWith(DocumentColorParams value, $Res Function(DocumentColorParams) _then) = _$DocumentColorParamsCopyWithImpl;
@useResult
$Res call({
 ProgressToken? partialResultToken, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$DocumentColorParamsCopyWithImpl<$Res>
    implements $DocumentColorParamsCopyWith<$Res> {
  _$DocumentColorParamsCopyWithImpl(this._self, this._then);

  final DocumentColorParams _self;
  final $Res Function(DocumentColorParams) _then;

/// Create a copy of DocumentColorParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? partialResultToken = freezed,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of DocumentColorParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _DocumentColorParams implements DocumentColorParams {
  const _DocumentColorParams({this.partialResultToken, required this.textDocument, this.workDoneToken});
  factory _DocumentColorParams.fromJson(Map<String, dynamic> json) => _$DocumentColorParamsFromJson(json);

/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
@override final  ProgressToken? partialResultToken;
/// The text document.
@override final  TextDocumentIdentifier textDocument;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of DocumentColorParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentColorParamsCopyWith<_DocumentColorParams> get copyWith => __$DocumentColorParamsCopyWithImpl<_DocumentColorParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentColorParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentColorParams&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,partialResultToken,textDocument,workDoneToken);

@override
String toString() {
  return 'DocumentColorParams(partialResultToken: $partialResultToken, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$DocumentColorParamsCopyWith<$Res> implements $DocumentColorParamsCopyWith<$Res> {
  factory _$DocumentColorParamsCopyWith(_DocumentColorParams value, $Res Function(_DocumentColorParams) _then) = __$DocumentColorParamsCopyWithImpl;
@override @useResult
$Res call({
 ProgressToken? partialResultToken, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$DocumentColorParamsCopyWithImpl<$Res>
    implements _$DocumentColorParamsCopyWith<$Res> {
  __$DocumentColorParamsCopyWithImpl(this._self, this._then);

  final _DocumentColorParams _self;
  final $Res Function(_DocumentColorParams) _then;

/// Create a copy of DocumentColorParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? partialResultToken = freezed,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_DocumentColorParams(
partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of DocumentColorParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$ColorInformation {

/// The actual color value for this color range.
 Color get color;/// The range in the document where this color appears.
 Range get range;
/// Create a copy of ColorInformation
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ColorInformationCopyWith<ColorInformation> get copyWith => _$ColorInformationCopyWithImpl<ColorInformation>(this as ColorInformation, _$identity);

  /// Serializes this ColorInformation to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ColorInformation&&(identical(other.color, color) || other.color == color)&&(identical(other.range, range) || other.range == range));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,color,range);

@override
String toString() {
  return 'ColorInformation(color: $color, range: $range)';
}


}

/// @nodoc
abstract mixin class $ColorInformationCopyWith<$Res>  {
  factory $ColorInformationCopyWith(ColorInformation value, $Res Function(ColorInformation) _then) = _$ColorInformationCopyWithImpl;
@useResult
$Res call({
 Color color, Range range
});


$ColorCopyWith<$Res> get color;$RangeCopyWith<$Res> get range;

}
/// @nodoc
class _$ColorInformationCopyWithImpl<$Res>
    implements $ColorInformationCopyWith<$Res> {
  _$ColorInformationCopyWithImpl(this._self, this._then);

  final ColorInformation _self;
  final $Res Function(ColorInformation) _then;

/// Create a copy of ColorInformation
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? color = null,Object? range = null,}) {
  return _then(_self.copyWith(
color: null == color ? _self.color : color // ignore: cast_nullable_to_non_nullable
as Color,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,
  ));
}
/// Create a copy of ColorInformation
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ColorCopyWith<$Res> get color {
  
  return $ColorCopyWith<$Res>(_self.color, (value) {
    return _then(_self.copyWith(color: value));
  });
}/// Create a copy of ColorInformation
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _ColorInformation implements ColorInformation {
  const _ColorInformation({required this.color, required this.range});
  factory _ColorInformation.fromJson(Map<String, dynamic> json) => _$ColorInformationFromJson(json);

/// The actual color value for this color range.
@override final  Color color;
/// The range in the document where this color appears.
@override final  Range range;

/// Create a copy of ColorInformation
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ColorInformationCopyWith<_ColorInformation> get copyWith => __$ColorInformationCopyWithImpl<_ColorInformation>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ColorInformationToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ColorInformation&&(identical(other.color, color) || other.color == color)&&(identical(other.range, range) || other.range == range));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,color,range);

@override
String toString() {
  return 'ColorInformation(color: $color, range: $range)';
}


}

/// @nodoc
abstract mixin class _$ColorInformationCopyWith<$Res> implements $ColorInformationCopyWith<$Res> {
  factory _$ColorInformationCopyWith(_ColorInformation value, $Res Function(_ColorInformation) _then) = __$ColorInformationCopyWithImpl;
@override @useResult
$Res call({
 Color color, Range range
});


@override $ColorCopyWith<$Res> get color;@override $RangeCopyWith<$Res> get range;

}
/// @nodoc
class __$ColorInformationCopyWithImpl<$Res>
    implements _$ColorInformationCopyWith<$Res> {
  __$ColorInformationCopyWithImpl(this._self, this._then);

  final _ColorInformation _self;
  final $Res Function(_ColorInformation) _then;

/// Create a copy of ColorInformation
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? color = null,Object? range = null,}) {
  return _then(_ColorInformation(
color: null == color ? _self.color : color // ignore: cast_nullable_to_non_nullable
as Color,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,
  ));
}

/// Create a copy of ColorInformation
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ColorCopyWith<$Res> get color {
  
  return $ColorCopyWith<$Res>(_self.color, (value) {
    return _then(_self.copyWith(color: value));
  });
}/// Create a copy of ColorInformation
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}


/// @nodoc
mixin _$DocumentColorRegistrationOptions {

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
 Sealed14 get documentSelector;/// The id used to register the request. The id can be used to deregister
/// the request again. See also Registration#id.
 String? get id;
/// Create a copy of DocumentColorRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentColorRegistrationOptionsCopyWith<DocumentColorRegistrationOptions> get copyWith => _$DocumentColorRegistrationOptionsCopyWithImpl<DocumentColorRegistrationOptions>(this as DocumentColorRegistrationOptions, _$identity);

  /// Serializes this DocumentColorRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentColorRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.id, id) || other.id == id));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,id);

@override
String toString() {
  return 'DocumentColorRegistrationOptions(documentSelector: $documentSelector, id: $id)';
}


}

/// @nodoc
abstract mixin class $DocumentColorRegistrationOptionsCopyWith<$Res>  {
  factory $DocumentColorRegistrationOptionsCopyWith(DocumentColorRegistrationOptions value, $Res Function(DocumentColorRegistrationOptions) _then) = _$DocumentColorRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 Sealed14 documentSelector, String? id
});




}
/// @nodoc
class _$DocumentColorRegistrationOptionsCopyWithImpl<$Res>
    implements $DocumentColorRegistrationOptionsCopyWith<$Res> {
  _$DocumentColorRegistrationOptionsCopyWithImpl(this._self, this._then);

  final DocumentColorRegistrationOptions _self;
  final $Res Function(DocumentColorRegistrationOptions) _then;

/// Create a copy of DocumentColorRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = null,Object? id = freezed,}) {
  return _then(_self.copyWith(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DocumentColorRegistrationOptions implements DocumentColorRegistrationOptions {
  const _DocumentColorRegistrationOptions({required this.documentSelector, this.id});
  factory _DocumentColorRegistrationOptions.fromJson(Map<String, dynamic> json) => _$DocumentColorRegistrationOptionsFromJson(json);

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
@override final  Sealed14 documentSelector;
/// The id used to register the request. The id can be used to deregister
/// the request again. See also Registration#id.
@override final  String? id;

/// Create a copy of DocumentColorRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentColorRegistrationOptionsCopyWith<_DocumentColorRegistrationOptions> get copyWith => __$DocumentColorRegistrationOptionsCopyWithImpl<_DocumentColorRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentColorRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentColorRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.id, id) || other.id == id));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,id);

@override
String toString() {
  return 'DocumentColorRegistrationOptions(documentSelector: $documentSelector, id: $id)';
}


}

/// @nodoc
abstract mixin class _$DocumentColorRegistrationOptionsCopyWith<$Res> implements $DocumentColorRegistrationOptionsCopyWith<$Res> {
  factory _$DocumentColorRegistrationOptionsCopyWith(_DocumentColorRegistrationOptions value, $Res Function(_DocumentColorRegistrationOptions) _then) = __$DocumentColorRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 Sealed14 documentSelector, String? id
});




}
/// @nodoc
class __$DocumentColorRegistrationOptionsCopyWithImpl<$Res>
    implements _$DocumentColorRegistrationOptionsCopyWith<$Res> {
  __$DocumentColorRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _DocumentColorRegistrationOptions _self;
  final $Res Function(_DocumentColorRegistrationOptions) _then;

/// Create a copy of DocumentColorRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = null,Object? id = freezed,}) {
  return _then(_DocumentColorRegistrationOptions(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$ColorPresentationParams {

/// The color to request presentations for.
 Color get color;/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
 ProgressToken? get partialResultToken;/// The range where the color would be inserted. Serves as a context.
 Range get range;/// The text document.
 TextDocumentIdentifier get textDocument;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of ColorPresentationParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ColorPresentationParamsCopyWith<ColorPresentationParams> get copyWith => _$ColorPresentationParamsCopyWithImpl<ColorPresentationParams>(this as ColorPresentationParams, _$identity);

  /// Serializes this ColorPresentationParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ColorPresentationParams&&(identical(other.color, color) || other.color == color)&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.range, range) || other.range == range)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,color,partialResultToken,range,textDocument,workDoneToken);

@override
String toString() {
  return 'ColorPresentationParams(color: $color, partialResultToken: $partialResultToken, range: $range, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $ColorPresentationParamsCopyWith<$Res>  {
  factory $ColorPresentationParamsCopyWith(ColorPresentationParams value, $Res Function(ColorPresentationParams) _then) = _$ColorPresentationParamsCopyWithImpl;
@useResult
$Res call({
 Color color, ProgressToken? partialResultToken, Range range, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


$ColorCopyWith<$Res> get color;$RangeCopyWith<$Res> get range;$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$ColorPresentationParamsCopyWithImpl<$Res>
    implements $ColorPresentationParamsCopyWith<$Res> {
  _$ColorPresentationParamsCopyWithImpl(this._self, this._then);

  final ColorPresentationParams _self;
  final $Res Function(ColorPresentationParams) _then;

/// Create a copy of ColorPresentationParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? color = null,Object? partialResultToken = freezed,Object? range = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
color: null == color ? _self.color : color // ignore: cast_nullable_to_non_nullable
as Color,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of ColorPresentationParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ColorCopyWith<$Res> get color {
  
  return $ColorCopyWith<$Res>(_self.color, (value) {
    return _then(_self.copyWith(color: value));
  });
}/// Create a copy of ColorPresentationParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}/// Create a copy of ColorPresentationParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _ColorPresentationParams implements ColorPresentationParams {
  const _ColorPresentationParams({required this.color, this.partialResultToken, required this.range, required this.textDocument, this.workDoneToken});
  factory _ColorPresentationParams.fromJson(Map<String, dynamic> json) => _$ColorPresentationParamsFromJson(json);

/// The color to request presentations for.
@override final  Color color;
/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
@override final  ProgressToken? partialResultToken;
/// The range where the color would be inserted. Serves as a context.
@override final  Range range;
/// The text document.
@override final  TextDocumentIdentifier textDocument;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of ColorPresentationParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ColorPresentationParamsCopyWith<_ColorPresentationParams> get copyWith => __$ColorPresentationParamsCopyWithImpl<_ColorPresentationParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ColorPresentationParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ColorPresentationParams&&(identical(other.color, color) || other.color == color)&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.range, range) || other.range == range)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,color,partialResultToken,range,textDocument,workDoneToken);

@override
String toString() {
  return 'ColorPresentationParams(color: $color, partialResultToken: $partialResultToken, range: $range, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$ColorPresentationParamsCopyWith<$Res> implements $ColorPresentationParamsCopyWith<$Res> {
  factory _$ColorPresentationParamsCopyWith(_ColorPresentationParams value, $Res Function(_ColorPresentationParams) _then) = __$ColorPresentationParamsCopyWithImpl;
@override @useResult
$Res call({
 Color color, ProgressToken? partialResultToken, Range range, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


@override $ColorCopyWith<$Res> get color;@override $RangeCopyWith<$Res> get range;@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$ColorPresentationParamsCopyWithImpl<$Res>
    implements _$ColorPresentationParamsCopyWith<$Res> {
  __$ColorPresentationParamsCopyWithImpl(this._self, this._then);

  final _ColorPresentationParams _self;
  final $Res Function(_ColorPresentationParams) _then;

/// Create a copy of ColorPresentationParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? color = null,Object? partialResultToken = freezed,Object? range = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_ColorPresentationParams(
color: null == color ? _self.color : color // ignore: cast_nullable_to_non_nullable
as Color,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of ColorPresentationParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ColorCopyWith<$Res> get color {
  
  return $ColorCopyWith<$Res>(_self.color, (value) {
    return _then(_self.copyWith(color: value));
  });
}/// Create a copy of ColorPresentationParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}/// Create a copy of ColorPresentationParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$ColorPresentation {

/// An optional array of additional {@link TextEdit text edits} that are
/// applied when selecting this color presentation. Edits must not overlap
/// with the main {@link ColorPresentation.textEdit edit} nor with
/// themselves.
 List<TextEdit>? get additionalTextEdits;/// The label of this color presentation. It will be shown on the color
/// picker header. By default this is also the text that is inserted when
/// selecting this color presentation.
 String get label;/// An {@link TextEdit edit} which is applied to a document when selecting
/// this presentation for the color. When `falsy` the {@link
/// ColorPresentation.label label} is used.
 TextEdit? get textEdit;
/// Create a copy of ColorPresentation
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ColorPresentationCopyWith<ColorPresentation> get copyWith => _$ColorPresentationCopyWithImpl<ColorPresentation>(this as ColorPresentation, _$identity);

  /// Serializes this ColorPresentation to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ColorPresentation&&const DeepCollectionEquality().equals(other.additionalTextEdits, additionalTextEdits)&&(identical(other.label, label) || other.label == label)&&(identical(other.textEdit, textEdit) || other.textEdit == textEdit));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(additionalTextEdits),label,textEdit);

@override
String toString() {
  return 'ColorPresentation(additionalTextEdits: $additionalTextEdits, label: $label, textEdit: $textEdit)';
}


}

/// @nodoc
abstract mixin class $ColorPresentationCopyWith<$Res>  {
  factory $ColorPresentationCopyWith(ColorPresentation value, $Res Function(ColorPresentation) _then) = _$ColorPresentationCopyWithImpl;
@useResult
$Res call({
 List<TextEdit>? additionalTextEdits, String label, TextEdit? textEdit
});


$TextEditCopyWith<$Res>? get textEdit;

}
/// @nodoc
class _$ColorPresentationCopyWithImpl<$Res>
    implements $ColorPresentationCopyWith<$Res> {
  _$ColorPresentationCopyWithImpl(this._self, this._then);

  final ColorPresentation _self;
  final $Res Function(ColorPresentation) _then;

/// Create a copy of ColorPresentation
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? additionalTextEdits = freezed,Object? label = null,Object? textEdit = freezed,}) {
  return _then(_self.copyWith(
additionalTextEdits: freezed == additionalTextEdits ? _self.additionalTextEdits : additionalTextEdits // ignore: cast_nullable_to_non_nullable
as List<TextEdit>?,label: null == label ? _self.label : label // ignore: cast_nullable_to_non_nullable
as String,textEdit: freezed == textEdit ? _self.textEdit : textEdit // ignore: cast_nullable_to_non_nullable
as TextEdit?,
  ));
}
/// Create a copy of ColorPresentation
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextEditCopyWith<$Res>? get textEdit {
    if (_self.textEdit == null) {
    return null;
  }

  return $TextEditCopyWith<$Res>(_self.textEdit!, (value) {
    return _then(_self.copyWith(textEdit: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _ColorPresentation implements ColorPresentation {
  const _ColorPresentation({final  List<TextEdit>? additionalTextEdits, required this.label, this.textEdit}): _additionalTextEdits = additionalTextEdits;
  factory _ColorPresentation.fromJson(Map<String, dynamic> json) => _$ColorPresentationFromJson(json);

/// An optional array of additional {@link TextEdit text edits} that are
/// applied when selecting this color presentation. Edits must not overlap
/// with the main {@link ColorPresentation.textEdit edit} nor with
/// themselves.
 final  List<TextEdit>? _additionalTextEdits;
/// An optional array of additional {@link TextEdit text edits} that are
/// applied when selecting this color presentation. Edits must not overlap
/// with the main {@link ColorPresentation.textEdit edit} nor with
/// themselves.
@override List<TextEdit>? get additionalTextEdits {
  final value = _additionalTextEdits;
  if (value == null) return null;
  if (_additionalTextEdits is EqualUnmodifiableListView) return _additionalTextEdits;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

/// The label of this color presentation. It will be shown on the color
/// picker header. By default this is also the text that is inserted when
/// selecting this color presentation.
@override final  String label;
/// An {@link TextEdit edit} which is applied to a document when selecting
/// this presentation for the color. When `falsy` the {@link
/// ColorPresentation.label label} is used.
@override final  TextEdit? textEdit;

/// Create a copy of ColorPresentation
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ColorPresentationCopyWith<_ColorPresentation> get copyWith => __$ColorPresentationCopyWithImpl<_ColorPresentation>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ColorPresentationToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ColorPresentation&&const DeepCollectionEquality().equals(other._additionalTextEdits, _additionalTextEdits)&&(identical(other.label, label) || other.label == label)&&(identical(other.textEdit, textEdit) || other.textEdit == textEdit));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_additionalTextEdits),label,textEdit);

@override
String toString() {
  return 'ColorPresentation(additionalTextEdits: $additionalTextEdits, label: $label, textEdit: $textEdit)';
}


}

/// @nodoc
abstract mixin class _$ColorPresentationCopyWith<$Res> implements $ColorPresentationCopyWith<$Res> {
  factory _$ColorPresentationCopyWith(_ColorPresentation value, $Res Function(_ColorPresentation) _then) = __$ColorPresentationCopyWithImpl;
@override @useResult
$Res call({
 List<TextEdit>? additionalTextEdits, String label, TextEdit? textEdit
});


@override $TextEditCopyWith<$Res>? get textEdit;

}
/// @nodoc
class __$ColorPresentationCopyWithImpl<$Res>
    implements _$ColorPresentationCopyWith<$Res> {
  __$ColorPresentationCopyWithImpl(this._self, this._then);

  final _ColorPresentation _self;
  final $Res Function(_ColorPresentation) _then;

/// Create a copy of ColorPresentation
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? additionalTextEdits = freezed,Object? label = null,Object? textEdit = freezed,}) {
  return _then(_ColorPresentation(
additionalTextEdits: freezed == additionalTextEdits ? _self._additionalTextEdits : additionalTextEdits // ignore: cast_nullable_to_non_nullable
as List<TextEdit>?,label: null == label ? _self.label : label // ignore: cast_nullable_to_non_nullable
as String,textEdit: freezed == textEdit ? _self.textEdit : textEdit // ignore: cast_nullable_to_non_nullable
as TextEdit?,
  ));
}

/// Create a copy of ColorPresentation
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextEditCopyWith<$Res>? get textEdit {
    if (_self.textEdit == null) {
    return null;
  }

  return $TextEditCopyWith<$Res>(_self.textEdit!, (value) {
    return _then(_self.copyWith(textEdit: value));
  });
}
}


/// @nodoc
mixin _$WorkDoneProgressOptions {

 bool? get workDoneProgress;
/// Create a copy of WorkDoneProgressOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkDoneProgressOptionsCopyWith<WorkDoneProgressOptions> get copyWith => _$WorkDoneProgressOptionsCopyWithImpl<WorkDoneProgressOptions>(this as WorkDoneProgressOptions, _$identity);

  /// Serializes this WorkDoneProgressOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkDoneProgressOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'WorkDoneProgressOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $WorkDoneProgressOptionsCopyWith<$Res>  {
  factory $WorkDoneProgressOptionsCopyWith(WorkDoneProgressOptions value, $Res Function(WorkDoneProgressOptions) _then) = _$WorkDoneProgressOptionsCopyWithImpl;
@useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class _$WorkDoneProgressOptionsCopyWithImpl<$Res>
    implements $WorkDoneProgressOptionsCopyWith<$Res> {
  _$WorkDoneProgressOptionsCopyWithImpl(this._self, this._then);

  final WorkDoneProgressOptions _self;
  final $Res Function(WorkDoneProgressOptions) _then;

/// Create a copy of WorkDoneProgressOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _WorkDoneProgressOptions implements WorkDoneProgressOptions {
  const _WorkDoneProgressOptions({this.workDoneProgress});
  factory _WorkDoneProgressOptions.fromJson(Map<String, dynamic> json) => _$WorkDoneProgressOptionsFromJson(json);

@override final  bool? workDoneProgress;

/// Create a copy of WorkDoneProgressOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkDoneProgressOptionsCopyWith<_WorkDoneProgressOptions> get copyWith => __$WorkDoneProgressOptionsCopyWithImpl<_WorkDoneProgressOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkDoneProgressOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkDoneProgressOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'WorkDoneProgressOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$WorkDoneProgressOptionsCopyWith<$Res> implements $WorkDoneProgressOptionsCopyWith<$Res> {
  factory _$WorkDoneProgressOptionsCopyWith(_WorkDoneProgressOptions value, $Res Function(_WorkDoneProgressOptions) _then) = __$WorkDoneProgressOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class __$WorkDoneProgressOptionsCopyWithImpl<$Res>
    implements _$WorkDoneProgressOptionsCopyWith<$Res> {
  __$WorkDoneProgressOptionsCopyWithImpl(this._self, this._then);

  final _WorkDoneProgressOptions _self;
  final $Res Function(_WorkDoneProgressOptions) _then;

/// Create a copy of WorkDoneProgressOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_WorkDoneProgressOptions(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$TextDocumentRegistrationOptions {

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
 Sealed14 get documentSelector;
/// Create a copy of TextDocumentRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TextDocumentRegistrationOptionsCopyWith<TextDocumentRegistrationOptions> get copyWith => _$TextDocumentRegistrationOptionsCopyWithImpl<TextDocumentRegistrationOptions>(this as TextDocumentRegistrationOptions, _$identity);

  /// Serializes this TextDocumentRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TextDocumentRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector);

@override
String toString() {
  return 'TextDocumentRegistrationOptions(documentSelector: $documentSelector)';
}


}

/// @nodoc
abstract mixin class $TextDocumentRegistrationOptionsCopyWith<$Res>  {
  factory $TextDocumentRegistrationOptionsCopyWith(TextDocumentRegistrationOptions value, $Res Function(TextDocumentRegistrationOptions) _then) = _$TextDocumentRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 Sealed14 documentSelector
});




}
/// @nodoc
class _$TextDocumentRegistrationOptionsCopyWithImpl<$Res>
    implements $TextDocumentRegistrationOptionsCopyWith<$Res> {
  _$TextDocumentRegistrationOptionsCopyWithImpl(this._self, this._then);

  final TextDocumentRegistrationOptions _self;
  final $Res Function(TextDocumentRegistrationOptions) _then;

/// Create a copy of TextDocumentRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = null,}) {
  return _then(_self.copyWith(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _TextDocumentRegistrationOptions implements TextDocumentRegistrationOptions {
  const _TextDocumentRegistrationOptions({required this.documentSelector});
  factory _TextDocumentRegistrationOptions.fromJson(Map<String, dynamic> json) => _$TextDocumentRegistrationOptionsFromJson(json);

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
@override final  Sealed14 documentSelector;

/// Create a copy of TextDocumentRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TextDocumentRegistrationOptionsCopyWith<_TextDocumentRegistrationOptions> get copyWith => __$TextDocumentRegistrationOptionsCopyWithImpl<_TextDocumentRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TextDocumentRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TextDocumentRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector);

@override
String toString() {
  return 'TextDocumentRegistrationOptions(documentSelector: $documentSelector)';
}


}

/// @nodoc
abstract mixin class _$TextDocumentRegistrationOptionsCopyWith<$Res> implements $TextDocumentRegistrationOptionsCopyWith<$Res> {
  factory _$TextDocumentRegistrationOptionsCopyWith(_TextDocumentRegistrationOptions value, $Res Function(_TextDocumentRegistrationOptions) _then) = __$TextDocumentRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 Sealed14 documentSelector
});




}
/// @nodoc
class __$TextDocumentRegistrationOptionsCopyWithImpl<$Res>
    implements _$TextDocumentRegistrationOptionsCopyWith<$Res> {
  __$TextDocumentRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _TextDocumentRegistrationOptions _self;
  final $Res Function(_TextDocumentRegistrationOptions) _then;

/// Create a copy of TextDocumentRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = null,}) {
  return _then(_TextDocumentRegistrationOptions(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,
  ));
}


}


/// @nodoc
mixin _$FoldingRangeParams {

/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
 ProgressToken? get partialResultToken;/// The text document.
 TextDocumentIdentifier get textDocument;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of FoldingRangeParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FoldingRangeParamsCopyWith<FoldingRangeParams> get copyWith => _$FoldingRangeParamsCopyWithImpl<FoldingRangeParams>(this as FoldingRangeParams, _$identity);

  /// Serializes this FoldingRangeParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FoldingRangeParams&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,partialResultToken,textDocument,workDoneToken);

@override
String toString() {
  return 'FoldingRangeParams(partialResultToken: $partialResultToken, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $FoldingRangeParamsCopyWith<$Res>  {
  factory $FoldingRangeParamsCopyWith(FoldingRangeParams value, $Res Function(FoldingRangeParams) _then) = _$FoldingRangeParamsCopyWithImpl;
@useResult
$Res call({
 ProgressToken? partialResultToken, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$FoldingRangeParamsCopyWithImpl<$Res>
    implements $FoldingRangeParamsCopyWith<$Res> {
  _$FoldingRangeParamsCopyWithImpl(this._self, this._then);

  final FoldingRangeParams _self;
  final $Res Function(FoldingRangeParams) _then;

/// Create a copy of FoldingRangeParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? partialResultToken = freezed,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of FoldingRangeParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _FoldingRangeParams implements FoldingRangeParams {
  const _FoldingRangeParams({this.partialResultToken, required this.textDocument, this.workDoneToken});
  factory _FoldingRangeParams.fromJson(Map<String, dynamic> json) => _$FoldingRangeParamsFromJson(json);

/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
@override final  ProgressToken? partialResultToken;
/// The text document.
@override final  TextDocumentIdentifier textDocument;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of FoldingRangeParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$FoldingRangeParamsCopyWith<_FoldingRangeParams> get copyWith => __$FoldingRangeParamsCopyWithImpl<_FoldingRangeParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$FoldingRangeParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _FoldingRangeParams&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,partialResultToken,textDocument,workDoneToken);

@override
String toString() {
  return 'FoldingRangeParams(partialResultToken: $partialResultToken, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$FoldingRangeParamsCopyWith<$Res> implements $FoldingRangeParamsCopyWith<$Res> {
  factory _$FoldingRangeParamsCopyWith(_FoldingRangeParams value, $Res Function(_FoldingRangeParams) _then) = __$FoldingRangeParamsCopyWithImpl;
@override @useResult
$Res call({
 ProgressToken? partialResultToken, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$FoldingRangeParamsCopyWithImpl<$Res>
    implements _$FoldingRangeParamsCopyWith<$Res> {
  __$FoldingRangeParamsCopyWithImpl(this._self, this._then);

  final _FoldingRangeParams _self;
  final $Res Function(_FoldingRangeParams) _then;

/// Create a copy of FoldingRangeParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? partialResultToken = freezed,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_FoldingRangeParams(
partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of FoldingRangeParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$FoldingRange {

/// The text that the client should show when the specified range is
/// collapsed. If not defined or not supported by the client, a default
/// will be chosen by the client.
/// @since 3.17.0
 String? get collapsedText;/// The zero-based character offset before the folded range ends. If not
/// defined, defaults to the length of the end line.
 int? get endCharacter;/// The zero-based end line of the range to fold. The folded area ends with
/// the line's last character. To be valid, the end must be zero or larger
/// and smaller than the number of lines in the document.
 int get endLine;/// Describes the kind of the folding range such as `comment' or 'region'.
/// The kind is used to categorize folding ranges and used by commands like
/// 'Fold all comments'. See {@link FoldingRangeKind} for an enumeration of
/// standardized kinds.
 FoldingRangeKind? get kind;/// The zero-based character offset from where the folded range starts. If
/// not defined, defaults to the length of the start line.
 int? get startCharacter;/// The zero-based start line of the range to fold. The folded area starts
/// after the line's last character. To be valid, the end must be zero or
/// larger and smaller than the number of lines in the document.
 int get startLine;
/// Create a copy of FoldingRange
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FoldingRangeCopyWith<FoldingRange> get copyWith => _$FoldingRangeCopyWithImpl<FoldingRange>(this as FoldingRange, _$identity);

  /// Serializes this FoldingRange to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FoldingRange&&(identical(other.collapsedText, collapsedText) || other.collapsedText == collapsedText)&&(identical(other.endCharacter, endCharacter) || other.endCharacter == endCharacter)&&(identical(other.endLine, endLine) || other.endLine == endLine)&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.startCharacter, startCharacter) || other.startCharacter == startCharacter)&&(identical(other.startLine, startLine) || other.startLine == startLine));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,collapsedText,endCharacter,endLine,kind,startCharacter,startLine);

@override
String toString() {
  return 'FoldingRange(collapsedText: $collapsedText, endCharacter: $endCharacter, endLine: $endLine, kind: $kind, startCharacter: $startCharacter, startLine: $startLine)';
}


}

/// @nodoc
abstract mixin class $FoldingRangeCopyWith<$Res>  {
  factory $FoldingRangeCopyWith(FoldingRange value, $Res Function(FoldingRange) _then) = _$FoldingRangeCopyWithImpl;
@useResult
$Res call({
 String? collapsedText, int? endCharacter, int endLine, FoldingRangeKind? kind, int? startCharacter, int startLine
});




}
/// @nodoc
class _$FoldingRangeCopyWithImpl<$Res>
    implements $FoldingRangeCopyWith<$Res> {
  _$FoldingRangeCopyWithImpl(this._self, this._then);

  final FoldingRange _self;
  final $Res Function(FoldingRange) _then;

/// Create a copy of FoldingRange
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? collapsedText = freezed,Object? endCharacter = freezed,Object? endLine = null,Object? kind = freezed,Object? startCharacter = freezed,Object? startLine = null,}) {
  return _then(_self.copyWith(
collapsedText: freezed == collapsedText ? _self.collapsedText : collapsedText // ignore: cast_nullable_to_non_nullable
as String?,endCharacter: freezed == endCharacter ? _self.endCharacter : endCharacter // ignore: cast_nullable_to_non_nullable
as int?,endLine: null == endLine ? _self.endLine : endLine // ignore: cast_nullable_to_non_nullable
as int,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as FoldingRangeKind?,startCharacter: freezed == startCharacter ? _self.startCharacter : startCharacter // ignore: cast_nullable_to_non_nullable
as int?,startLine: null == startLine ? _self.startLine : startLine // ignore: cast_nullable_to_non_nullable
as int,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _FoldingRange implements FoldingRange {
  const _FoldingRange({this.collapsedText, this.endCharacter, required this.endLine, this.kind, this.startCharacter, required this.startLine});
  factory _FoldingRange.fromJson(Map<String, dynamic> json) => _$FoldingRangeFromJson(json);

/// The text that the client should show when the specified range is
/// collapsed. If not defined or not supported by the client, a default
/// will be chosen by the client.
/// @since 3.17.0
@override final  String? collapsedText;
/// The zero-based character offset before the folded range ends. If not
/// defined, defaults to the length of the end line.
@override final  int? endCharacter;
/// The zero-based end line of the range to fold. The folded area ends with
/// the line's last character. To be valid, the end must be zero or larger
/// and smaller than the number of lines in the document.
@override final  int endLine;
/// Describes the kind of the folding range such as `comment' or 'region'.
/// The kind is used to categorize folding ranges and used by commands like
/// 'Fold all comments'. See {@link FoldingRangeKind} for an enumeration of
/// standardized kinds.
@override final  FoldingRangeKind? kind;
/// The zero-based character offset from where the folded range starts. If
/// not defined, defaults to the length of the start line.
@override final  int? startCharacter;
/// The zero-based start line of the range to fold. The folded area starts
/// after the line's last character. To be valid, the end must be zero or
/// larger and smaller than the number of lines in the document.
@override final  int startLine;

/// Create a copy of FoldingRange
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$FoldingRangeCopyWith<_FoldingRange> get copyWith => __$FoldingRangeCopyWithImpl<_FoldingRange>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$FoldingRangeToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _FoldingRange&&(identical(other.collapsedText, collapsedText) || other.collapsedText == collapsedText)&&(identical(other.endCharacter, endCharacter) || other.endCharacter == endCharacter)&&(identical(other.endLine, endLine) || other.endLine == endLine)&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.startCharacter, startCharacter) || other.startCharacter == startCharacter)&&(identical(other.startLine, startLine) || other.startLine == startLine));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,collapsedText,endCharacter,endLine,kind,startCharacter,startLine);

@override
String toString() {
  return 'FoldingRange(collapsedText: $collapsedText, endCharacter: $endCharacter, endLine: $endLine, kind: $kind, startCharacter: $startCharacter, startLine: $startLine)';
}


}

/// @nodoc
abstract mixin class _$FoldingRangeCopyWith<$Res> implements $FoldingRangeCopyWith<$Res> {
  factory _$FoldingRangeCopyWith(_FoldingRange value, $Res Function(_FoldingRange) _then) = __$FoldingRangeCopyWithImpl;
@override @useResult
$Res call({
 String? collapsedText, int? endCharacter, int endLine, FoldingRangeKind? kind, int? startCharacter, int startLine
});




}
/// @nodoc
class __$FoldingRangeCopyWithImpl<$Res>
    implements _$FoldingRangeCopyWith<$Res> {
  __$FoldingRangeCopyWithImpl(this._self, this._then);

  final _FoldingRange _self;
  final $Res Function(_FoldingRange) _then;

/// Create a copy of FoldingRange
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? collapsedText = freezed,Object? endCharacter = freezed,Object? endLine = null,Object? kind = freezed,Object? startCharacter = freezed,Object? startLine = null,}) {
  return _then(_FoldingRange(
collapsedText: freezed == collapsedText ? _self.collapsedText : collapsedText // ignore: cast_nullable_to_non_nullable
as String?,endCharacter: freezed == endCharacter ? _self.endCharacter : endCharacter // ignore: cast_nullable_to_non_nullable
as int?,endLine: null == endLine ? _self.endLine : endLine // ignore: cast_nullable_to_non_nullable
as int,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as FoldingRangeKind?,startCharacter: freezed == startCharacter ? _self.startCharacter : startCharacter // ignore: cast_nullable_to_non_nullable
as int?,startLine: null == startLine ? _self.startLine : startLine // ignore: cast_nullable_to_non_nullable
as int,
  ));
}


}


/// @nodoc
mixin _$FoldingRangeRegistrationOptions {

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
 Sealed14 get documentSelector;/// The id used to register the request. The id can be used to deregister
/// the request again. See also Registration#id.
 String? get id;
/// Create a copy of FoldingRangeRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FoldingRangeRegistrationOptionsCopyWith<FoldingRangeRegistrationOptions> get copyWith => _$FoldingRangeRegistrationOptionsCopyWithImpl<FoldingRangeRegistrationOptions>(this as FoldingRangeRegistrationOptions, _$identity);

  /// Serializes this FoldingRangeRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FoldingRangeRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.id, id) || other.id == id));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,id);

@override
String toString() {
  return 'FoldingRangeRegistrationOptions(documentSelector: $documentSelector, id: $id)';
}


}

/// @nodoc
abstract mixin class $FoldingRangeRegistrationOptionsCopyWith<$Res>  {
  factory $FoldingRangeRegistrationOptionsCopyWith(FoldingRangeRegistrationOptions value, $Res Function(FoldingRangeRegistrationOptions) _then) = _$FoldingRangeRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 Sealed14 documentSelector, String? id
});




}
/// @nodoc
class _$FoldingRangeRegistrationOptionsCopyWithImpl<$Res>
    implements $FoldingRangeRegistrationOptionsCopyWith<$Res> {
  _$FoldingRangeRegistrationOptionsCopyWithImpl(this._self, this._then);

  final FoldingRangeRegistrationOptions _self;
  final $Res Function(FoldingRangeRegistrationOptions) _then;

/// Create a copy of FoldingRangeRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = null,Object? id = freezed,}) {
  return _then(_self.copyWith(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _FoldingRangeRegistrationOptions implements FoldingRangeRegistrationOptions {
  const _FoldingRangeRegistrationOptions({required this.documentSelector, this.id});
  factory _FoldingRangeRegistrationOptions.fromJson(Map<String, dynamic> json) => _$FoldingRangeRegistrationOptionsFromJson(json);

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
@override final  Sealed14 documentSelector;
/// The id used to register the request. The id can be used to deregister
/// the request again. See also Registration#id.
@override final  String? id;

/// Create a copy of FoldingRangeRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$FoldingRangeRegistrationOptionsCopyWith<_FoldingRangeRegistrationOptions> get copyWith => __$FoldingRangeRegistrationOptionsCopyWithImpl<_FoldingRangeRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$FoldingRangeRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _FoldingRangeRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.id, id) || other.id == id));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,id);

@override
String toString() {
  return 'FoldingRangeRegistrationOptions(documentSelector: $documentSelector, id: $id)';
}


}

/// @nodoc
abstract mixin class _$FoldingRangeRegistrationOptionsCopyWith<$Res> implements $FoldingRangeRegistrationOptionsCopyWith<$Res> {
  factory _$FoldingRangeRegistrationOptionsCopyWith(_FoldingRangeRegistrationOptions value, $Res Function(_FoldingRangeRegistrationOptions) _then) = __$FoldingRangeRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 Sealed14 documentSelector, String? id
});




}
/// @nodoc
class __$FoldingRangeRegistrationOptionsCopyWithImpl<$Res>
    implements _$FoldingRangeRegistrationOptionsCopyWith<$Res> {
  __$FoldingRangeRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _FoldingRangeRegistrationOptions _self;
  final $Res Function(_FoldingRangeRegistrationOptions) _then;

/// Create a copy of FoldingRangeRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = null,Object? id = freezed,}) {
  return _then(_FoldingRangeRegistrationOptions(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$DeclarationParams {

/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
 ProgressToken? get partialResultToken;/// The position inside the text document.
 Position get position;/// The text document.
 TextDocumentIdentifier get textDocument;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of DeclarationParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DeclarationParamsCopyWith<DeclarationParams> get copyWith => _$DeclarationParamsCopyWithImpl<DeclarationParams>(this as DeclarationParams, _$identity);

  /// Serializes this DeclarationParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DeclarationParams&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.position, position) || other.position == position)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,partialResultToken,position,textDocument,workDoneToken);

@override
String toString() {
  return 'DeclarationParams(partialResultToken: $partialResultToken, position: $position, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $DeclarationParamsCopyWith<$Res>  {
  factory $DeclarationParamsCopyWith(DeclarationParams value, $Res Function(DeclarationParams) _then) = _$DeclarationParamsCopyWithImpl;
@useResult
$Res call({
 ProgressToken? partialResultToken, Position position, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


$PositionCopyWith<$Res> get position;$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$DeclarationParamsCopyWithImpl<$Res>
    implements $DeclarationParamsCopyWith<$Res> {
  _$DeclarationParamsCopyWithImpl(this._self, this._then);

  final DeclarationParams _self;
  final $Res Function(DeclarationParams) _then;

/// Create a copy of DeclarationParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? partialResultToken = freezed,Object? position = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of DeclarationParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of DeclarationParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _DeclarationParams implements DeclarationParams {
  const _DeclarationParams({this.partialResultToken, required this.position, required this.textDocument, this.workDoneToken});
  factory _DeclarationParams.fromJson(Map<String, dynamic> json) => _$DeclarationParamsFromJson(json);

/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
@override final  ProgressToken? partialResultToken;
/// The position inside the text document.
@override final  Position position;
/// The text document.
@override final  TextDocumentIdentifier textDocument;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of DeclarationParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DeclarationParamsCopyWith<_DeclarationParams> get copyWith => __$DeclarationParamsCopyWithImpl<_DeclarationParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DeclarationParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DeclarationParams&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.position, position) || other.position == position)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,partialResultToken,position,textDocument,workDoneToken);

@override
String toString() {
  return 'DeclarationParams(partialResultToken: $partialResultToken, position: $position, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$DeclarationParamsCopyWith<$Res> implements $DeclarationParamsCopyWith<$Res> {
  factory _$DeclarationParamsCopyWith(_DeclarationParams value, $Res Function(_DeclarationParams) _then) = __$DeclarationParamsCopyWithImpl;
@override @useResult
$Res call({
 ProgressToken? partialResultToken, Position position, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


@override $PositionCopyWith<$Res> get position;@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$DeclarationParamsCopyWithImpl<$Res>
    implements _$DeclarationParamsCopyWith<$Res> {
  __$DeclarationParamsCopyWithImpl(this._self, this._then);

  final _DeclarationParams _self;
  final $Res Function(_DeclarationParams) _then;

/// Create a copy of DeclarationParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? partialResultToken = freezed,Object? position = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_DeclarationParams(
partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of DeclarationParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of DeclarationParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$DeclarationRegistrationOptions {

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
 Sealed14 get documentSelector;/// The id used to register the request. The id can be used to deregister
/// the request again. See also Registration#id.
 String? get id;
/// Create a copy of DeclarationRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DeclarationRegistrationOptionsCopyWith<DeclarationRegistrationOptions> get copyWith => _$DeclarationRegistrationOptionsCopyWithImpl<DeclarationRegistrationOptions>(this as DeclarationRegistrationOptions, _$identity);

  /// Serializes this DeclarationRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DeclarationRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.id, id) || other.id == id));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,id);

@override
String toString() {
  return 'DeclarationRegistrationOptions(documentSelector: $documentSelector, id: $id)';
}


}

/// @nodoc
abstract mixin class $DeclarationRegistrationOptionsCopyWith<$Res>  {
  factory $DeclarationRegistrationOptionsCopyWith(DeclarationRegistrationOptions value, $Res Function(DeclarationRegistrationOptions) _then) = _$DeclarationRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 Sealed14 documentSelector, String? id
});




}
/// @nodoc
class _$DeclarationRegistrationOptionsCopyWithImpl<$Res>
    implements $DeclarationRegistrationOptionsCopyWith<$Res> {
  _$DeclarationRegistrationOptionsCopyWithImpl(this._self, this._then);

  final DeclarationRegistrationOptions _self;
  final $Res Function(DeclarationRegistrationOptions) _then;

/// Create a copy of DeclarationRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = null,Object? id = freezed,}) {
  return _then(_self.copyWith(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DeclarationRegistrationOptions implements DeclarationRegistrationOptions {
  const _DeclarationRegistrationOptions({required this.documentSelector, this.id});
  factory _DeclarationRegistrationOptions.fromJson(Map<String, dynamic> json) => _$DeclarationRegistrationOptionsFromJson(json);

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
@override final  Sealed14 documentSelector;
/// The id used to register the request. The id can be used to deregister
/// the request again. See also Registration#id.
@override final  String? id;

/// Create a copy of DeclarationRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DeclarationRegistrationOptionsCopyWith<_DeclarationRegistrationOptions> get copyWith => __$DeclarationRegistrationOptionsCopyWithImpl<_DeclarationRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DeclarationRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DeclarationRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.id, id) || other.id == id));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,id);

@override
String toString() {
  return 'DeclarationRegistrationOptions(documentSelector: $documentSelector, id: $id)';
}


}

/// @nodoc
abstract mixin class _$DeclarationRegistrationOptionsCopyWith<$Res> implements $DeclarationRegistrationOptionsCopyWith<$Res> {
  factory _$DeclarationRegistrationOptionsCopyWith(_DeclarationRegistrationOptions value, $Res Function(_DeclarationRegistrationOptions) _then) = __$DeclarationRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 Sealed14 documentSelector, String? id
});




}
/// @nodoc
class __$DeclarationRegistrationOptionsCopyWithImpl<$Res>
    implements _$DeclarationRegistrationOptionsCopyWith<$Res> {
  __$DeclarationRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _DeclarationRegistrationOptions _self;
  final $Res Function(_DeclarationRegistrationOptions) _then;

/// Create a copy of DeclarationRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = null,Object? id = freezed,}) {
  return _then(_DeclarationRegistrationOptions(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$SelectionRangeParams {

/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
 ProgressToken? get partialResultToken;/// The positions inside the text document.
 List<Position> get positions;/// The text document.
 TextDocumentIdentifier get textDocument;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of SelectionRangeParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SelectionRangeParamsCopyWith<SelectionRangeParams> get copyWith => _$SelectionRangeParamsCopyWithImpl<SelectionRangeParams>(this as SelectionRangeParams, _$identity);

  /// Serializes this SelectionRangeParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SelectionRangeParams&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&const DeepCollectionEquality().equals(other.positions, positions)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,partialResultToken,const DeepCollectionEquality().hash(positions),textDocument,workDoneToken);

@override
String toString() {
  return 'SelectionRangeParams(partialResultToken: $partialResultToken, positions: $positions, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $SelectionRangeParamsCopyWith<$Res>  {
  factory $SelectionRangeParamsCopyWith(SelectionRangeParams value, $Res Function(SelectionRangeParams) _then) = _$SelectionRangeParamsCopyWithImpl;
@useResult
$Res call({
 ProgressToken? partialResultToken, List<Position> positions, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$SelectionRangeParamsCopyWithImpl<$Res>
    implements $SelectionRangeParamsCopyWith<$Res> {
  _$SelectionRangeParamsCopyWithImpl(this._self, this._then);

  final SelectionRangeParams _self;
  final $Res Function(SelectionRangeParams) _then;

/// Create a copy of SelectionRangeParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? partialResultToken = freezed,Object? positions = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,positions: null == positions ? _self.positions : positions // ignore: cast_nullable_to_non_nullable
as List<Position>,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of SelectionRangeParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _SelectionRangeParams implements SelectionRangeParams {
  const _SelectionRangeParams({this.partialResultToken, required final  List<Position> positions, required this.textDocument, this.workDoneToken}): _positions = positions;
  factory _SelectionRangeParams.fromJson(Map<String, dynamic> json) => _$SelectionRangeParamsFromJson(json);

/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
@override final  ProgressToken? partialResultToken;
/// The positions inside the text document.
 final  List<Position> _positions;
/// The positions inside the text document.
@override List<Position> get positions {
  if (_positions is EqualUnmodifiableListView) return _positions;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_positions);
}

/// The text document.
@override final  TextDocumentIdentifier textDocument;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of SelectionRangeParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SelectionRangeParamsCopyWith<_SelectionRangeParams> get copyWith => __$SelectionRangeParamsCopyWithImpl<_SelectionRangeParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SelectionRangeParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SelectionRangeParams&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&const DeepCollectionEquality().equals(other._positions, _positions)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,partialResultToken,const DeepCollectionEquality().hash(_positions),textDocument,workDoneToken);

@override
String toString() {
  return 'SelectionRangeParams(partialResultToken: $partialResultToken, positions: $positions, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$SelectionRangeParamsCopyWith<$Res> implements $SelectionRangeParamsCopyWith<$Res> {
  factory _$SelectionRangeParamsCopyWith(_SelectionRangeParams value, $Res Function(_SelectionRangeParams) _then) = __$SelectionRangeParamsCopyWithImpl;
@override @useResult
$Res call({
 ProgressToken? partialResultToken, List<Position> positions, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$SelectionRangeParamsCopyWithImpl<$Res>
    implements _$SelectionRangeParamsCopyWith<$Res> {
  __$SelectionRangeParamsCopyWithImpl(this._self, this._then);

  final _SelectionRangeParams _self;
  final $Res Function(_SelectionRangeParams) _then;

/// Create a copy of SelectionRangeParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? partialResultToken = freezed,Object? positions = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_SelectionRangeParams(
partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,positions: null == positions ? _self._positions : positions // ignore: cast_nullable_to_non_nullable
as List<Position>,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of SelectionRangeParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$SelectionRange {

/// The parent selection range containing this range. Therefore
/// `parent.range` must contain `this.range`.
 SelectionRange? get parent;/// The {@link Range range} of this selection range.
 Range get range;
/// Create a copy of SelectionRange
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SelectionRangeCopyWith<SelectionRange> get copyWith => _$SelectionRangeCopyWithImpl<SelectionRange>(this as SelectionRange, _$identity);

  /// Serializes this SelectionRange to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SelectionRange&&(identical(other.parent, parent) || other.parent == parent)&&(identical(other.range, range) || other.range == range));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,parent,range);

@override
String toString() {
  return 'SelectionRange(parent: $parent, range: $range)';
}


}

/// @nodoc
abstract mixin class $SelectionRangeCopyWith<$Res>  {
  factory $SelectionRangeCopyWith(SelectionRange value, $Res Function(SelectionRange) _then) = _$SelectionRangeCopyWithImpl;
@useResult
$Res call({
 SelectionRange? parent, Range range
});


$SelectionRangeCopyWith<$Res>? get parent;$RangeCopyWith<$Res> get range;

}
/// @nodoc
class _$SelectionRangeCopyWithImpl<$Res>
    implements $SelectionRangeCopyWith<$Res> {
  _$SelectionRangeCopyWithImpl(this._self, this._then);

  final SelectionRange _self;
  final $Res Function(SelectionRange) _then;

/// Create a copy of SelectionRange
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? parent = freezed,Object? range = null,}) {
  return _then(_self.copyWith(
parent: freezed == parent ? _self.parent : parent // ignore: cast_nullable_to_non_nullable
as SelectionRange?,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,
  ));
}
/// Create a copy of SelectionRange
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SelectionRangeCopyWith<$Res>? get parent {
    if (_self.parent == null) {
    return null;
  }

  return $SelectionRangeCopyWith<$Res>(_self.parent!, (value) {
    return _then(_self.copyWith(parent: value));
  });
}/// Create a copy of SelectionRange
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _SelectionRange implements SelectionRange {
  const _SelectionRange({this.parent, required this.range});
  factory _SelectionRange.fromJson(Map<String, dynamic> json) => _$SelectionRangeFromJson(json);

/// The parent selection range containing this range. Therefore
/// `parent.range` must contain `this.range`.
@override final  SelectionRange? parent;
/// The {@link Range range} of this selection range.
@override final  Range range;

/// Create a copy of SelectionRange
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SelectionRangeCopyWith<_SelectionRange> get copyWith => __$SelectionRangeCopyWithImpl<_SelectionRange>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SelectionRangeToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SelectionRange&&(identical(other.parent, parent) || other.parent == parent)&&(identical(other.range, range) || other.range == range));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,parent,range);

@override
String toString() {
  return 'SelectionRange(parent: $parent, range: $range)';
}


}

/// @nodoc
abstract mixin class _$SelectionRangeCopyWith<$Res> implements $SelectionRangeCopyWith<$Res> {
  factory _$SelectionRangeCopyWith(_SelectionRange value, $Res Function(_SelectionRange) _then) = __$SelectionRangeCopyWithImpl;
@override @useResult
$Res call({
 SelectionRange? parent, Range range
});


@override $SelectionRangeCopyWith<$Res>? get parent;@override $RangeCopyWith<$Res> get range;

}
/// @nodoc
class __$SelectionRangeCopyWithImpl<$Res>
    implements _$SelectionRangeCopyWith<$Res> {
  __$SelectionRangeCopyWithImpl(this._self, this._then);

  final _SelectionRange _self;
  final $Res Function(_SelectionRange) _then;

/// Create a copy of SelectionRange
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? parent = freezed,Object? range = null,}) {
  return _then(_SelectionRange(
parent: freezed == parent ? _self.parent : parent // ignore: cast_nullable_to_non_nullable
as SelectionRange?,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,
  ));
}

/// Create a copy of SelectionRange
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SelectionRangeCopyWith<$Res>? get parent {
    if (_self.parent == null) {
    return null;
  }

  return $SelectionRangeCopyWith<$Res>(_self.parent!, (value) {
    return _then(_self.copyWith(parent: value));
  });
}/// Create a copy of SelectionRange
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}


/// @nodoc
mixin _$SelectionRangeRegistrationOptions {

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
 Sealed14 get documentSelector;/// The id used to register the request. The id can be used to deregister
/// the request again. See also Registration#id.
 String? get id;
/// Create a copy of SelectionRangeRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SelectionRangeRegistrationOptionsCopyWith<SelectionRangeRegistrationOptions> get copyWith => _$SelectionRangeRegistrationOptionsCopyWithImpl<SelectionRangeRegistrationOptions>(this as SelectionRangeRegistrationOptions, _$identity);

  /// Serializes this SelectionRangeRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SelectionRangeRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.id, id) || other.id == id));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,id);

@override
String toString() {
  return 'SelectionRangeRegistrationOptions(documentSelector: $documentSelector, id: $id)';
}


}

/// @nodoc
abstract mixin class $SelectionRangeRegistrationOptionsCopyWith<$Res>  {
  factory $SelectionRangeRegistrationOptionsCopyWith(SelectionRangeRegistrationOptions value, $Res Function(SelectionRangeRegistrationOptions) _then) = _$SelectionRangeRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 Sealed14 documentSelector, String? id
});




}
/// @nodoc
class _$SelectionRangeRegistrationOptionsCopyWithImpl<$Res>
    implements $SelectionRangeRegistrationOptionsCopyWith<$Res> {
  _$SelectionRangeRegistrationOptionsCopyWithImpl(this._self, this._then);

  final SelectionRangeRegistrationOptions _self;
  final $Res Function(SelectionRangeRegistrationOptions) _then;

/// Create a copy of SelectionRangeRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = null,Object? id = freezed,}) {
  return _then(_self.copyWith(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _SelectionRangeRegistrationOptions implements SelectionRangeRegistrationOptions {
  const _SelectionRangeRegistrationOptions({required this.documentSelector, this.id});
  factory _SelectionRangeRegistrationOptions.fromJson(Map<String, dynamic> json) => _$SelectionRangeRegistrationOptionsFromJson(json);

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
@override final  Sealed14 documentSelector;
/// The id used to register the request. The id can be used to deregister
/// the request again. See also Registration#id.
@override final  String? id;

/// Create a copy of SelectionRangeRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SelectionRangeRegistrationOptionsCopyWith<_SelectionRangeRegistrationOptions> get copyWith => __$SelectionRangeRegistrationOptionsCopyWithImpl<_SelectionRangeRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SelectionRangeRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SelectionRangeRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.id, id) || other.id == id));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,id);

@override
String toString() {
  return 'SelectionRangeRegistrationOptions(documentSelector: $documentSelector, id: $id)';
}


}

/// @nodoc
abstract mixin class _$SelectionRangeRegistrationOptionsCopyWith<$Res> implements $SelectionRangeRegistrationOptionsCopyWith<$Res> {
  factory _$SelectionRangeRegistrationOptionsCopyWith(_SelectionRangeRegistrationOptions value, $Res Function(_SelectionRangeRegistrationOptions) _then) = __$SelectionRangeRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 Sealed14 documentSelector, String? id
});




}
/// @nodoc
class __$SelectionRangeRegistrationOptionsCopyWithImpl<$Res>
    implements _$SelectionRangeRegistrationOptionsCopyWith<$Res> {
  __$SelectionRangeRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _SelectionRangeRegistrationOptions _self;
  final $Res Function(_SelectionRangeRegistrationOptions) _then;

/// Create a copy of SelectionRangeRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = null,Object? id = freezed,}) {
  return _then(_SelectionRangeRegistrationOptions(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$WorkDoneProgressCreateParams {

/// The token to be used to report progress.
 ProgressToken get token;
/// Create a copy of WorkDoneProgressCreateParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkDoneProgressCreateParamsCopyWith<WorkDoneProgressCreateParams> get copyWith => _$WorkDoneProgressCreateParamsCopyWithImpl<WorkDoneProgressCreateParams>(this as WorkDoneProgressCreateParams, _$identity);

  /// Serializes this WorkDoneProgressCreateParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkDoneProgressCreateParams&&(identical(other.token, token) || other.token == token));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,token);

@override
String toString() {
  return 'WorkDoneProgressCreateParams(token: $token)';
}


}

/// @nodoc
abstract mixin class $WorkDoneProgressCreateParamsCopyWith<$Res>  {
  factory $WorkDoneProgressCreateParamsCopyWith(WorkDoneProgressCreateParams value, $Res Function(WorkDoneProgressCreateParams) _then) = _$WorkDoneProgressCreateParamsCopyWithImpl;
@useResult
$Res call({
 ProgressToken token
});




}
/// @nodoc
class _$WorkDoneProgressCreateParamsCopyWithImpl<$Res>
    implements $WorkDoneProgressCreateParamsCopyWith<$Res> {
  _$WorkDoneProgressCreateParamsCopyWithImpl(this._self, this._then);

  final WorkDoneProgressCreateParams _self;
  final $Res Function(WorkDoneProgressCreateParams) _then;

/// Create a copy of WorkDoneProgressCreateParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? token = null,}) {
  return _then(_self.copyWith(
token: null == token ? _self.token : token // ignore: cast_nullable_to_non_nullable
as ProgressToken,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _WorkDoneProgressCreateParams implements WorkDoneProgressCreateParams {
  const _WorkDoneProgressCreateParams({required this.token});
  factory _WorkDoneProgressCreateParams.fromJson(Map<String, dynamic> json) => _$WorkDoneProgressCreateParamsFromJson(json);

/// The token to be used to report progress.
@override final  ProgressToken token;

/// Create a copy of WorkDoneProgressCreateParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkDoneProgressCreateParamsCopyWith<_WorkDoneProgressCreateParams> get copyWith => __$WorkDoneProgressCreateParamsCopyWithImpl<_WorkDoneProgressCreateParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkDoneProgressCreateParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkDoneProgressCreateParams&&(identical(other.token, token) || other.token == token));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,token);

@override
String toString() {
  return 'WorkDoneProgressCreateParams(token: $token)';
}


}

/// @nodoc
abstract mixin class _$WorkDoneProgressCreateParamsCopyWith<$Res> implements $WorkDoneProgressCreateParamsCopyWith<$Res> {
  factory _$WorkDoneProgressCreateParamsCopyWith(_WorkDoneProgressCreateParams value, $Res Function(_WorkDoneProgressCreateParams) _then) = __$WorkDoneProgressCreateParamsCopyWithImpl;
@override @useResult
$Res call({
 ProgressToken token
});




}
/// @nodoc
class __$WorkDoneProgressCreateParamsCopyWithImpl<$Res>
    implements _$WorkDoneProgressCreateParamsCopyWith<$Res> {
  __$WorkDoneProgressCreateParamsCopyWithImpl(this._self, this._then);

  final _WorkDoneProgressCreateParams _self;
  final $Res Function(_WorkDoneProgressCreateParams) _then;

/// Create a copy of WorkDoneProgressCreateParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? token = null,}) {
  return _then(_WorkDoneProgressCreateParams(
token: null == token ? _self.token : token // ignore: cast_nullable_to_non_nullable
as ProgressToken,
  ));
}


}


/// @nodoc
mixin _$WorkDoneProgressCancelParams {

/// The token to be used to report progress.
 ProgressToken get token;
/// Create a copy of WorkDoneProgressCancelParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkDoneProgressCancelParamsCopyWith<WorkDoneProgressCancelParams> get copyWith => _$WorkDoneProgressCancelParamsCopyWithImpl<WorkDoneProgressCancelParams>(this as WorkDoneProgressCancelParams, _$identity);

  /// Serializes this WorkDoneProgressCancelParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkDoneProgressCancelParams&&(identical(other.token, token) || other.token == token));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,token);

@override
String toString() {
  return 'WorkDoneProgressCancelParams(token: $token)';
}


}

/// @nodoc
abstract mixin class $WorkDoneProgressCancelParamsCopyWith<$Res>  {
  factory $WorkDoneProgressCancelParamsCopyWith(WorkDoneProgressCancelParams value, $Res Function(WorkDoneProgressCancelParams) _then) = _$WorkDoneProgressCancelParamsCopyWithImpl;
@useResult
$Res call({
 ProgressToken token
});




}
/// @nodoc
class _$WorkDoneProgressCancelParamsCopyWithImpl<$Res>
    implements $WorkDoneProgressCancelParamsCopyWith<$Res> {
  _$WorkDoneProgressCancelParamsCopyWithImpl(this._self, this._then);

  final WorkDoneProgressCancelParams _self;
  final $Res Function(WorkDoneProgressCancelParams) _then;

/// Create a copy of WorkDoneProgressCancelParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? token = null,}) {
  return _then(_self.copyWith(
token: null == token ? _self.token : token // ignore: cast_nullable_to_non_nullable
as ProgressToken,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _WorkDoneProgressCancelParams implements WorkDoneProgressCancelParams {
  const _WorkDoneProgressCancelParams({required this.token});
  factory _WorkDoneProgressCancelParams.fromJson(Map<String, dynamic> json) => _$WorkDoneProgressCancelParamsFromJson(json);

/// The token to be used to report progress.
@override final  ProgressToken token;

/// Create a copy of WorkDoneProgressCancelParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkDoneProgressCancelParamsCopyWith<_WorkDoneProgressCancelParams> get copyWith => __$WorkDoneProgressCancelParamsCopyWithImpl<_WorkDoneProgressCancelParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkDoneProgressCancelParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkDoneProgressCancelParams&&(identical(other.token, token) || other.token == token));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,token);

@override
String toString() {
  return 'WorkDoneProgressCancelParams(token: $token)';
}


}

/// @nodoc
abstract mixin class _$WorkDoneProgressCancelParamsCopyWith<$Res> implements $WorkDoneProgressCancelParamsCopyWith<$Res> {
  factory _$WorkDoneProgressCancelParamsCopyWith(_WorkDoneProgressCancelParams value, $Res Function(_WorkDoneProgressCancelParams) _then) = __$WorkDoneProgressCancelParamsCopyWithImpl;
@override @useResult
$Res call({
 ProgressToken token
});




}
/// @nodoc
class __$WorkDoneProgressCancelParamsCopyWithImpl<$Res>
    implements _$WorkDoneProgressCancelParamsCopyWith<$Res> {
  __$WorkDoneProgressCancelParamsCopyWithImpl(this._self, this._then);

  final _WorkDoneProgressCancelParams _self;
  final $Res Function(_WorkDoneProgressCancelParams) _then;

/// Create a copy of WorkDoneProgressCancelParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? token = null,}) {
  return _then(_WorkDoneProgressCancelParams(
token: null == token ? _self.token : token // ignore: cast_nullable_to_non_nullable
as ProgressToken,
  ));
}


}


/// @nodoc
mixin _$CallHierarchyPrepareParams {

/// The position inside the text document.
 Position get position;/// The text document.
 TextDocumentIdentifier get textDocument;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of CallHierarchyPrepareParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CallHierarchyPrepareParamsCopyWith<CallHierarchyPrepareParams> get copyWith => _$CallHierarchyPrepareParamsCopyWithImpl<CallHierarchyPrepareParams>(this as CallHierarchyPrepareParams, _$identity);

  /// Serializes this CallHierarchyPrepareParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CallHierarchyPrepareParams&&(identical(other.position, position) || other.position == position)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,position,textDocument,workDoneToken);

@override
String toString() {
  return 'CallHierarchyPrepareParams(position: $position, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $CallHierarchyPrepareParamsCopyWith<$Res>  {
  factory $CallHierarchyPrepareParamsCopyWith(CallHierarchyPrepareParams value, $Res Function(CallHierarchyPrepareParams) _then) = _$CallHierarchyPrepareParamsCopyWithImpl;
@useResult
$Res call({
 Position position, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


$PositionCopyWith<$Res> get position;$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$CallHierarchyPrepareParamsCopyWithImpl<$Res>
    implements $CallHierarchyPrepareParamsCopyWith<$Res> {
  _$CallHierarchyPrepareParamsCopyWithImpl(this._self, this._then);

  final CallHierarchyPrepareParams _self;
  final $Res Function(CallHierarchyPrepareParams) _then;

/// Create a copy of CallHierarchyPrepareParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? position = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of CallHierarchyPrepareParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of CallHierarchyPrepareParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _CallHierarchyPrepareParams implements CallHierarchyPrepareParams {
  const _CallHierarchyPrepareParams({required this.position, required this.textDocument, this.workDoneToken});
  factory _CallHierarchyPrepareParams.fromJson(Map<String, dynamic> json) => _$CallHierarchyPrepareParamsFromJson(json);

/// The position inside the text document.
@override final  Position position;
/// The text document.
@override final  TextDocumentIdentifier textDocument;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of CallHierarchyPrepareParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CallHierarchyPrepareParamsCopyWith<_CallHierarchyPrepareParams> get copyWith => __$CallHierarchyPrepareParamsCopyWithImpl<_CallHierarchyPrepareParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CallHierarchyPrepareParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CallHierarchyPrepareParams&&(identical(other.position, position) || other.position == position)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,position,textDocument,workDoneToken);

@override
String toString() {
  return 'CallHierarchyPrepareParams(position: $position, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$CallHierarchyPrepareParamsCopyWith<$Res> implements $CallHierarchyPrepareParamsCopyWith<$Res> {
  factory _$CallHierarchyPrepareParamsCopyWith(_CallHierarchyPrepareParams value, $Res Function(_CallHierarchyPrepareParams) _then) = __$CallHierarchyPrepareParamsCopyWithImpl;
@override @useResult
$Res call({
 Position position, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


@override $PositionCopyWith<$Res> get position;@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$CallHierarchyPrepareParamsCopyWithImpl<$Res>
    implements _$CallHierarchyPrepareParamsCopyWith<$Res> {
  __$CallHierarchyPrepareParamsCopyWithImpl(this._self, this._then);

  final _CallHierarchyPrepareParams _self;
  final $Res Function(_CallHierarchyPrepareParams) _then;

/// Create a copy of CallHierarchyPrepareParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? position = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_CallHierarchyPrepareParams(
position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of CallHierarchyPrepareParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of CallHierarchyPrepareParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$CallHierarchyItem {

/// A data entry field that is preserved between a call hierarchy prepare
/// and incoming calls or outgoing calls requests.
 LSPAny? get data;/// More detail for this item, e.g. the signature of a function.
 String? get detail;/// The kind of this item.
 SymbolKind get kind;/// The name of this item.
 String get name;/// The range enclosing this symbol not including leading/trailing
/// whitespace but everything else, e.g. comments and code.
 Range get range;/// The range that should be selected and revealed when this symbol is
/// being picked, e.g. the name of a function. Must be contained by the
/// {@link CallHierarchyItem.range `range`}.
 Range get selectionRange;/// Tags for this item.
 List<SymbolTag>? get tags;/// The resource identifier of this item.
 String get uri;
/// Create a copy of CallHierarchyItem
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CallHierarchyItemCopyWith<CallHierarchyItem> get copyWith => _$CallHierarchyItemCopyWithImpl<CallHierarchyItem>(this as CallHierarchyItem, _$identity);

  /// Serializes this CallHierarchyItem to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CallHierarchyItem&&(identical(other.data, data) || other.data == data)&&(identical(other.detail, detail) || other.detail == detail)&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.name, name) || other.name == name)&&(identical(other.range, range) || other.range == range)&&(identical(other.selectionRange, selectionRange) || other.selectionRange == selectionRange)&&const DeepCollectionEquality().equals(other.tags, tags)&&(identical(other.uri, uri) || other.uri == uri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,data,detail,kind,name,range,selectionRange,const DeepCollectionEquality().hash(tags),uri);

@override
String toString() {
  return 'CallHierarchyItem(data: $data, detail: $detail, kind: $kind, name: $name, range: $range, selectionRange: $selectionRange, tags: $tags, uri: $uri)';
}


}

/// @nodoc
abstract mixin class $CallHierarchyItemCopyWith<$Res>  {
  factory $CallHierarchyItemCopyWith(CallHierarchyItem value, $Res Function(CallHierarchyItem) _then) = _$CallHierarchyItemCopyWithImpl;
@useResult
$Res call({
 LSPAny? data, String? detail, SymbolKind kind, String name, Range range, Range selectionRange, List<SymbolTag>? tags, String uri
});


$RangeCopyWith<$Res> get range;$RangeCopyWith<$Res> get selectionRange;

}
/// @nodoc
class _$CallHierarchyItemCopyWithImpl<$Res>
    implements $CallHierarchyItemCopyWith<$Res> {
  _$CallHierarchyItemCopyWithImpl(this._self, this._then);

  final CallHierarchyItem _self;
  final $Res Function(CallHierarchyItem) _then;

/// Create a copy of CallHierarchyItem
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? data = freezed,Object? detail = freezed,Object? kind = null,Object? name = null,Object? range = null,Object? selectionRange = null,Object? tags = freezed,Object? uri = null,}) {
  return _then(_self.copyWith(
data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LSPAny?,detail: freezed == detail ? _self.detail : detail // ignore: cast_nullable_to_non_nullable
as String?,kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as SymbolKind,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,selectionRange: null == selectionRange ? _self.selectionRange : selectionRange // ignore: cast_nullable_to_non_nullable
as Range,tags: freezed == tags ? _self.tags : tags // ignore: cast_nullable_to_non_nullable
as List<SymbolTag>?,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}
/// Create a copy of CallHierarchyItem
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}/// Create a copy of CallHierarchyItem
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get selectionRange {
  
  return $RangeCopyWith<$Res>(_self.selectionRange, (value) {
    return _then(_self.copyWith(selectionRange: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _CallHierarchyItem implements CallHierarchyItem {
  const _CallHierarchyItem({this.data, this.detail, required this.kind, required this.name, required this.range, required this.selectionRange, final  List<SymbolTag>? tags, required this.uri}): _tags = tags;
  factory _CallHierarchyItem.fromJson(Map<String, dynamic> json) => _$CallHierarchyItemFromJson(json);

/// A data entry field that is preserved between a call hierarchy prepare
/// and incoming calls or outgoing calls requests.
@override final  LSPAny? data;
/// More detail for this item, e.g. the signature of a function.
@override final  String? detail;
/// The kind of this item.
@override final  SymbolKind kind;
/// The name of this item.
@override final  String name;
/// The range enclosing this symbol not including leading/trailing
/// whitespace but everything else, e.g. comments and code.
@override final  Range range;
/// The range that should be selected and revealed when this symbol is
/// being picked, e.g. the name of a function. Must be contained by the
/// {@link CallHierarchyItem.range `range`}.
@override final  Range selectionRange;
/// Tags for this item.
 final  List<SymbolTag>? _tags;
/// Tags for this item.
@override List<SymbolTag>? get tags {
  final value = _tags;
  if (value == null) return null;
  if (_tags is EqualUnmodifiableListView) return _tags;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

/// The resource identifier of this item.
@override final  String uri;

/// Create a copy of CallHierarchyItem
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CallHierarchyItemCopyWith<_CallHierarchyItem> get copyWith => __$CallHierarchyItemCopyWithImpl<_CallHierarchyItem>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CallHierarchyItemToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CallHierarchyItem&&(identical(other.data, data) || other.data == data)&&(identical(other.detail, detail) || other.detail == detail)&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.name, name) || other.name == name)&&(identical(other.range, range) || other.range == range)&&(identical(other.selectionRange, selectionRange) || other.selectionRange == selectionRange)&&const DeepCollectionEquality().equals(other._tags, _tags)&&(identical(other.uri, uri) || other.uri == uri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,data,detail,kind,name,range,selectionRange,const DeepCollectionEquality().hash(_tags),uri);

@override
String toString() {
  return 'CallHierarchyItem(data: $data, detail: $detail, kind: $kind, name: $name, range: $range, selectionRange: $selectionRange, tags: $tags, uri: $uri)';
}


}

/// @nodoc
abstract mixin class _$CallHierarchyItemCopyWith<$Res> implements $CallHierarchyItemCopyWith<$Res> {
  factory _$CallHierarchyItemCopyWith(_CallHierarchyItem value, $Res Function(_CallHierarchyItem) _then) = __$CallHierarchyItemCopyWithImpl;
@override @useResult
$Res call({
 LSPAny? data, String? detail, SymbolKind kind, String name, Range range, Range selectionRange, List<SymbolTag>? tags, String uri
});


@override $RangeCopyWith<$Res> get range;@override $RangeCopyWith<$Res> get selectionRange;

}
/// @nodoc
class __$CallHierarchyItemCopyWithImpl<$Res>
    implements _$CallHierarchyItemCopyWith<$Res> {
  __$CallHierarchyItemCopyWithImpl(this._self, this._then);

  final _CallHierarchyItem _self;
  final $Res Function(_CallHierarchyItem) _then;

/// Create a copy of CallHierarchyItem
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? data = freezed,Object? detail = freezed,Object? kind = null,Object? name = null,Object? range = null,Object? selectionRange = null,Object? tags = freezed,Object? uri = null,}) {
  return _then(_CallHierarchyItem(
data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LSPAny?,detail: freezed == detail ? _self.detail : detail // ignore: cast_nullable_to_non_nullable
as String?,kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as SymbolKind,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,selectionRange: null == selectionRange ? _self.selectionRange : selectionRange // ignore: cast_nullable_to_non_nullable
as Range,tags: freezed == tags ? _self._tags : tags // ignore: cast_nullable_to_non_nullable
as List<SymbolTag>?,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

/// Create a copy of CallHierarchyItem
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}/// Create a copy of CallHierarchyItem
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get selectionRange {
  
  return $RangeCopyWith<$Res>(_self.selectionRange, (value) {
    return _then(_self.copyWith(selectionRange: value));
  });
}
}


/// @nodoc
mixin _$CallHierarchyRegistrationOptions {

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
 Sealed14 get documentSelector;/// The id used to register the request. The id can be used to deregister
/// the request again. See also Registration#id.
 String? get id;
/// Create a copy of CallHierarchyRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CallHierarchyRegistrationOptionsCopyWith<CallHierarchyRegistrationOptions> get copyWith => _$CallHierarchyRegistrationOptionsCopyWithImpl<CallHierarchyRegistrationOptions>(this as CallHierarchyRegistrationOptions, _$identity);

  /// Serializes this CallHierarchyRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CallHierarchyRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.id, id) || other.id == id));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,id);

@override
String toString() {
  return 'CallHierarchyRegistrationOptions(documentSelector: $documentSelector, id: $id)';
}


}

/// @nodoc
abstract mixin class $CallHierarchyRegistrationOptionsCopyWith<$Res>  {
  factory $CallHierarchyRegistrationOptionsCopyWith(CallHierarchyRegistrationOptions value, $Res Function(CallHierarchyRegistrationOptions) _then) = _$CallHierarchyRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 Sealed14 documentSelector, String? id
});




}
/// @nodoc
class _$CallHierarchyRegistrationOptionsCopyWithImpl<$Res>
    implements $CallHierarchyRegistrationOptionsCopyWith<$Res> {
  _$CallHierarchyRegistrationOptionsCopyWithImpl(this._self, this._then);

  final CallHierarchyRegistrationOptions _self;
  final $Res Function(CallHierarchyRegistrationOptions) _then;

/// Create a copy of CallHierarchyRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = null,Object? id = freezed,}) {
  return _then(_self.copyWith(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _CallHierarchyRegistrationOptions implements CallHierarchyRegistrationOptions {
  const _CallHierarchyRegistrationOptions({required this.documentSelector, this.id});
  factory _CallHierarchyRegistrationOptions.fromJson(Map<String, dynamic> json) => _$CallHierarchyRegistrationOptionsFromJson(json);

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
@override final  Sealed14 documentSelector;
/// The id used to register the request. The id can be used to deregister
/// the request again. See also Registration#id.
@override final  String? id;

/// Create a copy of CallHierarchyRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CallHierarchyRegistrationOptionsCopyWith<_CallHierarchyRegistrationOptions> get copyWith => __$CallHierarchyRegistrationOptionsCopyWithImpl<_CallHierarchyRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CallHierarchyRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CallHierarchyRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.id, id) || other.id == id));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,id);

@override
String toString() {
  return 'CallHierarchyRegistrationOptions(documentSelector: $documentSelector, id: $id)';
}


}

/// @nodoc
abstract mixin class _$CallHierarchyRegistrationOptionsCopyWith<$Res> implements $CallHierarchyRegistrationOptionsCopyWith<$Res> {
  factory _$CallHierarchyRegistrationOptionsCopyWith(_CallHierarchyRegistrationOptions value, $Res Function(_CallHierarchyRegistrationOptions) _then) = __$CallHierarchyRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 Sealed14 documentSelector, String? id
});




}
/// @nodoc
class __$CallHierarchyRegistrationOptionsCopyWithImpl<$Res>
    implements _$CallHierarchyRegistrationOptionsCopyWith<$Res> {
  __$CallHierarchyRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _CallHierarchyRegistrationOptions _self;
  final $Res Function(_CallHierarchyRegistrationOptions) _then;

/// Create a copy of CallHierarchyRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = null,Object? id = freezed,}) {
  return _then(_CallHierarchyRegistrationOptions(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$CallHierarchyIncomingCallsParams {

 CallHierarchyItem get item;/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
 ProgressToken? get partialResultToken;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of CallHierarchyIncomingCallsParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CallHierarchyIncomingCallsParamsCopyWith<CallHierarchyIncomingCallsParams> get copyWith => _$CallHierarchyIncomingCallsParamsCopyWithImpl<CallHierarchyIncomingCallsParams>(this as CallHierarchyIncomingCallsParams, _$identity);

  /// Serializes this CallHierarchyIncomingCallsParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CallHierarchyIncomingCallsParams&&(identical(other.item, item) || other.item == item)&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,item,partialResultToken,workDoneToken);

@override
String toString() {
  return 'CallHierarchyIncomingCallsParams(item: $item, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $CallHierarchyIncomingCallsParamsCopyWith<$Res>  {
  factory $CallHierarchyIncomingCallsParamsCopyWith(CallHierarchyIncomingCallsParams value, $Res Function(CallHierarchyIncomingCallsParams) _then) = _$CallHierarchyIncomingCallsParamsCopyWithImpl;
@useResult
$Res call({
 CallHierarchyItem item, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


$CallHierarchyItemCopyWith<$Res> get item;

}
/// @nodoc
class _$CallHierarchyIncomingCallsParamsCopyWithImpl<$Res>
    implements $CallHierarchyIncomingCallsParamsCopyWith<$Res> {
  _$CallHierarchyIncomingCallsParamsCopyWithImpl(this._self, this._then);

  final CallHierarchyIncomingCallsParams _self;
  final $Res Function(CallHierarchyIncomingCallsParams) _then;

/// Create a copy of CallHierarchyIncomingCallsParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? item = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
item: null == item ? _self.item : item // ignore: cast_nullable_to_non_nullable
as CallHierarchyItem,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of CallHierarchyIncomingCallsParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CallHierarchyItemCopyWith<$Res> get item {
  
  return $CallHierarchyItemCopyWith<$Res>(_self.item, (value) {
    return _then(_self.copyWith(item: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _CallHierarchyIncomingCallsParams implements CallHierarchyIncomingCallsParams {
  const _CallHierarchyIncomingCallsParams({required this.item, this.partialResultToken, this.workDoneToken});
  factory _CallHierarchyIncomingCallsParams.fromJson(Map<String, dynamic> json) => _$CallHierarchyIncomingCallsParamsFromJson(json);

@override final  CallHierarchyItem item;
/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
@override final  ProgressToken? partialResultToken;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of CallHierarchyIncomingCallsParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CallHierarchyIncomingCallsParamsCopyWith<_CallHierarchyIncomingCallsParams> get copyWith => __$CallHierarchyIncomingCallsParamsCopyWithImpl<_CallHierarchyIncomingCallsParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CallHierarchyIncomingCallsParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CallHierarchyIncomingCallsParams&&(identical(other.item, item) || other.item == item)&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,item,partialResultToken,workDoneToken);

@override
String toString() {
  return 'CallHierarchyIncomingCallsParams(item: $item, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$CallHierarchyIncomingCallsParamsCopyWith<$Res> implements $CallHierarchyIncomingCallsParamsCopyWith<$Res> {
  factory _$CallHierarchyIncomingCallsParamsCopyWith(_CallHierarchyIncomingCallsParams value, $Res Function(_CallHierarchyIncomingCallsParams) _then) = __$CallHierarchyIncomingCallsParamsCopyWithImpl;
@override @useResult
$Res call({
 CallHierarchyItem item, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


@override $CallHierarchyItemCopyWith<$Res> get item;

}
/// @nodoc
class __$CallHierarchyIncomingCallsParamsCopyWithImpl<$Res>
    implements _$CallHierarchyIncomingCallsParamsCopyWith<$Res> {
  __$CallHierarchyIncomingCallsParamsCopyWithImpl(this._self, this._then);

  final _CallHierarchyIncomingCallsParams _self;
  final $Res Function(_CallHierarchyIncomingCallsParams) _then;

/// Create a copy of CallHierarchyIncomingCallsParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? item = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_CallHierarchyIncomingCallsParams(
item: null == item ? _self.item : item // ignore: cast_nullable_to_non_nullable
as CallHierarchyItem,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of CallHierarchyIncomingCallsParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CallHierarchyItemCopyWith<$Res> get item {
  
  return $CallHierarchyItemCopyWith<$Res>(_self.item, (value) {
    return _then(_self.copyWith(item: value));
  });
}
}


/// @nodoc
mixin _$CallHierarchyIncomingCall {

/// The item that makes the call.
 CallHierarchyItem get from;/// The ranges at which the calls appear. This is relative to the caller
/// denoted by {@link CallHierarchyIncomingCall.from `this.from`}.
 List<Range> get fromRanges;
/// Create a copy of CallHierarchyIncomingCall
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CallHierarchyIncomingCallCopyWith<CallHierarchyIncomingCall> get copyWith => _$CallHierarchyIncomingCallCopyWithImpl<CallHierarchyIncomingCall>(this as CallHierarchyIncomingCall, _$identity);

  /// Serializes this CallHierarchyIncomingCall to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CallHierarchyIncomingCall&&(identical(other.from, from) || other.from == from)&&const DeepCollectionEquality().equals(other.fromRanges, fromRanges));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,from,const DeepCollectionEquality().hash(fromRanges));

@override
String toString() {
  return 'CallHierarchyIncomingCall(from: $from, fromRanges: $fromRanges)';
}


}

/// @nodoc
abstract mixin class $CallHierarchyIncomingCallCopyWith<$Res>  {
  factory $CallHierarchyIncomingCallCopyWith(CallHierarchyIncomingCall value, $Res Function(CallHierarchyIncomingCall) _then) = _$CallHierarchyIncomingCallCopyWithImpl;
@useResult
$Res call({
 CallHierarchyItem from, List<Range> fromRanges
});


$CallHierarchyItemCopyWith<$Res> get from;

}
/// @nodoc
class _$CallHierarchyIncomingCallCopyWithImpl<$Res>
    implements $CallHierarchyIncomingCallCopyWith<$Res> {
  _$CallHierarchyIncomingCallCopyWithImpl(this._self, this._then);

  final CallHierarchyIncomingCall _self;
  final $Res Function(CallHierarchyIncomingCall) _then;

/// Create a copy of CallHierarchyIncomingCall
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? from = null,Object? fromRanges = null,}) {
  return _then(_self.copyWith(
from: null == from ? _self.from : from // ignore: cast_nullable_to_non_nullable
as CallHierarchyItem,fromRanges: null == fromRanges ? _self.fromRanges : fromRanges // ignore: cast_nullable_to_non_nullable
as List<Range>,
  ));
}
/// Create a copy of CallHierarchyIncomingCall
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CallHierarchyItemCopyWith<$Res> get from {
  
  return $CallHierarchyItemCopyWith<$Res>(_self.from, (value) {
    return _then(_self.copyWith(from: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _CallHierarchyIncomingCall implements CallHierarchyIncomingCall {
  const _CallHierarchyIncomingCall({required this.from, required final  List<Range> fromRanges}): _fromRanges = fromRanges;
  factory _CallHierarchyIncomingCall.fromJson(Map<String, dynamic> json) => _$CallHierarchyIncomingCallFromJson(json);

/// The item that makes the call.
@override final  CallHierarchyItem from;
/// The ranges at which the calls appear. This is relative to the caller
/// denoted by {@link CallHierarchyIncomingCall.from `this.from`}.
 final  List<Range> _fromRanges;
/// The ranges at which the calls appear. This is relative to the caller
/// denoted by {@link CallHierarchyIncomingCall.from `this.from`}.
@override List<Range> get fromRanges {
  if (_fromRanges is EqualUnmodifiableListView) return _fromRanges;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_fromRanges);
}


/// Create a copy of CallHierarchyIncomingCall
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CallHierarchyIncomingCallCopyWith<_CallHierarchyIncomingCall> get copyWith => __$CallHierarchyIncomingCallCopyWithImpl<_CallHierarchyIncomingCall>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CallHierarchyIncomingCallToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CallHierarchyIncomingCall&&(identical(other.from, from) || other.from == from)&&const DeepCollectionEquality().equals(other._fromRanges, _fromRanges));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,from,const DeepCollectionEquality().hash(_fromRanges));

@override
String toString() {
  return 'CallHierarchyIncomingCall(from: $from, fromRanges: $fromRanges)';
}


}

/// @nodoc
abstract mixin class _$CallHierarchyIncomingCallCopyWith<$Res> implements $CallHierarchyIncomingCallCopyWith<$Res> {
  factory _$CallHierarchyIncomingCallCopyWith(_CallHierarchyIncomingCall value, $Res Function(_CallHierarchyIncomingCall) _then) = __$CallHierarchyIncomingCallCopyWithImpl;
@override @useResult
$Res call({
 CallHierarchyItem from, List<Range> fromRanges
});


@override $CallHierarchyItemCopyWith<$Res> get from;

}
/// @nodoc
class __$CallHierarchyIncomingCallCopyWithImpl<$Res>
    implements _$CallHierarchyIncomingCallCopyWith<$Res> {
  __$CallHierarchyIncomingCallCopyWithImpl(this._self, this._then);

  final _CallHierarchyIncomingCall _self;
  final $Res Function(_CallHierarchyIncomingCall) _then;

/// Create a copy of CallHierarchyIncomingCall
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? from = null,Object? fromRanges = null,}) {
  return _then(_CallHierarchyIncomingCall(
from: null == from ? _self.from : from // ignore: cast_nullable_to_non_nullable
as CallHierarchyItem,fromRanges: null == fromRanges ? _self._fromRanges : fromRanges // ignore: cast_nullable_to_non_nullable
as List<Range>,
  ));
}

/// Create a copy of CallHierarchyIncomingCall
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CallHierarchyItemCopyWith<$Res> get from {
  
  return $CallHierarchyItemCopyWith<$Res>(_self.from, (value) {
    return _then(_self.copyWith(from: value));
  });
}
}


/// @nodoc
mixin _$CallHierarchyOutgoingCallsParams {

 CallHierarchyItem get item;/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
 ProgressToken? get partialResultToken;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of CallHierarchyOutgoingCallsParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CallHierarchyOutgoingCallsParamsCopyWith<CallHierarchyOutgoingCallsParams> get copyWith => _$CallHierarchyOutgoingCallsParamsCopyWithImpl<CallHierarchyOutgoingCallsParams>(this as CallHierarchyOutgoingCallsParams, _$identity);

  /// Serializes this CallHierarchyOutgoingCallsParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CallHierarchyOutgoingCallsParams&&(identical(other.item, item) || other.item == item)&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,item,partialResultToken,workDoneToken);

@override
String toString() {
  return 'CallHierarchyOutgoingCallsParams(item: $item, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $CallHierarchyOutgoingCallsParamsCopyWith<$Res>  {
  factory $CallHierarchyOutgoingCallsParamsCopyWith(CallHierarchyOutgoingCallsParams value, $Res Function(CallHierarchyOutgoingCallsParams) _then) = _$CallHierarchyOutgoingCallsParamsCopyWithImpl;
@useResult
$Res call({
 CallHierarchyItem item, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


$CallHierarchyItemCopyWith<$Res> get item;

}
/// @nodoc
class _$CallHierarchyOutgoingCallsParamsCopyWithImpl<$Res>
    implements $CallHierarchyOutgoingCallsParamsCopyWith<$Res> {
  _$CallHierarchyOutgoingCallsParamsCopyWithImpl(this._self, this._then);

  final CallHierarchyOutgoingCallsParams _self;
  final $Res Function(CallHierarchyOutgoingCallsParams) _then;

/// Create a copy of CallHierarchyOutgoingCallsParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? item = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
item: null == item ? _self.item : item // ignore: cast_nullable_to_non_nullable
as CallHierarchyItem,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of CallHierarchyOutgoingCallsParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CallHierarchyItemCopyWith<$Res> get item {
  
  return $CallHierarchyItemCopyWith<$Res>(_self.item, (value) {
    return _then(_self.copyWith(item: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _CallHierarchyOutgoingCallsParams implements CallHierarchyOutgoingCallsParams {
  const _CallHierarchyOutgoingCallsParams({required this.item, this.partialResultToken, this.workDoneToken});
  factory _CallHierarchyOutgoingCallsParams.fromJson(Map<String, dynamic> json) => _$CallHierarchyOutgoingCallsParamsFromJson(json);

@override final  CallHierarchyItem item;
/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
@override final  ProgressToken? partialResultToken;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of CallHierarchyOutgoingCallsParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CallHierarchyOutgoingCallsParamsCopyWith<_CallHierarchyOutgoingCallsParams> get copyWith => __$CallHierarchyOutgoingCallsParamsCopyWithImpl<_CallHierarchyOutgoingCallsParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CallHierarchyOutgoingCallsParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CallHierarchyOutgoingCallsParams&&(identical(other.item, item) || other.item == item)&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,item,partialResultToken,workDoneToken);

@override
String toString() {
  return 'CallHierarchyOutgoingCallsParams(item: $item, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$CallHierarchyOutgoingCallsParamsCopyWith<$Res> implements $CallHierarchyOutgoingCallsParamsCopyWith<$Res> {
  factory _$CallHierarchyOutgoingCallsParamsCopyWith(_CallHierarchyOutgoingCallsParams value, $Res Function(_CallHierarchyOutgoingCallsParams) _then) = __$CallHierarchyOutgoingCallsParamsCopyWithImpl;
@override @useResult
$Res call({
 CallHierarchyItem item, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


@override $CallHierarchyItemCopyWith<$Res> get item;

}
/// @nodoc
class __$CallHierarchyOutgoingCallsParamsCopyWithImpl<$Res>
    implements _$CallHierarchyOutgoingCallsParamsCopyWith<$Res> {
  __$CallHierarchyOutgoingCallsParamsCopyWithImpl(this._self, this._then);

  final _CallHierarchyOutgoingCallsParams _self;
  final $Res Function(_CallHierarchyOutgoingCallsParams) _then;

/// Create a copy of CallHierarchyOutgoingCallsParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? item = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_CallHierarchyOutgoingCallsParams(
item: null == item ? _self.item : item // ignore: cast_nullable_to_non_nullable
as CallHierarchyItem,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of CallHierarchyOutgoingCallsParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CallHierarchyItemCopyWith<$Res> get item {
  
  return $CallHierarchyItemCopyWith<$Res>(_self.item, (value) {
    return _then(_self.copyWith(item: value));
  });
}
}


/// @nodoc
mixin _$CallHierarchyOutgoingCall {

/// The range at which this item is called. This is the range relative to
/// the caller, e.g the item passed to {@link
/// CallHierarchyItemProvider.provideCallHierarchyOutgoingCalls
/// `provideCallHierarchyOutgoingCalls`} and not {@link
/// CallHierarchyOutgoingCall.to `this.to`}.
 List<Range> get fromRanges;/// The item that is called.
 CallHierarchyItem get to;
/// Create a copy of CallHierarchyOutgoingCall
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CallHierarchyOutgoingCallCopyWith<CallHierarchyOutgoingCall> get copyWith => _$CallHierarchyOutgoingCallCopyWithImpl<CallHierarchyOutgoingCall>(this as CallHierarchyOutgoingCall, _$identity);

  /// Serializes this CallHierarchyOutgoingCall to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CallHierarchyOutgoingCall&&const DeepCollectionEquality().equals(other.fromRanges, fromRanges)&&(identical(other.to, to) || other.to == to));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(fromRanges),to);

@override
String toString() {
  return 'CallHierarchyOutgoingCall(fromRanges: $fromRanges, to: $to)';
}


}

/// @nodoc
abstract mixin class $CallHierarchyOutgoingCallCopyWith<$Res>  {
  factory $CallHierarchyOutgoingCallCopyWith(CallHierarchyOutgoingCall value, $Res Function(CallHierarchyOutgoingCall) _then) = _$CallHierarchyOutgoingCallCopyWithImpl;
@useResult
$Res call({
 List<Range> fromRanges, CallHierarchyItem to
});


$CallHierarchyItemCopyWith<$Res> get to;

}
/// @nodoc
class _$CallHierarchyOutgoingCallCopyWithImpl<$Res>
    implements $CallHierarchyOutgoingCallCopyWith<$Res> {
  _$CallHierarchyOutgoingCallCopyWithImpl(this._self, this._then);

  final CallHierarchyOutgoingCall _self;
  final $Res Function(CallHierarchyOutgoingCall) _then;

/// Create a copy of CallHierarchyOutgoingCall
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? fromRanges = null,Object? to = null,}) {
  return _then(_self.copyWith(
fromRanges: null == fromRanges ? _self.fromRanges : fromRanges // ignore: cast_nullable_to_non_nullable
as List<Range>,to: null == to ? _self.to : to // ignore: cast_nullable_to_non_nullable
as CallHierarchyItem,
  ));
}
/// Create a copy of CallHierarchyOutgoingCall
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CallHierarchyItemCopyWith<$Res> get to {
  
  return $CallHierarchyItemCopyWith<$Res>(_self.to, (value) {
    return _then(_self.copyWith(to: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _CallHierarchyOutgoingCall implements CallHierarchyOutgoingCall {
  const _CallHierarchyOutgoingCall({required final  List<Range> fromRanges, required this.to}): _fromRanges = fromRanges;
  factory _CallHierarchyOutgoingCall.fromJson(Map<String, dynamic> json) => _$CallHierarchyOutgoingCallFromJson(json);

/// The range at which this item is called. This is the range relative to
/// the caller, e.g the item passed to {@link
/// CallHierarchyItemProvider.provideCallHierarchyOutgoingCalls
/// `provideCallHierarchyOutgoingCalls`} and not {@link
/// CallHierarchyOutgoingCall.to `this.to`}.
 final  List<Range> _fromRanges;
/// The range at which this item is called. This is the range relative to
/// the caller, e.g the item passed to {@link
/// CallHierarchyItemProvider.provideCallHierarchyOutgoingCalls
/// `provideCallHierarchyOutgoingCalls`} and not {@link
/// CallHierarchyOutgoingCall.to `this.to`}.
@override List<Range> get fromRanges {
  if (_fromRanges is EqualUnmodifiableListView) return _fromRanges;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_fromRanges);
}

/// The item that is called.
@override final  CallHierarchyItem to;

/// Create a copy of CallHierarchyOutgoingCall
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CallHierarchyOutgoingCallCopyWith<_CallHierarchyOutgoingCall> get copyWith => __$CallHierarchyOutgoingCallCopyWithImpl<_CallHierarchyOutgoingCall>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CallHierarchyOutgoingCallToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CallHierarchyOutgoingCall&&const DeepCollectionEquality().equals(other._fromRanges, _fromRanges)&&(identical(other.to, to) || other.to == to));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_fromRanges),to);

@override
String toString() {
  return 'CallHierarchyOutgoingCall(fromRanges: $fromRanges, to: $to)';
}


}

/// @nodoc
abstract mixin class _$CallHierarchyOutgoingCallCopyWith<$Res> implements $CallHierarchyOutgoingCallCopyWith<$Res> {
  factory _$CallHierarchyOutgoingCallCopyWith(_CallHierarchyOutgoingCall value, $Res Function(_CallHierarchyOutgoingCall) _then) = __$CallHierarchyOutgoingCallCopyWithImpl;
@override @useResult
$Res call({
 List<Range> fromRanges, CallHierarchyItem to
});


@override $CallHierarchyItemCopyWith<$Res> get to;

}
/// @nodoc
class __$CallHierarchyOutgoingCallCopyWithImpl<$Res>
    implements _$CallHierarchyOutgoingCallCopyWith<$Res> {
  __$CallHierarchyOutgoingCallCopyWithImpl(this._self, this._then);

  final _CallHierarchyOutgoingCall _self;
  final $Res Function(_CallHierarchyOutgoingCall) _then;

/// Create a copy of CallHierarchyOutgoingCall
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? fromRanges = null,Object? to = null,}) {
  return _then(_CallHierarchyOutgoingCall(
fromRanges: null == fromRanges ? _self._fromRanges : fromRanges // ignore: cast_nullable_to_non_nullable
as List<Range>,to: null == to ? _self.to : to // ignore: cast_nullable_to_non_nullable
as CallHierarchyItem,
  ));
}

/// Create a copy of CallHierarchyOutgoingCall
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CallHierarchyItemCopyWith<$Res> get to {
  
  return $CallHierarchyItemCopyWith<$Res>(_self.to, (value) {
    return _then(_self.copyWith(to: value));
  });
}
}


/// @nodoc
mixin _$SemanticTokensParams {

/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
 ProgressToken? get partialResultToken;/// The text document.
 TextDocumentIdentifier get textDocument;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of SemanticTokensParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SemanticTokensParamsCopyWith<SemanticTokensParams> get copyWith => _$SemanticTokensParamsCopyWithImpl<SemanticTokensParams>(this as SemanticTokensParams, _$identity);

  /// Serializes this SemanticTokensParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SemanticTokensParams&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,partialResultToken,textDocument,workDoneToken);

@override
String toString() {
  return 'SemanticTokensParams(partialResultToken: $partialResultToken, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $SemanticTokensParamsCopyWith<$Res>  {
  factory $SemanticTokensParamsCopyWith(SemanticTokensParams value, $Res Function(SemanticTokensParams) _then) = _$SemanticTokensParamsCopyWithImpl;
@useResult
$Res call({
 ProgressToken? partialResultToken, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$SemanticTokensParamsCopyWithImpl<$Res>
    implements $SemanticTokensParamsCopyWith<$Res> {
  _$SemanticTokensParamsCopyWithImpl(this._self, this._then);

  final SemanticTokensParams _self;
  final $Res Function(SemanticTokensParams) _then;

/// Create a copy of SemanticTokensParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? partialResultToken = freezed,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of SemanticTokensParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _SemanticTokensParams implements SemanticTokensParams {
  const _SemanticTokensParams({this.partialResultToken, required this.textDocument, this.workDoneToken});
  factory _SemanticTokensParams.fromJson(Map<String, dynamic> json) => _$SemanticTokensParamsFromJson(json);

/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
@override final  ProgressToken? partialResultToken;
/// The text document.
@override final  TextDocumentIdentifier textDocument;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of SemanticTokensParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SemanticTokensParamsCopyWith<_SemanticTokensParams> get copyWith => __$SemanticTokensParamsCopyWithImpl<_SemanticTokensParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SemanticTokensParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SemanticTokensParams&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,partialResultToken,textDocument,workDoneToken);

@override
String toString() {
  return 'SemanticTokensParams(partialResultToken: $partialResultToken, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$SemanticTokensParamsCopyWith<$Res> implements $SemanticTokensParamsCopyWith<$Res> {
  factory _$SemanticTokensParamsCopyWith(_SemanticTokensParams value, $Res Function(_SemanticTokensParams) _then) = __$SemanticTokensParamsCopyWithImpl;
@override @useResult
$Res call({
 ProgressToken? partialResultToken, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$SemanticTokensParamsCopyWithImpl<$Res>
    implements _$SemanticTokensParamsCopyWith<$Res> {
  __$SemanticTokensParamsCopyWithImpl(this._self, this._then);

  final _SemanticTokensParams _self;
  final $Res Function(_SemanticTokensParams) _then;

/// Create a copy of SemanticTokensParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? partialResultToken = freezed,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_SemanticTokensParams(
partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of SemanticTokensParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$SemanticTokens {

/// The actual tokens.
 List<int> get data;/// An optional result id. If provided and clients support delta updating
/// the client will include the result id in the next semantic token
/// request. A server can then instead of computing all semantic tokens
/// again simply send a delta.
 String? get resultId;
/// Create a copy of SemanticTokens
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SemanticTokensCopyWith<SemanticTokens> get copyWith => _$SemanticTokensCopyWithImpl<SemanticTokens>(this as SemanticTokens, _$identity);

  /// Serializes this SemanticTokens to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SemanticTokens&&const DeepCollectionEquality().equals(other.data, data)&&(identical(other.resultId, resultId) || other.resultId == resultId));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(data),resultId);

@override
String toString() {
  return 'SemanticTokens(data: $data, resultId: $resultId)';
}


}

/// @nodoc
abstract mixin class $SemanticTokensCopyWith<$Res>  {
  factory $SemanticTokensCopyWith(SemanticTokens value, $Res Function(SemanticTokens) _then) = _$SemanticTokensCopyWithImpl;
@useResult
$Res call({
 List<int> data, String? resultId
});




}
/// @nodoc
class _$SemanticTokensCopyWithImpl<$Res>
    implements $SemanticTokensCopyWith<$Res> {
  _$SemanticTokensCopyWithImpl(this._self, this._then);

  final SemanticTokens _self;
  final $Res Function(SemanticTokens) _then;

/// Create a copy of SemanticTokens
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? data = null,Object? resultId = freezed,}) {
  return _then(_self.copyWith(
data: null == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as List<int>,resultId: freezed == resultId ? _self.resultId : resultId // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _SemanticTokens implements SemanticTokens {
  const _SemanticTokens({required final  List<int> data, this.resultId}): _data = data;
  factory _SemanticTokens.fromJson(Map<String, dynamic> json) => _$SemanticTokensFromJson(json);

/// The actual tokens.
 final  List<int> _data;
/// The actual tokens.
@override List<int> get data {
  if (_data is EqualUnmodifiableListView) return _data;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_data);
}

/// An optional result id. If provided and clients support delta updating
/// the client will include the result id in the next semantic token
/// request. A server can then instead of computing all semantic tokens
/// again simply send a delta.
@override final  String? resultId;

/// Create a copy of SemanticTokens
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SemanticTokensCopyWith<_SemanticTokens> get copyWith => __$SemanticTokensCopyWithImpl<_SemanticTokens>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SemanticTokensToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SemanticTokens&&const DeepCollectionEquality().equals(other._data, _data)&&(identical(other.resultId, resultId) || other.resultId == resultId));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_data),resultId);

@override
String toString() {
  return 'SemanticTokens(data: $data, resultId: $resultId)';
}


}

/// @nodoc
abstract mixin class _$SemanticTokensCopyWith<$Res> implements $SemanticTokensCopyWith<$Res> {
  factory _$SemanticTokensCopyWith(_SemanticTokens value, $Res Function(_SemanticTokens) _then) = __$SemanticTokensCopyWithImpl;
@override @useResult
$Res call({
 List<int> data, String? resultId
});




}
/// @nodoc
class __$SemanticTokensCopyWithImpl<$Res>
    implements _$SemanticTokensCopyWith<$Res> {
  __$SemanticTokensCopyWithImpl(this._self, this._then);

  final _SemanticTokens _self;
  final $Res Function(_SemanticTokens) _then;

/// Create a copy of SemanticTokens
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? data = null,Object? resultId = freezed,}) {
  return _then(_SemanticTokens(
data: null == data ? _self._data : data // ignore: cast_nullable_to_non_nullable
as List<int>,resultId: freezed == resultId ? _self.resultId : resultId // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$SemanticTokensPartialResult {

 List<int> get data;
/// Create a copy of SemanticTokensPartialResult
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SemanticTokensPartialResultCopyWith<SemanticTokensPartialResult> get copyWith => _$SemanticTokensPartialResultCopyWithImpl<SemanticTokensPartialResult>(this as SemanticTokensPartialResult, _$identity);

  /// Serializes this SemanticTokensPartialResult to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SemanticTokensPartialResult&&const DeepCollectionEquality().equals(other.data, data));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(data));

@override
String toString() {
  return 'SemanticTokensPartialResult(data: $data)';
}


}

/// @nodoc
abstract mixin class $SemanticTokensPartialResultCopyWith<$Res>  {
  factory $SemanticTokensPartialResultCopyWith(SemanticTokensPartialResult value, $Res Function(SemanticTokensPartialResult) _then) = _$SemanticTokensPartialResultCopyWithImpl;
@useResult
$Res call({
 List<int> data
});




}
/// @nodoc
class _$SemanticTokensPartialResultCopyWithImpl<$Res>
    implements $SemanticTokensPartialResultCopyWith<$Res> {
  _$SemanticTokensPartialResultCopyWithImpl(this._self, this._then);

  final SemanticTokensPartialResult _self;
  final $Res Function(SemanticTokensPartialResult) _then;

/// Create a copy of SemanticTokensPartialResult
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? data = null,}) {
  return _then(_self.copyWith(
data: null == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as List<int>,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _SemanticTokensPartialResult implements SemanticTokensPartialResult {
  const _SemanticTokensPartialResult({required final  List<int> data}): _data = data;
  factory _SemanticTokensPartialResult.fromJson(Map<String, dynamic> json) => _$SemanticTokensPartialResultFromJson(json);

 final  List<int> _data;
@override List<int> get data {
  if (_data is EqualUnmodifiableListView) return _data;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_data);
}


/// Create a copy of SemanticTokensPartialResult
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SemanticTokensPartialResultCopyWith<_SemanticTokensPartialResult> get copyWith => __$SemanticTokensPartialResultCopyWithImpl<_SemanticTokensPartialResult>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SemanticTokensPartialResultToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SemanticTokensPartialResult&&const DeepCollectionEquality().equals(other._data, _data));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_data));

@override
String toString() {
  return 'SemanticTokensPartialResult(data: $data)';
}


}

/// @nodoc
abstract mixin class _$SemanticTokensPartialResultCopyWith<$Res> implements $SemanticTokensPartialResultCopyWith<$Res> {
  factory _$SemanticTokensPartialResultCopyWith(_SemanticTokensPartialResult value, $Res Function(_SemanticTokensPartialResult) _then) = __$SemanticTokensPartialResultCopyWithImpl;
@override @useResult
$Res call({
 List<int> data
});




}
/// @nodoc
class __$SemanticTokensPartialResultCopyWithImpl<$Res>
    implements _$SemanticTokensPartialResultCopyWith<$Res> {
  __$SemanticTokensPartialResultCopyWithImpl(this._self, this._then);

  final _SemanticTokensPartialResult _self;
  final $Res Function(_SemanticTokensPartialResult) _then;

/// Create a copy of SemanticTokensPartialResult
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? data = null,}) {
  return _then(_SemanticTokensPartialResult(
data: null == data ? _self._data : data // ignore: cast_nullable_to_non_nullable
as List<int>,
  ));
}


}


/// @nodoc
mixin _$SemanticTokensRegistrationOptions {

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
 Sealed14 get documentSelector;/// Server supports providing semantic tokens for a full document.
 Sealed26? get full;/// The id used to register the request. The id can be used to deregister
/// the request again. See also Registration#id.
 String? get id;/// The legend used by the server
 SemanticTokensLegend get legend;/// Server supports providing semantic tokens for a specific range of a
/// document.
 Sealed25? get range;
/// Create a copy of SemanticTokensRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SemanticTokensRegistrationOptionsCopyWith<SemanticTokensRegistrationOptions> get copyWith => _$SemanticTokensRegistrationOptionsCopyWithImpl<SemanticTokensRegistrationOptions>(this as SemanticTokensRegistrationOptions, _$identity);

  /// Serializes this SemanticTokensRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SemanticTokensRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.full, full) || other.full == full)&&(identical(other.id, id) || other.id == id)&&(identical(other.legend, legend) || other.legend == legend)&&(identical(other.range, range) || other.range == range));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,full,id,legend,range);

@override
String toString() {
  return 'SemanticTokensRegistrationOptions(documentSelector: $documentSelector, full: $full, id: $id, legend: $legend, range: $range)';
}


}

/// @nodoc
abstract mixin class $SemanticTokensRegistrationOptionsCopyWith<$Res>  {
  factory $SemanticTokensRegistrationOptionsCopyWith(SemanticTokensRegistrationOptions value, $Res Function(SemanticTokensRegistrationOptions) _then) = _$SemanticTokensRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 Sealed14 documentSelector, Sealed26? full, String? id, SemanticTokensLegend legend, Sealed25? range
});


$SemanticTokensLegendCopyWith<$Res> get legend;

}
/// @nodoc
class _$SemanticTokensRegistrationOptionsCopyWithImpl<$Res>
    implements $SemanticTokensRegistrationOptionsCopyWith<$Res> {
  _$SemanticTokensRegistrationOptionsCopyWithImpl(this._self, this._then);

  final SemanticTokensRegistrationOptions _self;
  final $Res Function(SemanticTokensRegistrationOptions) _then;

/// Create a copy of SemanticTokensRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = null,Object? full = freezed,Object? id = freezed,Object? legend = null,Object? range = freezed,}) {
  return _then(_self.copyWith(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,full: freezed == full ? _self.full : full // ignore: cast_nullable_to_non_nullable
as Sealed26?,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,legend: null == legend ? _self.legend : legend // ignore: cast_nullable_to_non_nullable
as SemanticTokensLegend,range: freezed == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Sealed25?,
  ));
}
/// Create a copy of SemanticTokensRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SemanticTokensLegendCopyWith<$Res> get legend {
  
  return $SemanticTokensLegendCopyWith<$Res>(_self.legend, (value) {
    return _then(_self.copyWith(legend: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _SemanticTokensRegistrationOptions implements SemanticTokensRegistrationOptions {
  const _SemanticTokensRegistrationOptions({required this.documentSelector, this.full, this.id, required this.legend, this.range});
  factory _SemanticTokensRegistrationOptions.fromJson(Map<String, dynamic> json) => _$SemanticTokensRegistrationOptionsFromJson(json);

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
@override final  Sealed14 documentSelector;
/// Server supports providing semantic tokens for a full document.
@override final  Sealed26? full;
/// The id used to register the request. The id can be used to deregister
/// the request again. See also Registration#id.
@override final  String? id;
/// The legend used by the server
@override final  SemanticTokensLegend legend;
/// Server supports providing semantic tokens for a specific range of a
/// document.
@override final  Sealed25? range;

/// Create a copy of SemanticTokensRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SemanticTokensRegistrationOptionsCopyWith<_SemanticTokensRegistrationOptions> get copyWith => __$SemanticTokensRegistrationOptionsCopyWithImpl<_SemanticTokensRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SemanticTokensRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SemanticTokensRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.full, full) || other.full == full)&&(identical(other.id, id) || other.id == id)&&(identical(other.legend, legend) || other.legend == legend)&&(identical(other.range, range) || other.range == range));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,full,id,legend,range);

@override
String toString() {
  return 'SemanticTokensRegistrationOptions(documentSelector: $documentSelector, full: $full, id: $id, legend: $legend, range: $range)';
}


}

/// @nodoc
abstract mixin class _$SemanticTokensRegistrationOptionsCopyWith<$Res> implements $SemanticTokensRegistrationOptionsCopyWith<$Res> {
  factory _$SemanticTokensRegistrationOptionsCopyWith(_SemanticTokensRegistrationOptions value, $Res Function(_SemanticTokensRegistrationOptions) _then) = __$SemanticTokensRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 Sealed14 documentSelector, Sealed26? full, String? id, SemanticTokensLegend legend, Sealed25? range
});


@override $SemanticTokensLegendCopyWith<$Res> get legend;

}
/// @nodoc
class __$SemanticTokensRegistrationOptionsCopyWithImpl<$Res>
    implements _$SemanticTokensRegistrationOptionsCopyWith<$Res> {
  __$SemanticTokensRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _SemanticTokensRegistrationOptions _self;
  final $Res Function(_SemanticTokensRegistrationOptions) _then;

/// Create a copy of SemanticTokensRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = null,Object? full = freezed,Object? id = freezed,Object? legend = null,Object? range = freezed,}) {
  return _then(_SemanticTokensRegistrationOptions(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,full: freezed == full ? _self.full : full // ignore: cast_nullable_to_non_nullable
as Sealed26?,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,legend: null == legend ? _self.legend : legend // ignore: cast_nullable_to_non_nullable
as SemanticTokensLegend,range: freezed == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Sealed25?,
  ));
}

/// Create a copy of SemanticTokensRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SemanticTokensLegendCopyWith<$Res> get legend {
  
  return $SemanticTokensLegendCopyWith<$Res>(_self.legend, (value) {
    return _then(_self.copyWith(legend: value));
  });
}
}


/// @nodoc
mixin _$SemanticTokensDeltaParams {

/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
 ProgressToken? get partialResultToken;/// The result id of a previous response. The result Id can either point to
/// a full response or a delta response depending on what was received
/// last.
 String get previousResultId;/// The text document.
 TextDocumentIdentifier get textDocument;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of SemanticTokensDeltaParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SemanticTokensDeltaParamsCopyWith<SemanticTokensDeltaParams> get copyWith => _$SemanticTokensDeltaParamsCopyWithImpl<SemanticTokensDeltaParams>(this as SemanticTokensDeltaParams, _$identity);

  /// Serializes this SemanticTokensDeltaParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SemanticTokensDeltaParams&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.previousResultId, previousResultId) || other.previousResultId == previousResultId)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,partialResultToken,previousResultId,textDocument,workDoneToken);

@override
String toString() {
  return 'SemanticTokensDeltaParams(partialResultToken: $partialResultToken, previousResultId: $previousResultId, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $SemanticTokensDeltaParamsCopyWith<$Res>  {
  factory $SemanticTokensDeltaParamsCopyWith(SemanticTokensDeltaParams value, $Res Function(SemanticTokensDeltaParams) _then) = _$SemanticTokensDeltaParamsCopyWithImpl;
@useResult
$Res call({
 ProgressToken? partialResultToken, String previousResultId, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$SemanticTokensDeltaParamsCopyWithImpl<$Res>
    implements $SemanticTokensDeltaParamsCopyWith<$Res> {
  _$SemanticTokensDeltaParamsCopyWithImpl(this._self, this._then);

  final SemanticTokensDeltaParams _self;
  final $Res Function(SemanticTokensDeltaParams) _then;

/// Create a copy of SemanticTokensDeltaParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? partialResultToken = freezed,Object? previousResultId = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,previousResultId: null == previousResultId ? _self.previousResultId : previousResultId // ignore: cast_nullable_to_non_nullable
as String,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of SemanticTokensDeltaParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _SemanticTokensDeltaParams implements SemanticTokensDeltaParams {
  const _SemanticTokensDeltaParams({this.partialResultToken, required this.previousResultId, required this.textDocument, this.workDoneToken});
  factory _SemanticTokensDeltaParams.fromJson(Map<String, dynamic> json) => _$SemanticTokensDeltaParamsFromJson(json);

/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
@override final  ProgressToken? partialResultToken;
/// The result id of a previous response. The result Id can either point to
/// a full response or a delta response depending on what was received
/// last.
@override final  String previousResultId;
/// The text document.
@override final  TextDocumentIdentifier textDocument;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of SemanticTokensDeltaParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SemanticTokensDeltaParamsCopyWith<_SemanticTokensDeltaParams> get copyWith => __$SemanticTokensDeltaParamsCopyWithImpl<_SemanticTokensDeltaParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SemanticTokensDeltaParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SemanticTokensDeltaParams&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.previousResultId, previousResultId) || other.previousResultId == previousResultId)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,partialResultToken,previousResultId,textDocument,workDoneToken);

@override
String toString() {
  return 'SemanticTokensDeltaParams(partialResultToken: $partialResultToken, previousResultId: $previousResultId, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$SemanticTokensDeltaParamsCopyWith<$Res> implements $SemanticTokensDeltaParamsCopyWith<$Res> {
  factory _$SemanticTokensDeltaParamsCopyWith(_SemanticTokensDeltaParams value, $Res Function(_SemanticTokensDeltaParams) _then) = __$SemanticTokensDeltaParamsCopyWithImpl;
@override @useResult
$Res call({
 ProgressToken? partialResultToken, String previousResultId, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$SemanticTokensDeltaParamsCopyWithImpl<$Res>
    implements _$SemanticTokensDeltaParamsCopyWith<$Res> {
  __$SemanticTokensDeltaParamsCopyWithImpl(this._self, this._then);

  final _SemanticTokensDeltaParams _self;
  final $Res Function(_SemanticTokensDeltaParams) _then;

/// Create a copy of SemanticTokensDeltaParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? partialResultToken = freezed,Object? previousResultId = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_SemanticTokensDeltaParams(
partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,previousResultId: null == previousResultId ? _self.previousResultId : previousResultId // ignore: cast_nullable_to_non_nullable
as String,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of SemanticTokensDeltaParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$SemanticTokensDelta {

/// The semantic token edits to transform a previous result into a new
/// result.
 List<SemanticTokensEdit> get edits; String? get resultId;
/// Create a copy of SemanticTokensDelta
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SemanticTokensDeltaCopyWith<SemanticTokensDelta> get copyWith => _$SemanticTokensDeltaCopyWithImpl<SemanticTokensDelta>(this as SemanticTokensDelta, _$identity);

  /// Serializes this SemanticTokensDelta to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SemanticTokensDelta&&const DeepCollectionEquality().equals(other.edits, edits)&&(identical(other.resultId, resultId) || other.resultId == resultId));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(edits),resultId);

@override
String toString() {
  return 'SemanticTokensDelta(edits: $edits, resultId: $resultId)';
}


}

/// @nodoc
abstract mixin class $SemanticTokensDeltaCopyWith<$Res>  {
  factory $SemanticTokensDeltaCopyWith(SemanticTokensDelta value, $Res Function(SemanticTokensDelta) _then) = _$SemanticTokensDeltaCopyWithImpl;
@useResult
$Res call({
 List<SemanticTokensEdit> edits, String? resultId
});




}
/// @nodoc
class _$SemanticTokensDeltaCopyWithImpl<$Res>
    implements $SemanticTokensDeltaCopyWith<$Res> {
  _$SemanticTokensDeltaCopyWithImpl(this._self, this._then);

  final SemanticTokensDelta _self;
  final $Res Function(SemanticTokensDelta) _then;

/// Create a copy of SemanticTokensDelta
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? edits = null,Object? resultId = freezed,}) {
  return _then(_self.copyWith(
edits: null == edits ? _self.edits : edits // ignore: cast_nullable_to_non_nullable
as List<SemanticTokensEdit>,resultId: freezed == resultId ? _self.resultId : resultId // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _SemanticTokensDelta implements SemanticTokensDelta {
  const _SemanticTokensDelta({required final  List<SemanticTokensEdit> edits, this.resultId}): _edits = edits;
  factory _SemanticTokensDelta.fromJson(Map<String, dynamic> json) => _$SemanticTokensDeltaFromJson(json);

/// The semantic token edits to transform a previous result into a new
/// result.
 final  List<SemanticTokensEdit> _edits;
/// The semantic token edits to transform a previous result into a new
/// result.
@override List<SemanticTokensEdit> get edits {
  if (_edits is EqualUnmodifiableListView) return _edits;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_edits);
}

@override final  String? resultId;

/// Create a copy of SemanticTokensDelta
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SemanticTokensDeltaCopyWith<_SemanticTokensDelta> get copyWith => __$SemanticTokensDeltaCopyWithImpl<_SemanticTokensDelta>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SemanticTokensDeltaToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SemanticTokensDelta&&const DeepCollectionEquality().equals(other._edits, _edits)&&(identical(other.resultId, resultId) || other.resultId == resultId));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_edits),resultId);

@override
String toString() {
  return 'SemanticTokensDelta(edits: $edits, resultId: $resultId)';
}


}

/// @nodoc
abstract mixin class _$SemanticTokensDeltaCopyWith<$Res> implements $SemanticTokensDeltaCopyWith<$Res> {
  factory _$SemanticTokensDeltaCopyWith(_SemanticTokensDelta value, $Res Function(_SemanticTokensDelta) _then) = __$SemanticTokensDeltaCopyWithImpl;
@override @useResult
$Res call({
 List<SemanticTokensEdit> edits, String? resultId
});




}
/// @nodoc
class __$SemanticTokensDeltaCopyWithImpl<$Res>
    implements _$SemanticTokensDeltaCopyWith<$Res> {
  __$SemanticTokensDeltaCopyWithImpl(this._self, this._then);

  final _SemanticTokensDelta _self;
  final $Res Function(_SemanticTokensDelta) _then;

/// Create a copy of SemanticTokensDelta
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? edits = null,Object? resultId = freezed,}) {
  return _then(_SemanticTokensDelta(
edits: null == edits ? _self._edits : edits // ignore: cast_nullable_to_non_nullable
as List<SemanticTokensEdit>,resultId: freezed == resultId ? _self.resultId : resultId // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$SemanticTokensDeltaPartialResult {

 List<SemanticTokensEdit> get edits;
/// Create a copy of SemanticTokensDeltaPartialResult
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SemanticTokensDeltaPartialResultCopyWith<SemanticTokensDeltaPartialResult> get copyWith => _$SemanticTokensDeltaPartialResultCopyWithImpl<SemanticTokensDeltaPartialResult>(this as SemanticTokensDeltaPartialResult, _$identity);

  /// Serializes this SemanticTokensDeltaPartialResult to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SemanticTokensDeltaPartialResult&&const DeepCollectionEquality().equals(other.edits, edits));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(edits));

@override
String toString() {
  return 'SemanticTokensDeltaPartialResult(edits: $edits)';
}


}

/// @nodoc
abstract mixin class $SemanticTokensDeltaPartialResultCopyWith<$Res>  {
  factory $SemanticTokensDeltaPartialResultCopyWith(SemanticTokensDeltaPartialResult value, $Res Function(SemanticTokensDeltaPartialResult) _then) = _$SemanticTokensDeltaPartialResultCopyWithImpl;
@useResult
$Res call({
 List<SemanticTokensEdit> edits
});




}
/// @nodoc
class _$SemanticTokensDeltaPartialResultCopyWithImpl<$Res>
    implements $SemanticTokensDeltaPartialResultCopyWith<$Res> {
  _$SemanticTokensDeltaPartialResultCopyWithImpl(this._self, this._then);

  final SemanticTokensDeltaPartialResult _self;
  final $Res Function(SemanticTokensDeltaPartialResult) _then;

/// Create a copy of SemanticTokensDeltaPartialResult
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? edits = null,}) {
  return _then(_self.copyWith(
edits: null == edits ? _self.edits : edits // ignore: cast_nullable_to_non_nullable
as List<SemanticTokensEdit>,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _SemanticTokensDeltaPartialResult implements SemanticTokensDeltaPartialResult {
  const _SemanticTokensDeltaPartialResult({required final  List<SemanticTokensEdit> edits}): _edits = edits;
  factory _SemanticTokensDeltaPartialResult.fromJson(Map<String, dynamic> json) => _$SemanticTokensDeltaPartialResultFromJson(json);

 final  List<SemanticTokensEdit> _edits;
@override List<SemanticTokensEdit> get edits {
  if (_edits is EqualUnmodifiableListView) return _edits;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_edits);
}


/// Create a copy of SemanticTokensDeltaPartialResult
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SemanticTokensDeltaPartialResultCopyWith<_SemanticTokensDeltaPartialResult> get copyWith => __$SemanticTokensDeltaPartialResultCopyWithImpl<_SemanticTokensDeltaPartialResult>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SemanticTokensDeltaPartialResultToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SemanticTokensDeltaPartialResult&&const DeepCollectionEquality().equals(other._edits, _edits));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_edits));

@override
String toString() {
  return 'SemanticTokensDeltaPartialResult(edits: $edits)';
}


}

/// @nodoc
abstract mixin class _$SemanticTokensDeltaPartialResultCopyWith<$Res> implements $SemanticTokensDeltaPartialResultCopyWith<$Res> {
  factory _$SemanticTokensDeltaPartialResultCopyWith(_SemanticTokensDeltaPartialResult value, $Res Function(_SemanticTokensDeltaPartialResult) _then) = __$SemanticTokensDeltaPartialResultCopyWithImpl;
@override @useResult
$Res call({
 List<SemanticTokensEdit> edits
});




}
/// @nodoc
class __$SemanticTokensDeltaPartialResultCopyWithImpl<$Res>
    implements _$SemanticTokensDeltaPartialResultCopyWith<$Res> {
  __$SemanticTokensDeltaPartialResultCopyWithImpl(this._self, this._then);

  final _SemanticTokensDeltaPartialResult _self;
  final $Res Function(_SemanticTokensDeltaPartialResult) _then;

/// Create a copy of SemanticTokensDeltaPartialResult
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? edits = null,}) {
  return _then(_SemanticTokensDeltaPartialResult(
edits: null == edits ? _self._edits : edits // ignore: cast_nullable_to_non_nullable
as List<SemanticTokensEdit>,
  ));
}


}


/// @nodoc
mixin _$SemanticTokensRangeParams {

/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
 ProgressToken? get partialResultToken;/// The range the semantic tokens are requested for.
 Range get range;/// The text document.
 TextDocumentIdentifier get textDocument;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of SemanticTokensRangeParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SemanticTokensRangeParamsCopyWith<SemanticTokensRangeParams> get copyWith => _$SemanticTokensRangeParamsCopyWithImpl<SemanticTokensRangeParams>(this as SemanticTokensRangeParams, _$identity);

  /// Serializes this SemanticTokensRangeParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SemanticTokensRangeParams&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.range, range) || other.range == range)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,partialResultToken,range,textDocument,workDoneToken);

@override
String toString() {
  return 'SemanticTokensRangeParams(partialResultToken: $partialResultToken, range: $range, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $SemanticTokensRangeParamsCopyWith<$Res>  {
  factory $SemanticTokensRangeParamsCopyWith(SemanticTokensRangeParams value, $Res Function(SemanticTokensRangeParams) _then) = _$SemanticTokensRangeParamsCopyWithImpl;
@useResult
$Res call({
 ProgressToken? partialResultToken, Range range, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


$RangeCopyWith<$Res> get range;$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$SemanticTokensRangeParamsCopyWithImpl<$Res>
    implements $SemanticTokensRangeParamsCopyWith<$Res> {
  _$SemanticTokensRangeParamsCopyWithImpl(this._self, this._then);

  final SemanticTokensRangeParams _self;
  final $Res Function(SemanticTokensRangeParams) _then;

/// Create a copy of SemanticTokensRangeParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? partialResultToken = freezed,Object? range = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of SemanticTokensRangeParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}/// Create a copy of SemanticTokensRangeParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _SemanticTokensRangeParams implements SemanticTokensRangeParams {
  const _SemanticTokensRangeParams({this.partialResultToken, required this.range, required this.textDocument, this.workDoneToken});
  factory _SemanticTokensRangeParams.fromJson(Map<String, dynamic> json) => _$SemanticTokensRangeParamsFromJson(json);

/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
@override final  ProgressToken? partialResultToken;
/// The range the semantic tokens are requested for.
@override final  Range range;
/// The text document.
@override final  TextDocumentIdentifier textDocument;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of SemanticTokensRangeParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SemanticTokensRangeParamsCopyWith<_SemanticTokensRangeParams> get copyWith => __$SemanticTokensRangeParamsCopyWithImpl<_SemanticTokensRangeParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SemanticTokensRangeParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SemanticTokensRangeParams&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.range, range) || other.range == range)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,partialResultToken,range,textDocument,workDoneToken);

@override
String toString() {
  return 'SemanticTokensRangeParams(partialResultToken: $partialResultToken, range: $range, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$SemanticTokensRangeParamsCopyWith<$Res> implements $SemanticTokensRangeParamsCopyWith<$Res> {
  factory _$SemanticTokensRangeParamsCopyWith(_SemanticTokensRangeParams value, $Res Function(_SemanticTokensRangeParams) _then) = __$SemanticTokensRangeParamsCopyWithImpl;
@override @useResult
$Res call({
 ProgressToken? partialResultToken, Range range, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


@override $RangeCopyWith<$Res> get range;@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$SemanticTokensRangeParamsCopyWithImpl<$Res>
    implements _$SemanticTokensRangeParamsCopyWith<$Res> {
  __$SemanticTokensRangeParamsCopyWithImpl(this._self, this._then);

  final _SemanticTokensRangeParams _self;
  final $Res Function(_SemanticTokensRangeParams) _then;

/// Create a copy of SemanticTokensRangeParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? partialResultToken = freezed,Object? range = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_SemanticTokensRangeParams(
partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of SemanticTokensRangeParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}/// Create a copy of SemanticTokensRangeParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$ShowDocumentParams {

/// Indicates to show the resource in an external program. To show, for
/// example, `https://code.visualstudio.com/` in the default WEB browser
/// set `external` to `true`.
 bool? get external;/// An optional selection range if the document is a text document. Clients
/// might ignore the property if an external program is started or the file
/// is not a text file.
 Range? get selection;/// An optional property to indicate whether the editor showing the
/// document should take focus or not. Clients might ignore this property
/// if an external program is started.
 bool? get takeFocus;/// The uri to show.
 String get uri;
/// Create a copy of ShowDocumentParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ShowDocumentParamsCopyWith<ShowDocumentParams> get copyWith => _$ShowDocumentParamsCopyWithImpl<ShowDocumentParams>(this as ShowDocumentParams, _$identity);

  /// Serializes this ShowDocumentParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ShowDocumentParams&&(identical(other.external, external) || other.external == external)&&(identical(other.selection, selection) || other.selection == selection)&&(identical(other.takeFocus, takeFocus) || other.takeFocus == takeFocus)&&(identical(other.uri, uri) || other.uri == uri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,external,selection,takeFocus,uri);

@override
String toString() {
  return 'ShowDocumentParams(external: $external, selection: $selection, takeFocus: $takeFocus, uri: $uri)';
}


}

/// @nodoc
abstract mixin class $ShowDocumentParamsCopyWith<$Res>  {
  factory $ShowDocumentParamsCopyWith(ShowDocumentParams value, $Res Function(ShowDocumentParams) _then) = _$ShowDocumentParamsCopyWithImpl;
@useResult
$Res call({
 bool? external, Range? selection, bool? takeFocus, String uri
});


$RangeCopyWith<$Res>? get selection;

}
/// @nodoc
class _$ShowDocumentParamsCopyWithImpl<$Res>
    implements $ShowDocumentParamsCopyWith<$Res> {
  _$ShowDocumentParamsCopyWithImpl(this._self, this._then);

  final ShowDocumentParams _self;
  final $Res Function(ShowDocumentParams) _then;

/// Create a copy of ShowDocumentParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? external = freezed,Object? selection = freezed,Object? takeFocus = freezed,Object? uri = null,}) {
  return _then(_self.copyWith(
external: freezed == external ? _self.external : external // ignore: cast_nullable_to_non_nullable
as bool?,selection: freezed == selection ? _self.selection : selection // ignore: cast_nullable_to_non_nullable
as Range?,takeFocus: freezed == takeFocus ? _self.takeFocus : takeFocus // ignore: cast_nullable_to_non_nullable
as bool?,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}
/// Create a copy of ShowDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res>? get selection {
    if (_self.selection == null) {
    return null;
  }

  return $RangeCopyWith<$Res>(_self.selection!, (value) {
    return _then(_self.copyWith(selection: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _ShowDocumentParams implements ShowDocumentParams {
  const _ShowDocumentParams({this.external, this.selection, this.takeFocus, required this.uri});
  factory _ShowDocumentParams.fromJson(Map<String, dynamic> json) => _$ShowDocumentParamsFromJson(json);

/// Indicates to show the resource in an external program. To show, for
/// example, `https://code.visualstudio.com/` in the default WEB browser
/// set `external` to `true`.
@override final  bool? external;
/// An optional selection range if the document is a text document. Clients
/// might ignore the property if an external program is started or the file
/// is not a text file.
@override final  Range? selection;
/// An optional property to indicate whether the editor showing the
/// document should take focus or not. Clients might ignore this property
/// if an external program is started.
@override final  bool? takeFocus;
/// The uri to show.
@override final  String uri;

/// Create a copy of ShowDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ShowDocumentParamsCopyWith<_ShowDocumentParams> get copyWith => __$ShowDocumentParamsCopyWithImpl<_ShowDocumentParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ShowDocumentParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ShowDocumentParams&&(identical(other.external, external) || other.external == external)&&(identical(other.selection, selection) || other.selection == selection)&&(identical(other.takeFocus, takeFocus) || other.takeFocus == takeFocus)&&(identical(other.uri, uri) || other.uri == uri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,external,selection,takeFocus,uri);

@override
String toString() {
  return 'ShowDocumentParams(external: $external, selection: $selection, takeFocus: $takeFocus, uri: $uri)';
}


}

/// @nodoc
abstract mixin class _$ShowDocumentParamsCopyWith<$Res> implements $ShowDocumentParamsCopyWith<$Res> {
  factory _$ShowDocumentParamsCopyWith(_ShowDocumentParams value, $Res Function(_ShowDocumentParams) _then) = __$ShowDocumentParamsCopyWithImpl;
@override @useResult
$Res call({
 bool? external, Range? selection, bool? takeFocus, String uri
});


@override $RangeCopyWith<$Res>? get selection;

}
/// @nodoc
class __$ShowDocumentParamsCopyWithImpl<$Res>
    implements _$ShowDocumentParamsCopyWith<$Res> {
  __$ShowDocumentParamsCopyWithImpl(this._self, this._then);

  final _ShowDocumentParams _self;
  final $Res Function(_ShowDocumentParams) _then;

/// Create a copy of ShowDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? external = freezed,Object? selection = freezed,Object? takeFocus = freezed,Object? uri = null,}) {
  return _then(_ShowDocumentParams(
external: freezed == external ? _self.external : external // ignore: cast_nullable_to_non_nullable
as bool?,selection: freezed == selection ? _self.selection : selection // ignore: cast_nullable_to_non_nullable
as Range?,takeFocus: freezed == takeFocus ? _self.takeFocus : takeFocus // ignore: cast_nullable_to_non_nullable
as bool?,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

/// Create a copy of ShowDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res>? get selection {
    if (_self.selection == null) {
    return null;
  }

  return $RangeCopyWith<$Res>(_self.selection!, (value) {
    return _then(_self.copyWith(selection: value));
  });
}
}


/// @nodoc
mixin _$ShowDocumentResult {

/// A boolean indicating if the show was successful.
 bool get success;
/// Create a copy of ShowDocumentResult
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ShowDocumentResultCopyWith<ShowDocumentResult> get copyWith => _$ShowDocumentResultCopyWithImpl<ShowDocumentResult>(this as ShowDocumentResult, _$identity);

  /// Serializes this ShowDocumentResult to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ShowDocumentResult&&(identical(other.success, success) || other.success == success));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,success);

@override
String toString() {
  return 'ShowDocumentResult(success: $success)';
}


}

/// @nodoc
abstract mixin class $ShowDocumentResultCopyWith<$Res>  {
  factory $ShowDocumentResultCopyWith(ShowDocumentResult value, $Res Function(ShowDocumentResult) _then) = _$ShowDocumentResultCopyWithImpl;
@useResult
$Res call({
 bool success
});




}
/// @nodoc
class _$ShowDocumentResultCopyWithImpl<$Res>
    implements $ShowDocumentResultCopyWith<$Res> {
  _$ShowDocumentResultCopyWithImpl(this._self, this._then);

  final ShowDocumentResult _self;
  final $Res Function(ShowDocumentResult) _then;

/// Create a copy of ShowDocumentResult
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? success = null,}) {
  return _then(_self.copyWith(
success: null == success ? _self.success : success // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _ShowDocumentResult implements ShowDocumentResult {
  const _ShowDocumentResult({required this.success});
  factory _ShowDocumentResult.fromJson(Map<String, dynamic> json) => _$ShowDocumentResultFromJson(json);

/// A boolean indicating if the show was successful.
@override final  bool success;

/// Create a copy of ShowDocumentResult
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ShowDocumentResultCopyWith<_ShowDocumentResult> get copyWith => __$ShowDocumentResultCopyWithImpl<_ShowDocumentResult>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ShowDocumentResultToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ShowDocumentResult&&(identical(other.success, success) || other.success == success));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,success);

@override
String toString() {
  return 'ShowDocumentResult(success: $success)';
}


}

/// @nodoc
abstract mixin class _$ShowDocumentResultCopyWith<$Res> implements $ShowDocumentResultCopyWith<$Res> {
  factory _$ShowDocumentResultCopyWith(_ShowDocumentResult value, $Res Function(_ShowDocumentResult) _then) = __$ShowDocumentResultCopyWithImpl;
@override @useResult
$Res call({
 bool success
});




}
/// @nodoc
class __$ShowDocumentResultCopyWithImpl<$Res>
    implements _$ShowDocumentResultCopyWith<$Res> {
  __$ShowDocumentResultCopyWithImpl(this._self, this._then);

  final _ShowDocumentResult _self;
  final $Res Function(_ShowDocumentResult) _then;

/// Create a copy of ShowDocumentResult
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? success = null,}) {
  return _then(_ShowDocumentResult(
success: null == success ? _self.success : success // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}


}


/// @nodoc
mixin _$LinkedEditingRangeParams {

/// The position inside the text document.
 Position get position;/// The text document.
 TextDocumentIdentifier get textDocument;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of LinkedEditingRangeParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LinkedEditingRangeParamsCopyWith<LinkedEditingRangeParams> get copyWith => _$LinkedEditingRangeParamsCopyWithImpl<LinkedEditingRangeParams>(this as LinkedEditingRangeParams, _$identity);

  /// Serializes this LinkedEditingRangeParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LinkedEditingRangeParams&&(identical(other.position, position) || other.position == position)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,position,textDocument,workDoneToken);

@override
String toString() {
  return 'LinkedEditingRangeParams(position: $position, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $LinkedEditingRangeParamsCopyWith<$Res>  {
  factory $LinkedEditingRangeParamsCopyWith(LinkedEditingRangeParams value, $Res Function(LinkedEditingRangeParams) _then) = _$LinkedEditingRangeParamsCopyWithImpl;
@useResult
$Res call({
 Position position, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


$PositionCopyWith<$Res> get position;$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$LinkedEditingRangeParamsCopyWithImpl<$Res>
    implements $LinkedEditingRangeParamsCopyWith<$Res> {
  _$LinkedEditingRangeParamsCopyWithImpl(this._self, this._then);

  final LinkedEditingRangeParams _self;
  final $Res Function(LinkedEditingRangeParams) _then;

/// Create a copy of LinkedEditingRangeParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? position = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of LinkedEditingRangeParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of LinkedEditingRangeParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _LinkedEditingRangeParams implements LinkedEditingRangeParams {
  const _LinkedEditingRangeParams({required this.position, required this.textDocument, this.workDoneToken});
  factory _LinkedEditingRangeParams.fromJson(Map<String, dynamic> json) => _$LinkedEditingRangeParamsFromJson(json);

/// The position inside the text document.
@override final  Position position;
/// The text document.
@override final  TextDocumentIdentifier textDocument;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of LinkedEditingRangeParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$LinkedEditingRangeParamsCopyWith<_LinkedEditingRangeParams> get copyWith => __$LinkedEditingRangeParamsCopyWithImpl<_LinkedEditingRangeParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$LinkedEditingRangeParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _LinkedEditingRangeParams&&(identical(other.position, position) || other.position == position)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,position,textDocument,workDoneToken);

@override
String toString() {
  return 'LinkedEditingRangeParams(position: $position, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$LinkedEditingRangeParamsCopyWith<$Res> implements $LinkedEditingRangeParamsCopyWith<$Res> {
  factory _$LinkedEditingRangeParamsCopyWith(_LinkedEditingRangeParams value, $Res Function(_LinkedEditingRangeParams) _then) = __$LinkedEditingRangeParamsCopyWithImpl;
@override @useResult
$Res call({
 Position position, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


@override $PositionCopyWith<$Res> get position;@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$LinkedEditingRangeParamsCopyWithImpl<$Res>
    implements _$LinkedEditingRangeParamsCopyWith<$Res> {
  __$LinkedEditingRangeParamsCopyWithImpl(this._self, this._then);

  final _LinkedEditingRangeParams _self;
  final $Res Function(_LinkedEditingRangeParams) _then;

/// Create a copy of LinkedEditingRangeParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? position = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_LinkedEditingRangeParams(
position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of LinkedEditingRangeParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of LinkedEditingRangeParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$LinkedEditingRanges {

/// A list of ranges that can be edited together. The ranges must have
/// identical length and contain identical text content. The ranges cannot
/// overlap.
 List<Range> get ranges;/// An optional word pattern (regular expression) that describes valid
/// contents for the given ranges. If no pattern is provided, the client
/// configuration's word pattern will be used.
 String? get wordPattern;
/// Create a copy of LinkedEditingRanges
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LinkedEditingRangesCopyWith<LinkedEditingRanges> get copyWith => _$LinkedEditingRangesCopyWithImpl<LinkedEditingRanges>(this as LinkedEditingRanges, _$identity);

  /// Serializes this LinkedEditingRanges to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LinkedEditingRanges&&const DeepCollectionEquality().equals(other.ranges, ranges)&&(identical(other.wordPattern, wordPattern) || other.wordPattern == wordPattern));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(ranges),wordPattern);

@override
String toString() {
  return 'LinkedEditingRanges(ranges: $ranges, wordPattern: $wordPattern)';
}


}

/// @nodoc
abstract mixin class $LinkedEditingRangesCopyWith<$Res>  {
  factory $LinkedEditingRangesCopyWith(LinkedEditingRanges value, $Res Function(LinkedEditingRanges) _then) = _$LinkedEditingRangesCopyWithImpl;
@useResult
$Res call({
 List<Range> ranges, String? wordPattern
});




}
/// @nodoc
class _$LinkedEditingRangesCopyWithImpl<$Res>
    implements $LinkedEditingRangesCopyWith<$Res> {
  _$LinkedEditingRangesCopyWithImpl(this._self, this._then);

  final LinkedEditingRanges _self;
  final $Res Function(LinkedEditingRanges) _then;

/// Create a copy of LinkedEditingRanges
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? ranges = null,Object? wordPattern = freezed,}) {
  return _then(_self.copyWith(
ranges: null == ranges ? _self.ranges : ranges // ignore: cast_nullable_to_non_nullable
as List<Range>,wordPattern: freezed == wordPattern ? _self.wordPattern : wordPattern // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _LinkedEditingRanges implements LinkedEditingRanges {
  const _LinkedEditingRanges({required final  List<Range> ranges, this.wordPattern}): _ranges = ranges;
  factory _LinkedEditingRanges.fromJson(Map<String, dynamic> json) => _$LinkedEditingRangesFromJson(json);

/// A list of ranges that can be edited together. The ranges must have
/// identical length and contain identical text content. The ranges cannot
/// overlap.
 final  List<Range> _ranges;
/// A list of ranges that can be edited together. The ranges must have
/// identical length and contain identical text content. The ranges cannot
/// overlap.
@override List<Range> get ranges {
  if (_ranges is EqualUnmodifiableListView) return _ranges;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_ranges);
}

/// An optional word pattern (regular expression) that describes valid
/// contents for the given ranges. If no pattern is provided, the client
/// configuration's word pattern will be used.
@override final  String? wordPattern;

/// Create a copy of LinkedEditingRanges
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$LinkedEditingRangesCopyWith<_LinkedEditingRanges> get copyWith => __$LinkedEditingRangesCopyWithImpl<_LinkedEditingRanges>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$LinkedEditingRangesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _LinkedEditingRanges&&const DeepCollectionEquality().equals(other._ranges, _ranges)&&(identical(other.wordPattern, wordPattern) || other.wordPattern == wordPattern));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_ranges),wordPattern);

@override
String toString() {
  return 'LinkedEditingRanges(ranges: $ranges, wordPattern: $wordPattern)';
}


}

/// @nodoc
abstract mixin class _$LinkedEditingRangesCopyWith<$Res> implements $LinkedEditingRangesCopyWith<$Res> {
  factory _$LinkedEditingRangesCopyWith(_LinkedEditingRanges value, $Res Function(_LinkedEditingRanges) _then) = __$LinkedEditingRangesCopyWithImpl;
@override @useResult
$Res call({
 List<Range> ranges, String? wordPattern
});




}
/// @nodoc
class __$LinkedEditingRangesCopyWithImpl<$Res>
    implements _$LinkedEditingRangesCopyWith<$Res> {
  __$LinkedEditingRangesCopyWithImpl(this._self, this._then);

  final _LinkedEditingRanges _self;
  final $Res Function(_LinkedEditingRanges) _then;

/// Create a copy of LinkedEditingRanges
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? ranges = null,Object? wordPattern = freezed,}) {
  return _then(_LinkedEditingRanges(
ranges: null == ranges ? _self._ranges : ranges // ignore: cast_nullable_to_non_nullable
as List<Range>,wordPattern: freezed == wordPattern ? _self.wordPattern : wordPattern // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$LinkedEditingRangeRegistrationOptions {

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
 Sealed14 get documentSelector;/// The id used to register the request. The id can be used to deregister
/// the request again. See also Registration#id.
 String? get id;
/// Create a copy of LinkedEditingRangeRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LinkedEditingRangeRegistrationOptionsCopyWith<LinkedEditingRangeRegistrationOptions> get copyWith => _$LinkedEditingRangeRegistrationOptionsCopyWithImpl<LinkedEditingRangeRegistrationOptions>(this as LinkedEditingRangeRegistrationOptions, _$identity);

  /// Serializes this LinkedEditingRangeRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LinkedEditingRangeRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.id, id) || other.id == id));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,id);

@override
String toString() {
  return 'LinkedEditingRangeRegistrationOptions(documentSelector: $documentSelector, id: $id)';
}


}

/// @nodoc
abstract mixin class $LinkedEditingRangeRegistrationOptionsCopyWith<$Res>  {
  factory $LinkedEditingRangeRegistrationOptionsCopyWith(LinkedEditingRangeRegistrationOptions value, $Res Function(LinkedEditingRangeRegistrationOptions) _then) = _$LinkedEditingRangeRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 Sealed14 documentSelector, String? id
});




}
/// @nodoc
class _$LinkedEditingRangeRegistrationOptionsCopyWithImpl<$Res>
    implements $LinkedEditingRangeRegistrationOptionsCopyWith<$Res> {
  _$LinkedEditingRangeRegistrationOptionsCopyWithImpl(this._self, this._then);

  final LinkedEditingRangeRegistrationOptions _self;
  final $Res Function(LinkedEditingRangeRegistrationOptions) _then;

/// Create a copy of LinkedEditingRangeRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = null,Object? id = freezed,}) {
  return _then(_self.copyWith(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _LinkedEditingRangeRegistrationOptions implements LinkedEditingRangeRegistrationOptions {
  const _LinkedEditingRangeRegistrationOptions({required this.documentSelector, this.id});
  factory _LinkedEditingRangeRegistrationOptions.fromJson(Map<String, dynamic> json) => _$LinkedEditingRangeRegistrationOptionsFromJson(json);

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
@override final  Sealed14 documentSelector;
/// The id used to register the request. The id can be used to deregister
/// the request again. See also Registration#id.
@override final  String? id;

/// Create a copy of LinkedEditingRangeRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$LinkedEditingRangeRegistrationOptionsCopyWith<_LinkedEditingRangeRegistrationOptions> get copyWith => __$LinkedEditingRangeRegistrationOptionsCopyWithImpl<_LinkedEditingRangeRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$LinkedEditingRangeRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _LinkedEditingRangeRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.id, id) || other.id == id));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,id);

@override
String toString() {
  return 'LinkedEditingRangeRegistrationOptions(documentSelector: $documentSelector, id: $id)';
}


}

/// @nodoc
abstract mixin class _$LinkedEditingRangeRegistrationOptionsCopyWith<$Res> implements $LinkedEditingRangeRegistrationOptionsCopyWith<$Res> {
  factory _$LinkedEditingRangeRegistrationOptionsCopyWith(_LinkedEditingRangeRegistrationOptions value, $Res Function(_LinkedEditingRangeRegistrationOptions) _then) = __$LinkedEditingRangeRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 Sealed14 documentSelector, String? id
});




}
/// @nodoc
class __$LinkedEditingRangeRegistrationOptionsCopyWithImpl<$Res>
    implements _$LinkedEditingRangeRegistrationOptionsCopyWith<$Res> {
  __$LinkedEditingRangeRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _LinkedEditingRangeRegistrationOptions _self;
  final $Res Function(_LinkedEditingRangeRegistrationOptions) _then;

/// Create a copy of LinkedEditingRangeRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = null,Object? id = freezed,}) {
  return _then(_LinkedEditingRangeRegistrationOptions(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$CreateFilesParams {

/// An array of all files/folders created in this operation.
 List<FileCreate> get files;
/// Create a copy of CreateFilesParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CreateFilesParamsCopyWith<CreateFilesParams> get copyWith => _$CreateFilesParamsCopyWithImpl<CreateFilesParams>(this as CreateFilesParams, _$identity);

  /// Serializes this CreateFilesParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CreateFilesParams&&const DeepCollectionEquality().equals(other.files, files));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(files));

@override
String toString() {
  return 'CreateFilesParams(files: $files)';
}


}

/// @nodoc
abstract mixin class $CreateFilesParamsCopyWith<$Res>  {
  factory $CreateFilesParamsCopyWith(CreateFilesParams value, $Res Function(CreateFilesParams) _then) = _$CreateFilesParamsCopyWithImpl;
@useResult
$Res call({
 List<FileCreate> files
});




}
/// @nodoc
class _$CreateFilesParamsCopyWithImpl<$Res>
    implements $CreateFilesParamsCopyWith<$Res> {
  _$CreateFilesParamsCopyWithImpl(this._self, this._then);

  final CreateFilesParams _self;
  final $Res Function(CreateFilesParams) _then;

/// Create a copy of CreateFilesParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? files = null,}) {
  return _then(_self.copyWith(
files: null == files ? _self.files : files // ignore: cast_nullable_to_non_nullable
as List<FileCreate>,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _CreateFilesParams implements CreateFilesParams {
  const _CreateFilesParams({required final  List<FileCreate> files}): _files = files;
  factory _CreateFilesParams.fromJson(Map<String, dynamic> json) => _$CreateFilesParamsFromJson(json);

/// An array of all files/folders created in this operation.
 final  List<FileCreate> _files;
/// An array of all files/folders created in this operation.
@override List<FileCreate> get files {
  if (_files is EqualUnmodifiableListView) return _files;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_files);
}


/// Create a copy of CreateFilesParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CreateFilesParamsCopyWith<_CreateFilesParams> get copyWith => __$CreateFilesParamsCopyWithImpl<_CreateFilesParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CreateFilesParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CreateFilesParams&&const DeepCollectionEquality().equals(other._files, _files));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_files));

@override
String toString() {
  return 'CreateFilesParams(files: $files)';
}


}

/// @nodoc
abstract mixin class _$CreateFilesParamsCopyWith<$Res> implements $CreateFilesParamsCopyWith<$Res> {
  factory _$CreateFilesParamsCopyWith(_CreateFilesParams value, $Res Function(_CreateFilesParams) _then) = __$CreateFilesParamsCopyWithImpl;
@override @useResult
$Res call({
 List<FileCreate> files
});




}
/// @nodoc
class __$CreateFilesParamsCopyWithImpl<$Res>
    implements _$CreateFilesParamsCopyWith<$Res> {
  __$CreateFilesParamsCopyWithImpl(this._self, this._then);

  final _CreateFilesParams _self;
  final $Res Function(_CreateFilesParams) _then;

/// Create a copy of CreateFilesParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? files = null,}) {
  return _then(_CreateFilesParams(
files: null == files ? _self._files : files // ignore: cast_nullable_to_non_nullable
as List<FileCreate>,
  ));
}


}


/// @nodoc
mixin _$WorkspaceEdit {

/// A map of change annotations that can be referenced in
/// `AnnotatedTextEdit`s or create, rename and delete file / folder
/// operations.
/// Whether clients honor this property depends on the client capability
/// `workspace.changeAnnotationSupport`.
/// @since 3.16.0
 Map<ChangeAnnotationIdentifier, ChangeAnnotation>? get changeAnnotations;/// Holds changes to existing resources.
 Map<String, List<TextEdit>>? get changes;/// Depending on the client capability
/// `workspace.workspaceEdit.resourceOperations` document changes are
/// either an array of `TextDocumentEdit`s to express changes to n
/// different text documents where each text document edit addresses a
/// specific version of a text document. Or it can contain above
/// `TextDocumentEdit`s mixed with create, rename and delete file / folder
/// operations.
/// Whether a client supports versioned document edits is expressed via
/// `workspace.workspaceEdit.documentChanges` client capability.
/// If a client neither supports `documentChanges` nor
/// `workspace.workspaceEdit.resourceOperations` then only plain
/// `TextEdit`s using the `changes` property are supported.
 List<Sealed15>? get documentChanges;
/// Create a copy of WorkspaceEdit
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkspaceEditCopyWith<WorkspaceEdit> get copyWith => _$WorkspaceEditCopyWithImpl<WorkspaceEdit>(this as WorkspaceEdit, _$identity);

  /// Serializes this WorkspaceEdit to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkspaceEdit&&const DeepCollectionEquality().equals(other.changeAnnotations, changeAnnotations)&&const DeepCollectionEquality().equals(other.changes, changes)&&const DeepCollectionEquality().equals(other.documentChanges, documentChanges));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(changeAnnotations),const DeepCollectionEquality().hash(changes),const DeepCollectionEquality().hash(documentChanges));

@override
String toString() {
  return 'WorkspaceEdit(changeAnnotations: $changeAnnotations, changes: $changes, documentChanges: $documentChanges)';
}


}

/// @nodoc
abstract mixin class $WorkspaceEditCopyWith<$Res>  {
  factory $WorkspaceEditCopyWith(WorkspaceEdit value, $Res Function(WorkspaceEdit) _then) = _$WorkspaceEditCopyWithImpl;
@useResult
$Res call({
 Map<ChangeAnnotationIdentifier, ChangeAnnotation>? changeAnnotations, Map<String, List<TextEdit>>? changes, List<Sealed15>? documentChanges
});




}
/// @nodoc
class _$WorkspaceEditCopyWithImpl<$Res>
    implements $WorkspaceEditCopyWith<$Res> {
  _$WorkspaceEditCopyWithImpl(this._self, this._then);

  final WorkspaceEdit _self;
  final $Res Function(WorkspaceEdit) _then;

/// Create a copy of WorkspaceEdit
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? changeAnnotations = freezed,Object? changes = freezed,Object? documentChanges = freezed,}) {
  return _then(_self.copyWith(
changeAnnotations: freezed == changeAnnotations ? _self.changeAnnotations : changeAnnotations // ignore: cast_nullable_to_non_nullable
as Map<ChangeAnnotationIdentifier, ChangeAnnotation>?,changes: freezed == changes ? _self.changes : changes // ignore: cast_nullable_to_non_nullable
as Map<String, List<TextEdit>>?,documentChanges: freezed == documentChanges ? _self.documentChanges : documentChanges // ignore: cast_nullable_to_non_nullable
as List<Sealed15>?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _WorkspaceEdit implements WorkspaceEdit {
  const _WorkspaceEdit({final  Map<ChangeAnnotationIdentifier, ChangeAnnotation>? changeAnnotations, final  Map<String, List<TextEdit>>? changes, final  List<Sealed15>? documentChanges}): _changeAnnotations = changeAnnotations,_changes = changes,_documentChanges = documentChanges;
  factory _WorkspaceEdit.fromJson(Map<String, dynamic> json) => _$WorkspaceEditFromJson(json);

/// A map of change annotations that can be referenced in
/// `AnnotatedTextEdit`s or create, rename and delete file / folder
/// operations.
/// Whether clients honor this property depends on the client capability
/// `workspace.changeAnnotationSupport`.
/// @since 3.16.0
 final  Map<ChangeAnnotationIdentifier, ChangeAnnotation>? _changeAnnotations;
/// A map of change annotations that can be referenced in
/// `AnnotatedTextEdit`s or create, rename and delete file / folder
/// operations.
/// Whether clients honor this property depends on the client capability
/// `workspace.changeAnnotationSupport`.
/// @since 3.16.0
@override Map<ChangeAnnotationIdentifier, ChangeAnnotation>? get changeAnnotations {
  final value = _changeAnnotations;
  if (value == null) return null;
  if (_changeAnnotations is EqualUnmodifiableMapView) return _changeAnnotations;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(value);
}

/// Holds changes to existing resources.
 final  Map<String, List<TextEdit>>? _changes;
/// Holds changes to existing resources.
@override Map<String, List<TextEdit>>? get changes {
  final value = _changes;
  if (value == null) return null;
  if (_changes is EqualUnmodifiableMapView) return _changes;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(value);
}

/// Depending on the client capability
/// `workspace.workspaceEdit.resourceOperations` document changes are
/// either an array of `TextDocumentEdit`s to express changes to n
/// different text documents where each text document edit addresses a
/// specific version of a text document. Or it can contain above
/// `TextDocumentEdit`s mixed with create, rename and delete file / folder
/// operations.
/// Whether a client supports versioned document edits is expressed via
/// `workspace.workspaceEdit.documentChanges` client capability.
/// If a client neither supports `documentChanges` nor
/// `workspace.workspaceEdit.resourceOperations` then only plain
/// `TextEdit`s using the `changes` property are supported.
 final  List<Sealed15>? _documentChanges;
/// Depending on the client capability
/// `workspace.workspaceEdit.resourceOperations` document changes are
/// either an array of `TextDocumentEdit`s to express changes to n
/// different text documents where each text document edit addresses a
/// specific version of a text document. Or it can contain above
/// `TextDocumentEdit`s mixed with create, rename and delete file / folder
/// operations.
/// Whether a client supports versioned document edits is expressed via
/// `workspace.workspaceEdit.documentChanges` client capability.
/// If a client neither supports `documentChanges` nor
/// `workspace.workspaceEdit.resourceOperations` then only plain
/// `TextEdit`s using the `changes` property are supported.
@override List<Sealed15>? get documentChanges {
  final value = _documentChanges;
  if (value == null) return null;
  if (_documentChanges is EqualUnmodifiableListView) return _documentChanges;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}


/// Create a copy of WorkspaceEdit
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkspaceEditCopyWith<_WorkspaceEdit> get copyWith => __$WorkspaceEditCopyWithImpl<_WorkspaceEdit>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkspaceEditToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkspaceEdit&&const DeepCollectionEquality().equals(other._changeAnnotations, _changeAnnotations)&&const DeepCollectionEquality().equals(other._changes, _changes)&&const DeepCollectionEquality().equals(other._documentChanges, _documentChanges));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_changeAnnotations),const DeepCollectionEquality().hash(_changes),const DeepCollectionEquality().hash(_documentChanges));

@override
String toString() {
  return 'WorkspaceEdit(changeAnnotations: $changeAnnotations, changes: $changes, documentChanges: $documentChanges)';
}


}

/// @nodoc
abstract mixin class _$WorkspaceEditCopyWith<$Res> implements $WorkspaceEditCopyWith<$Res> {
  factory _$WorkspaceEditCopyWith(_WorkspaceEdit value, $Res Function(_WorkspaceEdit) _then) = __$WorkspaceEditCopyWithImpl;
@override @useResult
$Res call({
 Map<ChangeAnnotationIdentifier, ChangeAnnotation>? changeAnnotations, Map<String, List<TextEdit>>? changes, List<Sealed15>? documentChanges
});




}
/// @nodoc
class __$WorkspaceEditCopyWithImpl<$Res>
    implements _$WorkspaceEditCopyWith<$Res> {
  __$WorkspaceEditCopyWithImpl(this._self, this._then);

  final _WorkspaceEdit _self;
  final $Res Function(_WorkspaceEdit) _then;

/// Create a copy of WorkspaceEdit
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? changeAnnotations = freezed,Object? changes = freezed,Object? documentChanges = freezed,}) {
  return _then(_WorkspaceEdit(
changeAnnotations: freezed == changeAnnotations ? _self._changeAnnotations : changeAnnotations // ignore: cast_nullable_to_non_nullable
as Map<ChangeAnnotationIdentifier, ChangeAnnotation>?,changes: freezed == changes ? _self._changes : changes // ignore: cast_nullable_to_non_nullable
as Map<String, List<TextEdit>>?,documentChanges: freezed == documentChanges ? _self._documentChanges : documentChanges // ignore: cast_nullable_to_non_nullable
as List<Sealed15>?,
  ));
}


}


/// @nodoc
mixin _$FileOperationRegistrationOptions {

/// The actual filters.
 List<FileOperationFilter> get filters;
/// Create a copy of FileOperationRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FileOperationRegistrationOptionsCopyWith<FileOperationRegistrationOptions> get copyWith => _$FileOperationRegistrationOptionsCopyWithImpl<FileOperationRegistrationOptions>(this as FileOperationRegistrationOptions, _$identity);

  /// Serializes this FileOperationRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FileOperationRegistrationOptions&&const DeepCollectionEquality().equals(other.filters, filters));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(filters));

@override
String toString() {
  return 'FileOperationRegistrationOptions(filters: $filters)';
}


}

/// @nodoc
abstract mixin class $FileOperationRegistrationOptionsCopyWith<$Res>  {
  factory $FileOperationRegistrationOptionsCopyWith(FileOperationRegistrationOptions value, $Res Function(FileOperationRegistrationOptions) _then) = _$FileOperationRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 List<FileOperationFilter> filters
});




}
/// @nodoc
class _$FileOperationRegistrationOptionsCopyWithImpl<$Res>
    implements $FileOperationRegistrationOptionsCopyWith<$Res> {
  _$FileOperationRegistrationOptionsCopyWithImpl(this._self, this._then);

  final FileOperationRegistrationOptions _self;
  final $Res Function(FileOperationRegistrationOptions) _then;

/// Create a copy of FileOperationRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? filters = null,}) {
  return _then(_self.copyWith(
filters: null == filters ? _self.filters : filters // ignore: cast_nullable_to_non_nullable
as List<FileOperationFilter>,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _FileOperationRegistrationOptions implements FileOperationRegistrationOptions {
  const _FileOperationRegistrationOptions({required final  List<FileOperationFilter> filters}): _filters = filters;
  factory _FileOperationRegistrationOptions.fromJson(Map<String, dynamic> json) => _$FileOperationRegistrationOptionsFromJson(json);

/// The actual filters.
 final  List<FileOperationFilter> _filters;
/// The actual filters.
@override List<FileOperationFilter> get filters {
  if (_filters is EqualUnmodifiableListView) return _filters;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_filters);
}


/// Create a copy of FileOperationRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$FileOperationRegistrationOptionsCopyWith<_FileOperationRegistrationOptions> get copyWith => __$FileOperationRegistrationOptionsCopyWithImpl<_FileOperationRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$FileOperationRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _FileOperationRegistrationOptions&&const DeepCollectionEquality().equals(other._filters, _filters));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_filters));

@override
String toString() {
  return 'FileOperationRegistrationOptions(filters: $filters)';
}


}

/// @nodoc
abstract mixin class _$FileOperationRegistrationOptionsCopyWith<$Res> implements $FileOperationRegistrationOptionsCopyWith<$Res> {
  factory _$FileOperationRegistrationOptionsCopyWith(_FileOperationRegistrationOptions value, $Res Function(_FileOperationRegistrationOptions) _then) = __$FileOperationRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 List<FileOperationFilter> filters
});




}
/// @nodoc
class __$FileOperationRegistrationOptionsCopyWithImpl<$Res>
    implements _$FileOperationRegistrationOptionsCopyWith<$Res> {
  __$FileOperationRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _FileOperationRegistrationOptions _self;
  final $Res Function(_FileOperationRegistrationOptions) _then;

/// Create a copy of FileOperationRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? filters = null,}) {
  return _then(_FileOperationRegistrationOptions(
filters: null == filters ? _self._filters : filters // ignore: cast_nullable_to_non_nullable
as List<FileOperationFilter>,
  ));
}


}


/// @nodoc
mixin _$RenameFilesParams {

/// An array of all files/folders renamed in this operation. When a folder
/// is renamed, only the folder will be included, and not its children.
 List<FileRename> get files;
/// Create a copy of RenameFilesParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RenameFilesParamsCopyWith<RenameFilesParams> get copyWith => _$RenameFilesParamsCopyWithImpl<RenameFilesParams>(this as RenameFilesParams, _$identity);

  /// Serializes this RenameFilesParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RenameFilesParams&&const DeepCollectionEquality().equals(other.files, files));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(files));

@override
String toString() {
  return 'RenameFilesParams(files: $files)';
}


}

/// @nodoc
abstract mixin class $RenameFilesParamsCopyWith<$Res>  {
  factory $RenameFilesParamsCopyWith(RenameFilesParams value, $Res Function(RenameFilesParams) _then) = _$RenameFilesParamsCopyWithImpl;
@useResult
$Res call({
 List<FileRename> files
});




}
/// @nodoc
class _$RenameFilesParamsCopyWithImpl<$Res>
    implements $RenameFilesParamsCopyWith<$Res> {
  _$RenameFilesParamsCopyWithImpl(this._self, this._then);

  final RenameFilesParams _self;
  final $Res Function(RenameFilesParams) _then;

/// Create a copy of RenameFilesParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? files = null,}) {
  return _then(_self.copyWith(
files: null == files ? _self.files : files // ignore: cast_nullable_to_non_nullable
as List<FileRename>,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _RenameFilesParams implements RenameFilesParams {
  const _RenameFilesParams({required final  List<FileRename> files}): _files = files;
  factory _RenameFilesParams.fromJson(Map<String, dynamic> json) => _$RenameFilesParamsFromJson(json);

/// An array of all files/folders renamed in this operation. When a folder
/// is renamed, only the folder will be included, and not its children.
 final  List<FileRename> _files;
/// An array of all files/folders renamed in this operation. When a folder
/// is renamed, only the folder will be included, and not its children.
@override List<FileRename> get files {
  if (_files is EqualUnmodifiableListView) return _files;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_files);
}


/// Create a copy of RenameFilesParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RenameFilesParamsCopyWith<_RenameFilesParams> get copyWith => __$RenameFilesParamsCopyWithImpl<_RenameFilesParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$RenameFilesParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _RenameFilesParams&&const DeepCollectionEquality().equals(other._files, _files));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_files));

@override
String toString() {
  return 'RenameFilesParams(files: $files)';
}


}

/// @nodoc
abstract mixin class _$RenameFilesParamsCopyWith<$Res> implements $RenameFilesParamsCopyWith<$Res> {
  factory _$RenameFilesParamsCopyWith(_RenameFilesParams value, $Res Function(_RenameFilesParams) _then) = __$RenameFilesParamsCopyWithImpl;
@override @useResult
$Res call({
 List<FileRename> files
});




}
/// @nodoc
class __$RenameFilesParamsCopyWithImpl<$Res>
    implements _$RenameFilesParamsCopyWith<$Res> {
  __$RenameFilesParamsCopyWithImpl(this._self, this._then);

  final _RenameFilesParams _self;
  final $Res Function(_RenameFilesParams) _then;

/// Create a copy of RenameFilesParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? files = null,}) {
  return _then(_RenameFilesParams(
files: null == files ? _self._files : files // ignore: cast_nullable_to_non_nullable
as List<FileRename>,
  ));
}


}


/// @nodoc
mixin _$DeleteFilesParams {

/// An array of all files/folders deleted in this operation.
 List<FileDelete> get files;
/// Create a copy of DeleteFilesParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DeleteFilesParamsCopyWith<DeleteFilesParams> get copyWith => _$DeleteFilesParamsCopyWithImpl<DeleteFilesParams>(this as DeleteFilesParams, _$identity);

  /// Serializes this DeleteFilesParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DeleteFilesParams&&const DeepCollectionEquality().equals(other.files, files));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(files));

@override
String toString() {
  return 'DeleteFilesParams(files: $files)';
}


}

/// @nodoc
abstract mixin class $DeleteFilesParamsCopyWith<$Res>  {
  factory $DeleteFilesParamsCopyWith(DeleteFilesParams value, $Res Function(DeleteFilesParams) _then) = _$DeleteFilesParamsCopyWithImpl;
@useResult
$Res call({
 List<FileDelete> files
});




}
/// @nodoc
class _$DeleteFilesParamsCopyWithImpl<$Res>
    implements $DeleteFilesParamsCopyWith<$Res> {
  _$DeleteFilesParamsCopyWithImpl(this._self, this._then);

  final DeleteFilesParams _self;
  final $Res Function(DeleteFilesParams) _then;

/// Create a copy of DeleteFilesParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? files = null,}) {
  return _then(_self.copyWith(
files: null == files ? _self.files : files // ignore: cast_nullable_to_non_nullable
as List<FileDelete>,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DeleteFilesParams implements DeleteFilesParams {
  const _DeleteFilesParams({required final  List<FileDelete> files}): _files = files;
  factory _DeleteFilesParams.fromJson(Map<String, dynamic> json) => _$DeleteFilesParamsFromJson(json);

/// An array of all files/folders deleted in this operation.
 final  List<FileDelete> _files;
/// An array of all files/folders deleted in this operation.
@override List<FileDelete> get files {
  if (_files is EqualUnmodifiableListView) return _files;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_files);
}


/// Create a copy of DeleteFilesParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DeleteFilesParamsCopyWith<_DeleteFilesParams> get copyWith => __$DeleteFilesParamsCopyWithImpl<_DeleteFilesParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DeleteFilesParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DeleteFilesParams&&const DeepCollectionEquality().equals(other._files, _files));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_files));

@override
String toString() {
  return 'DeleteFilesParams(files: $files)';
}


}

/// @nodoc
abstract mixin class _$DeleteFilesParamsCopyWith<$Res> implements $DeleteFilesParamsCopyWith<$Res> {
  factory _$DeleteFilesParamsCopyWith(_DeleteFilesParams value, $Res Function(_DeleteFilesParams) _then) = __$DeleteFilesParamsCopyWithImpl;
@override @useResult
$Res call({
 List<FileDelete> files
});




}
/// @nodoc
class __$DeleteFilesParamsCopyWithImpl<$Res>
    implements _$DeleteFilesParamsCopyWith<$Res> {
  __$DeleteFilesParamsCopyWithImpl(this._self, this._then);

  final _DeleteFilesParams _self;
  final $Res Function(_DeleteFilesParams) _then;

/// Create a copy of DeleteFilesParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? files = null,}) {
  return _then(_DeleteFilesParams(
files: null == files ? _self._files : files // ignore: cast_nullable_to_non_nullable
as List<FileDelete>,
  ));
}


}


/// @nodoc
mixin _$MonikerParams {

/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
 ProgressToken? get partialResultToken;/// The position inside the text document.
 Position get position;/// The text document.
 TextDocumentIdentifier get textDocument;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of MonikerParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$MonikerParamsCopyWith<MonikerParams> get copyWith => _$MonikerParamsCopyWithImpl<MonikerParams>(this as MonikerParams, _$identity);

  /// Serializes this MonikerParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is MonikerParams&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.position, position) || other.position == position)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,partialResultToken,position,textDocument,workDoneToken);

@override
String toString() {
  return 'MonikerParams(partialResultToken: $partialResultToken, position: $position, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $MonikerParamsCopyWith<$Res>  {
  factory $MonikerParamsCopyWith(MonikerParams value, $Res Function(MonikerParams) _then) = _$MonikerParamsCopyWithImpl;
@useResult
$Res call({
 ProgressToken? partialResultToken, Position position, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


$PositionCopyWith<$Res> get position;$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$MonikerParamsCopyWithImpl<$Res>
    implements $MonikerParamsCopyWith<$Res> {
  _$MonikerParamsCopyWithImpl(this._self, this._then);

  final MonikerParams _self;
  final $Res Function(MonikerParams) _then;

/// Create a copy of MonikerParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? partialResultToken = freezed,Object? position = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of MonikerParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of MonikerParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _MonikerParams implements MonikerParams {
  const _MonikerParams({this.partialResultToken, required this.position, required this.textDocument, this.workDoneToken});
  factory _MonikerParams.fromJson(Map<String, dynamic> json) => _$MonikerParamsFromJson(json);

/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
@override final  ProgressToken? partialResultToken;
/// The position inside the text document.
@override final  Position position;
/// The text document.
@override final  TextDocumentIdentifier textDocument;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of MonikerParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$MonikerParamsCopyWith<_MonikerParams> get copyWith => __$MonikerParamsCopyWithImpl<_MonikerParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$MonikerParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _MonikerParams&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.position, position) || other.position == position)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,partialResultToken,position,textDocument,workDoneToken);

@override
String toString() {
  return 'MonikerParams(partialResultToken: $partialResultToken, position: $position, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$MonikerParamsCopyWith<$Res> implements $MonikerParamsCopyWith<$Res> {
  factory _$MonikerParamsCopyWith(_MonikerParams value, $Res Function(_MonikerParams) _then) = __$MonikerParamsCopyWithImpl;
@override @useResult
$Res call({
 ProgressToken? partialResultToken, Position position, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


@override $PositionCopyWith<$Res> get position;@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$MonikerParamsCopyWithImpl<$Res>
    implements _$MonikerParamsCopyWith<$Res> {
  __$MonikerParamsCopyWithImpl(this._self, this._then);

  final _MonikerParams _self;
  final $Res Function(_MonikerParams) _then;

/// Create a copy of MonikerParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? partialResultToken = freezed,Object? position = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_MonikerParams(
partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of MonikerParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of MonikerParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$Moniker {

/// The identifier of the moniker. The value is opaque in LSIF however
/// schema owners are allowed to define the structure if they want.
 String get identifier;/// The moniker kind if known.
 MonikerKind? get kind;/// The scheme of the moniker. For example tsc or .Net
 String get scheme;/// The scope in which the moniker is unique
 UniquenessLevel get unique;
/// Create a copy of Moniker
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$MonikerCopyWith<Moniker> get copyWith => _$MonikerCopyWithImpl<Moniker>(this as Moniker, _$identity);

  /// Serializes this Moniker to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Moniker&&(identical(other.identifier, identifier) || other.identifier == identifier)&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.scheme, scheme) || other.scheme == scheme)&&(identical(other.unique, unique) || other.unique == unique));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,identifier,kind,scheme,unique);

@override
String toString() {
  return 'Moniker(identifier: $identifier, kind: $kind, scheme: $scheme, unique: $unique)';
}


}

/// @nodoc
abstract mixin class $MonikerCopyWith<$Res>  {
  factory $MonikerCopyWith(Moniker value, $Res Function(Moniker) _then) = _$MonikerCopyWithImpl;
@useResult
$Res call({
 String identifier, MonikerKind? kind, String scheme, UniquenessLevel unique
});




}
/// @nodoc
class _$MonikerCopyWithImpl<$Res>
    implements $MonikerCopyWith<$Res> {
  _$MonikerCopyWithImpl(this._self, this._then);

  final Moniker _self;
  final $Res Function(Moniker) _then;

/// Create a copy of Moniker
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? identifier = null,Object? kind = freezed,Object? scheme = null,Object? unique = null,}) {
  return _then(_self.copyWith(
identifier: null == identifier ? _self.identifier : identifier // ignore: cast_nullable_to_non_nullable
as String,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as MonikerKind?,scheme: null == scheme ? _self.scheme : scheme // ignore: cast_nullable_to_non_nullable
as String,unique: null == unique ? _self.unique : unique // ignore: cast_nullable_to_non_nullable
as UniquenessLevel,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _Moniker implements Moniker {
  const _Moniker({required this.identifier, this.kind, required this.scheme, required this.unique});
  factory _Moniker.fromJson(Map<String, dynamic> json) => _$MonikerFromJson(json);

/// The identifier of the moniker. The value is opaque in LSIF however
/// schema owners are allowed to define the structure if they want.
@override final  String identifier;
/// The moniker kind if known.
@override final  MonikerKind? kind;
/// The scheme of the moniker. For example tsc or .Net
@override final  String scheme;
/// The scope in which the moniker is unique
@override final  UniquenessLevel unique;

/// Create a copy of Moniker
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$MonikerCopyWith<_Moniker> get copyWith => __$MonikerCopyWithImpl<_Moniker>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$MonikerToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _Moniker&&(identical(other.identifier, identifier) || other.identifier == identifier)&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.scheme, scheme) || other.scheme == scheme)&&(identical(other.unique, unique) || other.unique == unique));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,identifier,kind,scheme,unique);

@override
String toString() {
  return 'Moniker(identifier: $identifier, kind: $kind, scheme: $scheme, unique: $unique)';
}


}

/// @nodoc
abstract mixin class _$MonikerCopyWith<$Res> implements $MonikerCopyWith<$Res> {
  factory _$MonikerCopyWith(_Moniker value, $Res Function(_Moniker) _then) = __$MonikerCopyWithImpl;
@override @useResult
$Res call({
 String identifier, MonikerKind? kind, String scheme, UniquenessLevel unique
});




}
/// @nodoc
class __$MonikerCopyWithImpl<$Res>
    implements _$MonikerCopyWith<$Res> {
  __$MonikerCopyWithImpl(this._self, this._then);

  final _Moniker _self;
  final $Res Function(_Moniker) _then;

/// Create a copy of Moniker
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? identifier = null,Object? kind = freezed,Object? scheme = null,Object? unique = null,}) {
  return _then(_Moniker(
identifier: null == identifier ? _self.identifier : identifier // ignore: cast_nullable_to_non_nullable
as String,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as MonikerKind?,scheme: null == scheme ? _self.scheme : scheme // ignore: cast_nullable_to_non_nullable
as String,unique: null == unique ? _self.unique : unique // ignore: cast_nullable_to_non_nullable
as UniquenessLevel,
  ));
}


}


/// @nodoc
mixin _$MonikerRegistrationOptions {

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
 Sealed14 get documentSelector;
/// Create a copy of MonikerRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$MonikerRegistrationOptionsCopyWith<MonikerRegistrationOptions> get copyWith => _$MonikerRegistrationOptionsCopyWithImpl<MonikerRegistrationOptions>(this as MonikerRegistrationOptions, _$identity);

  /// Serializes this MonikerRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is MonikerRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector);

@override
String toString() {
  return 'MonikerRegistrationOptions(documentSelector: $documentSelector)';
}


}

/// @nodoc
abstract mixin class $MonikerRegistrationOptionsCopyWith<$Res>  {
  factory $MonikerRegistrationOptionsCopyWith(MonikerRegistrationOptions value, $Res Function(MonikerRegistrationOptions) _then) = _$MonikerRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 Sealed14 documentSelector
});




}
/// @nodoc
class _$MonikerRegistrationOptionsCopyWithImpl<$Res>
    implements $MonikerRegistrationOptionsCopyWith<$Res> {
  _$MonikerRegistrationOptionsCopyWithImpl(this._self, this._then);

  final MonikerRegistrationOptions _self;
  final $Res Function(MonikerRegistrationOptions) _then;

/// Create a copy of MonikerRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = null,}) {
  return _then(_self.copyWith(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _MonikerRegistrationOptions implements MonikerRegistrationOptions {
  const _MonikerRegistrationOptions({required this.documentSelector});
  factory _MonikerRegistrationOptions.fromJson(Map<String, dynamic> json) => _$MonikerRegistrationOptionsFromJson(json);

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
@override final  Sealed14 documentSelector;

/// Create a copy of MonikerRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$MonikerRegistrationOptionsCopyWith<_MonikerRegistrationOptions> get copyWith => __$MonikerRegistrationOptionsCopyWithImpl<_MonikerRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$MonikerRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _MonikerRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector);

@override
String toString() {
  return 'MonikerRegistrationOptions(documentSelector: $documentSelector)';
}


}

/// @nodoc
abstract mixin class _$MonikerRegistrationOptionsCopyWith<$Res> implements $MonikerRegistrationOptionsCopyWith<$Res> {
  factory _$MonikerRegistrationOptionsCopyWith(_MonikerRegistrationOptions value, $Res Function(_MonikerRegistrationOptions) _then) = __$MonikerRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 Sealed14 documentSelector
});




}
/// @nodoc
class __$MonikerRegistrationOptionsCopyWithImpl<$Res>
    implements _$MonikerRegistrationOptionsCopyWith<$Res> {
  __$MonikerRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _MonikerRegistrationOptions _self;
  final $Res Function(_MonikerRegistrationOptions) _then;

/// Create a copy of MonikerRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = null,}) {
  return _then(_MonikerRegistrationOptions(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,
  ));
}


}


/// @nodoc
mixin _$TypeHierarchyPrepareParams {

/// The position inside the text document.
 Position get position;/// The text document.
 TextDocumentIdentifier get textDocument;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of TypeHierarchyPrepareParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TypeHierarchyPrepareParamsCopyWith<TypeHierarchyPrepareParams> get copyWith => _$TypeHierarchyPrepareParamsCopyWithImpl<TypeHierarchyPrepareParams>(this as TypeHierarchyPrepareParams, _$identity);

  /// Serializes this TypeHierarchyPrepareParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TypeHierarchyPrepareParams&&(identical(other.position, position) || other.position == position)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,position,textDocument,workDoneToken);

@override
String toString() {
  return 'TypeHierarchyPrepareParams(position: $position, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $TypeHierarchyPrepareParamsCopyWith<$Res>  {
  factory $TypeHierarchyPrepareParamsCopyWith(TypeHierarchyPrepareParams value, $Res Function(TypeHierarchyPrepareParams) _then) = _$TypeHierarchyPrepareParamsCopyWithImpl;
@useResult
$Res call({
 Position position, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


$PositionCopyWith<$Res> get position;$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$TypeHierarchyPrepareParamsCopyWithImpl<$Res>
    implements $TypeHierarchyPrepareParamsCopyWith<$Res> {
  _$TypeHierarchyPrepareParamsCopyWithImpl(this._self, this._then);

  final TypeHierarchyPrepareParams _self;
  final $Res Function(TypeHierarchyPrepareParams) _then;

/// Create a copy of TypeHierarchyPrepareParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? position = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of TypeHierarchyPrepareParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of TypeHierarchyPrepareParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _TypeHierarchyPrepareParams implements TypeHierarchyPrepareParams {
  const _TypeHierarchyPrepareParams({required this.position, required this.textDocument, this.workDoneToken});
  factory _TypeHierarchyPrepareParams.fromJson(Map<String, dynamic> json) => _$TypeHierarchyPrepareParamsFromJson(json);

/// The position inside the text document.
@override final  Position position;
/// The text document.
@override final  TextDocumentIdentifier textDocument;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of TypeHierarchyPrepareParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TypeHierarchyPrepareParamsCopyWith<_TypeHierarchyPrepareParams> get copyWith => __$TypeHierarchyPrepareParamsCopyWithImpl<_TypeHierarchyPrepareParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TypeHierarchyPrepareParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TypeHierarchyPrepareParams&&(identical(other.position, position) || other.position == position)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,position,textDocument,workDoneToken);

@override
String toString() {
  return 'TypeHierarchyPrepareParams(position: $position, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$TypeHierarchyPrepareParamsCopyWith<$Res> implements $TypeHierarchyPrepareParamsCopyWith<$Res> {
  factory _$TypeHierarchyPrepareParamsCopyWith(_TypeHierarchyPrepareParams value, $Res Function(_TypeHierarchyPrepareParams) _then) = __$TypeHierarchyPrepareParamsCopyWithImpl;
@override @useResult
$Res call({
 Position position, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


@override $PositionCopyWith<$Res> get position;@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$TypeHierarchyPrepareParamsCopyWithImpl<$Res>
    implements _$TypeHierarchyPrepareParamsCopyWith<$Res> {
  __$TypeHierarchyPrepareParamsCopyWithImpl(this._self, this._then);

  final _TypeHierarchyPrepareParams _self;
  final $Res Function(_TypeHierarchyPrepareParams) _then;

/// Create a copy of TypeHierarchyPrepareParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? position = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_TypeHierarchyPrepareParams(
position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of TypeHierarchyPrepareParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of TypeHierarchyPrepareParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$TypeHierarchyItem {

/// A data entry field that is preserved between a type hierarchy prepare
/// and supertypes or subtypes requests. It could also be used to identify
/// the type hierarchy in the server, helping improve the performance on
/// resolving supertypes and subtypes.
 LSPAny? get data;/// More detail for this item, e.g. the signature of a function.
 String? get detail;/// The kind of this item.
 SymbolKind get kind;/// The name of this item.
 String get name;/// The range enclosing this symbol not including leading/trailing
/// whitespace but everything else, e.g. comments and code.
 Range get range;/// The range that should be selected and revealed when this symbol is
/// being picked, e.g. the name of a function. Must be contained by the
/// {@link TypeHierarchyItem.range `range`}.
 Range get selectionRange;/// Tags for this item.
 List<SymbolTag>? get tags;/// The resource identifier of this item.
 String get uri;
/// Create a copy of TypeHierarchyItem
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TypeHierarchyItemCopyWith<TypeHierarchyItem> get copyWith => _$TypeHierarchyItemCopyWithImpl<TypeHierarchyItem>(this as TypeHierarchyItem, _$identity);

  /// Serializes this TypeHierarchyItem to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TypeHierarchyItem&&(identical(other.data, data) || other.data == data)&&(identical(other.detail, detail) || other.detail == detail)&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.name, name) || other.name == name)&&(identical(other.range, range) || other.range == range)&&(identical(other.selectionRange, selectionRange) || other.selectionRange == selectionRange)&&const DeepCollectionEquality().equals(other.tags, tags)&&(identical(other.uri, uri) || other.uri == uri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,data,detail,kind,name,range,selectionRange,const DeepCollectionEquality().hash(tags),uri);

@override
String toString() {
  return 'TypeHierarchyItem(data: $data, detail: $detail, kind: $kind, name: $name, range: $range, selectionRange: $selectionRange, tags: $tags, uri: $uri)';
}


}

/// @nodoc
abstract mixin class $TypeHierarchyItemCopyWith<$Res>  {
  factory $TypeHierarchyItemCopyWith(TypeHierarchyItem value, $Res Function(TypeHierarchyItem) _then) = _$TypeHierarchyItemCopyWithImpl;
@useResult
$Res call({
 LSPAny? data, String? detail, SymbolKind kind, String name, Range range, Range selectionRange, List<SymbolTag>? tags, String uri
});


$RangeCopyWith<$Res> get range;$RangeCopyWith<$Res> get selectionRange;

}
/// @nodoc
class _$TypeHierarchyItemCopyWithImpl<$Res>
    implements $TypeHierarchyItemCopyWith<$Res> {
  _$TypeHierarchyItemCopyWithImpl(this._self, this._then);

  final TypeHierarchyItem _self;
  final $Res Function(TypeHierarchyItem) _then;

/// Create a copy of TypeHierarchyItem
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? data = freezed,Object? detail = freezed,Object? kind = null,Object? name = null,Object? range = null,Object? selectionRange = null,Object? tags = freezed,Object? uri = null,}) {
  return _then(_self.copyWith(
data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LSPAny?,detail: freezed == detail ? _self.detail : detail // ignore: cast_nullable_to_non_nullable
as String?,kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as SymbolKind,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,selectionRange: null == selectionRange ? _self.selectionRange : selectionRange // ignore: cast_nullable_to_non_nullable
as Range,tags: freezed == tags ? _self.tags : tags // ignore: cast_nullable_to_non_nullable
as List<SymbolTag>?,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}
/// Create a copy of TypeHierarchyItem
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}/// Create a copy of TypeHierarchyItem
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get selectionRange {
  
  return $RangeCopyWith<$Res>(_self.selectionRange, (value) {
    return _then(_self.copyWith(selectionRange: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _TypeHierarchyItem implements TypeHierarchyItem {
  const _TypeHierarchyItem({this.data, this.detail, required this.kind, required this.name, required this.range, required this.selectionRange, final  List<SymbolTag>? tags, required this.uri}): _tags = tags;
  factory _TypeHierarchyItem.fromJson(Map<String, dynamic> json) => _$TypeHierarchyItemFromJson(json);

/// A data entry field that is preserved between a type hierarchy prepare
/// and supertypes or subtypes requests. It could also be used to identify
/// the type hierarchy in the server, helping improve the performance on
/// resolving supertypes and subtypes.
@override final  LSPAny? data;
/// More detail for this item, e.g. the signature of a function.
@override final  String? detail;
/// The kind of this item.
@override final  SymbolKind kind;
/// The name of this item.
@override final  String name;
/// The range enclosing this symbol not including leading/trailing
/// whitespace but everything else, e.g. comments and code.
@override final  Range range;
/// The range that should be selected and revealed when this symbol is
/// being picked, e.g. the name of a function. Must be contained by the
/// {@link TypeHierarchyItem.range `range`}.
@override final  Range selectionRange;
/// Tags for this item.
 final  List<SymbolTag>? _tags;
/// Tags for this item.
@override List<SymbolTag>? get tags {
  final value = _tags;
  if (value == null) return null;
  if (_tags is EqualUnmodifiableListView) return _tags;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

/// The resource identifier of this item.
@override final  String uri;

/// Create a copy of TypeHierarchyItem
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TypeHierarchyItemCopyWith<_TypeHierarchyItem> get copyWith => __$TypeHierarchyItemCopyWithImpl<_TypeHierarchyItem>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TypeHierarchyItemToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TypeHierarchyItem&&(identical(other.data, data) || other.data == data)&&(identical(other.detail, detail) || other.detail == detail)&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.name, name) || other.name == name)&&(identical(other.range, range) || other.range == range)&&(identical(other.selectionRange, selectionRange) || other.selectionRange == selectionRange)&&const DeepCollectionEquality().equals(other._tags, _tags)&&(identical(other.uri, uri) || other.uri == uri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,data,detail,kind,name,range,selectionRange,const DeepCollectionEquality().hash(_tags),uri);

@override
String toString() {
  return 'TypeHierarchyItem(data: $data, detail: $detail, kind: $kind, name: $name, range: $range, selectionRange: $selectionRange, tags: $tags, uri: $uri)';
}


}

/// @nodoc
abstract mixin class _$TypeHierarchyItemCopyWith<$Res> implements $TypeHierarchyItemCopyWith<$Res> {
  factory _$TypeHierarchyItemCopyWith(_TypeHierarchyItem value, $Res Function(_TypeHierarchyItem) _then) = __$TypeHierarchyItemCopyWithImpl;
@override @useResult
$Res call({
 LSPAny? data, String? detail, SymbolKind kind, String name, Range range, Range selectionRange, List<SymbolTag>? tags, String uri
});


@override $RangeCopyWith<$Res> get range;@override $RangeCopyWith<$Res> get selectionRange;

}
/// @nodoc
class __$TypeHierarchyItemCopyWithImpl<$Res>
    implements _$TypeHierarchyItemCopyWith<$Res> {
  __$TypeHierarchyItemCopyWithImpl(this._self, this._then);

  final _TypeHierarchyItem _self;
  final $Res Function(_TypeHierarchyItem) _then;

/// Create a copy of TypeHierarchyItem
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? data = freezed,Object? detail = freezed,Object? kind = null,Object? name = null,Object? range = null,Object? selectionRange = null,Object? tags = freezed,Object? uri = null,}) {
  return _then(_TypeHierarchyItem(
data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LSPAny?,detail: freezed == detail ? _self.detail : detail // ignore: cast_nullable_to_non_nullable
as String?,kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as SymbolKind,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,selectionRange: null == selectionRange ? _self.selectionRange : selectionRange // ignore: cast_nullable_to_non_nullable
as Range,tags: freezed == tags ? _self._tags : tags // ignore: cast_nullable_to_non_nullable
as List<SymbolTag>?,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

/// Create a copy of TypeHierarchyItem
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}/// Create a copy of TypeHierarchyItem
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get selectionRange {
  
  return $RangeCopyWith<$Res>(_self.selectionRange, (value) {
    return _then(_self.copyWith(selectionRange: value));
  });
}
}


/// @nodoc
mixin _$TypeHierarchyRegistrationOptions {

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
 Sealed14 get documentSelector;/// The id used to register the request. The id can be used to deregister
/// the request again. See also Registration#id.
 String? get id;
/// Create a copy of TypeHierarchyRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TypeHierarchyRegistrationOptionsCopyWith<TypeHierarchyRegistrationOptions> get copyWith => _$TypeHierarchyRegistrationOptionsCopyWithImpl<TypeHierarchyRegistrationOptions>(this as TypeHierarchyRegistrationOptions, _$identity);

  /// Serializes this TypeHierarchyRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TypeHierarchyRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.id, id) || other.id == id));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,id);

@override
String toString() {
  return 'TypeHierarchyRegistrationOptions(documentSelector: $documentSelector, id: $id)';
}


}

/// @nodoc
abstract mixin class $TypeHierarchyRegistrationOptionsCopyWith<$Res>  {
  factory $TypeHierarchyRegistrationOptionsCopyWith(TypeHierarchyRegistrationOptions value, $Res Function(TypeHierarchyRegistrationOptions) _then) = _$TypeHierarchyRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 Sealed14 documentSelector, String? id
});




}
/// @nodoc
class _$TypeHierarchyRegistrationOptionsCopyWithImpl<$Res>
    implements $TypeHierarchyRegistrationOptionsCopyWith<$Res> {
  _$TypeHierarchyRegistrationOptionsCopyWithImpl(this._self, this._then);

  final TypeHierarchyRegistrationOptions _self;
  final $Res Function(TypeHierarchyRegistrationOptions) _then;

/// Create a copy of TypeHierarchyRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = null,Object? id = freezed,}) {
  return _then(_self.copyWith(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _TypeHierarchyRegistrationOptions implements TypeHierarchyRegistrationOptions {
  const _TypeHierarchyRegistrationOptions({required this.documentSelector, this.id});
  factory _TypeHierarchyRegistrationOptions.fromJson(Map<String, dynamic> json) => _$TypeHierarchyRegistrationOptionsFromJson(json);

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
@override final  Sealed14 documentSelector;
/// The id used to register the request. The id can be used to deregister
/// the request again. See also Registration#id.
@override final  String? id;

/// Create a copy of TypeHierarchyRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TypeHierarchyRegistrationOptionsCopyWith<_TypeHierarchyRegistrationOptions> get copyWith => __$TypeHierarchyRegistrationOptionsCopyWithImpl<_TypeHierarchyRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TypeHierarchyRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TypeHierarchyRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.id, id) || other.id == id));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,id);

@override
String toString() {
  return 'TypeHierarchyRegistrationOptions(documentSelector: $documentSelector, id: $id)';
}


}

/// @nodoc
abstract mixin class _$TypeHierarchyRegistrationOptionsCopyWith<$Res> implements $TypeHierarchyRegistrationOptionsCopyWith<$Res> {
  factory _$TypeHierarchyRegistrationOptionsCopyWith(_TypeHierarchyRegistrationOptions value, $Res Function(_TypeHierarchyRegistrationOptions) _then) = __$TypeHierarchyRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 Sealed14 documentSelector, String? id
});




}
/// @nodoc
class __$TypeHierarchyRegistrationOptionsCopyWithImpl<$Res>
    implements _$TypeHierarchyRegistrationOptionsCopyWith<$Res> {
  __$TypeHierarchyRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _TypeHierarchyRegistrationOptions _self;
  final $Res Function(_TypeHierarchyRegistrationOptions) _then;

/// Create a copy of TypeHierarchyRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = null,Object? id = freezed,}) {
  return _then(_TypeHierarchyRegistrationOptions(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$TypeHierarchySupertypesParams {

 TypeHierarchyItem get item;/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
 ProgressToken? get partialResultToken;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of TypeHierarchySupertypesParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TypeHierarchySupertypesParamsCopyWith<TypeHierarchySupertypesParams> get copyWith => _$TypeHierarchySupertypesParamsCopyWithImpl<TypeHierarchySupertypesParams>(this as TypeHierarchySupertypesParams, _$identity);

  /// Serializes this TypeHierarchySupertypesParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TypeHierarchySupertypesParams&&(identical(other.item, item) || other.item == item)&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,item,partialResultToken,workDoneToken);

@override
String toString() {
  return 'TypeHierarchySupertypesParams(item: $item, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $TypeHierarchySupertypesParamsCopyWith<$Res>  {
  factory $TypeHierarchySupertypesParamsCopyWith(TypeHierarchySupertypesParams value, $Res Function(TypeHierarchySupertypesParams) _then) = _$TypeHierarchySupertypesParamsCopyWithImpl;
@useResult
$Res call({
 TypeHierarchyItem item, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


$TypeHierarchyItemCopyWith<$Res> get item;

}
/// @nodoc
class _$TypeHierarchySupertypesParamsCopyWithImpl<$Res>
    implements $TypeHierarchySupertypesParamsCopyWith<$Res> {
  _$TypeHierarchySupertypesParamsCopyWithImpl(this._self, this._then);

  final TypeHierarchySupertypesParams _self;
  final $Res Function(TypeHierarchySupertypesParams) _then;

/// Create a copy of TypeHierarchySupertypesParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? item = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
item: null == item ? _self.item : item // ignore: cast_nullable_to_non_nullable
as TypeHierarchyItem,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of TypeHierarchySupertypesParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TypeHierarchyItemCopyWith<$Res> get item {
  
  return $TypeHierarchyItemCopyWith<$Res>(_self.item, (value) {
    return _then(_self.copyWith(item: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _TypeHierarchySupertypesParams implements TypeHierarchySupertypesParams {
  const _TypeHierarchySupertypesParams({required this.item, this.partialResultToken, this.workDoneToken});
  factory _TypeHierarchySupertypesParams.fromJson(Map<String, dynamic> json) => _$TypeHierarchySupertypesParamsFromJson(json);

@override final  TypeHierarchyItem item;
/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
@override final  ProgressToken? partialResultToken;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of TypeHierarchySupertypesParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TypeHierarchySupertypesParamsCopyWith<_TypeHierarchySupertypesParams> get copyWith => __$TypeHierarchySupertypesParamsCopyWithImpl<_TypeHierarchySupertypesParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TypeHierarchySupertypesParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TypeHierarchySupertypesParams&&(identical(other.item, item) || other.item == item)&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,item,partialResultToken,workDoneToken);

@override
String toString() {
  return 'TypeHierarchySupertypesParams(item: $item, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$TypeHierarchySupertypesParamsCopyWith<$Res> implements $TypeHierarchySupertypesParamsCopyWith<$Res> {
  factory _$TypeHierarchySupertypesParamsCopyWith(_TypeHierarchySupertypesParams value, $Res Function(_TypeHierarchySupertypesParams) _then) = __$TypeHierarchySupertypesParamsCopyWithImpl;
@override @useResult
$Res call({
 TypeHierarchyItem item, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


@override $TypeHierarchyItemCopyWith<$Res> get item;

}
/// @nodoc
class __$TypeHierarchySupertypesParamsCopyWithImpl<$Res>
    implements _$TypeHierarchySupertypesParamsCopyWith<$Res> {
  __$TypeHierarchySupertypesParamsCopyWithImpl(this._self, this._then);

  final _TypeHierarchySupertypesParams _self;
  final $Res Function(_TypeHierarchySupertypesParams) _then;

/// Create a copy of TypeHierarchySupertypesParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? item = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_TypeHierarchySupertypesParams(
item: null == item ? _self.item : item // ignore: cast_nullable_to_non_nullable
as TypeHierarchyItem,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of TypeHierarchySupertypesParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TypeHierarchyItemCopyWith<$Res> get item {
  
  return $TypeHierarchyItemCopyWith<$Res>(_self.item, (value) {
    return _then(_self.copyWith(item: value));
  });
}
}


/// @nodoc
mixin _$TypeHierarchySubtypesParams {

 TypeHierarchyItem get item;/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
 ProgressToken? get partialResultToken;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of TypeHierarchySubtypesParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TypeHierarchySubtypesParamsCopyWith<TypeHierarchySubtypesParams> get copyWith => _$TypeHierarchySubtypesParamsCopyWithImpl<TypeHierarchySubtypesParams>(this as TypeHierarchySubtypesParams, _$identity);

  /// Serializes this TypeHierarchySubtypesParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TypeHierarchySubtypesParams&&(identical(other.item, item) || other.item == item)&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,item,partialResultToken,workDoneToken);

@override
String toString() {
  return 'TypeHierarchySubtypesParams(item: $item, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $TypeHierarchySubtypesParamsCopyWith<$Res>  {
  factory $TypeHierarchySubtypesParamsCopyWith(TypeHierarchySubtypesParams value, $Res Function(TypeHierarchySubtypesParams) _then) = _$TypeHierarchySubtypesParamsCopyWithImpl;
@useResult
$Res call({
 TypeHierarchyItem item, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


$TypeHierarchyItemCopyWith<$Res> get item;

}
/// @nodoc
class _$TypeHierarchySubtypesParamsCopyWithImpl<$Res>
    implements $TypeHierarchySubtypesParamsCopyWith<$Res> {
  _$TypeHierarchySubtypesParamsCopyWithImpl(this._self, this._then);

  final TypeHierarchySubtypesParams _self;
  final $Res Function(TypeHierarchySubtypesParams) _then;

/// Create a copy of TypeHierarchySubtypesParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? item = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
item: null == item ? _self.item : item // ignore: cast_nullable_to_non_nullable
as TypeHierarchyItem,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of TypeHierarchySubtypesParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TypeHierarchyItemCopyWith<$Res> get item {
  
  return $TypeHierarchyItemCopyWith<$Res>(_self.item, (value) {
    return _then(_self.copyWith(item: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _TypeHierarchySubtypesParams implements TypeHierarchySubtypesParams {
  const _TypeHierarchySubtypesParams({required this.item, this.partialResultToken, this.workDoneToken});
  factory _TypeHierarchySubtypesParams.fromJson(Map<String, dynamic> json) => _$TypeHierarchySubtypesParamsFromJson(json);

@override final  TypeHierarchyItem item;
/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
@override final  ProgressToken? partialResultToken;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of TypeHierarchySubtypesParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TypeHierarchySubtypesParamsCopyWith<_TypeHierarchySubtypesParams> get copyWith => __$TypeHierarchySubtypesParamsCopyWithImpl<_TypeHierarchySubtypesParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TypeHierarchySubtypesParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TypeHierarchySubtypesParams&&(identical(other.item, item) || other.item == item)&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,item,partialResultToken,workDoneToken);

@override
String toString() {
  return 'TypeHierarchySubtypesParams(item: $item, partialResultToken: $partialResultToken, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$TypeHierarchySubtypesParamsCopyWith<$Res> implements $TypeHierarchySubtypesParamsCopyWith<$Res> {
  factory _$TypeHierarchySubtypesParamsCopyWith(_TypeHierarchySubtypesParams value, $Res Function(_TypeHierarchySubtypesParams) _then) = __$TypeHierarchySubtypesParamsCopyWithImpl;
@override @useResult
$Res call({
 TypeHierarchyItem item, ProgressToken? partialResultToken, ProgressToken? workDoneToken
});


@override $TypeHierarchyItemCopyWith<$Res> get item;

}
/// @nodoc
class __$TypeHierarchySubtypesParamsCopyWithImpl<$Res>
    implements _$TypeHierarchySubtypesParamsCopyWith<$Res> {
  __$TypeHierarchySubtypesParamsCopyWithImpl(this._self, this._then);

  final _TypeHierarchySubtypesParams _self;
  final $Res Function(_TypeHierarchySubtypesParams) _then;

/// Create a copy of TypeHierarchySubtypesParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? item = null,Object? partialResultToken = freezed,Object? workDoneToken = freezed,}) {
  return _then(_TypeHierarchySubtypesParams(
item: null == item ? _self.item : item // ignore: cast_nullable_to_non_nullable
as TypeHierarchyItem,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of TypeHierarchySubtypesParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TypeHierarchyItemCopyWith<$Res> get item {
  
  return $TypeHierarchyItemCopyWith<$Res>(_self.item, (value) {
    return _then(_self.copyWith(item: value));
  });
}
}


/// @nodoc
mixin _$InlineValueParams {

/// Additional information about the context in which inline values were
/// requested.
 InlineValueContext get context;/// The document range for which inline values should be computed.
 Range get range;/// The text document.
 TextDocumentIdentifier get textDocument;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of InlineValueParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlineValueParamsCopyWith<InlineValueParams> get copyWith => _$InlineValueParamsCopyWithImpl<InlineValueParams>(this as InlineValueParams, _$identity);

  /// Serializes this InlineValueParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlineValueParams&&(identical(other.context, context) || other.context == context)&&(identical(other.range, range) || other.range == range)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,context,range,textDocument,workDoneToken);

@override
String toString() {
  return 'InlineValueParams(context: $context, range: $range, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $InlineValueParamsCopyWith<$Res>  {
  factory $InlineValueParamsCopyWith(InlineValueParams value, $Res Function(InlineValueParams) _then) = _$InlineValueParamsCopyWithImpl;
@useResult
$Res call({
 InlineValueContext context, Range range, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


$InlineValueContextCopyWith<$Res> get context;$RangeCopyWith<$Res> get range;$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$InlineValueParamsCopyWithImpl<$Res>
    implements $InlineValueParamsCopyWith<$Res> {
  _$InlineValueParamsCopyWithImpl(this._self, this._then);

  final InlineValueParams _self;
  final $Res Function(InlineValueParams) _then;

/// Create a copy of InlineValueParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? context = null,Object? range = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
context: null == context ? _self.context : context // ignore: cast_nullable_to_non_nullable
as InlineValueContext,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of InlineValueParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$InlineValueContextCopyWith<$Res> get context {
  
  return $InlineValueContextCopyWith<$Res>(_self.context, (value) {
    return _then(_self.copyWith(context: value));
  });
}/// Create a copy of InlineValueParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}/// Create a copy of InlineValueParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _InlineValueParams implements InlineValueParams {
  const _InlineValueParams({required this.context, required this.range, required this.textDocument, this.workDoneToken});
  factory _InlineValueParams.fromJson(Map<String, dynamic> json) => _$InlineValueParamsFromJson(json);

/// Additional information about the context in which inline values were
/// requested.
@override final  InlineValueContext context;
/// The document range for which inline values should be computed.
@override final  Range range;
/// The text document.
@override final  TextDocumentIdentifier textDocument;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of InlineValueParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlineValueParamsCopyWith<_InlineValueParams> get copyWith => __$InlineValueParamsCopyWithImpl<_InlineValueParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlineValueParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlineValueParams&&(identical(other.context, context) || other.context == context)&&(identical(other.range, range) || other.range == range)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,context,range,textDocument,workDoneToken);

@override
String toString() {
  return 'InlineValueParams(context: $context, range: $range, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$InlineValueParamsCopyWith<$Res> implements $InlineValueParamsCopyWith<$Res> {
  factory _$InlineValueParamsCopyWith(_InlineValueParams value, $Res Function(_InlineValueParams) _then) = __$InlineValueParamsCopyWithImpl;
@override @useResult
$Res call({
 InlineValueContext context, Range range, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


@override $InlineValueContextCopyWith<$Res> get context;@override $RangeCopyWith<$Res> get range;@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$InlineValueParamsCopyWithImpl<$Res>
    implements _$InlineValueParamsCopyWith<$Res> {
  __$InlineValueParamsCopyWithImpl(this._self, this._then);

  final _InlineValueParams _self;
  final $Res Function(_InlineValueParams) _then;

/// Create a copy of InlineValueParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? context = null,Object? range = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_InlineValueParams(
context: null == context ? _self.context : context // ignore: cast_nullable_to_non_nullable
as InlineValueContext,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of InlineValueParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$InlineValueContextCopyWith<$Res> get context {
  
  return $InlineValueContextCopyWith<$Res>(_self.context, (value) {
    return _then(_self.copyWith(context: value));
  });
}/// Create a copy of InlineValueParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}/// Create a copy of InlineValueParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$InlineValueRegistrationOptions {

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
 Sealed14 get documentSelector;/// The id used to register the request. The id can be used to deregister
/// the request again. See also Registration#id.
 String? get id;
/// Create a copy of InlineValueRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlineValueRegistrationOptionsCopyWith<InlineValueRegistrationOptions> get copyWith => _$InlineValueRegistrationOptionsCopyWithImpl<InlineValueRegistrationOptions>(this as InlineValueRegistrationOptions, _$identity);

  /// Serializes this InlineValueRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlineValueRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.id, id) || other.id == id));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,id);

@override
String toString() {
  return 'InlineValueRegistrationOptions(documentSelector: $documentSelector, id: $id)';
}


}

/// @nodoc
abstract mixin class $InlineValueRegistrationOptionsCopyWith<$Res>  {
  factory $InlineValueRegistrationOptionsCopyWith(InlineValueRegistrationOptions value, $Res Function(InlineValueRegistrationOptions) _then) = _$InlineValueRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 Sealed14 documentSelector, String? id
});




}
/// @nodoc
class _$InlineValueRegistrationOptionsCopyWithImpl<$Res>
    implements $InlineValueRegistrationOptionsCopyWith<$Res> {
  _$InlineValueRegistrationOptionsCopyWithImpl(this._self, this._then);

  final InlineValueRegistrationOptions _self;
  final $Res Function(InlineValueRegistrationOptions) _then;

/// Create a copy of InlineValueRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = null,Object? id = freezed,}) {
  return _then(_self.copyWith(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _InlineValueRegistrationOptions implements InlineValueRegistrationOptions {
  const _InlineValueRegistrationOptions({required this.documentSelector, this.id});
  factory _InlineValueRegistrationOptions.fromJson(Map<String, dynamic> json) => _$InlineValueRegistrationOptionsFromJson(json);

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
@override final  Sealed14 documentSelector;
/// The id used to register the request. The id can be used to deregister
/// the request again. See also Registration#id.
@override final  String? id;

/// Create a copy of InlineValueRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlineValueRegistrationOptionsCopyWith<_InlineValueRegistrationOptions> get copyWith => __$InlineValueRegistrationOptionsCopyWithImpl<_InlineValueRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlineValueRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlineValueRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.id, id) || other.id == id));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,id);

@override
String toString() {
  return 'InlineValueRegistrationOptions(documentSelector: $documentSelector, id: $id)';
}


}

/// @nodoc
abstract mixin class _$InlineValueRegistrationOptionsCopyWith<$Res> implements $InlineValueRegistrationOptionsCopyWith<$Res> {
  factory _$InlineValueRegistrationOptionsCopyWith(_InlineValueRegistrationOptions value, $Res Function(_InlineValueRegistrationOptions) _then) = __$InlineValueRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 Sealed14 documentSelector, String? id
});




}
/// @nodoc
class __$InlineValueRegistrationOptionsCopyWithImpl<$Res>
    implements _$InlineValueRegistrationOptionsCopyWith<$Res> {
  __$InlineValueRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _InlineValueRegistrationOptions _self;
  final $Res Function(_InlineValueRegistrationOptions) _then;

/// Create a copy of InlineValueRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = null,Object? id = freezed,}) {
  return _then(_InlineValueRegistrationOptions(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$InlayHintParams {

/// The document range for which inlay hints should be computed.
 Range get range;/// The text document.
 TextDocumentIdentifier get textDocument;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of InlayHintParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlayHintParamsCopyWith<InlayHintParams> get copyWith => _$InlayHintParamsCopyWithImpl<InlayHintParams>(this as InlayHintParams, _$identity);

  /// Serializes this InlayHintParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlayHintParams&&(identical(other.range, range) || other.range == range)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,range,textDocument,workDoneToken);

@override
String toString() {
  return 'InlayHintParams(range: $range, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $InlayHintParamsCopyWith<$Res>  {
  factory $InlayHintParamsCopyWith(InlayHintParams value, $Res Function(InlayHintParams) _then) = _$InlayHintParamsCopyWithImpl;
@useResult
$Res call({
 Range range, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


$RangeCopyWith<$Res> get range;$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$InlayHintParamsCopyWithImpl<$Res>
    implements $InlayHintParamsCopyWith<$Res> {
  _$InlayHintParamsCopyWithImpl(this._self, this._then);

  final InlayHintParams _self;
  final $Res Function(InlayHintParams) _then;

/// Create a copy of InlayHintParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? range = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of InlayHintParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}/// Create a copy of InlayHintParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _InlayHintParams implements InlayHintParams {
  const _InlayHintParams({required this.range, required this.textDocument, this.workDoneToken});
  factory _InlayHintParams.fromJson(Map<String, dynamic> json) => _$InlayHintParamsFromJson(json);

/// The document range for which inlay hints should be computed.
@override final  Range range;
/// The text document.
@override final  TextDocumentIdentifier textDocument;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of InlayHintParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlayHintParamsCopyWith<_InlayHintParams> get copyWith => __$InlayHintParamsCopyWithImpl<_InlayHintParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlayHintParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlayHintParams&&(identical(other.range, range) || other.range == range)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,range,textDocument,workDoneToken);

@override
String toString() {
  return 'InlayHintParams(range: $range, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$InlayHintParamsCopyWith<$Res> implements $InlayHintParamsCopyWith<$Res> {
  factory _$InlayHintParamsCopyWith(_InlayHintParams value, $Res Function(_InlayHintParams) _then) = __$InlayHintParamsCopyWithImpl;
@override @useResult
$Res call({
 Range range, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


@override $RangeCopyWith<$Res> get range;@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$InlayHintParamsCopyWithImpl<$Res>
    implements _$InlayHintParamsCopyWith<$Res> {
  __$InlayHintParamsCopyWithImpl(this._self, this._then);

  final _InlayHintParams _self;
  final $Res Function(_InlayHintParams) _then;

/// Create a copy of InlayHintParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? range = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_InlayHintParams(
range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of InlayHintParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}/// Create a copy of InlayHintParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$InlayHint {

/// A data entry field that is preserved on an inlay hint between a
/// `textDocument/inlayHint` and a `inlayHint/resolve` request.
 LSPAny? get data;/// The kind of this hint. Can be omitted in which case the client should
/// fall back to a reasonable default.
 InlayHintKind? get kind;/// The label of this hint. A human readable string or an array of
/// InlayHintLabelPart label parts.
/// *Note* that neither the string nor the label part can be empty.
 Sealed16 get label;/// Render padding before the hint.
/// Note: Padding should use the editor's background color, not the
/// background color of the hint itself. That means padding can be used to
/// visually align/separate an inlay hint.
 bool? get paddingLeft;/// Render padding after the hint.
/// Note: Padding should use the editor's background color, not the
/// background color of the hint itself. That means padding can be used to
/// visually align/separate an inlay hint.
 bool? get paddingRight;/// The position of this hint.
/// If multiple hints have the same position, they will be shown in the
/// order they appear in the response.
 Position get position;/// Optional text edits that are performed when accepting this inlay hint.
/// *Note* that edits are expected to change the document so that the inlay
/// hint (or its nearest variant) is now part of the document and the inlay
/// hint itself is now obsolete.
 List<TextEdit>? get textEdits;/// The tooltip text when you hover over this item.
 Sealed17? get tooltip;
/// Create a copy of InlayHint
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlayHintCopyWith<InlayHint> get copyWith => _$InlayHintCopyWithImpl<InlayHint>(this as InlayHint, _$identity);

  /// Serializes this InlayHint to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlayHint&&(identical(other.data, data) || other.data == data)&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.label, label) || other.label == label)&&(identical(other.paddingLeft, paddingLeft) || other.paddingLeft == paddingLeft)&&(identical(other.paddingRight, paddingRight) || other.paddingRight == paddingRight)&&(identical(other.position, position) || other.position == position)&&const DeepCollectionEquality().equals(other.textEdits, textEdits)&&(identical(other.tooltip, tooltip) || other.tooltip == tooltip));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,data,kind,label,paddingLeft,paddingRight,position,const DeepCollectionEquality().hash(textEdits),tooltip);

@override
String toString() {
  return 'InlayHint(data: $data, kind: $kind, label: $label, paddingLeft: $paddingLeft, paddingRight: $paddingRight, position: $position, textEdits: $textEdits, tooltip: $tooltip)';
}


}

/// @nodoc
abstract mixin class $InlayHintCopyWith<$Res>  {
  factory $InlayHintCopyWith(InlayHint value, $Res Function(InlayHint) _then) = _$InlayHintCopyWithImpl;
@useResult
$Res call({
 LSPAny? data, InlayHintKind? kind, Sealed16 label, bool? paddingLeft, bool? paddingRight, Position position, List<TextEdit>? textEdits, Sealed17? tooltip
});


$PositionCopyWith<$Res> get position;

}
/// @nodoc
class _$InlayHintCopyWithImpl<$Res>
    implements $InlayHintCopyWith<$Res> {
  _$InlayHintCopyWithImpl(this._self, this._then);

  final InlayHint _self;
  final $Res Function(InlayHint) _then;

/// Create a copy of InlayHint
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? data = freezed,Object? kind = freezed,Object? label = null,Object? paddingLeft = freezed,Object? paddingRight = freezed,Object? position = null,Object? textEdits = freezed,Object? tooltip = freezed,}) {
  return _then(_self.copyWith(
data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LSPAny?,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as InlayHintKind?,label: null == label ? _self.label : label // ignore: cast_nullable_to_non_nullable
as Sealed16,paddingLeft: freezed == paddingLeft ? _self.paddingLeft : paddingLeft // ignore: cast_nullable_to_non_nullable
as bool?,paddingRight: freezed == paddingRight ? _self.paddingRight : paddingRight // ignore: cast_nullable_to_non_nullable
as bool?,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,textEdits: freezed == textEdits ? _self.textEdits : textEdits // ignore: cast_nullable_to_non_nullable
as List<TextEdit>?,tooltip: freezed == tooltip ? _self.tooltip : tooltip // ignore: cast_nullable_to_non_nullable
as Sealed17?,
  ));
}
/// Create a copy of InlayHint
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _InlayHint implements InlayHint {
  const _InlayHint({this.data, this.kind, required this.label, this.paddingLeft, this.paddingRight, required this.position, final  List<TextEdit>? textEdits, this.tooltip}): _textEdits = textEdits;
  factory _InlayHint.fromJson(Map<String, dynamic> json) => _$InlayHintFromJson(json);

/// A data entry field that is preserved on an inlay hint between a
/// `textDocument/inlayHint` and a `inlayHint/resolve` request.
@override final  LSPAny? data;
/// The kind of this hint. Can be omitted in which case the client should
/// fall back to a reasonable default.
@override final  InlayHintKind? kind;
/// The label of this hint. A human readable string or an array of
/// InlayHintLabelPart label parts.
/// *Note* that neither the string nor the label part can be empty.
@override final  Sealed16 label;
/// Render padding before the hint.
/// Note: Padding should use the editor's background color, not the
/// background color of the hint itself. That means padding can be used to
/// visually align/separate an inlay hint.
@override final  bool? paddingLeft;
/// Render padding after the hint.
/// Note: Padding should use the editor's background color, not the
/// background color of the hint itself. That means padding can be used to
/// visually align/separate an inlay hint.
@override final  bool? paddingRight;
/// The position of this hint.
/// If multiple hints have the same position, they will be shown in the
/// order they appear in the response.
@override final  Position position;
/// Optional text edits that are performed when accepting this inlay hint.
/// *Note* that edits are expected to change the document so that the inlay
/// hint (or its nearest variant) is now part of the document and the inlay
/// hint itself is now obsolete.
 final  List<TextEdit>? _textEdits;
/// Optional text edits that are performed when accepting this inlay hint.
/// *Note* that edits are expected to change the document so that the inlay
/// hint (or its nearest variant) is now part of the document and the inlay
/// hint itself is now obsolete.
@override List<TextEdit>? get textEdits {
  final value = _textEdits;
  if (value == null) return null;
  if (_textEdits is EqualUnmodifiableListView) return _textEdits;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

/// The tooltip text when you hover over this item.
@override final  Sealed17? tooltip;

/// Create a copy of InlayHint
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlayHintCopyWith<_InlayHint> get copyWith => __$InlayHintCopyWithImpl<_InlayHint>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlayHintToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlayHint&&(identical(other.data, data) || other.data == data)&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.label, label) || other.label == label)&&(identical(other.paddingLeft, paddingLeft) || other.paddingLeft == paddingLeft)&&(identical(other.paddingRight, paddingRight) || other.paddingRight == paddingRight)&&(identical(other.position, position) || other.position == position)&&const DeepCollectionEquality().equals(other._textEdits, _textEdits)&&(identical(other.tooltip, tooltip) || other.tooltip == tooltip));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,data,kind,label,paddingLeft,paddingRight,position,const DeepCollectionEquality().hash(_textEdits),tooltip);

@override
String toString() {
  return 'InlayHint(data: $data, kind: $kind, label: $label, paddingLeft: $paddingLeft, paddingRight: $paddingRight, position: $position, textEdits: $textEdits, tooltip: $tooltip)';
}


}

/// @nodoc
abstract mixin class _$InlayHintCopyWith<$Res> implements $InlayHintCopyWith<$Res> {
  factory _$InlayHintCopyWith(_InlayHint value, $Res Function(_InlayHint) _then) = __$InlayHintCopyWithImpl;
@override @useResult
$Res call({
 LSPAny? data, InlayHintKind? kind, Sealed16 label, bool? paddingLeft, bool? paddingRight, Position position, List<TextEdit>? textEdits, Sealed17? tooltip
});


@override $PositionCopyWith<$Res> get position;

}
/// @nodoc
class __$InlayHintCopyWithImpl<$Res>
    implements _$InlayHintCopyWith<$Res> {
  __$InlayHintCopyWithImpl(this._self, this._then);

  final _InlayHint _self;
  final $Res Function(_InlayHint) _then;

/// Create a copy of InlayHint
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? data = freezed,Object? kind = freezed,Object? label = null,Object? paddingLeft = freezed,Object? paddingRight = freezed,Object? position = null,Object? textEdits = freezed,Object? tooltip = freezed,}) {
  return _then(_InlayHint(
data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LSPAny?,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as InlayHintKind?,label: null == label ? _self.label : label // ignore: cast_nullable_to_non_nullable
as Sealed16,paddingLeft: freezed == paddingLeft ? _self.paddingLeft : paddingLeft // ignore: cast_nullable_to_non_nullable
as bool?,paddingRight: freezed == paddingRight ? _self.paddingRight : paddingRight // ignore: cast_nullable_to_non_nullable
as bool?,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,textEdits: freezed == textEdits ? _self._textEdits : textEdits // ignore: cast_nullable_to_non_nullable
as List<TextEdit>?,tooltip: freezed == tooltip ? _self.tooltip : tooltip // ignore: cast_nullable_to_non_nullable
as Sealed17?,
  ));
}

/// Create a copy of InlayHint
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}
}


/// @nodoc
mixin _$InlayHintRegistrationOptions {

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
 Sealed14 get documentSelector;/// The id used to register the request. The id can be used to deregister
/// the request again. See also Registration#id.
 String? get id;/// The server provides support to resolve additional information for an
/// inlay hint item.
 bool? get resolveProvider;
/// Create a copy of InlayHintRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlayHintRegistrationOptionsCopyWith<InlayHintRegistrationOptions> get copyWith => _$InlayHintRegistrationOptionsCopyWithImpl<InlayHintRegistrationOptions>(this as InlayHintRegistrationOptions, _$identity);

  /// Serializes this InlayHintRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlayHintRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.id, id) || other.id == id)&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,id,resolveProvider);

@override
String toString() {
  return 'InlayHintRegistrationOptions(documentSelector: $documentSelector, id: $id, resolveProvider: $resolveProvider)';
}


}

/// @nodoc
abstract mixin class $InlayHintRegistrationOptionsCopyWith<$Res>  {
  factory $InlayHintRegistrationOptionsCopyWith(InlayHintRegistrationOptions value, $Res Function(InlayHintRegistrationOptions) _then) = _$InlayHintRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 Sealed14 documentSelector, String? id, bool? resolveProvider
});




}
/// @nodoc
class _$InlayHintRegistrationOptionsCopyWithImpl<$Res>
    implements $InlayHintRegistrationOptionsCopyWith<$Res> {
  _$InlayHintRegistrationOptionsCopyWithImpl(this._self, this._then);

  final InlayHintRegistrationOptions _self;
  final $Res Function(InlayHintRegistrationOptions) _then;

/// Create a copy of InlayHintRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = null,Object? id = freezed,Object? resolveProvider = freezed,}) {
  return _then(_self.copyWith(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _InlayHintRegistrationOptions implements InlayHintRegistrationOptions {
  const _InlayHintRegistrationOptions({required this.documentSelector, this.id, this.resolveProvider});
  factory _InlayHintRegistrationOptions.fromJson(Map<String, dynamic> json) => _$InlayHintRegistrationOptionsFromJson(json);

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
@override final  Sealed14 documentSelector;
/// The id used to register the request. The id can be used to deregister
/// the request again. See also Registration#id.
@override final  String? id;
/// The server provides support to resolve additional information for an
/// inlay hint item.
@override final  bool? resolveProvider;

/// Create a copy of InlayHintRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlayHintRegistrationOptionsCopyWith<_InlayHintRegistrationOptions> get copyWith => __$InlayHintRegistrationOptionsCopyWithImpl<_InlayHintRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlayHintRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlayHintRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.id, id) || other.id == id)&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,id,resolveProvider);

@override
String toString() {
  return 'InlayHintRegistrationOptions(documentSelector: $documentSelector, id: $id, resolveProvider: $resolveProvider)';
}


}

/// @nodoc
abstract mixin class _$InlayHintRegistrationOptionsCopyWith<$Res> implements $InlayHintRegistrationOptionsCopyWith<$Res> {
  factory _$InlayHintRegistrationOptionsCopyWith(_InlayHintRegistrationOptions value, $Res Function(_InlayHintRegistrationOptions) _then) = __$InlayHintRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 Sealed14 documentSelector, String? id, bool? resolveProvider
});




}
/// @nodoc
class __$InlayHintRegistrationOptionsCopyWithImpl<$Res>
    implements _$InlayHintRegistrationOptionsCopyWith<$Res> {
  __$InlayHintRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _InlayHintRegistrationOptions _self;
  final $Res Function(_InlayHintRegistrationOptions) _then;

/// Create a copy of InlayHintRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = null,Object? id = freezed,Object? resolveProvider = freezed,}) {
  return _then(_InlayHintRegistrationOptions(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DocumentDiagnosticParams {

/// The additional identifier  provided during registration.
 String? get identifier;/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
 ProgressToken? get partialResultToken;/// The result id of a previous response if provided.
 String? get previousResultId;/// The text document.
 TextDocumentIdentifier get textDocument;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of DocumentDiagnosticParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentDiagnosticParamsCopyWith<DocumentDiagnosticParams> get copyWith => _$DocumentDiagnosticParamsCopyWithImpl<DocumentDiagnosticParams>(this as DocumentDiagnosticParams, _$identity);

  /// Serializes this DocumentDiagnosticParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentDiagnosticParams&&(identical(other.identifier, identifier) || other.identifier == identifier)&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.previousResultId, previousResultId) || other.previousResultId == previousResultId)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,identifier,partialResultToken,previousResultId,textDocument,workDoneToken);

@override
String toString() {
  return 'DocumentDiagnosticParams(identifier: $identifier, partialResultToken: $partialResultToken, previousResultId: $previousResultId, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $DocumentDiagnosticParamsCopyWith<$Res>  {
  factory $DocumentDiagnosticParamsCopyWith(DocumentDiagnosticParams value, $Res Function(DocumentDiagnosticParams) _then) = _$DocumentDiagnosticParamsCopyWithImpl;
@useResult
$Res call({
 String? identifier, ProgressToken? partialResultToken, String? previousResultId, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$DocumentDiagnosticParamsCopyWithImpl<$Res>
    implements $DocumentDiagnosticParamsCopyWith<$Res> {
  _$DocumentDiagnosticParamsCopyWithImpl(this._self, this._then);

  final DocumentDiagnosticParams _self;
  final $Res Function(DocumentDiagnosticParams) _then;

/// Create a copy of DocumentDiagnosticParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? identifier = freezed,Object? partialResultToken = freezed,Object? previousResultId = freezed,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
identifier: freezed == identifier ? _self.identifier : identifier // ignore: cast_nullable_to_non_nullable
as String?,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,previousResultId: freezed == previousResultId ? _self.previousResultId : previousResultId // ignore: cast_nullable_to_non_nullable
as String?,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of DocumentDiagnosticParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _DocumentDiagnosticParams implements DocumentDiagnosticParams {
  const _DocumentDiagnosticParams({this.identifier, this.partialResultToken, this.previousResultId, required this.textDocument, this.workDoneToken});
  factory _DocumentDiagnosticParams.fromJson(Map<String, dynamic> json) => _$DocumentDiagnosticParamsFromJson(json);

/// The additional identifier  provided during registration.
@override final  String? identifier;
/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
@override final  ProgressToken? partialResultToken;
/// The result id of a previous response if provided.
@override final  String? previousResultId;
/// The text document.
@override final  TextDocumentIdentifier textDocument;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of DocumentDiagnosticParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentDiagnosticParamsCopyWith<_DocumentDiagnosticParams> get copyWith => __$DocumentDiagnosticParamsCopyWithImpl<_DocumentDiagnosticParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentDiagnosticParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentDiagnosticParams&&(identical(other.identifier, identifier) || other.identifier == identifier)&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.previousResultId, previousResultId) || other.previousResultId == previousResultId)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,identifier,partialResultToken,previousResultId,textDocument,workDoneToken);

@override
String toString() {
  return 'DocumentDiagnosticParams(identifier: $identifier, partialResultToken: $partialResultToken, previousResultId: $previousResultId, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$DocumentDiagnosticParamsCopyWith<$Res> implements $DocumentDiagnosticParamsCopyWith<$Res> {
  factory _$DocumentDiagnosticParamsCopyWith(_DocumentDiagnosticParams value, $Res Function(_DocumentDiagnosticParams) _then) = __$DocumentDiagnosticParamsCopyWithImpl;
@override @useResult
$Res call({
 String? identifier, ProgressToken? partialResultToken, String? previousResultId, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$DocumentDiagnosticParamsCopyWithImpl<$Res>
    implements _$DocumentDiagnosticParamsCopyWith<$Res> {
  __$DocumentDiagnosticParamsCopyWithImpl(this._self, this._then);

  final _DocumentDiagnosticParams _self;
  final $Res Function(_DocumentDiagnosticParams) _then;

/// Create a copy of DocumentDiagnosticParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? identifier = freezed,Object? partialResultToken = freezed,Object? previousResultId = freezed,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_DocumentDiagnosticParams(
identifier: freezed == identifier ? _self.identifier : identifier // ignore: cast_nullable_to_non_nullable
as String?,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,previousResultId: freezed == previousResultId ? _self.previousResultId : previousResultId // ignore: cast_nullable_to_non_nullable
as String?,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of DocumentDiagnosticParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$DocumentDiagnosticReportPartialResult {

 Map<String, Sealed18> get relatedDocuments;
/// Create a copy of DocumentDiagnosticReportPartialResult
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentDiagnosticReportPartialResultCopyWith<DocumentDiagnosticReportPartialResult> get copyWith => _$DocumentDiagnosticReportPartialResultCopyWithImpl<DocumentDiagnosticReportPartialResult>(this as DocumentDiagnosticReportPartialResult, _$identity);

  /// Serializes this DocumentDiagnosticReportPartialResult to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentDiagnosticReportPartialResult&&const DeepCollectionEquality().equals(other.relatedDocuments, relatedDocuments));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(relatedDocuments));

@override
String toString() {
  return 'DocumentDiagnosticReportPartialResult(relatedDocuments: $relatedDocuments)';
}


}

/// @nodoc
abstract mixin class $DocumentDiagnosticReportPartialResultCopyWith<$Res>  {
  factory $DocumentDiagnosticReportPartialResultCopyWith(DocumentDiagnosticReportPartialResult value, $Res Function(DocumentDiagnosticReportPartialResult) _then) = _$DocumentDiagnosticReportPartialResultCopyWithImpl;
@useResult
$Res call({
 Map<String, Sealed18> relatedDocuments
});




}
/// @nodoc
class _$DocumentDiagnosticReportPartialResultCopyWithImpl<$Res>
    implements $DocumentDiagnosticReportPartialResultCopyWith<$Res> {
  _$DocumentDiagnosticReportPartialResultCopyWithImpl(this._self, this._then);

  final DocumentDiagnosticReportPartialResult _self;
  final $Res Function(DocumentDiagnosticReportPartialResult) _then;

/// Create a copy of DocumentDiagnosticReportPartialResult
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? relatedDocuments = null,}) {
  return _then(_self.copyWith(
relatedDocuments: null == relatedDocuments ? _self.relatedDocuments : relatedDocuments // ignore: cast_nullable_to_non_nullable
as Map<String, Sealed18>,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DocumentDiagnosticReportPartialResult implements DocumentDiagnosticReportPartialResult {
  const _DocumentDiagnosticReportPartialResult({required final  Map<String, Sealed18> relatedDocuments}): _relatedDocuments = relatedDocuments;
  factory _DocumentDiagnosticReportPartialResult.fromJson(Map<String, dynamic> json) => _$DocumentDiagnosticReportPartialResultFromJson(json);

 final  Map<String, Sealed18> _relatedDocuments;
@override Map<String, Sealed18> get relatedDocuments {
  if (_relatedDocuments is EqualUnmodifiableMapView) return _relatedDocuments;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(_relatedDocuments);
}


/// Create a copy of DocumentDiagnosticReportPartialResult
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentDiagnosticReportPartialResultCopyWith<_DocumentDiagnosticReportPartialResult> get copyWith => __$DocumentDiagnosticReportPartialResultCopyWithImpl<_DocumentDiagnosticReportPartialResult>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentDiagnosticReportPartialResultToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentDiagnosticReportPartialResult&&const DeepCollectionEquality().equals(other._relatedDocuments, _relatedDocuments));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_relatedDocuments));

@override
String toString() {
  return 'DocumentDiagnosticReportPartialResult(relatedDocuments: $relatedDocuments)';
}


}

/// @nodoc
abstract mixin class _$DocumentDiagnosticReportPartialResultCopyWith<$Res> implements $DocumentDiagnosticReportPartialResultCopyWith<$Res> {
  factory _$DocumentDiagnosticReportPartialResultCopyWith(_DocumentDiagnosticReportPartialResult value, $Res Function(_DocumentDiagnosticReportPartialResult) _then) = __$DocumentDiagnosticReportPartialResultCopyWithImpl;
@override @useResult
$Res call({
 Map<String, Sealed18> relatedDocuments
});




}
/// @nodoc
class __$DocumentDiagnosticReportPartialResultCopyWithImpl<$Res>
    implements _$DocumentDiagnosticReportPartialResultCopyWith<$Res> {
  __$DocumentDiagnosticReportPartialResultCopyWithImpl(this._self, this._then);

  final _DocumentDiagnosticReportPartialResult _self;
  final $Res Function(_DocumentDiagnosticReportPartialResult) _then;

/// Create a copy of DocumentDiagnosticReportPartialResult
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? relatedDocuments = null,}) {
  return _then(_DocumentDiagnosticReportPartialResult(
relatedDocuments: null == relatedDocuments ? _self._relatedDocuments : relatedDocuments // ignore: cast_nullable_to_non_nullable
as Map<String, Sealed18>,
  ));
}


}


/// @nodoc
mixin _$DiagnosticServerCancellationData {

 bool get retriggerRequest;
/// Create a copy of DiagnosticServerCancellationData
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DiagnosticServerCancellationDataCopyWith<DiagnosticServerCancellationData> get copyWith => _$DiagnosticServerCancellationDataCopyWithImpl<DiagnosticServerCancellationData>(this as DiagnosticServerCancellationData, _$identity);

  /// Serializes this DiagnosticServerCancellationData to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DiagnosticServerCancellationData&&(identical(other.retriggerRequest, retriggerRequest) || other.retriggerRequest == retriggerRequest));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,retriggerRequest);

@override
String toString() {
  return 'DiagnosticServerCancellationData(retriggerRequest: $retriggerRequest)';
}


}

/// @nodoc
abstract mixin class $DiagnosticServerCancellationDataCopyWith<$Res>  {
  factory $DiagnosticServerCancellationDataCopyWith(DiagnosticServerCancellationData value, $Res Function(DiagnosticServerCancellationData) _then) = _$DiagnosticServerCancellationDataCopyWithImpl;
@useResult
$Res call({
 bool retriggerRequest
});




}
/// @nodoc
class _$DiagnosticServerCancellationDataCopyWithImpl<$Res>
    implements $DiagnosticServerCancellationDataCopyWith<$Res> {
  _$DiagnosticServerCancellationDataCopyWithImpl(this._self, this._then);

  final DiagnosticServerCancellationData _self;
  final $Res Function(DiagnosticServerCancellationData) _then;

/// Create a copy of DiagnosticServerCancellationData
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? retriggerRequest = null,}) {
  return _then(_self.copyWith(
retriggerRequest: null == retriggerRequest ? _self.retriggerRequest : retriggerRequest // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DiagnosticServerCancellationData implements DiagnosticServerCancellationData {
  const _DiagnosticServerCancellationData({required this.retriggerRequest});
  factory _DiagnosticServerCancellationData.fromJson(Map<String, dynamic> json) => _$DiagnosticServerCancellationDataFromJson(json);

@override final  bool retriggerRequest;

/// Create a copy of DiagnosticServerCancellationData
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DiagnosticServerCancellationDataCopyWith<_DiagnosticServerCancellationData> get copyWith => __$DiagnosticServerCancellationDataCopyWithImpl<_DiagnosticServerCancellationData>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DiagnosticServerCancellationDataToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DiagnosticServerCancellationData&&(identical(other.retriggerRequest, retriggerRequest) || other.retriggerRequest == retriggerRequest));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,retriggerRequest);

@override
String toString() {
  return 'DiagnosticServerCancellationData(retriggerRequest: $retriggerRequest)';
}


}

/// @nodoc
abstract mixin class _$DiagnosticServerCancellationDataCopyWith<$Res> implements $DiagnosticServerCancellationDataCopyWith<$Res> {
  factory _$DiagnosticServerCancellationDataCopyWith(_DiagnosticServerCancellationData value, $Res Function(_DiagnosticServerCancellationData) _then) = __$DiagnosticServerCancellationDataCopyWithImpl;
@override @useResult
$Res call({
 bool retriggerRequest
});




}
/// @nodoc
class __$DiagnosticServerCancellationDataCopyWithImpl<$Res>
    implements _$DiagnosticServerCancellationDataCopyWith<$Res> {
  __$DiagnosticServerCancellationDataCopyWithImpl(this._self, this._then);

  final _DiagnosticServerCancellationData _self;
  final $Res Function(_DiagnosticServerCancellationData) _then;

/// Create a copy of DiagnosticServerCancellationData
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? retriggerRequest = null,}) {
  return _then(_DiagnosticServerCancellationData(
retriggerRequest: null == retriggerRequest ? _self.retriggerRequest : retriggerRequest // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}


}


/// @nodoc
mixin _$DiagnosticRegistrationOptions {

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
 Sealed14 get documentSelector;/// The id used to register the request. The id can be used to deregister
/// the request again. See also Registration#id.
 String? get id;/// An optional identifier under which the diagnostics are managed by the
/// client.
 String? get identifier;/// Whether the language has inter file dependencies meaning that editing
/// code in one file can result in a different diagnostic set in another
/// file. Inter file dependencies are common for most programming languages
/// and typically uncommon for linters.
 bool get interFileDependencies;/// The server provides support for workspace diagnostics as well.
 bool get workspaceDiagnostics;
/// Create a copy of DiagnosticRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DiagnosticRegistrationOptionsCopyWith<DiagnosticRegistrationOptions> get copyWith => _$DiagnosticRegistrationOptionsCopyWithImpl<DiagnosticRegistrationOptions>(this as DiagnosticRegistrationOptions, _$identity);

  /// Serializes this DiagnosticRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DiagnosticRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.id, id) || other.id == id)&&(identical(other.identifier, identifier) || other.identifier == identifier)&&(identical(other.interFileDependencies, interFileDependencies) || other.interFileDependencies == interFileDependencies)&&(identical(other.workspaceDiagnostics, workspaceDiagnostics) || other.workspaceDiagnostics == workspaceDiagnostics));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,id,identifier,interFileDependencies,workspaceDiagnostics);

@override
String toString() {
  return 'DiagnosticRegistrationOptions(documentSelector: $documentSelector, id: $id, identifier: $identifier, interFileDependencies: $interFileDependencies, workspaceDiagnostics: $workspaceDiagnostics)';
}


}

/// @nodoc
abstract mixin class $DiagnosticRegistrationOptionsCopyWith<$Res>  {
  factory $DiagnosticRegistrationOptionsCopyWith(DiagnosticRegistrationOptions value, $Res Function(DiagnosticRegistrationOptions) _then) = _$DiagnosticRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 Sealed14 documentSelector, String? id, String? identifier, bool interFileDependencies, bool workspaceDiagnostics
});




}
/// @nodoc
class _$DiagnosticRegistrationOptionsCopyWithImpl<$Res>
    implements $DiagnosticRegistrationOptionsCopyWith<$Res> {
  _$DiagnosticRegistrationOptionsCopyWithImpl(this._self, this._then);

  final DiagnosticRegistrationOptions _self;
  final $Res Function(DiagnosticRegistrationOptions) _then;

/// Create a copy of DiagnosticRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = null,Object? id = freezed,Object? identifier = freezed,Object? interFileDependencies = null,Object? workspaceDiagnostics = null,}) {
  return _then(_self.copyWith(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,identifier: freezed == identifier ? _self.identifier : identifier // ignore: cast_nullable_to_non_nullable
as String?,interFileDependencies: null == interFileDependencies ? _self.interFileDependencies : interFileDependencies // ignore: cast_nullable_to_non_nullable
as bool,workspaceDiagnostics: null == workspaceDiagnostics ? _self.workspaceDiagnostics : workspaceDiagnostics // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DiagnosticRegistrationOptions implements DiagnosticRegistrationOptions {
  const _DiagnosticRegistrationOptions({required this.documentSelector, this.id, this.identifier, required this.interFileDependencies, required this.workspaceDiagnostics});
  factory _DiagnosticRegistrationOptions.fromJson(Map<String, dynamic> json) => _$DiagnosticRegistrationOptionsFromJson(json);

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
@override final  Sealed14 documentSelector;
/// The id used to register the request. The id can be used to deregister
/// the request again. See also Registration#id.
@override final  String? id;
/// An optional identifier under which the diagnostics are managed by the
/// client.
@override final  String? identifier;
/// Whether the language has inter file dependencies meaning that editing
/// code in one file can result in a different diagnostic set in another
/// file. Inter file dependencies are common for most programming languages
/// and typically uncommon for linters.
@override final  bool interFileDependencies;
/// The server provides support for workspace diagnostics as well.
@override final  bool workspaceDiagnostics;

/// Create a copy of DiagnosticRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DiagnosticRegistrationOptionsCopyWith<_DiagnosticRegistrationOptions> get copyWith => __$DiagnosticRegistrationOptionsCopyWithImpl<_DiagnosticRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DiagnosticRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DiagnosticRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.id, id) || other.id == id)&&(identical(other.identifier, identifier) || other.identifier == identifier)&&(identical(other.interFileDependencies, interFileDependencies) || other.interFileDependencies == interFileDependencies)&&(identical(other.workspaceDiagnostics, workspaceDiagnostics) || other.workspaceDiagnostics == workspaceDiagnostics));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,id,identifier,interFileDependencies,workspaceDiagnostics);

@override
String toString() {
  return 'DiagnosticRegistrationOptions(documentSelector: $documentSelector, id: $id, identifier: $identifier, interFileDependencies: $interFileDependencies, workspaceDiagnostics: $workspaceDiagnostics)';
}


}

/// @nodoc
abstract mixin class _$DiagnosticRegistrationOptionsCopyWith<$Res> implements $DiagnosticRegistrationOptionsCopyWith<$Res> {
  factory _$DiagnosticRegistrationOptionsCopyWith(_DiagnosticRegistrationOptions value, $Res Function(_DiagnosticRegistrationOptions) _then) = __$DiagnosticRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 Sealed14 documentSelector, String? id, String? identifier, bool interFileDependencies, bool workspaceDiagnostics
});




}
/// @nodoc
class __$DiagnosticRegistrationOptionsCopyWithImpl<$Res>
    implements _$DiagnosticRegistrationOptionsCopyWith<$Res> {
  __$DiagnosticRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _DiagnosticRegistrationOptions _self;
  final $Res Function(_DiagnosticRegistrationOptions) _then;

/// Create a copy of DiagnosticRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = null,Object? id = freezed,Object? identifier = freezed,Object? interFileDependencies = null,Object? workspaceDiagnostics = null,}) {
  return _then(_DiagnosticRegistrationOptions(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,identifier: freezed == identifier ? _self.identifier : identifier // ignore: cast_nullable_to_non_nullable
as String?,interFileDependencies: null == interFileDependencies ? _self.interFileDependencies : interFileDependencies // ignore: cast_nullable_to_non_nullable
as bool,workspaceDiagnostics: null == workspaceDiagnostics ? _self.workspaceDiagnostics : workspaceDiagnostics // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}


}


/// @nodoc
mixin _$WorkspaceDiagnosticParams {

/// The additional identifier provided during registration.
 String? get identifier;/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
 ProgressToken? get partialResultToken;/// The currently known diagnostic reports with their previous result ids.
 List<PreviousResultId> get previousResultIds;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of WorkspaceDiagnosticParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkspaceDiagnosticParamsCopyWith<WorkspaceDiagnosticParams> get copyWith => _$WorkspaceDiagnosticParamsCopyWithImpl<WorkspaceDiagnosticParams>(this as WorkspaceDiagnosticParams, _$identity);

  /// Serializes this WorkspaceDiagnosticParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkspaceDiagnosticParams&&(identical(other.identifier, identifier) || other.identifier == identifier)&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&const DeepCollectionEquality().equals(other.previousResultIds, previousResultIds)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,identifier,partialResultToken,const DeepCollectionEquality().hash(previousResultIds),workDoneToken);

@override
String toString() {
  return 'WorkspaceDiagnosticParams(identifier: $identifier, partialResultToken: $partialResultToken, previousResultIds: $previousResultIds, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $WorkspaceDiagnosticParamsCopyWith<$Res>  {
  factory $WorkspaceDiagnosticParamsCopyWith(WorkspaceDiagnosticParams value, $Res Function(WorkspaceDiagnosticParams) _then) = _$WorkspaceDiagnosticParamsCopyWithImpl;
@useResult
$Res call({
 String? identifier, ProgressToken? partialResultToken, List<PreviousResultId> previousResultIds, ProgressToken? workDoneToken
});




}
/// @nodoc
class _$WorkspaceDiagnosticParamsCopyWithImpl<$Res>
    implements $WorkspaceDiagnosticParamsCopyWith<$Res> {
  _$WorkspaceDiagnosticParamsCopyWithImpl(this._self, this._then);

  final WorkspaceDiagnosticParams _self;
  final $Res Function(WorkspaceDiagnosticParams) _then;

/// Create a copy of WorkspaceDiagnosticParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? identifier = freezed,Object? partialResultToken = freezed,Object? previousResultIds = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
identifier: freezed == identifier ? _self.identifier : identifier // ignore: cast_nullable_to_non_nullable
as String?,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,previousResultIds: null == previousResultIds ? _self.previousResultIds : previousResultIds // ignore: cast_nullable_to_non_nullable
as List<PreviousResultId>,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _WorkspaceDiagnosticParams implements WorkspaceDiagnosticParams {
  const _WorkspaceDiagnosticParams({this.identifier, this.partialResultToken, required final  List<PreviousResultId> previousResultIds, this.workDoneToken}): _previousResultIds = previousResultIds;
  factory _WorkspaceDiagnosticParams.fromJson(Map<String, dynamic> json) => _$WorkspaceDiagnosticParamsFromJson(json);

/// The additional identifier provided during registration.
@override final  String? identifier;
/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
@override final  ProgressToken? partialResultToken;
/// The currently known diagnostic reports with their previous result ids.
 final  List<PreviousResultId> _previousResultIds;
/// The currently known diagnostic reports with their previous result ids.
@override List<PreviousResultId> get previousResultIds {
  if (_previousResultIds is EqualUnmodifiableListView) return _previousResultIds;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_previousResultIds);
}

/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of WorkspaceDiagnosticParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkspaceDiagnosticParamsCopyWith<_WorkspaceDiagnosticParams> get copyWith => __$WorkspaceDiagnosticParamsCopyWithImpl<_WorkspaceDiagnosticParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkspaceDiagnosticParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkspaceDiagnosticParams&&(identical(other.identifier, identifier) || other.identifier == identifier)&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&const DeepCollectionEquality().equals(other._previousResultIds, _previousResultIds)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,identifier,partialResultToken,const DeepCollectionEquality().hash(_previousResultIds),workDoneToken);

@override
String toString() {
  return 'WorkspaceDiagnosticParams(identifier: $identifier, partialResultToken: $partialResultToken, previousResultIds: $previousResultIds, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$WorkspaceDiagnosticParamsCopyWith<$Res> implements $WorkspaceDiagnosticParamsCopyWith<$Res> {
  factory _$WorkspaceDiagnosticParamsCopyWith(_WorkspaceDiagnosticParams value, $Res Function(_WorkspaceDiagnosticParams) _then) = __$WorkspaceDiagnosticParamsCopyWithImpl;
@override @useResult
$Res call({
 String? identifier, ProgressToken? partialResultToken, List<PreviousResultId> previousResultIds, ProgressToken? workDoneToken
});




}
/// @nodoc
class __$WorkspaceDiagnosticParamsCopyWithImpl<$Res>
    implements _$WorkspaceDiagnosticParamsCopyWith<$Res> {
  __$WorkspaceDiagnosticParamsCopyWithImpl(this._self, this._then);

  final _WorkspaceDiagnosticParams _self;
  final $Res Function(_WorkspaceDiagnosticParams) _then;

/// Create a copy of WorkspaceDiagnosticParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? identifier = freezed,Object? partialResultToken = freezed,Object? previousResultIds = null,Object? workDoneToken = freezed,}) {
  return _then(_WorkspaceDiagnosticParams(
identifier: freezed == identifier ? _self.identifier : identifier // ignore: cast_nullable_to_non_nullable
as String?,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,previousResultIds: null == previousResultIds ? _self._previousResultIds : previousResultIds // ignore: cast_nullable_to_non_nullable
as List<PreviousResultId>,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}


}


/// @nodoc
mixin _$WorkspaceDiagnosticReport {

 List<WorkspaceDocumentDiagnosticReport> get items;
/// Create a copy of WorkspaceDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkspaceDiagnosticReportCopyWith<WorkspaceDiagnosticReport> get copyWith => _$WorkspaceDiagnosticReportCopyWithImpl<WorkspaceDiagnosticReport>(this as WorkspaceDiagnosticReport, _$identity);

  /// Serializes this WorkspaceDiagnosticReport to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkspaceDiagnosticReport&&const DeepCollectionEquality().equals(other.items, items));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(items));

@override
String toString() {
  return 'WorkspaceDiagnosticReport(items: $items)';
}


}

/// @nodoc
abstract mixin class $WorkspaceDiagnosticReportCopyWith<$Res>  {
  factory $WorkspaceDiagnosticReportCopyWith(WorkspaceDiagnosticReport value, $Res Function(WorkspaceDiagnosticReport) _then) = _$WorkspaceDiagnosticReportCopyWithImpl;
@useResult
$Res call({
 List<WorkspaceDocumentDiagnosticReport> items
});




}
/// @nodoc
class _$WorkspaceDiagnosticReportCopyWithImpl<$Res>
    implements $WorkspaceDiagnosticReportCopyWith<$Res> {
  _$WorkspaceDiagnosticReportCopyWithImpl(this._self, this._then);

  final WorkspaceDiagnosticReport _self;
  final $Res Function(WorkspaceDiagnosticReport) _then;

/// Create a copy of WorkspaceDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? items = null,}) {
  return _then(_self.copyWith(
items: null == items ? _self.items : items // ignore: cast_nullable_to_non_nullable
as List<WorkspaceDocumentDiagnosticReport>,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _WorkspaceDiagnosticReport implements WorkspaceDiagnosticReport {
  const _WorkspaceDiagnosticReport({required final  List<WorkspaceDocumentDiagnosticReport> items}): _items = items;
  factory _WorkspaceDiagnosticReport.fromJson(Map<String, dynamic> json) => _$WorkspaceDiagnosticReportFromJson(json);

 final  List<WorkspaceDocumentDiagnosticReport> _items;
@override List<WorkspaceDocumentDiagnosticReport> get items {
  if (_items is EqualUnmodifiableListView) return _items;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_items);
}


/// Create a copy of WorkspaceDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkspaceDiagnosticReportCopyWith<_WorkspaceDiagnosticReport> get copyWith => __$WorkspaceDiagnosticReportCopyWithImpl<_WorkspaceDiagnosticReport>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkspaceDiagnosticReportToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkspaceDiagnosticReport&&const DeepCollectionEquality().equals(other._items, _items));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_items));

@override
String toString() {
  return 'WorkspaceDiagnosticReport(items: $items)';
}


}

/// @nodoc
abstract mixin class _$WorkspaceDiagnosticReportCopyWith<$Res> implements $WorkspaceDiagnosticReportCopyWith<$Res> {
  factory _$WorkspaceDiagnosticReportCopyWith(_WorkspaceDiagnosticReport value, $Res Function(_WorkspaceDiagnosticReport) _then) = __$WorkspaceDiagnosticReportCopyWithImpl;
@override @useResult
$Res call({
 List<WorkspaceDocumentDiagnosticReport> items
});




}
/// @nodoc
class __$WorkspaceDiagnosticReportCopyWithImpl<$Res>
    implements _$WorkspaceDiagnosticReportCopyWith<$Res> {
  __$WorkspaceDiagnosticReportCopyWithImpl(this._self, this._then);

  final _WorkspaceDiagnosticReport _self;
  final $Res Function(_WorkspaceDiagnosticReport) _then;

/// Create a copy of WorkspaceDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? items = null,}) {
  return _then(_WorkspaceDiagnosticReport(
items: null == items ? _self._items : items // ignore: cast_nullable_to_non_nullable
as List<WorkspaceDocumentDiagnosticReport>,
  ));
}


}


/// @nodoc
mixin _$WorkspaceDiagnosticReportPartialResult {

 List<WorkspaceDocumentDiagnosticReport> get items;
/// Create a copy of WorkspaceDiagnosticReportPartialResult
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkspaceDiagnosticReportPartialResultCopyWith<WorkspaceDiagnosticReportPartialResult> get copyWith => _$WorkspaceDiagnosticReportPartialResultCopyWithImpl<WorkspaceDiagnosticReportPartialResult>(this as WorkspaceDiagnosticReportPartialResult, _$identity);

  /// Serializes this WorkspaceDiagnosticReportPartialResult to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkspaceDiagnosticReportPartialResult&&const DeepCollectionEquality().equals(other.items, items));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(items));

@override
String toString() {
  return 'WorkspaceDiagnosticReportPartialResult(items: $items)';
}


}

/// @nodoc
abstract mixin class $WorkspaceDiagnosticReportPartialResultCopyWith<$Res>  {
  factory $WorkspaceDiagnosticReportPartialResultCopyWith(WorkspaceDiagnosticReportPartialResult value, $Res Function(WorkspaceDiagnosticReportPartialResult) _then) = _$WorkspaceDiagnosticReportPartialResultCopyWithImpl;
@useResult
$Res call({
 List<WorkspaceDocumentDiagnosticReport> items
});




}
/// @nodoc
class _$WorkspaceDiagnosticReportPartialResultCopyWithImpl<$Res>
    implements $WorkspaceDiagnosticReportPartialResultCopyWith<$Res> {
  _$WorkspaceDiagnosticReportPartialResultCopyWithImpl(this._self, this._then);

  final WorkspaceDiagnosticReportPartialResult _self;
  final $Res Function(WorkspaceDiagnosticReportPartialResult) _then;

/// Create a copy of WorkspaceDiagnosticReportPartialResult
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? items = null,}) {
  return _then(_self.copyWith(
items: null == items ? _self.items : items // ignore: cast_nullable_to_non_nullable
as List<WorkspaceDocumentDiagnosticReport>,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _WorkspaceDiagnosticReportPartialResult implements WorkspaceDiagnosticReportPartialResult {
  const _WorkspaceDiagnosticReportPartialResult({required final  List<WorkspaceDocumentDiagnosticReport> items}): _items = items;
  factory _WorkspaceDiagnosticReportPartialResult.fromJson(Map<String, dynamic> json) => _$WorkspaceDiagnosticReportPartialResultFromJson(json);

 final  List<WorkspaceDocumentDiagnosticReport> _items;
@override List<WorkspaceDocumentDiagnosticReport> get items {
  if (_items is EqualUnmodifiableListView) return _items;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_items);
}


/// Create a copy of WorkspaceDiagnosticReportPartialResult
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkspaceDiagnosticReportPartialResultCopyWith<_WorkspaceDiagnosticReportPartialResult> get copyWith => __$WorkspaceDiagnosticReportPartialResultCopyWithImpl<_WorkspaceDiagnosticReportPartialResult>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkspaceDiagnosticReportPartialResultToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkspaceDiagnosticReportPartialResult&&const DeepCollectionEquality().equals(other._items, _items));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_items));

@override
String toString() {
  return 'WorkspaceDiagnosticReportPartialResult(items: $items)';
}


}

/// @nodoc
abstract mixin class _$WorkspaceDiagnosticReportPartialResultCopyWith<$Res> implements $WorkspaceDiagnosticReportPartialResultCopyWith<$Res> {
  factory _$WorkspaceDiagnosticReportPartialResultCopyWith(_WorkspaceDiagnosticReportPartialResult value, $Res Function(_WorkspaceDiagnosticReportPartialResult) _then) = __$WorkspaceDiagnosticReportPartialResultCopyWithImpl;
@override @useResult
$Res call({
 List<WorkspaceDocumentDiagnosticReport> items
});




}
/// @nodoc
class __$WorkspaceDiagnosticReportPartialResultCopyWithImpl<$Res>
    implements _$WorkspaceDiagnosticReportPartialResultCopyWith<$Res> {
  __$WorkspaceDiagnosticReportPartialResultCopyWithImpl(this._self, this._then);

  final _WorkspaceDiagnosticReportPartialResult _self;
  final $Res Function(_WorkspaceDiagnosticReportPartialResult) _then;

/// Create a copy of WorkspaceDiagnosticReportPartialResult
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? items = null,}) {
  return _then(_WorkspaceDiagnosticReportPartialResult(
items: null == items ? _self._items : items // ignore: cast_nullable_to_non_nullable
as List<WorkspaceDocumentDiagnosticReport>,
  ));
}


}


/// @nodoc
mixin _$DidOpenNotebookDocumentParams {

/// The text documents that represent the content of a notebook cell.
 List<TextDocumentItem> get cellTextDocuments;/// The notebook document that got opened.
 NotebookDocument get notebookDocument;
/// Create a copy of DidOpenNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DidOpenNotebookDocumentParamsCopyWith<DidOpenNotebookDocumentParams> get copyWith => _$DidOpenNotebookDocumentParamsCopyWithImpl<DidOpenNotebookDocumentParams>(this as DidOpenNotebookDocumentParams, _$identity);

  /// Serializes this DidOpenNotebookDocumentParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DidOpenNotebookDocumentParams&&const DeepCollectionEquality().equals(other.cellTextDocuments, cellTextDocuments)&&(identical(other.notebookDocument, notebookDocument) || other.notebookDocument == notebookDocument));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(cellTextDocuments),notebookDocument);

@override
String toString() {
  return 'DidOpenNotebookDocumentParams(cellTextDocuments: $cellTextDocuments, notebookDocument: $notebookDocument)';
}


}

/// @nodoc
abstract mixin class $DidOpenNotebookDocumentParamsCopyWith<$Res>  {
  factory $DidOpenNotebookDocumentParamsCopyWith(DidOpenNotebookDocumentParams value, $Res Function(DidOpenNotebookDocumentParams) _then) = _$DidOpenNotebookDocumentParamsCopyWithImpl;
@useResult
$Res call({
 List<TextDocumentItem> cellTextDocuments, NotebookDocument notebookDocument
});


$NotebookDocumentCopyWith<$Res> get notebookDocument;

}
/// @nodoc
class _$DidOpenNotebookDocumentParamsCopyWithImpl<$Res>
    implements $DidOpenNotebookDocumentParamsCopyWith<$Res> {
  _$DidOpenNotebookDocumentParamsCopyWithImpl(this._self, this._then);

  final DidOpenNotebookDocumentParams _self;
  final $Res Function(DidOpenNotebookDocumentParams) _then;

/// Create a copy of DidOpenNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? cellTextDocuments = null,Object? notebookDocument = null,}) {
  return _then(_self.copyWith(
cellTextDocuments: null == cellTextDocuments ? _self.cellTextDocuments : cellTextDocuments // ignore: cast_nullable_to_non_nullable
as List<TextDocumentItem>,notebookDocument: null == notebookDocument ? _self.notebookDocument : notebookDocument // ignore: cast_nullable_to_non_nullable
as NotebookDocument,
  ));
}
/// Create a copy of DidOpenNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$NotebookDocumentCopyWith<$Res> get notebookDocument {
  
  return $NotebookDocumentCopyWith<$Res>(_self.notebookDocument, (value) {
    return _then(_self.copyWith(notebookDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _DidOpenNotebookDocumentParams implements DidOpenNotebookDocumentParams {
  const _DidOpenNotebookDocumentParams({required final  List<TextDocumentItem> cellTextDocuments, required this.notebookDocument}): _cellTextDocuments = cellTextDocuments;
  factory _DidOpenNotebookDocumentParams.fromJson(Map<String, dynamic> json) => _$DidOpenNotebookDocumentParamsFromJson(json);

/// The text documents that represent the content of a notebook cell.
 final  List<TextDocumentItem> _cellTextDocuments;
/// The text documents that represent the content of a notebook cell.
@override List<TextDocumentItem> get cellTextDocuments {
  if (_cellTextDocuments is EqualUnmodifiableListView) return _cellTextDocuments;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_cellTextDocuments);
}

/// The notebook document that got opened.
@override final  NotebookDocument notebookDocument;

/// Create a copy of DidOpenNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DidOpenNotebookDocumentParamsCopyWith<_DidOpenNotebookDocumentParams> get copyWith => __$DidOpenNotebookDocumentParamsCopyWithImpl<_DidOpenNotebookDocumentParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DidOpenNotebookDocumentParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DidOpenNotebookDocumentParams&&const DeepCollectionEquality().equals(other._cellTextDocuments, _cellTextDocuments)&&(identical(other.notebookDocument, notebookDocument) || other.notebookDocument == notebookDocument));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_cellTextDocuments),notebookDocument);

@override
String toString() {
  return 'DidOpenNotebookDocumentParams(cellTextDocuments: $cellTextDocuments, notebookDocument: $notebookDocument)';
}


}

/// @nodoc
abstract mixin class _$DidOpenNotebookDocumentParamsCopyWith<$Res> implements $DidOpenNotebookDocumentParamsCopyWith<$Res> {
  factory _$DidOpenNotebookDocumentParamsCopyWith(_DidOpenNotebookDocumentParams value, $Res Function(_DidOpenNotebookDocumentParams) _then) = __$DidOpenNotebookDocumentParamsCopyWithImpl;
@override @useResult
$Res call({
 List<TextDocumentItem> cellTextDocuments, NotebookDocument notebookDocument
});


@override $NotebookDocumentCopyWith<$Res> get notebookDocument;

}
/// @nodoc
class __$DidOpenNotebookDocumentParamsCopyWithImpl<$Res>
    implements _$DidOpenNotebookDocumentParamsCopyWith<$Res> {
  __$DidOpenNotebookDocumentParamsCopyWithImpl(this._self, this._then);

  final _DidOpenNotebookDocumentParams _self;
  final $Res Function(_DidOpenNotebookDocumentParams) _then;

/// Create a copy of DidOpenNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? cellTextDocuments = null,Object? notebookDocument = null,}) {
  return _then(_DidOpenNotebookDocumentParams(
cellTextDocuments: null == cellTextDocuments ? _self._cellTextDocuments : cellTextDocuments // ignore: cast_nullable_to_non_nullable
as List<TextDocumentItem>,notebookDocument: null == notebookDocument ? _self.notebookDocument : notebookDocument // ignore: cast_nullable_to_non_nullable
as NotebookDocument,
  ));
}

/// Create a copy of DidOpenNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$NotebookDocumentCopyWith<$Res> get notebookDocument {
  
  return $NotebookDocumentCopyWith<$Res>(_self.notebookDocument, (value) {
    return _then(_self.copyWith(notebookDocument: value));
  });
}
}


/// @nodoc
mixin _$DidChangeNotebookDocumentParams {

/// The actual changes to the notebook document.
/// The changes describe single state changes to the notebook document. So
/// if there are two changes c1 (at array index 0) and c2 (at array index
/// 1) for a notebook in state S then c1 moves the notebook from S to S'
/// and c2 from S' to S''. So c1 is computed on the state S and c2 is
/// computed on the state S'.
/// To mirror the content of a notebook using change events use the
/// following approach: - start with the same initial content - apply the
/// 'notebookDocument/didChange' notifications in the order you receive
/// them. - apply the `NotebookChangeEvent`s in a single notification in
/// the order you receive them.
 NotebookDocumentChangeEvent get change;/// The notebook document that did change. The version number points to the
/// version after all provided changes have been applied. If only the text
/// document content of a cell changes the notebook version doesn't
/// necessarily have to change.
 VersionedNotebookDocumentIdentifier get notebookDocument;
/// Create a copy of DidChangeNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DidChangeNotebookDocumentParamsCopyWith<DidChangeNotebookDocumentParams> get copyWith => _$DidChangeNotebookDocumentParamsCopyWithImpl<DidChangeNotebookDocumentParams>(this as DidChangeNotebookDocumentParams, _$identity);

  /// Serializes this DidChangeNotebookDocumentParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DidChangeNotebookDocumentParams&&(identical(other.change, change) || other.change == change)&&(identical(other.notebookDocument, notebookDocument) || other.notebookDocument == notebookDocument));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,change,notebookDocument);

@override
String toString() {
  return 'DidChangeNotebookDocumentParams(change: $change, notebookDocument: $notebookDocument)';
}


}

/// @nodoc
abstract mixin class $DidChangeNotebookDocumentParamsCopyWith<$Res>  {
  factory $DidChangeNotebookDocumentParamsCopyWith(DidChangeNotebookDocumentParams value, $Res Function(DidChangeNotebookDocumentParams) _then) = _$DidChangeNotebookDocumentParamsCopyWithImpl;
@useResult
$Res call({
 NotebookDocumentChangeEvent change, VersionedNotebookDocumentIdentifier notebookDocument
});


$NotebookDocumentChangeEventCopyWith<$Res> get change;$VersionedNotebookDocumentIdentifierCopyWith<$Res> get notebookDocument;

}
/// @nodoc
class _$DidChangeNotebookDocumentParamsCopyWithImpl<$Res>
    implements $DidChangeNotebookDocumentParamsCopyWith<$Res> {
  _$DidChangeNotebookDocumentParamsCopyWithImpl(this._self, this._then);

  final DidChangeNotebookDocumentParams _self;
  final $Res Function(DidChangeNotebookDocumentParams) _then;

/// Create a copy of DidChangeNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? change = null,Object? notebookDocument = null,}) {
  return _then(_self.copyWith(
change: null == change ? _self.change : change // ignore: cast_nullable_to_non_nullable
as NotebookDocumentChangeEvent,notebookDocument: null == notebookDocument ? _self.notebookDocument : notebookDocument // ignore: cast_nullable_to_non_nullable
as VersionedNotebookDocumentIdentifier,
  ));
}
/// Create a copy of DidChangeNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$NotebookDocumentChangeEventCopyWith<$Res> get change {
  
  return $NotebookDocumentChangeEventCopyWith<$Res>(_self.change, (value) {
    return _then(_self.copyWith(change: value));
  });
}/// Create a copy of DidChangeNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$VersionedNotebookDocumentIdentifierCopyWith<$Res> get notebookDocument {
  
  return $VersionedNotebookDocumentIdentifierCopyWith<$Res>(_self.notebookDocument, (value) {
    return _then(_self.copyWith(notebookDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _DidChangeNotebookDocumentParams implements DidChangeNotebookDocumentParams {
  const _DidChangeNotebookDocumentParams({required this.change, required this.notebookDocument});
  factory _DidChangeNotebookDocumentParams.fromJson(Map<String, dynamic> json) => _$DidChangeNotebookDocumentParamsFromJson(json);

/// The actual changes to the notebook document.
/// The changes describe single state changes to the notebook document. So
/// if there are two changes c1 (at array index 0) and c2 (at array index
/// 1) for a notebook in state S then c1 moves the notebook from S to S'
/// and c2 from S' to S''. So c1 is computed on the state S and c2 is
/// computed on the state S'.
/// To mirror the content of a notebook using change events use the
/// following approach: - start with the same initial content - apply the
/// 'notebookDocument/didChange' notifications in the order you receive
/// them. - apply the `NotebookChangeEvent`s in a single notification in
/// the order you receive them.
@override final  NotebookDocumentChangeEvent change;
/// The notebook document that did change. The version number points to the
/// version after all provided changes have been applied. If only the text
/// document content of a cell changes the notebook version doesn't
/// necessarily have to change.
@override final  VersionedNotebookDocumentIdentifier notebookDocument;

/// Create a copy of DidChangeNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DidChangeNotebookDocumentParamsCopyWith<_DidChangeNotebookDocumentParams> get copyWith => __$DidChangeNotebookDocumentParamsCopyWithImpl<_DidChangeNotebookDocumentParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DidChangeNotebookDocumentParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DidChangeNotebookDocumentParams&&(identical(other.change, change) || other.change == change)&&(identical(other.notebookDocument, notebookDocument) || other.notebookDocument == notebookDocument));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,change,notebookDocument);

@override
String toString() {
  return 'DidChangeNotebookDocumentParams(change: $change, notebookDocument: $notebookDocument)';
}


}

/// @nodoc
abstract mixin class _$DidChangeNotebookDocumentParamsCopyWith<$Res> implements $DidChangeNotebookDocumentParamsCopyWith<$Res> {
  factory _$DidChangeNotebookDocumentParamsCopyWith(_DidChangeNotebookDocumentParams value, $Res Function(_DidChangeNotebookDocumentParams) _then) = __$DidChangeNotebookDocumentParamsCopyWithImpl;
@override @useResult
$Res call({
 NotebookDocumentChangeEvent change, VersionedNotebookDocumentIdentifier notebookDocument
});


@override $NotebookDocumentChangeEventCopyWith<$Res> get change;@override $VersionedNotebookDocumentIdentifierCopyWith<$Res> get notebookDocument;

}
/// @nodoc
class __$DidChangeNotebookDocumentParamsCopyWithImpl<$Res>
    implements _$DidChangeNotebookDocumentParamsCopyWith<$Res> {
  __$DidChangeNotebookDocumentParamsCopyWithImpl(this._self, this._then);

  final _DidChangeNotebookDocumentParams _self;
  final $Res Function(_DidChangeNotebookDocumentParams) _then;

/// Create a copy of DidChangeNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? change = null,Object? notebookDocument = null,}) {
  return _then(_DidChangeNotebookDocumentParams(
change: null == change ? _self.change : change // ignore: cast_nullable_to_non_nullable
as NotebookDocumentChangeEvent,notebookDocument: null == notebookDocument ? _self.notebookDocument : notebookDocument // ignore: cast_nullable_to_non_nullable
as VersionedNotebookDocumentIdentifier,
  ));
}

/// Create a copy of DidChangeNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$NotebookDocumentChangeEventCopyWith<$Res> get change {
  
  return $NotebookDocumentChangeEventCopyWith<$Res>(_self.change, (value) {
    return _then(_self.copyWith(change: value));
  });
}/// Create a copy of DidChangeNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$VersionedNotebookDocumentIdentifierCopyWith<$Res> get notebookDocument {
  
  return $VersionedNotebookDocumentIdentifierCopyWith<$Res>(_self.notebookDocument, (value) {
    return _then(_self.copyWith(notebookDocument: value));
  });
}
}


/// @nodoc
mixin _$DidSaveNotebookDocumentParams {

/// The notebook document that got saved.
 NotebookDocumentIdentifier get notebookDocument;
/// Create a copy of DidSaveNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DidSaveNotebookDocumentParamsCopyWith<DidSaveNotebookDocumentParams> get copyWith => _$DidSaveNotebookDocumentParamsCopyWithImpl<DidSaveNotebookDocumentParams>(this as DidSaveNotebookDocumentParams, _$identity);

  /// Serializes this DidSaveNotebookDocumentParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DidSaveNotebookDocumentParams&&(identical(other.notebookDocument, notebookDocument) || other.notebookDocument == notebookDocument));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,notebookDocument);

@override
String toString() {
  return 'DidSaveNotebookDocumentParams(notebookDocument: $notebookDocument)';
}


}

/// @nodoc
abstract mixin class $DidSaveNotebookDocumentParamsCopyWith<$Res>  {
  factory $DidSaveNotebookDocumentParamsCopyWith(DidSaveNotebookDocumentParams value, $Res Function(DidSaveNotebookDocumentParams) _then) = _$DidSaveNotebookDocumentParamsCopyWithImpl;
@useResult
$Res call({
 NotebookDocumentIdentifier notebookDocument
});


$NotebookDocumentIdentifierCopyWith<$Res> get notebookDocument;

}
/// @nodoc
class _$DidSaveNotebookDocumentParamsCopyWithImpl<$Res>
    implements $DidSaveNotebookDocumentParamsCopyWith<$Res> {
  _$DidSaveNotebookDocumentParamsCopyWithImpl(this._self, this._then);

  final DidSaveNotebookDocumentParams _self;
  final $Res Function(DidSaveNotebookDocumentParams) _then;

/// Create a copy of DidSaveNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? notebookDocument = null,}) {
  return _then(_self.copyWith(
notebookDocument: null == notebookDocument ? _self.notebookDocument : notebookDocument // ignore: cast_nullable_to_non_nullable
as NotebookDocumentIdentifier,
  ));
}
/// Create a copy of DidSaveNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$NotebookDocumentIdentifierCopyWith<$Res> get notebookDocument {
  
  return $NotebookDocumentIdentifierCopyWith<$Res>(_self.notebookDocument, (value) {
    return _then(_self.copyWith(notebookDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _DidSaveNotebookDocumentParams implements DidSaveNotebookDocumentParams {
  const _DidSaveNotebookDocumentParams({required this.notebookDocument});
  factory _DidSaveNotebookDocumentParams.fromJson(Map<String, dynamic> json) => _$DidSaveNotebookDocumentParamsFromJson(json);

/// The notebook document that got saved.
@override final  NotebookDocumentIdentifier notebookDocument;

/// Create a copy of DidSaveNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DidSaveNotebookDocumentParamsCopyWith<_DidSaveNotebookDocumentParams> get copyWith => __$DidSaveNotebookDocumentParamsCopyWithImpl<_DidSaveNotebookDocumentParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DidSaveNotebookDocumentParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DidSaveNotebookDocumentParams&&(identical(other.notebookDocument, notebookDocument) || other.notebookDocument == notebookDocument));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,notebookDocument);

@override
String toString() {
  return 'DidSaveNotebookDocumentParams(notebookDocument: $notebookDocument)';
}


}

/// @nodoc
abstract mixin class _$DidSaveNotebookDocumentParamsCopyWith<$Res> implements $DidSaveNotebookDocumentParamsCopyWith<$Res> {
  factory _$DidSaveNotebookDocumentParamsCopyWith(_DidSaveNotebookDocumentParams value, $Res Function(_DidSaveNotebookDocumentParams) _then) = __$DidSaveNotebookDocumentParamsCopyWithImpl;
@override @useResult
$Res call({
 NotebookDocumentIdentifier notebookDocument
});


@override $NotebookDocumentIdentifierCopyWith<$Res> get notebookDocument;

}
/// @nodoc
class __$DidSaveNotebookDocumentParamsCopyWithImpl<$Res>
    implements _$DidSaveNotebookDocumentParamsCopyWith<$Res> {
  __$DidSaveNotebookDocumentParamsCopyWithImpl(this._self, this._then);

  final _DidSaveNotebookDocumentParams _self;
  final $Res Function(_DidSaveNotebookDocumentParams) _then;

/// Create a copy of DidSaveNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? notebookDocument = null,}) {
  return _then(_DidSaveNotebookDocumentParams(
notebookDocument: null == notebookDocument ? _self.notebookDocument : notebookDocument // ignore: cast_nullable_to_non_nullable
as NotebookDocumentIdentifier,
  ));
}

/// Create a copy of DidSaveNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$NotebookDocumentIdentifierCopyWith<$Res> get notebookDocument {
  
  return $NotebookDocumentIdentifierCopyWith<$Res>(_self.notebookDocument, (value) {
    return _then(_self.copyWith(notebookDocument: value));
  });
}
}


/// @nodoc
mixin _$DidCloseNotebookDocumentParams {

/// The text documents that represent the content of a notebook cell that
/// got closed.
 List<TextDocumentIdentifier> get cellTextDocuments;/// The notebook document that got closed.
 NotebookDocumentIdentifier get notebookDocument;
/// Create a copy of DidCloseNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DidCloseNotebookDocumentParamsCopyWith<DidCloseNotebookDocumentParams> get copyWith => _$DidCloseNotebookDocumentParamsCopyWithImpl<DidCloseNotebookDocumentParams>(this as DidCloseNotebookDocumentParams, _$identity);

  /// Serializes this DidCloseNotebookDocumentParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DidCloseNotebookDocumentParams&&const DeepCollectionEquality().equals(other.cellTextDocuments, cellTextDocuments)&&(identical(other.notebookDocument, notebookDocument) || other.notebookDocument == notebookDocument));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(cellTextDocuments),notebookDocument);

@override
String toString() {
  return 'DidCloseNotebookDocumentParams(cellTextDocuments: $cellTextDocuments, notebookDocument: $notebookDocument)';
}


}

/// @nodoc
abstract mixin class $DidCloseNotebookDocumentParamsCopyWith<$Res>  {
  factory $DidCloseNotebookDocumentParamsCopyWith(DidCloseNotebookDocumentParams value, $Res Function(DidCloseNotebookDocumentParams) _then) = _$DidCloseNotebookDocumentParamsCopyWithImpl;
@useResult
$Res call({
 List<TextDocumentIdentifier> cellTextDocuments, NotebookDocumentIdentifier notebookDocument
});


$NotebookDocumentIdentifierCopyWith<$Res> get notebookDocument;

}
/// @nodoc
class _$DidCloseNotebookDocumentParamsCopyWithImpl<$Res>
    implements $DidCloseNotebookDocumentParamsCopyWith<$Res> {
  _$DidCloseNotebookDocumentParamsCopyWithImpl(this._self, this._then);

  final DidCloseNotebookDocumentParams _self;
  final $Res Function(DidCloseNotebookDocumentParams) _then;

/// Create a copy of DidCloseNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? cellTextDocuments = null,Object? notebookDocument = null,}) {
  return _then(_self.copyWith(
cellTextDocuments: null == cellTextDocuments ? _self.cellTextDocuments : cellTextDocuments // ignore: cast_nullable_to_non_nullable
as List<TextDocumentIdentifier>,notebookDocument: null == notebookDocument ? _self.notebookDocument : notebookDocument // ignore: cast_nullable_to_non_nullable
as NotebookDocumentIdentifier,
  ));
}
/// Create a copy of DidCloseNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$NotebookDocumentIdentifierCopyWith<$Res> get notebookDocument {
  
  return $NotebookDocumentIdentifierCopyWith<$Res>(_self.notebookDocument, (value) {
    return _then(_self.copyWith(notebookDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _DidCloseNotebookDocumentParams implements DidCloseNotebookDocumentParams {
  const _DidCloseNotebookDocumentParams({required final  List<TextDocumentIdentifier> cellTextDocuments, required this.notebookDocument}): _cellTextDocuments = cellTextDocuments;
  factory _DidCloseNotebookDocumentParams.fromJson(Map<String, dynamic> json) => _$DidCloseNotebookDocumentParamsFromJson(json);

/// The text documents that represent the content of a notebook cell that
/// got closed.
 final  List<TextDocumentIdentifier> _cellTextDocuments;
/// The text documents that represent the content of a notebook cell that
/// got closed.
@override List<TextDocumentIdentifier> get cellTextDocuments {
  if (_cellTextDocuments is EqualUnmodifiableListView) return _cellTextDocuments;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_cellTextDocuments);
}

/// The notebook document that got closed.
@override final  NotebookDocumentIdentifier notebookDocument;

/// Create a copy of DidCloseNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DidCloseNotebookDocumentParamsCopyWith<_DidCloseNotebookDocumentParams> get copyWith => __$DidCloseNotebookDocumentParamsCopyWithImpl<_DidCloseNotebookDocumentParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DidCloseNotebookDocumentParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DidCloseNotebookDocumentParams&&const DeepCollectionEquality().equals(other._cellTextDocuments, _cellTextDocuments)&&(identical(other.notebookDocument, notebookDocument) || other.notebookDocument == notebookDocument));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_cellTextDocuments),notebookDocument);

@override
String toString() {
  return 'DidCloseNotebookDocumentParams(cellTextDocuments: $cellTextDocuments, notebookDocument: $notebookDocument)';
}


}

/// @nodoc
abstract mixin class _$DidCloseNotebookDocumentParamsCopyWith<$Res> implements $DidCloseNotebookDocumentParamsCopyWith<$Res> {
  factory _$DidCloseNotebookDocumentParamsCopyWith(_DidCloseNotebookDocumentParams value, $Res Function(_DidCloseNotebookDocumentParams) _then) = __$DidCloseNotebookDocumentParamsCopyWithImpl;
@override @useResult
$Res call({
 List<TextDocumentIdentifier> cellTextDocuments, NotebookDocumentIdentifier notebookDocument
});


@override $NotebookDocumentIdentifierCopyWith<$Res> get notebookDocument;

}
/// @nodoc
class __$DidCloseNotebookDocumentParamsCopyWithImpl<$Res>
    implements _$DidCloseNotebookDocumentParamsCopyWith<$Res> {
  __$DidCloseNotebookDocumentParamsCopyWithImpl(this._self, this._then);

  final _DidCloseNotebookDocumentParams _self;
  final $Res Function(_DidCloseNotebookDocumentParams) _then;

/// Create a copy of DidCloseNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? cellTextDocuments = null,Object? notebookDocument = null,}) {
  return _then(_DidCloseNotebookDocumentParams(
cellTextDocuments: null == cellTextDocuments ? _self._cellTextDocuments : cellTextDocuments // ignore: cast_nullable_to_non_nullable
as List<TextDocumentIdentifier>,notebookDocument: null == notebookDocument ? _self.notebookDocument : notebookDocument // ignore: cast_nullable_to_non_nullable
as NotebookDocumentIdentifier,
  ));
}

/// Create a copy of DidCloseNotebookDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$NotebookDocumentIdentifierCopyWith<$Res> get notebookDocument {
  
  return $NotebookDocumentIdentifierCopyWith<$Res>(_self.notebookDocument, (value) {
    return _then(_self.copyWith(notebookDocument: value));
  });
}
}


/// @nodoc
mixin _$InlineCompletionParams {

/// Additional information about the context in which inline completions
/// were requested.
 InlineCompletionContext get context;/// The position inside the text document.
 Position get position;/// The text document.
 TextDocumentIdentifier get textDocument;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of InlineCompletionParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlineCompletionParamsCopyWith<InlineCompletionParams> get copyWith => _$InlineCompletionParamsCopyWithImpl<InlineCompletionParams>(this as InlineCompletionParams, _$identity);

  /// Serializes this InlineCompletionParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlineCompletionParams&&(identical(other.context, context) || other.context == context)&&(identical(other.position, position) || other.position == position)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,context,position,textDocument,workDoneToken);

@override
String toString() {
  return 'InlineCompletionParams(context: $context, position: $position, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $InlineCompletionParamsCopyWith<$Res>  {
  factory $InlineCompletionParamsCopyWith(InlineCompletionParams value, $Res Function(InlineCompletionParams) _then) = _$InlineCompletionParamsCopyWithImpl;
@useResult
$Res call({
 InlineCompletionContext context, Position position, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


$InlineCompletionContextCopyWith<$Res> get context;$PositionCopyWith<$Res> get position;$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$InlineCompletionParamsCopyWithImpl<$Res>
    implements $InlineCompletionParamsCopyWith<$Res> {
  _$InlineCompletionParamsCopyWithImpl(this._self, this._then);

  final InlineCompletionParams _self;
  final $Res Function(InlineCompletionParams) _then;

/// Create a copy of InlineCompletionParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? context = null,Object? position = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
context: null == context ? _self.context : context // ignore: cast_nullable_to_non_nullable
as InlineCompletionContext,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of InlineCompletionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$InlineCompletionContextCopyWith<$Res> get context {
  
  return $InlineCompletionContextCopyWith<$Res>(_self.context, (value) {
    return _then(_self.copyWith(context: value));
  });
}/// Create a copy of InlineCompletionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of InlineCompletionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _InlineCompletionParams implements InlineCompletionParams {
  const _InlineCompletionParams({required this.context, required this.position, required this.textDocument, this.workDoneToken});
  factory _InlineCompletionParams.fromJson(Map<String, dynamic> json) => _$InlineCompletionParamsFromJson(json);

/// Additional information about the context in which inline completions
/// were requested.
@override final  InlineCompletionContext context;
/// The position inside the text document.
@override final  Position position;
/// The text document.
@override final  TextDocumentIdentifier textDocument;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of InlineCompletionParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlineCompletionParamsCopyWith<_InlineCompletionParams> get copyWith => __$InlineCompletionParamsCopyWithImpl<_InlineCompletionParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlineCompletionParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlineCompletionParams&&(identical(other.context, context) || other.context == context)&&(identical(other.position, position) || other.position == position)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,context,position,textDocument,workDoneToken);

@override
String toString() {
  return 'InlineCompletionParams(context: $context, position: $position, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$InlineCompletionParamsCopyWith<$Res> implements $InlineCompletionParamsCopyWith<$Res> {
  factory _$InlineCompletionParamsCopyWith(_InlineCompletionParams value, $Res Function(_InlineCompletionParams) _then) = __$InlineCompletionParamsCopyWithImpl;
@override @useResult
$Res call({
 InlineCompletionContext context, Position position, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


@override $InlineCompletionContextCopyWith<$Res> get context;@override $PositionCopyWith<$Res> get position;@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$InlineCompletionParamsCopyWithImpl<$Res>
    implements _$InlineCompletionParamsCopyWith<$Res> {
  __$InlineCompletionParamsCopyWithImpl(this._self, this._then);

  final _InlineCompletionParams _self;
  final $Res Function(_InlineCompletionParams) _then;

/// Create a copy of InlineCompletionParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? context = null,Object? position = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_InlineCompletionParams(
context: null == context ? _self.context : context // ignore: cast_nullable_to_non_nullable
as InlineCompletionContext,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of InlineCompletionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$InlineCompletionContextCopyWith<$Res> get context {
  
  return $InlineCompletionContextCopyWith<$Res>(_self.context, (value) {
    return _then(_self.copyWith(context: value));
  });
}/// Create a copy of InlineCompletionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of InlineCompletionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$InlineCompletionList {

/// The inline completion items
 List<InlineCompletionItem> get items;
/// Create a copy of InlineCompletionList
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlineCompletionListCopyWith<InlineCompletionList> get copyWith => _$InlineCompletionListCopyWithImpl<InlineCompletionList>(this as InlineCompletionList, _$identity);

  /// Serializes this InlineCompletionList to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlineCompletionList&&const DeepCollectionEquality().equals(other.items, items));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(items));

@override
String toString() {
  return 'InlineCompletionList(items: $items)';
}


}

/// @nodoc
abstract mixin class $InlineCompletionListCopyWith<$Res>  {
  factory $InlineCompletionListCopyWith(InlineCompletionList value, $Res Function(InlineCompletionList) _then) = _$InlineCompletionListCopyWithImpl;
@useResult
$Res call({
 List<InlineCompletionItem> items
});




}
/// @nodoc
class _$InlineCompletionListCopyWithImpl<$Res>
    implements $InlineCompletionListCopyWith<$Res> {
  _$InlineCompletionListCopyWithImpl(this._self, this._then);

  final InlineCompletionList _self;
  final $Res Function(InlineCompletionList) _then;

/// Create a copy of InlineCompletionList
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? items = null,}) {
  return _then(_self.copyWith(
items: null == items ? _self.items : items // ignore: cast_nullable_to_non_nullable
as List<InlineCompletionItem>,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _InlineCompletionList implements InlineCompletionList {
  const _InlineCompletionList({required final  List<InlineCompletionItem> items}): _items = items;
  factory _InlineCompletionList.fromJson(Map<String, dynamic> json) => _$InlineCompletionListFromJson(json);

/// The inline completion items
 final  List<InlineCompletionItem> _items;
/// The inline completion items
@override List<InlineCompletionItem> get items {
  if (_items is EqualUnmodifiableListView) return _items;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_items);
}


/// Create a copy of InlineCompletionList
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlineCompletionListCopyWith<_InlineCompletionList> get copyWith => __$InlineCompletionListCopyWithImpl<_InlineCompletionList>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlineCompletionListToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlineCompletionList&&const DeepCollectionEquality().equals(other._items, _items));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_items));

@override
String toString() {
  return 'InlineCompletionList(items: $items)';
}


}

/// @nodoc
abstract mixin class _$InlineCompletionListCopyWith<$Res> implements $InlineCompletionListCopyWith<$Res> {
  factory _$InlineCompletionListCopyWith(_InlineCompletionList value, $Res Function(_InlineCompletionList) _then) = __$InlineCompletionListCopyWithImpl;
@override @useResult
$Res call({
 List<InlineCompletionItem> items
});




}
/// @nodoc
class __$InlineCompletionListCopyWithImpl<$Res>
    implements _$InlineCompletionListCopyWith<$Res> {
  __$InlineCompletionListCopyWithImpl(this._self, this._then);

  final _InlineCompletionList _self;
  final $Res Function(_InlineCompletionList) _then;

/// Create a copy of InlineCompletionList
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? items = null,}) {
  return _then(_InlineCompletionList(
items: null == items ? _self._items : items // ignore: cast_nullable_to_non_nullable
as List<InlineCompletionItem>,
  ));
}


}


/// @nodoc
mixin _$InlineCompletionItem {

/// An optional {@link Command} that is executed *after* inserting this
/// completion.
 Command? get command;/// A text that is used to decide if this inline completion should be
/// shown. When `falsy` the {@link InlineCompletionItem.insertText} is
/// used.
 String? get filterText;/// The text to replace the range with. Must be set.
 Sealed19 get insertText;/// The range to replace. Must begin and end on the same line.
 Range? get range;
/// Create a copy of InlineCompletionItem
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlineCompletionItemCopyWith<InlineCompletionItem> get copyWith => _$InlineCompletionItemCopyWithImpl<InlineCompletionItem>(this as InlineCompletionItem, _$identity);

  /// Serializes this InlineCompletionItem to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlineCompletionItem&&(identical(other.command, command) || other.command == command)&&(identical(other.filterText, filterText) || other.filterText == filterText)&&(identical(other.insertText, insertText) || other.insertText == insertText)&&(identical(other.range, range) || other.range == range));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,command,filterText,insertText,range);

@override
String toString() {
  return 'InlineCompletionItem(command: $command, filterText: $filterText, insertText: $insertText, range: $range)';
}


}

/// @nodoc
abstract mixin class $InlineCompletionItemCopyWith<$Res>  {
  factory $InlineCompletionItemCopyWith(InlineCompletionItem value, $Res Function(InlineCompletionItem) _then) = _$InlineCompletionItemCopyWithImpl;
@useResult
$Res call({
 Command? command, String? filterText, Sealed19 insertText, Range? range
});


$CommandCopyWith<$Res>? get command;$RangeCopyWith<$Res>? get range;

}
/// @nodoc
class _$InlineCompletionItemCopyWithImpl<$Res>
    implements $InlineCompletionItemCopyWith<$Res> {
  _$InlineCompletionItemCopyWithImpl(this._self, this._then);

  final InlineCompletionItem _self;
  final $Res Function(InlineCompletionItem) _then;

/// Create a copy of InlineCompletionItem
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? command = freezed,Object? filterText = freezed,Object? insertText = null,Object? range = freezed,}) {
  return _then(_self.copyWith(
command: freezed == command ? _self.command : command // ignore: cast_nullable_to_non_nullable
as Command?,filterText: freezed == filterText ? _self.filterText : filterText // ignore: cast_nullable_to_non_nullable
as String?,insertText: null == insertText ? _self.insertText : insertText // ignore: cast_nullable_to_non_nullable
as Sealed19,range: freezed == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range?,
  ));
}
/// Create a copy of InlineCompletionItem
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CommandCopyWith<$Res>? get command {
    if (_self.command == null) {
    return null;
  }

  return $CommandCopyWith<$Res>(_self.command!, (value) {
    return _then(_self.copyWith(command: value));
  });
}/// Create a copy of InlineCompletionItem
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res>? get range {
    if (_self.range == null) {
    return null;
  }

  return $RangeCopyWith<$Res>(_self.range!, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _InlineCompletionItem implements InlineCompletionItem {
  const _InlineCompletionItem({this.command, this.filterText, required this.insertText, this.range});
  factory _InlineCompletionItem.fromJson(Map<String, dynamic> json) => _$InlineCompletionItemFromJson(json);

/// An optional {@link Command} that is executed *after* inserting this
/// completion.
@override final  Command? command;
/// A text that is used to decide if this inline completion should be
/// shown. When `falsy` the {@link InlineCompletionItem.insertText} is
/// used.
@override final  String? filterText;
/// The text to replace the range with. Must be set.
@override final  Sealed19 insertText;
/// The range to replace. Must begin and end on the same line.
@override final  Range? range;

/// Create a copy of InlineCompletionItem
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlineCompletionItemCopyWith<_InlineCompletionItem> get copyWith => __$InlineCompletionItemCopyWithImpl<_InlineCompletionItem>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlineCompletionItemToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlineCompletionItem&&(identical(other.command, command) || other.command == command)&&(identical(other.filterText, filterText) || other.filterText == filterText)&&(identical(other.insertText, insertText) || other.insertText == insertText)&&(identical(other.range, range) || other.range == range));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,command,filterText,insertText,range);

@override
String toString() {
  return 'InlineCompletionItem(command: $command, filterText: $filterText, insertText: $insertText, range: $range)';
}


}

/// @nodoc
abstract mixin class _$InlineCompletionItemCopyWith<$Res> implements $InlineCompletionItemCopyWith<$Res> {
  factory _$InlineCompletionItemCopyWith(_InlineCompletionItem value, $Res Function(_InlineCompletionItem) _then) = __$InlineCompletionItemCopyWithImpl;
@override @useResult
$Res call({
 Command? command, String? filterText, Sealed19 insertText, Range? range
});


@override $CommandCopyWith<$Res>? get command;@override $RangeCopyWith<$Res>? get range;

}
/// @nodoc
class __$InlineCompletionItemCopyWithImpl<$Res>
    implements _$InlineCompletionItemCopyWith<$Res> {
  __$InlineCompletionItemCopyWithImpl(this._self, this._then);

  final _InlineCompletionItem _self;
  final $Res Function(_InlineCompletionItem) _then;

/// Create a copy of InlineCompletionItem
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? command = freezed,Object? filterText = freezed,Object? insertText = null,Object? range = freezed,}) {
  return _then(_InlineCompletionItem(
command: freezed == command ? _self.command : command // ignore: cast_nullable_to_non_nullable
as Command?,filterText: freezed == filterText ? _self.filterText : filterText // ignore: cast_nullable_to_non_nullable
as String?,insertText: null == insertText ? _self.insertText : insertText // ignore: cast_nullable_to_non_nullable
as Sealed19,range: freezed == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range?,
  ));
}

/// Create a copy of InlineCompletionItem
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CommandCopyWith<$Res>? get command {
    if (_self.command == null) {
    return null;
  }

  return $CommandCopyWith<$Res>(_self.command!, (value) {
    return _then(_self.copyWith(command: value));
  });
}/// Create a copy of InlineCompletionItem
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res>? get range {
    if (_self.range == null) {
    return null;
  }

  return $RangeCopyWith<$Res>(_self.range!, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}


/// @nodoc
mixin _$InlineCompletionRegistrationOptions {

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
 Sealed14 get documentSelector;/// The id used to register the request. The id can be used to deregister
/// the request again. See also Registration#id.
 String? get id;
/// Create a copy of InlineCompletionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlineCompletionRegistrationOptionsCopyWith<InlineCompletionRegistrationOptions> get copyWith => _$InlineCompletionRegistrationOptionsCopyWithImpl<InlineCompletionRegistrationOptions>(this as InlineCompletionRegistrationOptions, _$identity);

  /// Serializes this InlineCompletionRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlineCompletionRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.id, id) || other.id == id));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,id);

@override
String toString() {
  return 'InlineCompletionRegistrationOptions(documentSelector: $documentSelector, id: $id)';
}


}

/// @nodoc
abstract mixin class $InlineCompletionRegistrationOptionsCopyWith<$Res>  {
  factory $InlineCompletionRegistrationOptionsCopyWith(InlineCompletionRegistrationOptions value, $Res Function(InlineCompletionRegistrationOptions) _then) = _$InlineCompletionRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 Sealed14 documentSelector, String? id
});




}
/// @nodoc
class _$InlineCompletionRegistrationOptionsCopyWithImpl<$Res>
    implements $InlineCompletionRegistrationOptionsCopyWith<$Res> {
  _$InlineCompletionRegistrationOptionsCopyWithImpl(this._self, this._then);

  final InlineCompletionRegistrationOptions _self;
  final $Res Function(InlineCompletionRegistrationOptions) _then;

/// Create a copy of InlineCompletionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = null,Object? id = freezed,}) {
  return _then(_self.copyWith(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _InlineCompletionRegistrationOptions implements InlineCompletionRegistrationOptions {
  const _InlineCompletionRegistrationOptions({required this.documentSelector, this.id});
  factory _InlineCompletionRegistrationOptions.fromJson(Map<String, dynamic> json) => _$InlineCompletionRegistrationOptionsFromJson(json);

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
@override final  Sealed14 documentSelector;
/// The id used to register the request. The id can be used to deregister
/// the request again. See also Registration#id.
@override final  String? id;

/// Create a copy of InlineCompletionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlineCompletionRegistrationOptionsCopyWith<_InlineCompletionRegistrationOptions> get copyWith => __$InlineCompletionRegistrationOptionsCopyWithImpl<_InlineCompletionRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlineCompletionRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlineCompletionRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.id, id) || other.id == id));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,id);

@override
String toString() {
  return 'InlineCompletionRegistrationOptions(documentSelector: $documentSelector, id: $id)';
}


}

/// @nodoc
abstract mixin class _$InlineCompletionRegistrationOptionsCopyWith<$Res> implements $InlineCompletionRegistrationOptionsCopyWith<$Res> {
  factory _$InlineCompletionRegistrationOptionsCopyWith(_InlineCompletionRegistrationOptions value, $Res Function(_InlineCompletionRegistrationOptions) _then) = __$InlineCompletionRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 Sealed14 documentSelector, String? id
});




}
/// @nodoc
class __$InlineCompletionRegistrationOptionsCopyWithImpl<$Res>
    implements _$InlineCompletionRegistrationOptionsCopyWith<$Res> {
  __$InlineCompletionRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _InlineCompletionRegistrationOptions _self;
  final $Res Function(_InlineCompletionRegistrationOptions) _then;

/// Create a copy of InlineCompletionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = null,Object? id = freezed,}) {
  return _then(_InlineCompletionRegistrationOptions(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$RegistrationParams {

 List<Registration> get registrations;
/// Create a copy of RegistrationParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RegistrationParamsCopyWith<RegistrationParams> get copyWith => _$RegistrationParamsCopyWithImpl<RegistrationParams>(this as RegistrationParams, _$identity);

  /// Serializes this RegistrationParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RegistrationParams&&const DeepCollectionEquality().equals(other.registrations, registrations));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(registrations));

@override
String toString() {
  return 'RegistrationParams(registrations: $registrations)';
}


}

/// @nodoc
abstract mixin class $RegistrationParamsCopyWith<$Res>  {
  factory $RegistrationParamsCopyWith(RegistrationParams value, $Res Function(RegistrationParams) _then) = _$RegistrationParamsCopyWithImpl;
@useResult
$Res call({
 List<Registration> registrations
});




}
/// @nodoc
class _$RegistrationParamsCopyWithImpl<$Res>
    implements $RegistrationParamsCopyWith<$Res> {
  _$RegistrationParamsCopyWithImpl(this._self, this._then);

  final RegistrationParams _self;
  final $Res Function(RegistrationParams) _then;

/// Create a copy of RegistrationParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? registrations = null,}) {
  return _then(_self.copyWith(
registrations: null == registrations ? _self.registrations : registrations // ignore: cast_nullable_to_non_nullable
as List<Registration>,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _RegistrationParams implements RegistrationParams {
  const _RegistrationParams({required final  List<Registration> registrations}): _registrations = registrations;
  factory _RegistrationParams.fromJson(Map<String, dynamic> json) => _$RegistrationParamsFromJson(json);

 final  List<Registration> _registrations;
@override List<Registration> get registrations {
  if (_registrations is EqualUnmodifiableListView) return _registrations;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_registrations);
}


/// Create a copy of RegistrationParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RegistrationParamsCopyWith<_RegistrationParams> get copyWith => __$RegistrationParamsCopyWithImpl<_RegistrationParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$RegistrationParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _RegistrationParams&&const DeepCollectionEquality().equals(other._registrations, _registrations));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_registrations));

@override
String toString() {
  return 'RegistrationParams(registrations: $registrations)';
}


}

/// @nodoc
abstract mixin class _$RegistrationParamsCopyWith<$Res> implements $RegistrationParamsCopyWith<$Res> {
  factory _$RegistrationParamsCopyWith(_RegistrationParams value, $Res Function(_RegistrationParams) _then) = __$RegistrationParamsCopyWithImpl;
@override @useResult
$Res call({
 List<Registration> registrations
});




}
/// @nodoc
class __$RegistrationParamsCopyWithImpl<$Res>
    implements _$RegistrationParamsCopyWith<$Res> {
  __$RegistrationParamsCopyWithImpl(this._self, this._then);

  final _RegistrationParams _self;
  final $Res Function(_RegistrationParams) _then;

/// Create a copy of RegistrationParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? registrations = null,}) {
  return _then(_RegistrationParams(
registrations: null == registrations ? _self._registrations : registrations // ignore: cast_nullable_to_non_nullable
as List<Registration>,
  ));
}


}


/// @nodoc
mixin _$UnregistrationParams {

 List<Unregistration> get unregisterations;
/// Create a copy of UnregistrationParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UnregistrationParamsCopyWith<UnregistrationParams> get copyWith => _$UnregistrationParamsCopyWithImpl<UnregistrationParams>(this as UnregistrationParams, _$identity);

  /// Serializes this UnregistrationParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UnregistrationParams&&const DeepCollectionEquality().equals(other.unregisterations, unregisterations));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(unregisterations));

@override
String toString() {
  return 'UnregistrationParams(unregisterations: $unregisterations)';
}


}

/// @nodoc
abstract mixin class $UnregistrationParamsCopyWith<$Res>  {
  factory $UnregistrationParamsCopyWith(UnregistrationParams value, $Res Function(UnregistrationParams) _then) = _$UnregistrationParamsCopyWithImpl;
@useResult
$Res call({
 List<Unregistration> unregisterations
});




}
/// @nodoc
class _$UnregistrationParamsCopyWithImpl<$Res>
    implements $UnregistrationParamsCopyWith<$Res> {
  _$UnregistrationParamsCopyWithImpl(this._self, this._then);

  final UnregistrationParams _self;
  final $Res Function(UnregistrationParams) _then;

/// Create a copy of UnregistrationParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? unregisterations = null,}) {
  return _then(_self.copyWith(
unregisterations: null == unregisterations ? _self.unregisterations : unregisterations // ignore: cast_nullable_to_non_nullable
as List<Unregistration>,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _UnregistrationParams implements UnregistrationParams {
  const _UnregistrationParams({required final  List<Unregistration> unregisterations}): _unregisterations = unregisterations;
  factory _UnregistrationParams.fromJson(Map<String, dynamic> json) => _$UnregistrationParamsFromJson(json);

 final  List<Unregistration> _unregisterations;
@override List<Unregistration> get unregisterations {
  if (_unregisterations is EqualUnmodifiableListView) return _unregisterations;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_unregisterations);
}


/// Create a copy of UnregistrationParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$UnregistrationParamsCopyWith<_UnregistrationParams> get copyWith => __$UnregistrationParamsCopyWithImpl<_UnregistrationParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$UnregistrationParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _UnregistrationParams&&const DeepCollectionEquality().equals(other._unregisterations, _unregisterations));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_unregisterations));

@override
String toString() {
  return 'UnregistrationParams(unregisterations: $unregisterations)';
}


}

/// @nodoc
abstract mixin class _$UnregistrationParamsCopyWith<$Res> implements $UnregistrationParamsCopyWith<$Res> {
  factory _$UnregistrationParamsCopyWith(_UnregistrationParams value, $Res Function(_UnregistrationParams) _then) = __$UnregistrationParamsCopyWithImpl;
@override @useResult
$Res call({
 List<Unregistration> unregisterations
});




}
/// @nodoc
class __$UnregistrationParamsCopyWithImpl<$Res>
    implements _$UnregistrationParamsCopyWith<$Res> {
  __$UnregistrationParamsCopyWithImpl(this._self, this._then);

  final _UnregistrationParams _self;
  final $Res Function(_UnregistrationParams) _then;

/// Create a copy of UnregistrationParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? unregisterations = null,}) {
  return _then(_UnregistrationParams(
unregisterations: null == unregisterations ? _self._unregisterations : unregisterations // ignore: cast_nullable_to_non_nullable
as List<Unregistration>,
  ));
}


}


/// @nodoc
mixin _$InitializeParams {

/// The capabilities provided by the client (editor or tool)
 ClientCapabilities get capabilities;/// Information about the client
/// @since 3.15.0
 StringNameStringVersion? get clientInfo;/// User provided initialization options.
 LSPAny? get initializationOptions;/// The locale the client is currently showing the user interface in. This
/// must not necessarily be the locale of the operating system.
/// Uses IETF language tags as the value's syntax (See
/// https://en.wikipedia.org/wiki/IETF_language_tag)
/// @since 3.16.0
 String? get locale;/// The process Id of the parent process that started the server.
/// Is `null` if the process has not been started by another process. If
/// the parent process is not alive then the server should exit.
 Sealed28 get processId;/// The rootPath of the workspace. Is null if no folder is open.
/// @deprecated in favour of rootUri.
 Sealed29? get rootPath;/// The rootUri of the workspace. Is null if no folder is open. If both
/// `rootPath` and `rootUri` are set `rootUri` wins.
/// @deprecated in favour of workspaceFolders.
 Sealed29 get rootUri;/// The initial trace setting. If omitted trace is disabled ('off').
 TraceValues? get trace;/// The workspace folders configured in the client when the server starts.
/// This property is only available if the client supports workspace
/// folders. It can be `null` if the client supports workspace folders but
/// none are configured.
/// @since 3.6.0
 Sealed30? get workspaceFolders;
/// Create a copy of InitializeParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InitializeParamsCopyWith<InitializeParams> get copyWith => _$InitializeParamsCopyWithImpl<InitializeParams>(this as InitializeParams, _$identity);

  /// Serializes this InitializeParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InitializeParams&&(identical(other.capabilities, capabilities) || other.capabilities == capabilities)&&const DeepCollectionEquality().equals(other.clientInfo, clientInfo)&&(identical(other.initializationOptions, initializationOptions) || other.initializationOptions == initializationOptions)&&(identical(other.locale, locale) || other.locale == locale)&&(identical(other.processId, processId) || other.processId == processId)&&(identical(other.rootPath, rootPath) || other.rootPath == rootPath)&&(identical(other.rootUri, rootUri) || other.rootUri == rootUri)&&(identical(other.trace, trace) || other.trace == trace)&&(identical(other.workspaceFolders, workspaceFolders) || other.workspaceFolders == workspaceFolders));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,capabilities,const DeepCollectionEquality().hash(clientInfo),initializationOptions,locale,processId,rootPath,rootUri,trace,workspaceFolders);

@override
String toString() {
  return 'InitializeParams(capabilities: $capabilities, clientInfo: $clientInfo, initializationOptions: $initializationOptions, locale: $locale, processId: $processId, rootPath: $rootPath, rootUri: $rootUri, trace: $trace, workspaceFolders: $workspaceFolders)';
}


}

/// @nodoc
abstract mixin class $InitializeParamsCopyWith<$Res>  {
  factory $InitializeParamsCopyWith(InitializeParams value, $Res Function(InitializeParams) _then) = _$InitializeParamsCopyWithImpl;
@useResult
$Res call({
 ClientCapabilities capabilities, StringNameStringVersion? clientInfo, LSPAny? initializationOptions, String? locale, Sealed28 processId, Sealed29? rootPath, Sealed29 rootUri, TraceValues? trace, Sealed30? workspaceFolders
});


$ClientCapabilitiesCopyWith<$Res> get capabilities;

}
/// @nodoc
class _$InitializeParamsCopyWithImpl<$Res>
    implements $InitializeParamsCopyWith<$Res> {
  _$InitializeParamsCopyWithImpl(this._self, this._then);

  final InitializeParams _self;
  final $Res Function(InitializeParams) _then;

/// Create a copy of InitializeParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? capabilities = null,Object? clientInfo = freezed,Object? initializationOptions = freezed,Object? locale = freezed,Object? processId = null,Object? rootPath = freezed,Object? rootUri = null,Object? trace = freezed,Object? workspaceFolders = freezed,}) {
  return _then(_self.copyWith(
capabilities: null == capabilities ? _self.capabilities : capabilities // ignore: cast_nullable_to_non_nullable
as ClientCapabilities,clientInfo: freezed == clientInfo ? _self.clientInfo : clientInfo // ignore: cast_nullable_to_non_nullable
as StringNameStringVersion?,initializationOptions: freezed == initializationOptions ? _self.initializationOptions : initializationOptions // ignore: cast_nullable_to_non_nullable
as LSPAny?,locale: freezed == locale ? _self.locale : locale // ignore: cast_nullable_to_non_nullable
as String?,processId: null == processId ? _self.processId : processId // ignore: cast_nullable_to_non_nullable
as Sealed28,rootPath: freezed == rootPath ? _self.rootPath : rootPath // ignore: cast_nullable_to_non_nullable
as Sealed29?,rootUri: null == rootUri ? _self.rootUri : rootUri // ignore: cast_nullable_to_non_nullable
as Sealed29,trace: freezed == trace ? _self.trace : trace // ignore: cast_nullable_to_non_nullable
as TraceValues?,workspaceFolders: freezed == workspaceFolders ? _self.workspaceFolders : workspaceFolders // ignore: cast_nullable_to_non_nullable
as Sealed30?,
  ));
}
/// Create a copy of InitializeParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ClientCapabilitiesCopyWith<$Res> get capabilities {
  
  return $ClientCapabilitiesCopyWith<$Res>(_self.capabilities, (value) {
    return _then(_self.copyWith(capabilities: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _InitializeParams implements InitializeParams {
  const _InitializeParams({required this.capabilities, this.clientInfo, this.initializationOptions, this.locale, required this.processId, this.rootPath, required this.rootUri, this.trace, this.workspaceFolders});
  factory _InitializeParams.fromJson(Map<String, dynamic> json) => _$InitializeParamsFromJson(json);

/// The capabilities provided by the client (editor or tool)
@override final  ClientCapabilities capabilities;
/// Information about the client
/// @since 3.15.0
@override final  StringNameStringVersion? clientInfo;
/// User provided initialization options.
@override final  LSPAny? initializationOptions;
/// The locale the client is currently showing the user interface in. This
/// must not necessarily be the locale of the operating system.
/// Uses IETF language tags as the value's syntax (See
/// https://en.wikipedia.org/wiki/IETF_language_tag)
/// @since 3.16.0
@override final  String? locale;
/// The process Id of the parent process that started the server.
/// Is `null` if the process has not been started by another process. If
/// the parent process is not alive then the server should exit.
@override final  Sealed28 processId;
/// The rootPath of the workspace. Is null if no folder is open.
/// @deprecated in favour of rootUri.
@override final  Sealed29? rootPath;
/// The rootUri of the workspace. Is null if no folder is open. If both
/// `rootPath` and `rootUri` are set `rootUri` wins.
/// @deprecated in favour of workspaceFolders.
@override final  Sealed29 rootUri;
/// The initial trace setting. If omitted trace is disabled ('off').
@override final  TraceValues? trace;
/// The workspace folders configured in the client when the server starts.
/// This property is only available if the client supports workspace
/// folders. It can be `null` if the client supports workspace folders but
/// none are configured.
/// @since 3.6.0
@override final  Sealed30? workspaceFolders;

/// Create a copy of InitializeParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InitializeParamsCopyWith<_InitializeParams> get copyWith => __$InitializeParamsCopyWithImpl<_InitializeParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InitializeParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InitializeParams&&(identical(other.capabilities, capabilities) || other.capabilities == capabilities)&&const DeepCollectionEquality().equals(other.clientInfo, clientInfo)&&(identical(other.initializationOptions, initializationOptions) || other.initializationOptions == initializationOptions)&&(identical(other.locale, locale) || other.locale == locale)&&(identical(other.processId, processId) || other.processId == processId)&&(identical(other.rootPath, rootPath) || other.rootPath == rootPath)&&(identical(other.rootUri, rootUri) || other.rootUri == rootUri)&&(identical(other.trace, trace) || other.trace == trace)&&(identical(other.workspaceFolders, workspaceFolders) || other.workspaceFolders == workspaceFolders));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,capabilities,const DeepCollectionEquality().hash(clientInfo),initializationOptions,locale,processId,rootPath,rootUri,trace,workspaceFolders);

@override
String toString() {
  return 'InitializeParams(capabilities: $capabilities, clientInfo: $clientInfo, initializationOptions: $initializationOptions, locale: $locale, processId: $processId, rootPath: $rootPath, rootUri: $rootUri, trace: $trace, workspaceFolders: $workspaceFolders)';
}


}

/// @nodoc
abstract mixin class _$InitializeParamsCopyWith<$Res> implements $InitializeParamsCopyWith<$Res> {
  factory _$InitializeParamsCopyWith(_InitializeParams value, $Res Function(_InitializeParams) _then) = __$InitializeParamsCopyWithImpl;
@override @useResult
$Res call({
 ClientCapabilities capabilities, StringNameStringVersion? clientInfo, LSPAny? initializationOptions, String? locale, Sealed28 processId, Sealed29? rootPath, Sealed29 rootUri, TraceValues? trace, Sealed30? workspaceFolders
});


@override $ClientCapabilitiesCopyWith<$Res> get capabilities;

}
/// @nodoc
class __$InitializeParamsCopyWithImpl<$Res>
    implements _$InitializeParamsCopyWith<$Res> {
  __$InitializeParamsCopyWithImpl(this._self, this._then);

  final _InitializeParams _self;
  final $Res Function(_InitializeParams) _then;

/// Create a copy of InitializeParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? capabilities = null,Object? clientInfo = freezed,Object? initializationOptions = freezed,Object? locale = freezed,Object? processId = null,Object? rootPath = freezed,Object? rootUri = null,Object? trace = freezed,Object? workspaceFolders = freezed,}) {
  return _then(_InitializeParams(
capabilities: null == capabilities ? _self.capabilities : capabilities // ignore: cast_nullable_to_non_nullable
as ClientCapabilities,clientInfo: freezed == clientInfo ? _self.clientInfo : clientInfo // ignore: cast_nullable_to_non_nullable
as StringNameStringVersion?,initializationOptions: freezed == initializationOptions ? _self.initializationOptions : initializationOptions // ignore: cast_nullable_to_non_nullable
as LSPAny?,locale: freezed == locale ? _self.locale : locale // ignore: cast_nullable_to_non_nullable
as String?,processId: null == processId ? _self.processId : processId // ignore: cast_nullable_to_non_nullable
as Sealed28,rootPath: freezed == rootPath ? _self.rootPath : rootPath // ignore: cast_nullable_to_non_nullable
as Sealed29?,rootUri: null == rootUri ? _self.rootUri : rootUri // ignore: cast_nullable_to_non_nullable
as Sealed29,trace: freezed == trace ? _self.trace : trace // ignore: cast_nullable_to_non_nullable
as TraceValues?,workspaceFolders: freezed == workspaceFolders ? _self.workspaceFolders : workspaceFolders // ignore: cast_nullable_to_non_nullable
as Sealed30?,
  ));
}

/// Create a copy of InitializeParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ClientCapabilitiesCopyWith<$Res> get capabilities {
  
  return $ClientCapabilitiesCopyWith<$Res>(_self.capabilities, (value) {
    return _then(_self.copyWith(capabilities: value));
  });
}
}


/// @nodoc
mixin _$InitializeResult {

/// The capabilities the language server provides.
 ServerCapabilities get capabilities;/// Information about the server.
/// @since 3.15.0
 StringNameStringVersion? get serverInfo;
/// Create a copy of InitializeResult
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InitializeResultCopyWith<InitializeResult> get copyWith => _$InitializeResultCopyWithImpl<InitializeResult>(this as InitializeResult, _$identity);

  /// Serializes this InitializeResult to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InitializeResult&&(identical(other.capabilities, capabilities) || other.capabilities == capabilities)&&const DeepCollectionEquality().equals(other.serverInfo, serverInfo));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,capabilities,const DeepCollectionEquality().hash(serverInfo));

@override
String toString() {
  return 'InitializeResult(capabilities: $capabilities, serverInfo: $serverInfo)';
}


}

/// @nodoc
abstract mixin class $InitializeResultCopyWith<$Res>  {
  factory $InitializeResultCopyWith(InitializeResult value, $Res Function(InitializeResult) _then) = _$InitializeResultCopyWithImpl;
@useResult
$Res call({
 ServerCapabilities capabilities, StringNameStringVersion? serverInfo
});


$ServerCapabilitiesCopyWith<$Res> get capabilities;

}
/// @nodoc
class _$InitializeResultCopyWithImpl<$Res>
    implements $InitializeResultCopyWith<$Res> {
  _$InitializeResultCopyWithImpl(this._self, this._then);

  final InitializeResult _self;
  final $Res Function(InitializeResult) _then;

/// Create a copy of InitializeResult
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? capabilities = null,Object? serverInfo = freezed,}) {
  return _then(_self.copyWith(
capabilities: null == capabilities ? _self.capabilities : capabilities // ignore: cast_nullable_to_non_nullable
as ServerCapabilities,serverInfo: freezed == serverInfo ? _self.serverInfo : serverInfo // ignore: cast_nullable_to_non_nullable
as StringNameStringVersion?,
  ));
}
/// Create a copy of InitializeResult
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ServerCapabilitiesCopyWith<$Res> get capabilities {
  
  return $ServerCapabilitiesCopyWith<$Res>(_self.capabilities, (value) {
    return _then(_self.copyWith(capabilities: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _InitializeResult implements InitializeResult {
  const _InitializeResult({required this.capabilities, this.serverInfo});
  factory _InitializeResult.fromJson(Map<String, dynamic> json) => _$InitializeResultFromJson(json);

/// The capabilities the language server provides.
@override final  ServerCapabilities capabilities;
/// Information about the server.
/// @since 3.15.0
@override final  StringNameStringVersion? serverInfo;

/// Create a copy of InitializeResult
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InitializeResultCopyWith<_InitializeResult> get copyWith => __$InitializeResultCopyWithImpl<_InitializeResult>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InitializeResultToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InitializeResult&&(identical(other.capabilities, capabilities) || other.capabilities == capabilities)&&const DeepCollectionEquality().equals(other.serverInfo, serverInfo));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,capabilities,const DeepCollectionEquality().hash(serverInfo));

@override
String toString() {
  return 'InitializeResult(capabilities: $capabilities, serverInfo: $serverInfo)';
}


}

/// @nodoc
abstract mixin class _$InitializeResultCopyWith<$Res> implements $InitializeResultCopyWith<$Res> {
  factory _$InitializeResultCopyWith(_InitializeResult value, $Res Function(_InitializeResult) _then) = __$InitializeResultCopyWithImpl;
@override @useResult
$Res call({
 ServerCapabilities capabilities, StringNameStringVersion? serverInfo
});


@override $ServerCapabilitiesCopyWith<$Res> get capabilities;

}
/// @nodoc
class __$InitializeResultCopyWithImpl<$Res>
    implements _$InitializeResultCopyWith<$Res> {
  __$InitializeResultCopyWithImpl(this._self, this._then);

  final _InitializeResult _self;
  final $Res Function(_InitializeResult) _then;

/// Create a copy of InitializeResult
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? capabilities = null,Object? serverInfo = freezed,}) {
  return _then(_InitializeResult(
capabilities: null == capabilities ? _self.capabilities : capabilities // ignore: cast_nullable_to_non_nullable
as ServerCapabilities,serverInfo: freezed == serverInfo ? _self.serverInfo : serverInfo // ignore: cast_nullable_to_non_nullable
as StringNameStringVersion?,
  ));
}

/// Create a copy of InitializeResult
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ServerCapabilitiesCopyWith<$Res> get capabilities {
  
  return $ServerCapabilitiesCopyWith<$Res>(_self.capabilities, (value) {
    return _then(_self.copyWith(capabilities: value));
  });
}
}


/// @nodoc
mixin _$InitializeError {

/// Indicates whether the client execute the following retry logic: (1)
/// show the message provided by the ResponseError to the user (2) user
/// selects retry or cancel (3) if user selected retry the initialize
/// method is sent again.
 bool get retry;
/// Create a copy of InitializeError
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InitializeErrorCopyWith<InitializeError> get copyWith => _$InitializeErrorCopyWithImpl<InitializeError>(this as InitializeError, _$identity);

  /// Serializes this InitializeError to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InitializeError&&(identical(other.retry, retry) || other.retry == retry));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,retry);

@override
String toString() {
  return 'InitializeError(retry: $retry)';
}


}

/// @nodoc
abstract mixin class $InitializeErrorCopyWith<$Res>  {
  factory $InitializeErrorCopyWith(InitializeError value, $Res Function(InitializeError) _then) = _$InitializeErrorCopyWithImpl;
@useResult
$Res call({
 bool retry
});




}
/// @nodoc
class _$InitializeErrorCopyWithImpl<$Res>
    implements $InitializeErrorCopyWith<$Res> {
  _$InitializeErrorCopyWithImpl(this._self, this._then);

  final InitializeError _self;
  final $Res Function(InitializeError) _then;

/// Create a copy of InitializeError
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? retry = null,}) {
  return _then(_self.copyWith(
retry: null == retry ? _self.retry : retry // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _InitializeError implements InitializeError {
  const _InitializeError({required this.retry});
  factory _InitializeError.fromJson(Map<String, dynamic> json) => _$InitializeErrorFromJson(json);

/// Indicates whether the client execute the following retry logic: (1)
/// show the message provided by the ResponseError to the user (2) user
/// selects retry or cancel (3) if user selected retry the initialize
/// method is sent again.
@override final  bool retry;

/// Create a copy of InitializeError
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InitializeErrorCopyWith<_InitializeError> get copyWith => __$InitializeErrorCopyWithImpl<_InitializeError>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InitializeErrorToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InitializeError&&(identical(other.retry, retry) || other.retry == retry));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,retry);

@override
String toString() {
  return 'InitializeError(retry: $retry)';
}


}

/// @nodoc
abstract mixin class _$InitializeErrorCopyWith<$Res> implements $InitializeErrorCopyWith<$Res> {
  factory _$InitializeErrorCopyWith(_InitializeError value, $Res Function(_InitializeError) _then) = __$InitializeErrorCopyWithImpl;
@override @useResult
$Res call({
 bool retry
});




}
/// @nodoc
class __$InitializeErrorCopyWithImpl<$Res>
    implements _$InitializeErrorCopyWith<$Res> {
  __$InitializeErrorCopyWithImpl(this._self, this._then);

  final _InitializeError _self;
  final $Res Function(_InitializeError) _then;

/// Create a copy of InitializeError
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? retry = null,}) {
  return _then(_InitializeError(
retry: null == retry ? _self.retry : retry // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}


}


/// @nodoc
mixin _$InitializedParams {



  /// Serializes this InitializedParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InitializedParams);
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'InitializedParams()';
}


}

/// @nodoc
class $InitializedParamsCopyWith<$Res>  {
$InitializedParamsCopyWith(InitializedParams _, $Res Function(InitializedParams) __);
}



/// @nodoc
@JsonSerializable()

class _InitializedParams implements InitializedParams {
  const _InitializedParams();
  factory _InitializedParams.fromJson(Map<String, dynamic> json) => _$InitializedParamsFromJson(json);




@override
Map<String, dynamic> toJson() {
  return _$InitializedParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InitializedParams);
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => runtimeType.hashCode;

@override
String toString() {
  return 'InitializedParams()';
}


}





/// @nodoc
mixin _$DidChangeConfigurationParams {

/// The actual changed settings
 LSPAny get settings;
/// Create a copy of DidChangeConfigurationParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DidChangeConfigurationParamsCopyWith<DidChangeConfigurationParams> get copyWith => _$DidChangeConfigurationParamsCopyWithImpl<DidChangeConfigurationParams>(this as DidChangeConfigurationParams, _$identity);

  /// Serializes this DidChangeConfigurationParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DidChangeConfigurationParams&&(identical(other.settings, settings) || other.settings == settings));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,settings);

@override
String toString() {
  return 'DidChangeConfigurationParams(settings: $settings)';
}


}

/// @nodoc
abstract mixin class $DidChangeConfigurationParamsCopyWith<$Res>  {
  factory $DidChangeConfigurationParamsCopyWith(DidChangeConfigurationParams value, $Res Function(DidChangeConfigurationParams) _then) = _$DidChangeConfigurationParamsCopyWithImpl;
@useResult
$Res call({
 LSPAny settings
});




}
/// @nodoc
class _$DidChangeConfigurationParamsCopyWithImpl<$Res>
    implements $DidChangeConfigurationParamsCopyWith<$Res> {
  _$DidChangeConfigurationParamsCopyWithImpl(this._self, this._then);

  final DidChangeConfigurationParams _self;
  final $Res Function(DidChangeConfigurationParams) _then;

/// Create a copy of DidChangeConfigurationParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? settings = null,}) {
  return _then(_self.copyWith(
settings: null == settings ? _self.settings : settings // ignore: cast_nullable_to_non_nullable
as LSPAny,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DidChangeConfigurationParams implements DidChangeConfigurationParams {
  const _DidChangeConfigurationParams({required this.settings});
  factory _DidChangeConfigurationParams.fromJson(Map<String, dynamic> json) => _$DidChangeConfigurationParamsFromJson(json);

/// The actual changed settings
@override final  LSPAny settings;

/// Create a copy of DidChangeConfigurationParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DidChangeConfigurationParamsCopyWith<_DidChangeConfigurationParams> get copyWith => __$DidChangeConfigurationParamsCopyWithImpl<_DidChangeConfigurationParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DidChangeConfigurationParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DidChangeConfigurationParams&&(identical(other.settings, settings) || other.settings == settings));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,settings);

@override
String toString() {
  return 'DidChangeConfigurationParams(settings: $settings)';
}


}

/// @nodoc
abstract mixin class _$DidChangeConfigurationParamsCopyWith<$Res> implements $DidChangeConfigurationParamsCopyWith<$Res> {
  factory _$DidChangeConfigurationParamsCopyWith(_DidChangeConfigurationParams value, $Res Function(_DidChangeConfigurationParams) _then) = __$DidChangeConfigurationParamsCopyWithImpl;
@override @useResult
$Res call({
 LSPAny settings
});




}
/// @nodoc
class __$DidChangeConfigurationParamsCopyWithImpl<$Res>
    implements _$DidChangeConfigurationParamsCopyWith<$Res> {
  __$DidChangeConfigurationParamsCopyWithImpl(this._self, this._then);

  final _DidChangeConfigurationParams _self;
  final $Res Function(_DidChangeConfigurationParams) _then;

/// Create a copy of DidChangeConfigurationParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? settings = null,}) {
  return _then(_DidChangeConfigurationParams(
settings: null == settings ? _self.settings : settings // ignore: cast_nullable_to_non_nullable
as LSPAny,
  ));
}


}


/// @nodoc
mixin _$DidChangeConfigurationRegistrationOptions {

 Sealed20? get section;
/// Create a copy of DidChangeConfigurationRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DidChangeConfigurationRegistrationOptionsCopyWith<DidChangeConfigurationRegistrationOptions> get copyWith => _$DidChangeConfigurationRegistrationOptionsCopyWithImpl<DidChangeConfigurationRegistrationOptions>(this as DidChangeConfigurationRegistrationOptions, _$identity);

  /// Serializes this DidChangeConfigurationRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DidChangeConfigurationRegistrationOptions&&(identical(other.section, section) || other.section == section));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,section);

@override
String toString() {
  return 'DidChangeConfigurationRegistrationOptions(section: $section)';
}


}

/// @nodoc
abstract mixin class $DidChangeConfigurationRegistrationOptionsCopyWith<$Res>  {
  factory $DidChangeConfigurationRegistrationOptionsCopyWith(DidChangeConfigurationRegistrationOptions value, $Res Function(DidChangeConfigurationRegistrationOptions) _then) = _$DidChangeConfigurationRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 Sealed20? section
});




}
/// @nodoc
class _$DidChangeConfigurationRegistrationOptionsCopyWithImpl<$Res>
    implements $DidChangeConfigurationRegistrationOptionsCopyWith<$Res> {
  _$DidChangeConfigurationRegistrationOptionsCopyWithImpl(this._self, this._then);

  final DidChangeConfigurationRegistrationOptions _self;
  final $Res Function(DidChangeConfigurationRegistrationOptions) _then;

/// Create a copy of DidChangeConfigurationRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? section = freezed,}) {
  return _then(_self.copyWith(
section: freezed == section ? _self.section : section // ignore: cast_nullable_to_non_nullable
as Sealed20?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DidChangeConfigurationRegistrationOptions implements DidChangeConfigurationRegistrationOptions {
  const _DidChangeConfigurationRegistrationOptions({this.section});
  factory _DidChangeConfigurationRegistrationOptions.fromJson(Map<String, dynamic> json) => _$DidChangeConfigurationRegistrationOptionsFromJson(json);

@override final  Sealed20? section;

/// Create a copy of DidChangeConfigurationRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DidChangeConfigurationRegistrationOptionsCopyWith<_DidChangeConfigurationRegistrationOptions> get copyWith => __$DidChangeConfigurationRegistrationOptionsCopyWithImpl<_DidChangeConfigurationRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DidChangeConfigurationRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DidChangeConfigurationRegistrationOptions&&(identical(other.section, section) || other.section == section));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,section);

@override
String toString() {
  return 'DidChangeConfigurationRegistrationOptions(section: $section)';
}


}

/// @nodoc
abstract mixin class _$DidChangeConfigurationRegistrationOptionsCopyWith<$Res> implements $DidChangeConfigurationRegistrationOptionsCopyWith<$Res> {
  factory _$DidChangeConfigurationRegistrationOptionsCopyWith(_DidChangeConfigurationRegistrationOptions value, $Res Function(_DidChangeConfigurationRegistrationOptions) _then) = __$DidChangeConfigurationRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 Sealed20? section
});




}
/// @nodoc
class __$DidChangeConfigurationRegistrationOptionsCopyWithImpl<$Res>
    implements _$DidChangeConfigurationRegistrationOptionsCopyWith<$Res> {
  __$DidChangeConfigurationRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _DidChangeConfigurationRegistrationOptions _self;
  final $Res Function(_DidChangeConfigurationRegistrationOptions) _then;

/// Create a copy of DidChangeConfigurationRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? section = freezed,}) {
  return _then(_DidChangeConfigurationRegistrationOptions(
section: freezed == section ? _self.section : section // ignore: cast_nullable_to_non_nullable
as Sealed20?,
  ));
}


}


/// @nodoc
mixin _$ShowMessageParams {

/// The actual message.
 String get message;/// The message type. See {@link MessageType}
 MessageType get type;
/// Create a copy of ShowMessageParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ShowMessageParamsCopyWith<ShowMessageParams> get copyWith => _$ShowMessageParamsCopyWithImpl<ShowMessageParams>(this as ShowMessageParams, _$identity);

  /// Serializes this ShowMessageParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ShowMessageParams&&(identical(other.message, message) || other.message == message)&&(identical(other.type, type) || other.type == type));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,message,type);

@override
String toString() {
  return 'ShowMessageParams(message: $message, type: $type)';
}


}

/// @nodoc
abstract mixin class $ShowMessageParamsCopyWith<$Res>  {
  factory $ShowMessageParamsCopyWith(ShowMessageParams value, $Res Function(ShowMessageParams) _then) = _$ShowMessageParamsCopyWithImpl;
@useResult
$Res call({
 String message, MessageType type
});




}
/// @nodoc
class _$ShowMessageParamsCopyWithImpl<$Res>
    implements $ShowMessageParamsCopyWith<$Res> {
  _$ShowMessageParamsCopyWithImpl(this._self, this._then);

  final ShowMessageParams _self;
  final $Res Function(ShowMessageParams) _then;

/// Create a copy of ShowMessageParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? message = null,Object? type = null,}) {
  return _then(_self.copyWith(
message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,type: null == type ? _self.type : type // ignore: cast_nullable_to_non_nullable
as MessageType,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _ShowMessageParams implements ShowMessageParams {
  const _ShowMessageParams({required this.message, required this.type});
  factory _ShowMessageParams.fromJson(Map<String, dynamic> json) => _$ShowMessageParamsFromJson(json);

/// The actual message.
@override final  String message;
/// The message type. See {@link MessageType}
@override final  MessageType type;

/// Create a copy of ShowMessageParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ShowMessageParamsCopyWith<_ShowMessageParams> get copyWith => __$ShowMessageParamsCopyWithImpl<_ShowMessageParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ShowMessageParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ShowMessageParams&&(identical(other.message, message) || other.message == message)&&(identical(other.type, type) || other.type == type));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,message,type);

@override
String toString() {
  return 'ShowMessageParams(message: $message, type: $type)';
}


}

/// @nodoc
abstract mixin class _$ShowMessageParamsCopyWith<$Res> implements $ShowMessageParamsCopyWith<$Res> {
  factory _$ShowMessageParamsCopyWith(_ShowMessageParams value, $Res Function(_ShowMessageParams) _then) = __$ShowMessageParamsCopyWithImpl;
@override @useResult
$Res call({
 String message, MessageType type
});




}
/// @nodoc
class __$ShowMessageParamsCopyWithImpl<$Res>
    implements _$ShowMessageParamsCopyWith<$Res> {
  __$ShowMessageParamsCopyWithImpl(this._self, this._then);

  final _ShowMessageParams _self;
  final $Res Function(_ShowMessageParams) _then;

/// Create a copy of ShowMessageParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? message = null,Object? type = null,}) {
  return _then(_ShowMessageParams(
message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,type: null == type ? _self.type : type // ignore: cast_nullable_to_non_nullable
as MessageType,
  ));
}


}


/// @nodoc
mixin _$ShowMessageRequestParams {

/// The message action items to present.
 List<MessageActionItem>? get actions;/// The actual message.
 String get message;/// The message type. See {@link MessageType}
 MessageType get type;
/// Create a copy of ShowMessageRequestParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ShowMessageRequestParamsCopyWith<ShowMessageRequestParams> get copyWith => _$ShowMessageRequestParamsCopyWithImpl<ShowMessageRequestParams>(this as ShowMessageRequestParams, _$identity);

  /// Serializes this ShowMessageRequestParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ShowMessageRequestParams&&const DeepCollectionEquality().equals(other.actions, actions)&&(identical(other.message, message) || other.message == message)&&(identical(other.type, type) || other.type == type));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(actions),message,type);

@override
String toString() {
  return 'ShowMessageRequestParams(actions: $actions, message: $message, type: $type)';
}


}

/// @nodoc
abstract mixin class $ShowMessageRequestParamsCopyWith<$Res>  {
  factory $ShowMessageRequestParamsCopyWith(ShowMessageRequestParams value, $Res Function(ShowMessageRequestParams) _then) = _$ShowMessageRequestParamsCopyWithImpl;
@useResult
$Res call({
 List<MessageActionItem>? actions, String message, MessageType type
});




}
/// @nodoc
class _$ShowMessageRequestParamsCopyWithImpl<$Res>
    implements $ShowMessageRequestParamsCopyWith<$Res> {
  _$ShowMessageRequestParamsCopyWithImpl(this._self, this._then);

  final ShowMessageRequestParams _self;
  final $Res Function(ShowMessageRequestParams) _then;

/// Create a copy of ShowMessageRequestParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? actions = freezed,Object? message = null,Object? type = null,}) {
  return _then(_self.copyWith(
actions: freezed == actions ? _self.actions : actions // ignore: cast_nullable_to_non_nullable
as List<MessageActionItem>?,message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,type: null == type ? _self.type : type // ignore: cast_nullable_to_non_nullable
as MessageType,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _ShowMessageRequestParams implements ShowMessageRequestParams {
  const _ShowMessageRequestParams({final  List<MessageActionItem>? actions, required this.message, required this.type}): _actions = actions;
  factory _ShowMessageRequestParams.fromJson(Map<String, dynamic> json) => _$ShowMessageRequestParamsFromJson(json);

/// The message action items to present.
 final  List<MessageActionItem>? _actions;
/// The message action items to present.
@override List<MessageActionItem>? get actions {
  final value = _actions;
  if (value == null) return null;
  if (_actions is EqualUnmodifiableListView) return _actions;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

/// The actual message.
@override final  String message;
/// The message type. See {@link MessageType}
@override final  MessageType type;

/// Create a copy of ShowMessageRequestParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ShowMessageRequestParamsCopyWith<_ShowMessageRequestParams> get copyWith => __$ShowMessageRequestParamsCopyWithImpl<_ShowMessageRequestParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ShowMessageRequestParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ShowMessageRequestParams&&const DeepCollectionEquality().equals(other._actions, _actions)&&(identical(other.message, message) || other.message == message)&&(identical(other.type, type) || other.type == type));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_actions),message,type);

@override
String toString() {
  return 'ShowMessageRequestParams(actions: $actions, message: $message, type: $type)';
}


}

/// @nodoc
abstract mixin class _$ShowMessageRequestParamsCopyWith<$Res> implements $ShowMessageRequestParamsCopyWith<$Res> {
  factory _$ShowMessageRequestParamsCopyWith(_ShowMessageRequestParams value, $Res Function(_ShowMessageRequestParams) _then) = __$ShowMessageRequestParamsCopyWithImpl;
@override @useResult
$Res call({
 List<MessageActionItem>? actions, String message, MessageType type
});




}
/// @nodoc
class __$ShowMessageRequestParamsCopyWithImpl<$Res>
    implements _$ShowMessageRequestParamsCopyWith<$Res> {
  __$ShowMessageRequestParamsCopyWithImpl(this._self, this._then);

  final _ShowMessageRequestParams _self;
  final $Res Function(_ShowMessageRequestParams) _then;

/// Create a copy of ShowMessageRequestParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? actions = freezed,Object? message = null,Object? type = null,}) {
  return _then(_ShowMessageRequestParams(
actions: freezed == actions ? _self._actions : actions // ignore: cast_nullable_to_non_nullable
as List<MessageActionItem>?,message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,type: null == type ? _self.type : type // ignore: cast_nullable_to_non_nullable
as MessageType,
  ));
}


}


/// @nodoc
mixin _$MessageActionItem {

/// A short title like 'Retry', 'Open Log' etc.
 String get title;
/// Create a copy of MessageActionItem
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$MessageActionItemCopyWith<MessageActionItem> get copyWith => _$MessageActionItemCopyWithImpl<MessageActionItem>(this as MessageActionItem, _$identity);

  /// Serializes this MessageActionItem to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is MessageActionItem&&(identical(other.title, title) || other.title == title));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,title);

@override
String toString() {
  return 'MessageActionItem(title: $title)';
}


}

/// @nodoc
abstract mixin class $MessageActionItemCopyWith<$Res>  {
  factory $MessageActionItemCopyWith(MessageActionItem value, $Res Function(MessageActionItem) _then) = _$MessageActionItemCopyWithImpl;
@useResult
$Res call({
 String title
});




}
/// @nodoc
class _$MessageActionItemCopyWithImpl<$Res>
    implements $MessageActionItemCopyWith<$Res> {
  _$MessageActionItemCopyWithImpl(this._self, this._then);

  final MessageActionItem _self;
  final $Res Function(MessageActionItem) _then;

/// Create a copy of MessageActionItem
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? title = null,}) {
  return _then(_self.copyWith(
title: null == title ? _self.title : title // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _MessageActionItem implements MessageActionItem {
  const _MessageActionItem({required this.title});
  factory _MessageActionItem.fromJson(Map<String, dynamic> json) => _$MessageActionItemFromJson(json);

/// A short title like 'Retry', 'Open Log' etc.
@override final  String title;

/// Create a copy of MessageActionItem
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$MessageActionItemCopyWith<_MessageActionItem> get copyWith => __$MessageActionItemCopyWithImpl<_MessageActionItem>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$MessageActionItemToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _MessageActionItem&&(identical(other.title, title) || other.title == title));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,title);

@override
String toString() {
  return 'MessageActionItem(title: $title)';
}


}

/// @nodoc
abstract mixin class _$MessageActionItemCopyWith<$Res> implements $MessageActionItemCopyWith<$Res> {
  factory _$MessageActionItemCopyWith(_MessageActionItem value, $Res Function(_MessageActionItem) _then) = __$MessageActionItemCopyWithImpl;
@override @useResult
$Res call({
 String title
});




}
/// @nodoc
class __$MessageActionItemCopyWithImpl<$Res>
    implements _$MessageActionItemCopyWith<$Res> {
  __$MessageActionItemCopyWithImpl(this._self, this._then);

  final _MessageActionItem _self;
  final $Res Function(_MessageActionItem) _then;

/// Create a copy of MessageActionItem
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? title = null,}) {
  return _then(_MessageActionItem(
title: null == title ? _self.title : title // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}


/// @nodoc
mixin _$LogMessageParams {

/// The actual message.
 String get message;/// The message type. See {@link MessageType}
 MessageType get type;
/// Create a copy of LogMessageParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LogMessageParamsCopyWith<LogMessageParams> get copyWith => _$LogMessageParamsCopyWithImpl<LogMessageParams>(this as LogMessageParams, _$identity);

  /// Serializes this LogMessageParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LogMessageParams&&(identical(other.message, message) || other.message == message)&&(identical(other.type, type) || other.type == type));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,message,type);

@override
String toString() {
  return 'LogMessageParams(message: $message, type: $type)';
}


}

/// @nodoc
abstract mixin class $LogMessageParamsCopyWith<$Res>  {
  factory $LogMessageParamsCopyWith(LogMessageParams value, $Res Function(LogMessageParams) _then) = _$LogMessageParamsCopyWithImpl;
@useResult
$Res call({
 String message, MessageType type
});




}
/// @nodoc
class _$LogMessageParamsCopyWithImpl<$Res>
    implements $LogMessageParamsCopyWith<$Res> {
  _$LogMessageParamsCopyWithImpl(this._self, this._then);

  final LogMessageParams _self;
  final $Res Function(LogMessageParams) _then;

/// Create a copy of LogMessageParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? message = null,Object? type = null,}) {
  return _then(_self.copyWith(
message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,type: null == type ? _self.type : type // ignore: cast_nullable_to_non_nullable
as MessageType,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _LogMessageParams implements LogMessageParams {
  const _LogMessageParams({required this.message, required this.type});
  factory _LogMessageParams.fromJson(Map<String, dynamic> json) => _$LogMessageParamsFromJson(json);

/// The actual message.
@override final  String message;
/// The message type. See {@link MessageType}
@override final  MessageType type;

/// Create a copy of LogMessageParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$LogMessageParamsCopyWith<_LogMessageParams> get copyWith => __$LogMessageParamsCopyWithImpl<_LogMessageParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$LogMessageParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _LogMessageParams&&(identical(other.message, message) || other.message == message)&&(identical(other.type, type) || other.type == type));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,message,type);

@override
String toString() {
  return 'LogMessageParams(message: $message, type: $type)';
}


}

/// @nodoc
abstract mixin class _$LogMessageParamsCopyWith<$Res> implements $LogMessageParamsCopyWith<$Res> {
  factory _$LogMessageParamsCopyWith(_LogMessageParams value, $Res Function(_LogMessageParams) _then) = __$LogMessageParamsCopyWithImpl;
@override @useResult
$Res call({
 String message, MessageType type
});




}
/// @nodoc
class __$LogMessageParamsCopyWithImpl<$Res>
    implements _$LogMessageParamsCopyWith<$Res> {
  __$LogMessageParamsCopyWithImpl(this._self, this._then);

  final _LogMessageParams _self;
  final $Res Function(_LogMessageParams) _then;

/// Create a copy of LogMessageParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? message = null,Object? type = null,}) {
  return _then(_LogMessageParams(
message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,type: null == type ? _self.type : type // ignore: cast_nullable_to_non_nullable
as MessageType,
  ));
}


}


/// @nodoc
mixin _$DidOpenTextDocumentParams {

/// The document that was opened.
 TextDocumentItem get textDocument;
/// Create a copy of DidOpenTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DidOpenTextDocumentParamsCopyWith<DidOpenTextDocumentParams> get copyWith => _$DidOpenTextDocumentParamsCopyWithImpl<DidOpenTextDocumentParams>(this as DidOpenTextDocumentParams, _$identity);

  /// Serializes this DidOpenTextDocumentParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DidOpenTextDocumentParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument);

@override
String toString() {
  return 'DidOpenTextDocumentParams(textDocument: $textDocument)';
}


}

/// @nodoc
abstract mixin class $DidOpenTextDocumentParamsCopyWith<$Res>  {
  factory $DidOpenTextDocumentParamsCopyWith(DidOpenTextDocumentParams value, $Res Function(DidOpenTextDocumentParams) _then) = _$DidOpenTextDocumentParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentItem textDocument
});


$TextDocumentItemCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$DidOpenTextDocumentParamsCopyWithImpl<$Res>
    implements $DidOpenTextDocumentParamsCopyWith<$Res> {
  _$DidOpenTextDocumentParamsCopyWithImpl(this._self, this._then);

  final DidOpenTextDocumentParams _self;
  final $Res Function(DidOpenTextDocumentParams) _then;

/// Create a copy of DidOpenTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentItem,
  ));
}
/// Create a copy of DidOpenTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentItemCopyWith<$Res> get textDocument {
  
  return $TextDocumentItemCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _DidOpenTextDocumentParams implements DidOpenTextDocumentParams {
  const _DidOpenTextDocumentParams({required this.textDocument});
  factory _DidOpenTextDocumentParams.fromJson(Map<String, dynamic> json) => _$DidOpenTextDocumentParamsFromJson(json);

/// The document that was opened.
@override final  TextDocumentItem textDocument;

/// Create a copy of DidOpenTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DidOpenTextDocumentParamsCopyWith<_DidOpenTextDocumentParams> get copyWith => __$DidOpenTextDocumentParamsCopyWithImpl<_DidOpenTextDocumentParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DidOpenTextDocumentParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DidOpenTextDocumentParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument);

@override
String toString() {
  return 'DidOpenTextDocumentParams(textDocument: $textDocument)';
}


}

/// @nodoc
abstract mixin class _$DidOpenTextDocumentParamsCopyWith<$Res> implements $DidOpenTextDocumentParamsCopyWith<$Res> {
  factory _$DidOpenTextDocumentParamsCopyWith(_DidOpenTextDocumentParams value, $Res Function(_DidOpenTextDocumentParams) _then) = __$DidOpenTextDocumentParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentItem textDocument
});


@override $TextDocumentItemCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$DidOpenTextDocumentParamsCopyWithImpl<$Res>
    implements _$DidOpenTextDocumentParamsCopyWith<$Res> {
  __$DidOpenTextDocumentParamsCopyWithImpl(this._self, this._then);

  final _DidOpenTextDocumentParams _self;
  final $Res Function(_DidOpenTextDocumentParams) _then;

/// Create a copy of DidOpenTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,}) {
  return _then(_DidOpenTextDocumentParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentItem,
  ));
}

/// Create a copy of DidOpenTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentItemCopyWith<$Res> get textDocument {
  
  return $TextDocumentItemCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$DidChangeTextDocumentParams {

/// The actual content changes. The content changes describe single state
/// changes to the document. So if there are two content changes c1 (at
/// array index 0) and c2 (at array index 1) for a document in state S then
/// c1 moves the document from S to S' and c2 from S' to S''. So c1 is
/// computed on the state S and c2 is computed on the state S'.
/// To mirror the content of a document using change events use the
/// following approach: - start with the same initial content - apply the
/// 'textDocument/didChange' notifications in the order you receive them. -
/// apply the `TextDocumentContentChangeEvent`s in a single notification in
/// the order you receive them.
 List<TextDocumentContentChangeEvent> get contentChanges;/// The document that did change. The version number points to the version
/// after all provided content changes have been applied.
 VersionedTextDocumentIdentifier get textDocument;
/// Create a copy of DidChangeTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DidChangeTextDocumentParamsCopyWith<DidChangeTextDocumentParams> get copyWith => _$DidChangeTextDocumentParamsCopyWithImpl<DidChangeTextDocumentParams>(this as DidChangeTextDocumentParams, _$identity);

  /// Serializes this DidChangeTextDocumentParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DidChangeTextDocumentParams&&const DeepCollectionEquality().equals(other.contentChanges, contentChanges)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(contentChanges),textDocument);

@override
String toString() {
  return 'DidChangeTextDocumentParams(contentChanges: $contentChanges, textDocument: $textDocument)';
}


}

/// @nodoc
abstract mixin class $DidChangeTextDocumentParamsCopyWith<$Res>  {
  factory $DidChangeTextDocumentParamsCopyWith(DidChangeTextDocumentParams value, $Res Function(DidChangeTextDocumentParams) _then) = _$DidChangeTextDocumentParamsCopyWithImpl;
@useResult
$Res call({
 List<TextDocumentContentChangeEvent> contentChanges, VersionedTextDocumentIdentifier textDocument
});


$VersionedTextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$DidChangeTextDocumentParamsCopyWithImpl<$Res>
    implements $DidChangeTextDocumentParamsCopyWith<$Res> {
  _$DidChangeTextDocumentParamsCopyWithImpl(this._self, this._then);

  final DidChangeTextDocumentParams _self;
  final $Res Function(DidChangeTextDocumentParams) _then;

/// Create a copy of DidChangeTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? contentChanges = null,Object? textDocument = null,}) {
  return _then(_self.copyWith(
contentChanges: null == contentChanges ? _self.contentChanges : contentChanges // ignore: cast_nullable_to_non_nullable
as List<TextDocumentContentChangeEvent>,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as VersionedTextDocumentIdentifier,
  ));
}
/// Create a copy of DidChangeTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$VersionedTextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $VersionedTextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _DidChangeTextDocumentParams implements DidChangeTextDocumentParams {
  const _DidChangeTextDocumentParams({required final  List<TextDocumentContentChangeEvent> contentChanges, required this.textDocument}): _contentChanges = contentChanges;
  factory _DidChangeTextDocumentParams.fromJson(Map<String, dynamic> json) => _$DidChangeTextDocumentParamsFromJson(json);

/// The actual content changes. The content changes describe single state
/// changes to the document. So if there are two content changes c1 (at
/// array index 0) and c2 (at array index 1) for a document in state S then
/// c1 moves the document from S to S' and c2 from S' to S''. So c1 is
/// computed on the state S and c2 is computed on the state S'.
/// To mirror the content of a document using change events use the
/// following approach: - start with the same initial content - apply the
/// 'textDocument/didChange' notifications in the order you receive them. -
/// apply the `TextDocumentContentChangeEvent`s in a single notification in
/// the order you receive them.
 final  List<TextDocumentContentChangeEvent> _contentChanges;
/// The actual content changes. The content changes describe single state
/// changes to the document. So if there are two content changes c1 (at
/// array index 0) and c2 (at array index 1) for a document in state S then
/// c1 moves the document from S to S' and c2 from S' to S''. So c1 is
/// computed on the state S and c2 is computed on the state S'.
/// To mirror the content of a document using change events use the
/// following approach: - start with the same initial content - apply the
/// 'textDocument/didChange' notifications in the order you receive them. -
/// apply the `TextDocumentContentChangeEvent`s in a single notification in
/// the order you receive them.
@override List<TextDocumentContentChangeEvent> get contentChanges {
  if (_contentChanges is EqualUnmodifiableListView) return _contentChanges;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_contentChanges);
}

/// The document that did change. The version number points to the version
/// after all provided content changes have been applied.
@override final  VersionedTextDocumentIdentifier textDocument;

/// Create a copy of DidChangeTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DidChangeTextDocumentParamsCopyWith<_DidChangeTextDocumentParams> get copyWith => __$DidChangeTextDocumentParamsCopyWithImpl<_DidChangeTextDocumentParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DidChangeTextDocumentParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DidChangeTextDocumentParams&&const DeepCollectionEquality().equals(other._contentChanges, _contentChanges)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_contentChanges),textDocument);

@override
String toString() {
  return 'DidChangeTextDocumentParams(contentChanges: $contentChanges, textDocument: $textDocument)';
}


}

/// @nodoc
abstract mixin class _$DidChangeTextDocumentParamsCopyWith<$Res> implements $DidChangeTextDocumentParamsCopyWith<$Res> {
  factory _$DidChangeTextDocumentParamsCopyWith(_DidChangeTextDocumentParams value, $Res Function(_DidChangeTextDocumentParams) _then) = __$DidChangeTextDocumentParamsCopyWithImpl;
@override @useResult
$Res call({
 List<TextDocumentContentChangeEvent> contentChanges, VersionedTextDocumentIdentifier textDocument
});


@override $VersionedTextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$DidChangeTextDocumentParamsCopyWithImpl<$Res>
    implements _$DidChangeTextDocumentParamsCopyWith<$Res> {
  __$DidChangeTextDocumentParamsCopyWithImpl(this._self, this._then);

  final _DidChangeTextDocumentParams _self;
  final $Res Function(_DidChangeTextDocumentParams) _then;

/// Create a copy of DidChangeTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? contentChanges = null,Object? textDocument = null,}) {
  return _then(_DidChangeTextDocumentParams(
contentChanges: null == contentChanges ? _self._contentChanges : contentChanges // ignore: cast_nullable_to_non_nullable
as List<TextDocumentContentChangeEvent>,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as VersionedTextDocumentIdentifier,
  ));
}

/// Create a copy of DidChangeTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$VersionedTextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $VersionedTextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$TextDocumentChangeRegistrationOptions {

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
 Sealed14 get documentSelector;/// How documents are synced to the server.
 TextDocumentSyncKind get syncKind;
/// Create a copy of TextDocumentChangeRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TextDocumentChangeRegistrationOptionsCopyWith<TextDocumentChangeRegistrationOptions> get copyWith => _$TextDocumentChangeRegistrationOptionsCopyWithImpl<TextDocumentChangeRegistrationOptions>(this as TextDocumentChangeRegistrationOptions, _$identity);

  /// Serializes this TextDocumentChangeRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TextDocumentChangeRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.syncKind, syncKind) || other.syncKind == syncKind));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,syncKind);

@override
String toString() {
  return 'TextDocumentChangeRegistrationOptions(documentSelector: $documentSelector, syncKind: $syncKind)';
}


}

/// @nodoc
abstract mixin class $TextDocumentChangeRegistrationOptionsCopyWith<$Res>  {
  factory $TextDocumentChangeRegistrationOptionsCopyWith(TextDocumentChangeRegistrationOptions value, $Res Function(TextDocumentChangeRegistrationOptions) _then) = _$TextDocumentChangeRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 Sealed14 documentSelector, TextDocumentSyncKind syncKind
});




}
/// @nodoc
class _$TextDocumentChangeRegistrationOptionsCopyWithImpl<$Res>
    implements $TextDocumentChangeRegistrationOptionsCopyWith<$Res> {
  _$TextDocumentChangeRegistrationOptionsCopyWithImpl(this._self, this._then);

  final TextDocumentChangeRegistrationOptions _self;
  final $Res Function(TextDocumentChangeRegistrationOptions) _then;

/// Create a copy of TextDocumentChangeRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = null,Object? syncKind = null,}) {
  return _then(_self.copyWith(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,syncKind: null == syncKind ? _self.syncKind : syncKind // ignore: cast_nullable_to_non_nullable
as TextDocumentSyncKind,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _TextDocumentChangeRegistrationOptions implements TextDocumentChangeRegistrationOptions {
  const _TextDocumentChangeRegistrationOptions({required this.documentSelector, required this.syncKind});
  factory _TextDocumentChangeRegistrationOptions.fromJson(Map<String, dynamic> json) => _$TextDocumentChangeRegistrationOptionsFromJson(json);

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
@override final  Sealed14 documentSelector;
/// How documents are synced to the server.
@override final  TextDocumentSyncKind syncKind;

/// Create a copy of TextDocumentChangeRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TextDocumentChangeRegistrationOptionsCopyWith<_TextDocumentChangeRegistrationOptions> get copyWith => __$TextDocumentChangeRegistrationOptionsCopyWithImpl<_TextDocumentChangeRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TextDocumentChangeRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TextDocumentChangeRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.syncKind, syncKind) || other.syncKind == syncKind));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,syncKind);

@override
String toString() {
  return 'TextDocumentChangeRegistrationOptions(documentSelector: $documentSelector, syncKind: $syncKind)';
}


}

/// @nodoc
abstract mixin class _$TextDocumentChangeRegistrationOptionsCopyWith<$Res> implements $TextDocumentChangeRegistrationOptionsCopyWith<$Res> {
  factory _$TextDocumentChangeRegistrationOptionsCopyWith(_TextDocumentChangeRegistrationOptions value, $Res Function(_TextDocumentChangeRegistrationOptions) _then) = __$TextDocumentChangeRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 Sealed14 documentSelector, TextDocumentSyncKind syncKind
});




}
/// @nodoc
class __$TextDocumentChangeRegistrationOptionsCopyWithImpl<$Res>
    implements _$TextDocumentChangeRegistrationOptionsCopyWith<$Res> {
  __$TextDocumentChangeRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _TextDocumentChangeRegistrationOptions _self;
  final $Res Function(_TextDocumentChangeRegistrationOptions) _then;

/// Create a copy of TextDocumentChangeRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = null,Object? syncKind = null,}) {
  return _then(_TextDocumentChangeRegistrationOptions(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,syncKind: null == syncKind ? _self.syncKind : syncKind // ignore: cast_nullable_to_non_nullable
as TextDocumentSyncKind,
  ));
}


}


/// @nodoc
mixin _$DidCloseTextDocumentParams {

/// The document that was closed.
 TextDocumentIdentifier get textDocument;
/// Create a copy of DidCloseTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DidCloseTextDocumentParamsCopyWith<DidCloseTextDocumentParams> get copyWith => _$DidCloseTextDocumentParamsCopyWithImpl<DidCloseTextDocumentParams>(this as DidCloseTextDocumentParams, _$identity);

  /// Serializes this DidCloseTextDocumentParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DidCloseTextDocumentParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument);

@override
String toString() {
  return 'DidCloseTextDocumentParams(textDocument: $textDocument)';
}


}

/// @nodoc
abstract mixin class $DidCloseTextDocumentParamsCopyWith<$Res>  {
  factory $DidCloseTextDocumentParamsCopyWith(DidCloseTextDocumentParams value, $Res Function(DidCloseTextDocumentParams) _then) = _$DidCloseTextDocumentParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentIdentifier textDocument
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$DidCloseTextDocumentParamsCopyWithImpl<$Res>
    implements $DidCloseTextDocumentParamsCopyWith<$Res> {
  _$DidCloseTextDocumentParamsCopyWithImpl(this._self, this._then);

  final DidCloseTextDocumentParams _self;
  final $Res Function(DidCloseTextDocumentParams) _then;

/// Create a copy of DidCloseTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? textDocument = null,}) {
  return _then(_self.copyWith(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,
  ));
}
/// Create a copy of DidCloseTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _DidCloseTextDocumentParams implements DidCloseTextDocumentParams {
  const _DidCloseTextDocumentParams({required this.textDocument});
  factory _DidCloseTextDocumentParams.fromJson(Map<String, dynamic> json) => _$DidCloseTextDocumentParamsFromJson(json);

/// The document that was closed.
@override final  TextDocumentIdentifier textDocument;

/// Create a copy of DidCloseTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DidCloseTextDocumentParamsCopyWith<_DidCloseTextDocumentParams> get copyWith => __$DidCloseTextDocumentParamsCopyWithImpl<_DidCloseTextDocumentParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DidCloseTextDocumentParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DidCloseTextDocumentParams&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,textDocument);

@override
String toString() {
  return 'DidCloseTextDocumentParams(textDocument: $textDocument)';
}


}

/// @nodoc
abstract mixin class _$DidCloseTextDocumentParamsCopyWith<$Res> implements $DidCloseTextDocumentParamsCopyWith<$Res> {
  factory _$DidCloseTextDocumentParamsCopyWith(_DidCloseTextDocumentParams value, $Res Function(_DidCloseTextDocumentParams) _then) = __$DidCloseTextDocumentParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentIdentifier textDocument
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$DidCloseTextDocumentParamsCopyWithImpl<$Res>
    implements _$DidCloseTextDocumentParamsCopyWith<$Res> {
  __$DidCloseTextDocumentParamsCopyWithImpl(this._self, this._then);

  final _DidCloseTextDocumentParams _self;
  final $Res Function(_DidCloseTextDocumentParams) _then;

/// Create a copy of DidCloseTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? textDocument = null,}) {
  return _then(_DidCloseTextDocumentParams(
textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,
  ));
}

/// Create a copy of DidCloseTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$DidSaveTextDocumentParams {

/// Optional the content when saved. Depends on the includeText value when
/// the save notification was requested.
 String? get text;/// The document that was saved.
 TextDocumentIdentifier get textDocument;
/// Create a copy of DidSaveTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DidSaveTextDocumentParamsCopyWith<DidSaveTextDocumentParams> get copyWith => _$DidSaveTextDocumentParamsCopyWithImpl<DidSaveTextDocumentParams>(this as DidSaveTextDocumentParams, _$identity);

  /// Serializes this DidSaveTextDocumentParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DidSaveTextDocumentParams&&(identical(other.text, text) || other.text == text)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,text,textDocument);

@override
String toString() {
  return 'DidSaveTextDocumentParams(text: $text, textDocument: $textDocument)';
}


}

/// @nodoc
abstract mixin class $DidSaveTextDocumentParamsCopyWith<$Res>  {
  factory $DidSaveTextDocumentParamsCopyWith(DidSaveTextDocumentParams value, $Res Function(DidSaveTextDocumentParams) _then) = _$DidSaveTextDocumentParamsCopyWithImpl;
@useResult
$Res call({
 String? text, TextDocumentIdentifier textDocument
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$DidSaveTextDocumentParamsCopyWithImpl<$Res>
    implements $DidSaveTextDocumentParamsCopyWith<$Res> {
  _$DidSaveTextDocumentParamsCopyWithImpl(this._self, this._then);

  final DidSaveTextDocumentParams _self;
  final $Res Function(DidSaveTextDocumentParams) _then;

/// Create a copy of DidSaveTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? text = freezed,Object? textDocument = null,}) {
  return _then(_self.copyWith(
text: freezed == text ? _self.text : text // ignore: cast_nullable_to_non_nullable
as String?,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,
  ));
}
/// Create a copy of DidSaveTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _DidSaveTextDocumentParams implements DidSaveTextDocumentParams {
  const _DidSaveTextDocumentParams({this.text, required this.textDocument});
  factory _DidSaveTextDocumentParams.fromJson(Map<String, dynamic> json) => _$DidSaveTextDocumentParamsFromJson(json);

/// Optional the content when saved. Depends on the includeText value when
/// the save notification was requested.
@override final  String? text;
/// The document that was saved.
@override final  TextDocumentIdentifier textDocument;

/// Create a copy of DidSaveTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DidSaveTextDocumentParamsCopyWith<_DidSaveTextDocumentParams> get copyWith => __$DidSaveTextDocumentParamsCopyWithImpl<_DidSaveTextDocumentParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DidSaveTextDocumentParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DidSaveTextDocumentParams&&(identical(other.text, text) || other.text == text)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,text,textDocument);

@override
String toString() {
  return 'DidSaveTextDocumentParams(text: $text, textDocument: $textDocument)';
}


}

/// @nodoc
abstract mixin class _$DidSaveTextDocumentParamsCopyWith<$Res> implements $DidSaveTextDocumentParamsCopyWith<$Res> {
  factory _$DidSaveTextDocumentParamsCopyWith(_DidSaveTextDocumentParams value, $Res Function(_DidSaveTextDocumentParams) _then) = __$DidSaveTextDocumentParamsCopyWithImpl;
@override @useResult
$Res call({
 String? text, TextDocumentIdentifier textDocument
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$DidSaveTextDocumentParamsCopyWithImpl<$Res>
    implements _$DidSaveTextDocumentParamsCopyWith<$Res> {
  __$DidSaveTextDocumentParamsCopyWithImpl(this._self, this._then);

  final _DidSaveTextDocumentParams _self;
  final $Res Function(_DidSaveTextDocumentParams) _then;

/// Create a copy of DidSaveTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? text = freezed,Object? textDocument = null,}) {
  return _then(_DidSaveTextDocumentParams(
text: freezed == text ? _self.text : text // ignore: cast_nullable_to_non_nullable
as String?,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,
  ));
}

/// Create a copy of DidSaveTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$TextDocumentSaveRegistrationOptions {

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
 Sealed14 get documentSelector;/// The client is supposed to include the content on save.
 bool? get includeText;
/// Create a copy of TextDocumentSaveRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TextDocumentSaveRegistrationOptionsCopyWith<TextDocumentSaveRegistrationOptions> get copyWith => _$TextDocumentSaveRegistrationOptionsCopyWithImpl<TextDocumentSaveRegistrationOptions>(this as TextDocumentSaveRegistrationOptions, _$identity);

  /// Serializes this TextDocumentSaveRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TextDocumentSaveRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.includeText, includeText) || other.includeText == includeText));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,includeText);

@override
String toString() {
  return 'TextDocumentSaveRegistrationOptions(documentSelector: $documentSelector, includeText: $includeText)';
}


}

/// @nodoc
abstract mixin class $TextDocumentSaveRegistrationOptionsCopyWith<$Res>  {
  factory $TextDocumentSaveRegistrationOptionsCopyWith(TextDocumentSaveRegistrationOptions value, $Res Function(TextDocumentSaveRegistrationOptions) _then) = _$TextDocumentSaveRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 Sealed14 documentSelector, bool? includeText
});




}
/// @nodoc
class _$TextDocumentSaveRegistrationOptionsCopyWithImpl<$Res>
    implements $TextDocumentSaveRegistrationOptionsCopyWith<$Res> {
  _$TextDocumentSaveRegistrationOptionsCopyWithImpl(this._self, this._then);

  final TextDocumentSaveRegistrationOptions _self;
  final $Res Function(TextDocumentSaveRegistrationOptions) _then;

/// Create a copy of TextDocumentSaveRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = null,Object? includeText = freezed,}) {
  return _then(_self.copyWith(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,includeText: freezed == includeText ? _self.includeText : includeText // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _TextDocumentSaveRegistrationOptions implements TextDocumentSaveRegistrationOptions {
  const _TextDocumentSaveRegistrationOptions({required this.documentSelector, this.includeText});
  factory _TextDocumentSaveRegistrationOptions.fromJson(Map<String, dynamic> json) => _$TextDocumentSaveRegistrationOptionsFromJson(json);

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
@override final  Sealed14 documentSelector;
/// The client is supposed to include the content on save.
@override final  bool? includeText;

/// Create a copy of TextDocumentSaveRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TextDocumentSaveRegistrationOptionsCopyWith<_TextDocumentSaveRegistrationOptions> get copyWith => __$TextDocumentSaveRegistrationOptionsCopyWithImpl<_TextDocumentSaveRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TextDocumentSaveRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TextDocumentSaveRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.includeText, includeText) || other.includeText == includeText));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,includeText);

@override
String toString() {
  return 'TextDocumentSaveRegistrationOptions(documentSelector: $documentSelector, includeText: $includeText)';
}


}

/// @nodoc
abstract mixin class _$TextDocumentSaveRegistrationOptionsCopyWith<$Res> implements $TextDocumentSaveRegistrationOptionsCopyWith<$Res> {
  factory _$TextDocumentSaveRegistrationOptionsCopyWith(_TextDocumentSaveRegistrationOptions value, $Res Function(_TextDocumentSaveRegistrationOptions) _then) = __$TextDocumentSaveRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 Sealed14 documentSelector, bool? includeText
});




}
/// @nodoc
class __$TextDocumentSaveRegistrationOptionsCopyWithImpl<$Res>
    implements _$TextDocumentSaveRegistrationOptionsCopyWith<$Res> {
  __$TextDocumentSaveRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _TextDocumentSaveRegistrationOptions _self;
  final $Res Function(_TextDocumentSaveRegistrationOptions) _then;

/// Create a copy of TextDocumentSaveRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = null,Object? includeText = freezed,}) {
  return _then(_TextDocumentSaveRegistrationOptions(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,includeText: freezed == includeText ? _self.includeText : includeText // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$WillSaveTextDocumentParams {

/// The 'TextDocumentSaveReason'.
 TextDocumentSaveReason get reason;/// The document that will be saved.
 TextDocumentIdentifier get textDocument;
/// Create a copy of WillSaveTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WillSaveTextDocumentParamsCopyWith<WillSaveTextDocumentParams> get copyWith => _$WillSaveTextDocumentParamsCopyWithImpl<WillSaveTextDocumentParams>(this as WillSaveTextDocumentParams, _$identity);

  /// Serializes this WillSaveTextDocumentParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WillSaveTextDocumentParams&&(identical(other.reason, reason) || other.reason == reason)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,reason,textDocument);

@override
String toString() {
  return 'WillSaveTextDocumentParams(reason: $reason, textDocument: $textDocument)';
}


}

/// @nodoc
abstract mixin class $WillSaveTextDocumentParamsCopyWith<$Res>  {
  factory $WillSaveTextDocumentParamsCopyWith(WillSaveTextDocumentParams value, $Res Function(WillSaveTextDocumentParams) _then) = _$WillSaveTextDocumentParamsCopyWithImpl;
@useResult
$Res call({
 TextDocumentSaveReason reason, TextDocumentIdentifier textDocument
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$WillSaveTextDocumentParamsCopyWithImpl<$Res>
    implements $WillSaveTextDocumentParamsCopyWith<$Res> {
  _$WillSaveTextDocumentParamsCopyWithImpl(this._self, this._then);

  final WillSaveTextDocumentParams _self;
  final $Res Function(WillSaveTextDocumentParams) _then;

/// Create a copy of WillSaveTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? reason = null,Object? textDocument = null,}) {
  return _then(_self.copyWith(
reason: null == reason ? _self.reason : reason // ignore: cast_nullable_to_non_nullable
as TextDocumentSaveReason,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,
  ));
}
/// Create a copy of WillSaveTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _WillSaveTextDocumentParams implements WillSaveTextDocumentParams {
  const _WillSaveTextDocumentParams({required this.reason, required this.textDocument});
  factory _WillSaveTextDocumentParams.fromJson(Map<String, dynamic> json) => _$WillSaveTextDocumentParamsFromJson(json);

/// The 'TextDocumentSaveReason'.
@override final  TextDocumentSaveReason reason;
/// The document that will be saved.
@override final  TextDocumentIdentifier textDocument;

/// Create a copy of WillSaveTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WillSaveTextDocumentParamsCopyWith<_WillSaveTextDocumentParams> get copyWith => __$WillSaveTextDocumentParamsCopyWithImpl<_WillSaveTextDocumentParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WillSaveTextDocumentParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WillSaveTextDocumentParams&&(identical(other.reason, reason) || other.reason == reason)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,reason,textDocument);

@override
String toString() {
  return 'WillSaveTextDocumentParams(reason: $reason, textDocument: $textDocument)';
}


}

/// @nodoc
abstract mixin class _$WillSaveTextDocumentParamsCopyWith<$Res> implements $WillSaveTextDocumentParamsCopyWith<$Res> {
  factory _$WillSaveTextDocumentParamsCopyWith(_WillSaveTextDocumentParams value, $Res Function(_WillSaveTextDocumentParams) _then) = __$WillSaveTextDocumentParamsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentSaveReason reason, TextDocumentIdentifier textDocument
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$WillSaveTextDocumentParamsCopyWithImpl<$Res>
    implements _$WillSaveTextDocumentParamsCopyWith<$Res> {
  __$WillSaveTextDocumentParamsCopyWithImpl(this._self, this._then);

  final _WillSaveTextDocumentParams _self;
  final $Res Function(_WillSaveTextDocumentParams) _then;

/// Create a copy of WillSaveTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? reason = null,Object? textDocument = null,}) {
  return _then(_WillSaveTextDocumentParams(
reason: null == reason ? _self.reason : reason // ignore: cast_nullable_to_non_nullable
as TextDocumentSaveReason,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,
  ));
}

/// Create a copy of WillSaveTextDocumentParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$TextEdit {

/// The string to be inserted. For delete operations use an empty string.
 String get newText;/// The range of the text document to be manipulated. To insert text into a
/// document create a range where start === end.
 Range get range;
/// Create a copy of TextEdit
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TextEditCopyWith<TextEdit> get copyWith => _$TextEditCopyWithImpl<TextEdit>(this as TextEdit, _$identity);

  /// Serializes this TextEdit to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TextEdit&&(identical(other.newText, newText) || other.newText == newText)&&(identical(other.range, range) || other.range == range));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,newText,range);

@override
String toString() {
  return 'TextEdit(newText: $newText, range: $range)';
}


}

/// @nodoc
abstract mixin class $TextEditCopyWith<$Res>  {
  factory $TextEditCopyWith(TextEdit value, $Res Function(TextEdit) _then) = _$TextEditCopyWithImpl;
@useResult
$Res call({
 String newText, Range range
});


$RangeCopyWith<$Res> get range;

}
/// @nodoc
class _$TextEditCopyWithImpl<$Res>
    implements $TextEditCopyWith<$Res> {
  _$TextEditCopyWithImpl(this._self, this._then);

  final TextEdit _self;
  final $Res Function(TextEdit) _then;

/// Create a copy of TextEdit
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? newText = null,Object? range = null,}) {
  return _then(_self.copyWith(
newText: null == newText ? _self.newText : newText // ignore: cast_nullable_to_non_nullable
as String,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,
  ));
}
/// Create a copy of TextEdit
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _TextEdit implements TextEdit {
  const _TextEdit({required this.newText, required this.range});
  factory _TextEdit.fromJson(Map<String, dynamic> json) => _$TextEditFromJson(json);

/// The string to be inserted. For delete operations use an empty string.
@override final  String newText;
/// The range of the text document to be manipulated. To insert text into a
/// document create a range where start === end.
@override final  Range range;

/// Create a copy of TextEdit
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TextEditCopyWith<_TextEdit> get copyWith => __$TextEditCopyWithImpl<_TextEdit>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TextEditToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TextEdit&&(identical(other.newText, newText) || other.newText == newText)&&(identical(other.range, range) || other.range == range));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,newText,range);

@override
String toString() {
  return 'TextEdit(newText: $newText, range: $range)';
}


}

/// @nodoc
abstract mixin class _$TextEditCopyWith<$Res> implements $TextEditCopyWith<$Res> {
  factory _$TextEditCopyWith(_TextEdit value, $Res Function(_TextEdit) _then) = __$TextEditCopyWithImpl;
@override @useResult
$Res call({
 String newText, Range range
});


@override $RangeCopyWith<$Res> get range;

}
/// @nodoc
class __$TextEditCopyWithImpl<$Res>
    implements _$TextEditCopyWith<$Res> {
  __$TextEditCopyWithImpl(this._self, this._then);

  final _TextEdit _self;
  final $Res Function(_TextEdit) _then;

/// Create a copy of TextEdit
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? newText = null,Object? range = null,}) {
  return _then(_TextEdit(
newText: null == newText ? _self.newText : newText // ignore: cast_nullable_to_non_nullable
as String,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,
  ));
}

/// Create a copy of TextEdit
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}


/// @nodoc
mixin _$DidChangeWatchedFilesParams {

/// The actual file events.
 List<FileEvent> get changes;
/// Create a copy of DidChangeWatchedFilesParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DidChangeWatchedFilesParamsCopyWith<DidChangeWatchedFilesParams> get copyWith => _$DidChangeWatchedFilesParamsCopyWithImpl<DidChangeWatchedFilesParams>(this as DidChangeWatchedFilesParams, _$identity);

  /// Serializes this DidChangeWatchedFilesParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DidChangeWatchedFilesParams&&const DeepCollectionEquality().equals(other.changes, changes));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(changes));

@override
String toString() {
  return 'DidChangeWatchedFilesParams(changes: $changes)';
}


}

/// @nodoc
abstract mixin class $DidChangeWatchedFilesParamsCopyWith<$Res>  {
  factory $DidChangeWatchedFilesParamsCopyWith(DidChangeWatchedFilesParams value, $Res Function(DidChangeWatchedFilesParams) _then) = _$DidChangeWatchedFilesParamsCopyWithImpl;
@useResult
$Res call({
 List<FileEvent> changes
});




}
/// @nodoc
class _$DidChangeWatchedFilesParamsCopyWithImpl<$Res>
    implements $DidChangeWatchedFilesParamsCopyWith<$Res> {
  _$DidChangeWatchedFilesParamsCopyWithImpl(this._self, this._then);

  final DidChangeWatchedFilesParams _self;
  final $Res Function(DidChangeWatchedFilesParams) _then;

/// Create a copy of DidChangeWatchedFilesParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? changes = null,}) {
  return _then(_self.copyWith(
changes: null == changes ? _self.changes : changes // ignore: cast_nullable_to_non_nullable
as List<FileEvent>,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DidChangeWatchedFilesParams implements DidChangeWatchedFilesParams {
  const _DidChangeWatchedFilesParams({required final  List<FileEvent> changes}): _changes = changes;
  factory _DidChangeWatchedFilesParams.fromJson(Map<String, dynamic> json) => _$DidChangeWatchedFilesParamsFromJson(json);

/// The actual file events.
 final  List<FileEvent> _changes;
/// The actual file events.
@override List<FileEvent> get changes {
  if (_changes is EqualUnmodifiableListView) return _changes;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_changes);
}


/// Create a copy of DidChangeWatchedFilesParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DidChangeWatchedFilesParamsCopyWith<_DidChangeWatchedFilesParams> get copyWith => __$DidChangeWatchedFilesParamsCopyWithImpl<_DidChangeWatchedFilesParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DidChangeWatchedFilesParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DidChangeWatchedFilesParams&&const DeepCollectionEquality().equals(other._changes, _changes));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_changes));

@override
String toString() {
  return 'DidChangeWatchedFilesParams(changes: $changes)';
}


}

/// @nodoc
abstract mixin class _$DidChangeWatchedFilesParamsCopyWith<$Res> implements $DidChangeWatchedFilesParamsCopyWith<$Res> {
  factory _$DidChangeWatchedFilesParamsCopyWith(_DidChangeWatchedFilesParams value, $Res Function(_DidChangeWatchedFilesParams) _then) = __$DidChangeWatchedFilesParamsCopyWithImpl;
@override @useResult
$Res call({
 List<FileEvent> changes
});




}
/// @nodoc
class __$DidChangeWatchedFilesParamsCopyWithImpl<$Res>
    implements _$DidChangeWatchedFilesParamsCopyWith<$Res> {
  __$DidChangeWatchedFilesParamsCopyWithImpl(this._self, this._then);

  final _DidChangeWatchedFilesParams _self;
  final $Res Function(_DidChangeWatchedFilesParams) _then;

/// Create a copy of DidChangeWatchedFilesParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? changes = null,}) {
  return _then(_DidChangeWatchedFilesParams(
changes: null == changes ? _self._changes : changes // ignore: cast_nullable_to_non_nullable
as List<FileEvent>,
  ));
}


}


/// @nodoc
mixin _$DidChangeWatchedFilesRegistrationOptions {

/// The watchers to register.
 List<FileSystemWatcher> get watchers;
/// Create a copy of DidChangeWatchedFilesRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DidChangeWatchedFilesRegistrationOptionsCopyWith<DidChangeWatchedFilesRegistrationOptions> get copyWith => _$DidChangeWatchedFilesRegistrationOptionsCopyWithImpl<DidChangeWatchedFilesRegistrationOptions>(this as DidChangeWatchedFilesRegistrationOptions, _$identity);

  /// Serializes this DidChangeWatchedFilesRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DidChangeWatchedFilesRegistrationOptions&&const DeepCollectionEquality().equals(other.watchers, watchers));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(watchers));

@override
String toString() {
  return 'DidChangeWatchedFilesRegistrationOptions(watchers: $watchers)';
}


}

/// @nodoc
abstract mixin class $DidChangeWatchedFilesRegistrationOptionsCopyWith<$Res>  {
  factory $DidChangeWatchedFilesRegistrationOptionsCopyWith(DidChangeWatchedFilesRegistrationOptions value, $Res Function(DidChangeWatchedFilesRegistrationOptions) _then) = _$DidChangeWatchedFilesRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 List<FileSystemWatcher> watchers
});




}
/// @nodoc
class _$DidChangeWatchedFilesRegistrationOptionsCopyWithImpl<$Res>
    implements $DidChangeWatchedFilesRegistrationOptionsCopyWith<$Res> {
  _$DidChangeWatchedFilesRegistrationOptionsCopyWithImpl(this._self, this._then);

  final DidChangeWatchedFilesRegistrationOptions _self;
  final $Res Function(DidChangeWatchedFilesRegistrationOptions) _then;

/// Create a copy of DidChangeWatchedFilesRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? watchers = null,}) {
  return _then(_self.copyWith(
watchers: null == watchers ? _self.watchers : watchers // ignore: cast_nullable_to_non_nullable
as List<FileSystemWatcher>,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DidChangeWatchedFilesRegistrationOptions implements DidChangeWatchedFilesRegistrationOptions {
  const _DidChangeWatchedFilesRegistrationOptions({required final  List<FileSystemWatcher> watchers}): _watchers = watchers;
  factory _DidChangeWatchedFilesRegistrationOptions.fromJson(Map<String, dynamic> json) => _$DidChangeWatchedFilesRegistrationOptionsFromJson(json);

/// The watchers to register.
 final  List<FileSystemWatcher> _watchers;
/// The watchers to register.
@override List<FileSystemWatcher> get watchers {
  if (_watchers is EqualUnmodifiableListView) return _watchers;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_watchers);
}


/// Create a copy of DidChangeWatchedFilesRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DidChangeWatchedFilesRegistrationOptionsCopyWith<_DidChangeWatchedFilesRegistrationOptions> get copyWith => __$DidChangeWatchedFilesRegistrationOptionsCopyWithImpl<_DidChangeWatchedFilesRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DidChangeWatchedFilesRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DidChangeWatchedFilesRegistrationOptions&&const DeepCollectionEquality().equals(other._watchers, _watchers));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_watchers));

@override
String toString() {
  return 'DidChangeWatchedFilesRegistrationOptions(watchers: $watchers)';
}


}

/// @nodoc
abstract mixin class _$DidChangeWatchedFilesRegistrationOptionsCopyWith<$Res> implements $DidChangeWatchedFilesRegistrationOptionsCopyWith<$Res> {
  factory _$DidChangeWatchedFilesRegistrationOptionsCopyWith(_DidChangeWatchedFilesRegistrationOptions value, $Res Function(_DidChangeWatchedFilesRegistrationOptions) _then) = __$DidChangeWatchedFilesRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 List<FileSystemWatcher> watchers
});




}
/// @nodoc
class __$DidChangeWatchedFilesRegistrationOptionsCopyWithImpl<$Res>
    implements _$DidChangeWatchedFilesRegistrationOptionsCopyWith<$Res> {
  __$DidChangeWatchedFilesRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _DidChangeWatchedFilesRegistrationOptions _self;
  final $Res Function(_DidChangeWatchedFilesRegistrationOptions) _then;

/// Create a copy of DidChangeWatchedFilesRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? watchers = null,}) {
  return _then(_DidChangeWatchedFilesRegistrationOptions(
watchers: null == watchers ? _self._watchers : watchers // ignore: cast_nullable_to_non_nullable
as List<FileSystemWatcher>,
  ));
}


}


/// @nodoc
mixin _$PublishDiagnosticsParams {

/// An array of diagnostic information items.
 List<Diagnostic> get diagnostics;/// The URI for which diagnostic information is reported.
 String get uri;/// Optional the version number of the document the diagnostics are
/// published for.
/// @since 3.15.0
 int? get version;
/// Create a copy of PublishDiagnosticsParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$PublishDiagnosticsParamsCopyWith<PublishDiagnosticsParams> get copyWith => _$PublishDiagnosticsParamsCopyWithImpl<PublishDiagnosticsParams>(this as PublishDiagnosticsParams, _$identity);

  /// Serializes this PublishDiagnosticsParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is PublishDiagnosticsParams&&const DeepCollectionEquality().equals(other.diagnostics, diagnostics)&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.version, version) || other.version == version));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(diagnostics),uri,version);

@override
String toString() {
  return 'PublishDiagnosticsParams(diagnostics: $diagnostics, uri: $uri, version: $version)';
}


}

/// @nodoc
abstract mixin class $PublishDiagnosticsParamsCopyWith<$Res>  {
  factory $PublishDiagnosticsParamsCopyWith(PublishDiagnosticsParams value, $Res Function(PublishDiagnosticsParams) _then) = _$PublishDiagnosticsParamsCopyWithImpl;
@useResult
$Res call({
 List<Diagnostic> diagnostics, String uri, int? version
});




}
/// @nodoc
class _$PublishDiagnosticsParamsCopyWithImpl<$Res>
    implements $PublishDiagnosticsParamsCopyWith<$Res> {
  _$PublishDiagnosticsParamsCopyWithImpl(this._self, this._then);

  final PublishDiagnosticsParams _self;
  final $Res Function(PublishDiagnosticsParams) _then;

/// Create a copy of PublishDiagnosticsParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? diagnostics = null,Object? uri = null,Object? version = freezed,}) {
  return _then(_self.copyWith(
diagnostics: null == diagnostics ? _self.diagnostics : diagnostics // ignore: cast_nullable_to_non_nullable
as List<Diagnostic>,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,version: freezed == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as int?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _PublishDiagnosticsParams implements PublishDiagnosticsParams {
  const _PublishDiagnosticsParams({required final  List<Diagnostic> diagnostics, required this.uri, this.version}): _diagnostics = diagnostics;
  factory _PublishDiagnosticsParams.fromJson(Map<String, dynamic> json) => _$PublishDiagnosticsParamsFromJson(json);

/// An array of diagnostic information items.
 final  List<Diagnostic> _diagnostics;
/// An array of diagnostic information items.
@override List<Diagnostic> get diagnostics {
  if (_diagnostics is EqualUnmodifiableListView) return _diagnostics;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_diagnostics);
}

/// The URI for which diagnostic information is reported.
@override final  String uri;
/// Optional the version number of the document the diagnostics are
/// published for.
/// @since 3.15.0
@override final  int? version;

/// Create a copy of PublishDiagnosticsParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$PublishDiagnosticsParamsCopyWith<_PublishDiagnosticsParams> get copyWith => __$PublishDiagnosticsParamsCopyWithImpl<_PublishDiagnosticsParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$PublishDiagnosticsParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _PublishDiagnosticsParams&&const DeepCollectionEquality().equals(other._diagnostics, _diagnostics)&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.version, version) || other.version == version));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_diagnostics),uri,version);

@override
String toString() {
  return 'PublishDiagnosticsParams(diagnostics: $diagnostics, uri: $uri, version: $version)';
}


}

/// @nodoc
abstract mixin class _$PublishDiagnosticsParamsCopyWith<$Res> implements $PublishDiagnosticsParamsCopyWith<$Res> {
  factory _$PublishDiagnosticsParamsCopyWith(_PublishDiagnosticsParams value, $Res Function(_PublishDiagnosticsParams) _then) = __$PublishDiagnosticsParamsCopyWithImpl;
@override @useResult
$Res call({
 List<Diagnostic> diagnostics, String uri, int? version
});




}
/// @nodoc
class __$PublishDiagnosticsParamsCopyWithImpl<$Res>
    implements _$PublishDiagnosticsParamsCopyWith<$Res> {
  __$PublishDiagnosticsParamsCopyWithImpl(this._self, this._then);

  final _PublishDiagnosticsParams _self;
  final $Res Function(_PublishDiagnosticsParams) _then;

/// Create a copy of PublishDiagnosticsParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? diagnostics = null,Object? uri = null,Object? version = freezed,}) {
  return _then(_PublishDiagnosticsParams(
diagnostics: null == diagnostics ? _self._diagnostics : diagnostics // ignore: cast_nullable_to_non_nullable
as List<Diagnostic>,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,version: freezed == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as int?,
  ));
}


}


/// @nodoc
mixin _$CompletionParams {

/// The completion context. This is only available if the client specifies
/// to send this using the client capability
/// `textDocument.completion.contextSupport === true`
 CompletionContext? get context;/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
 ProgressToken? get partialResultToken;/// The position inside the text document.
 Position get position;/// The text document.
 TextDocumentIdentifier get textDocument;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of CompletionParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CompletionParamsCopyWith<CompletionParams> get copyWith => _$CompletionParamsCopyWithImpl<CompletionParams>(this as CompletionParams, _$identity);

  /// Serializes this CompletionParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CompletionParams&&(identical(other.context, context) || other.context == context)&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.position, position) || other.position == position)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,context,partialResultToken,position,textDocument,workDoneToken);

@override
String toString() {
  return 'CompletionParams(context: $context, partialResultToken: $partialResultToken, position: $position, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $CompletionParamsCopyWith<$Res>  {
  factory $CompletionParamsCopyWith(CompletionParams value, $Res Function(CompletionParams) _then) = _$CompletionParamsCopyWithImpl;
@useResult
$Res call({
 CompletionContext? context, ProgressToken? partialResultToken, Position position, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


$CompletionContextCopyWith<$Res>? get context;$PositionCopyWith<$Res> get position;$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$CompletionParamsCopyWithImpl<$Res>
    implements $CompletionParamsCopyWith<$Res> {
  _$CompletionParamsCopyWithImpl(this._self, this._then);

  final CompletionParams _self;
  final $Res Function(CompletionParams) _then;

/// Create a copy of CompletionParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? context = freezed,Object? partialResultToken = freezed,Object? position = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
context: freezed == context ? _self.context : context // ignore: cast_nullable_to_non_nullable
as CompletionContext?,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of CompletionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CompletionContextCopyWith<$Res>? get context {
    if (_self.context == null) {
    return null;
  }

  return $CompletionContextCopyWith<$Res>(_self.context!, (value) {
    return _then(_self.copyWith(context: value));
  });
}/// Create a copy of CompletionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of CompletionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _CompletionParams implements CompletionParams {
  const _CompletionParams({this.context, this.partialResultToken, required this.position, required this.textDocument, this.workDoneToken});
  factory _CompletionParams.fromJson(Map<String, dynamic> json) => _$CompletionParamsFromJson(json);

/// The completion context. This is only available if the client specifies
/// to send this using the client capability
/// `textDocument.completion.contextSupport === true`
@override final  CompletionContext? context;
/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
@override final  ProgressToken? partialResultToken;
/// The position inside the text document.
@override final  Position position;
/// The text document.
@override final  TextDocumentIdentifier textDocument;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of CompletionParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CompletionParamsCopyWith<_CompletionParams> get copyWith => __$CompletionParamsCopyWithImpl<_CompletionParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CompletionParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CompletionParams&&(identical(other.context, context) || other.context == context)&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.position, position) || other.position == position)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,context,partialResultToken,position,textDocument,workDoneToken);

@override
String toString() {
  return 'CompletionParams(context: $context, partialResultToken: $partialResultToken, position: $position, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$CompletionParamsCopyWith<$Res> implements $CompletionParamsCopyWith<$Res> {
  factory _$CompletionParamsCopyWith(_CompletionParams value, $Res Function(_CompletionParams) _then) = __$CompletionParamsCopyWithImpl;
@override @useResult
$Res call({
 CompletionContext? context, ProgressToken? partialResultToken, Position position, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


@override $CompletionContextCopyWith<$Res>? get context;@override $PositionCopyWith<$Res> get position;@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$CompletionParamsCopyWithImpl<$Res>
    implements _$CompletionParamsCopyWith<$Res> {
  __$CompletionParamsCopyWithImpl(this._self, this._then);

  final _CompletionParams _self;
  final $Res Function(_CompletionParams) _then;

/// Create a copy of CompletionParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? context = freezed,Object? partialResultToken = freezed,Object? position = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_CompletionParams(
context: freezed == context ? _self.context : context // ignore: cast_nullable_to_non_nullable
as CompletionContext?,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of CompletionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CompletionContextCopyWith<$Res>? get context {
    if (_self.context == null) {
    return null;
  }

  return $CompletionContextCopyWith<$Res>(_self.context!, (value) {
    return _then(_self.copyWith(context: value));
  });
}/// Create a copy of CompletionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of CompletionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$CompletionItem {

/// An optional array of additional {@link TextEdit text edits} that are
/// applied when selecting this completion. Edits must not overlap
/// (including the same insert position) with the main {@link
/// CompletionItem.textEdit edit} nor with themselves.
/// Additional text edits should be used to change text unrelated to the
/// current cursor position (for example adding an import statement at the
/// top of the file if the completion item will insert an unqualified
/// type).
 List<TextEdit>? get additionalTextEdits;/// An optional {@link Command command} that is executed *after* inserting
/// this completion. *Note* that additional modifications to the current
/// document should be described with the {@link
/// CompletionItem.additionalTextEdits additionalTextEdits}-property.
 Command? get command;/// An optional set of characters that when pressed while this completion
/// is active will accept it first and then type that character. *Note*
/// that all commit characters should have `length=1` and that superfluous
/// characters will be ignored.
 List<String>? get commitCharacters;/// A data entry field that is preserved on a completion item between a
/// {@link CompletionRequest} and a {@link CompletionResolveRequest}.
 LSPAny? get data;/// Indicates if this item is deprecated. @deprecated Use `tags` instead.
 bool? get deprecated;/// A human-readable string with additional information about this item,
/// like type or symbol information.
 String? get detail;/// A human-readable string that represents a doc-comment.
 Sealed17? get documentation;/// A string that should be used when filtering a set of completion items.
/// When `falsy` the {@link CompletionItem.label label} is used.
 String? get filterText;/// A string that should be inserted into a document when selecting this
/// completion. When `falsy` the {@link CompletionItem.label label} is
/// used.
/// The `insertText` is subject to interpretation by the client side. Some
/// tools might not take the string literally. For example VS Code when
/// code complete is requested in this example `con<cursor position>` and a
/// completion item with an `insertText` of `console` is provided it will
/// only insert `sole`. Therefore it is recommended to use `textEdit`
/// instead since it avoids additional client side interpretation.
 String? get insertText;/// The format of the insert text. The format applies to both the
/// `insertText` property and the `newText` property of a provided
/// `textEdit`. If omitted defaults to `InsertTextFormat.PlainText`.
/// Please note that the insertTextFormat doesn't apply to
/// `additionalTextEdits`.
 InsertTextFormat? get insertTextFormat;/// How whitespace and indentation is handled during completion item
/// insertion. If not provided the clients default value depends on the
/// `textDocument.completion.insertTextMode` client capability.
/// @since 3.16.0
 InsertTextMode? get insertTextMode;/// The kind of this completion item. Based of the kind an icon is chosen
/// by the editor.
 CompletionItemKind? get kind;/// The label of this completion item.
/// The label property is also by default the text that is inserted when
/// selecting this completion.
/// If label details are provided the label itself should be an unqualified
/// name of the completion item.
 String get label;/// Additional details for the label
/// @since 3.17.0
 CompletionItemLabelDetails? get labelDetails;/// Select this item when showing.
/// *Note* that only one completion item can be selected and that the tool
/// / client decides which item that is. The rule is that the *first* item
/// of those that match best is selected.
 bool? get preselect;/// A string that should be used when comparing this item with other items.
/// When `falsy` the {@link CompletionItem.label label} is used.
 String? get sortText;/// Tags for this completion item.
/// @since 3.15.0
 List<CompletionItemTag>? get tags;/// An {@link TextEdit edit} which is applied to a document when selecting
/// this completion. When an edit is provided the value of {@link
/// CompletionItem.insertText insertText} is ignored.
/// Most editors support two different operations when accepting a
/// completion item. One is to insert a completion text and the other is to
/// replace an existing text with a completion text. Since this can usually
/// not be predetermined by a server it can report both ranges. Clients
/// need to signal support for `InsertReplaceEdits` via the
/// `textDocument.completion.insertReplaceSupport` client capability
/// property.
/// *Note 1:* The text edit's range as well as both ranges from an insert
/// replace edit must be a [single line] and they must contain the position
/// at which completion has been requested. *Note 2:* If an
/// `InsertReplaceEdit` is returned the edit's insert range must be a
/// prefix of the edit's replace range, that means it must be contained and
/// starting at the same position.
/// @since 3.16.0 additional type `InsertReplaceEdit`
 Sealed21? get textEdit;/// The edit text used if the completion item is part of a CompletionList
/// and CompletionList defines an item default for the text edit range.
/// Clients will only honor this property if they opt into completion list
/// item defaults using the capability `completionList.itemDefaults`.
/// If not provided and a list's default range is provided the label
/// property is used as a text.
/// @since 3.17.0
 String? get textEditText;
/// Create a copy of CompletionItem
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CompletionItemCopyWith<CompletionItem> get copyWith => _$CompletionItemCopyWithImpl<CompletionItem>(this as CompletionItem, _$identity);

  /// Serializes this CompletionItem to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CompletionItem&&const DeepCollectionEquality().equals(other.additionalTextEdits, additionalTextEdits)&&(identical(other.command, command) || other.command == command)&&const DeepCollectionEquality().equals(other.commitCharacters, commitCharacters)&&(identical(other.data, data) || other.data == data)&&(identical(other.deprecated, deprecated) || other.deprecated == deprecated)&&(identical(other.detail, detail) || other.detail == detail)&&(identical(other.documentation, documentation) || other.documentation == documentation)&&(identical(other.filterText, filterText) || other.filterText == filterText)&&(identical(other.insertText, insertText) || other.insertText == insertText)&&(identical(other.insertTextFormat, insertTextFormat) || other.insertTextFormat == insertTextFormat)&&(identical(other.insertTextMode, insertTextMode) || other.insertTextMode == insertTextMode)&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.label, label) || other.label == label)&&(identical(other.labelDetails, labelDetails) || other.labelDetails == labelDetails)&&(identical(other.preselect, preselect) || other.preselect == preselect)&&(identical(other.sortText, sortText) || other.sortText == sortText)&&const DeepCollectionEquality().equals(other.tags, tags)&&(identical(other.textEdit, textEdit) || other.textEdit == textEdit)&&(identical(other.textEditText, textEditText) || other.textEditText == textEditText));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hashAll([runtimeType,const DeepCollectionEquality().hash(additionalTextEdits),command,const DeepCollectionEquality().hash(commitCharacters),data,deprecated,detail,documentation,filterText,insertText,insertTextFormat,insertTextMode,kind,label,labelDetails,preselect,sortText,const DeepCollectionEquality().hash(tags),textEdit,textEditText]);

@override
String toString() {
  return 'CompletionItem(additionalTextEdits: $additionalTextEdits, command: $command, commitCharacters: $commitCharacters, data: $data, deprecated: $deprecated, detail: $detail, documentation: $documentation, filterText: $filterText, insertText: $insertText, insertTextFormat: $insertTextFormat, insertTextMode: $insertTextMode, kind: $kind, label: $label, labelDetails: $labelDetails, preselect: $preselect, sortText: $sortText, tags: $tags, textEdit: $textEdit, textEditText: $textEditText)';
}


}

/// @nodoc
abstract mixin class $CompletionItemCopyWith<$Res>  {
  factory $CompletionItemCopyWith(CompletionItem value, $Res Function(CompletionItem) _then) = _$CompletionItemCopyWithImpl;
@useResult
$Res call({
 List<TextEdit>? additionalTextEdits, Command? command, List<String>? commitCharacters, LSPAny? data, bool? deprecated, String? detail, Sealed17? documentation, String? filterText, String? insertText, InsertTextFormat? insertTextFormat, InsertTextMode? insertTextMode, CompletionItemKind? kind, String label, CompletionItemLabelDetails? labelDetails, bool? preselect, String? sortText, List<CompletionItemTag>? tags, Sealed21? textEdit, String? textEditText
});


$CommandCopyWith<$Res>? get command;$CompletionItemLabelDetailsCopyWith<$Res>? get labelDetails;

}
/// @nodoc
class _$CompletionItemCopyWithImpl<$Res>
    implements $CompletionItemCopyWith<$Res> {
  _$CompletionItemCopyWithImpl(this._self, this._then);

  final CompletionItem _self;
  final $Res Function(CompletionItem) _then;

/// Create a copy of CompletionItem
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? additionalTextEdits = freezed,Object? command = freezed,Object? commitCharacters = freezed,Object? data = freezed,Object? deprecated = freezed,Object? detail = freezed,Object? documentation = freezed,Object? filterText = freezed,Object? insertText = freezed,Object? insertTextFormat = freezed,Object? insertTextMode = freezed,Object? kind = freezed,Object? label = null,Object? labelDetails = freezed,Object? preselect = freezed,Object? sortText = freezed,Object? tags = freezed,Object? textEdit = freezed,Object? textEditText = freezed,}) {
  return _then(_self.copyWith(
additionalTextEdits: freezed == additionalTextEdits ? _self.additionalTextEdits : additionalTextEdits // ignore: cast_nullable_to_non_nullable
as List<TextEdit>?,command: freezed == command ? _self.command : command // ignore: cast_nullable_to_non_nullable
as Command?,commitCharacters: freezed == commitCharacters ? _self.commitCharacters : commitCharacters // ignore: cast_nullable_to_non_nullable
as List<String>?,data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LSPAny?,deprecated: freezed == deprecated ? _self.deprecated : deprecated // ignore: cast_nullable_to_non_nullable
as bool?,detail: freezed == detail ? _self.detail : detail // ignore: cast_nullable_to_non_nullable
as String?,documentation: freezed == documentation ? _self.documentation : documentation // ignore: cast_nullable_to_non_nullable
as Sealed17?,filterText: freezed == filterText ? _self.filterText : filterText // ignore: cast_nullable_to_non_nullable
as String?,insertText: freezed == insertText ? _self.insertText : insertText // ignore: cast_nullable_to_non_nullable
as String?,insertTextFormat: freezed == insertTextFormat ? _self.insertTextFormat : insertTextFormat // ignore: cast_nullable_to_non_nullable
as InsertTextFormat?,insertTextMode: freezed == insertTextMode ? _self.insertTextMode : insertTextMode // ignore: cast_nullable_to_non_nullable
as InsertTextMode?,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as CompletionItemKind?,label: null == label ? _self.label : label // ignore: cast_nullable_to_non_nullable
as String,labelDetails: freezed == labelDetails ? _self.labelDetails : labelDetails // ignore: cast_nullable_to_non_nullable
as CompletionItemLabelDetails?,preselect: freezed == preselect ? _self.preselect : preselect // ignore: cast_nullable_to_non_nullable
as bool?,sortText: freezed == sortText ? _self.sortText : sortText // ignore: cast_nullable_to_non_nullable
as String?,tags: freezed == tags ? _self.tags : tags // ignore: cast_nullable_to_non_nullable
as List<CompletionItemTag>?,textEdit: freezed == textEdit ? _self.textEdit : textEdit // ignore: cast_nullable_to_non_nullable
as Sealed21?,textEditText: freezed == textEditText ? _self.textEditText : textEditText // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}
/// Create a copy of CompletionItem
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CommandCopyWith<$Res>? get command {
    if (_self.command == null) {
    return null;
  }

  return $CommandCopyWith<$Res>(_self.command!, (value) {
    return _then(_self.copyWith(command: value));
  });
}/// Create a copy of CompletionItem
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CompletionItemLabelDetailsCopyWith<$Res>? get labelDetails {
    if (_self.labelDetails == null) {
    return null;
  }

  return $CompletionItemLabelDetailsCopyWith<$Res>(_self.labelDetails!, (value) {
    return _then(_self.copyWith(labelDetails: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _CompletionItem implements CompletionItem {
  const _CompletionItem({final  List<TextEdit>? additionalTextEdits, this.command, final  List<String>? commitCharacters, this.data, this.deprecated, this.detail, this.documentation, this.filterText, this.insertText, this.insertTextFormat, this.insertTextMode, this.kind, required this.label, this.labelDetails, this.preselect, this.sortText, final  List<CompletionItemTag>? tags, this.textEdit, this.textEditText}): _additionalTextEdits = additionalTextEdits,_commitCharacters = commitCharacters,_tags = tags;
  factory _CompletionItem.fromJson(Map<String, dynamic> json) => _$CompletionItemFromJson(json);

/// An optional array of additional {@link TextEdit text edits} that are
/// applied when selecting this completion. Edits must not overlap
/// (including the same insert position) with the main {@link
/// CompletionItem.textEdit edit} nor with themselves.
/// Additional text edits should be used to change text unrelated to the
/// current cursor position (for example adding an import statement at the
/// top of the file if the completion item will insert an unqualified
/// type).
 final  List<TextEdit>? _additionalTextEdits;
/// An optional array of additional {@link TextEdit text edits} that are
/// applied when selecting this completion. Edits must not overlap
/// (including the same insert position) with the main {@link
/// CompletionItem.textEdit edit} nor with themselves.
/// Additional text edits should be used to change text unrelated to the
/// current cursor position (for example adding an import statement at the
/// top of the file if the completion item will insert an unqualified
/// type).
@override List<TextEdit>? get additionalTextEdits {
  final value = _additionalTextEdits;
  if (value == null) return null;
  if (_additionalTextEdits is EqualUnmodifiableListView) return _additionalTextEdits;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

/// An optional {@link Command command} that is executed *after* inserting
/// this completion. *Note* that additional modifications to the current
/// document should be described with the {@link
/// CompletionItem.additionalTextEdits additionalTextEdits}-property.
@override final  Command? command;
/// An optional set of characters that when pressed while this completion
/// is active will accept it first and then type that character. *Note*
/// that all commit characters should have `length=1` and that superfluous
/// characters will be ignored.
 final  List<String>? _commitCharacters;
/// An optional set of characters that when pressed while this completion
/// is active will accept it first and then type that character. *Note*
/// that all commit characters should have `length=1` and that superfluous
/// characters will be ignored.
@override List<String>? get commitCharacters {
  final value = _commitCharacters;
  if (value == null) return null;
  if (_commitCharacters is EqualUnmodifiableListView) return _commitCharacters;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

/// A data entry field that is preserved on a completion item between a
/// {@link CompletionRequest} and a {@link CompletionResolveRequest}.
@override final  LSPAny? data;
/// Indicates if this item is deprecated. @deprecated Use `tags` instead.
@override final  bool? deprecated;
/// A human-readable string with additional information about this item,
/// like type or symbol information.
@override final  String? detail;
/// A human-readable string that represents a doc-comment.
@override final  Sealed17? documentation;
/// A string that should be used when filtering a set of completion items.
/// When `falsy` the {@link CompletionItem.label label} is used.
@override final  String? filterText;
/// A string that should be inserted into a document when selecting this
/// completion. When `falsy` the {@link CompletionItem.label label} is
/// used.
/// The `insertText` is subject to interpretation by the client side. Some
/// tools might not take the string literally. For example VS Code when
/// code complete is requested in this example `con<cursor position>` and a
/// completion item with an `insertText` of `console` is provided it will
/// only insert `sole`. Therefore it is recommended to use `textEdit`
/// instead since it avoids additional client side interpretation.
@override final  String? insertText;
/// The format of the insert text. The format applies to both the
/// `insertText` property and the `newText` property of a provided
/// `textEdit`. If omitted defaults to `InsertTextFormat.PlainText`.
/// Please note that the insertTextFormat doesn't apply to
/// `additionalTextEdits`.
@override final  InsertTextFormat? insertTextFormat;
/// How whitespace and indentation is handled during completion item
/// insertion. If not provided the clients default value depends on the
/// `textDocument.completion.insertTextMode` client capability.
/// @since 3.16.0
@override final  InsertTextMode? insertTextMode;
/// The kind of this completion item. Based of the kind an icon is chosen
/// by the editor.
@override final  CompletionItemKind? kind;
/// The label of this completion item.
/// The label property is also by default the text that is inserted when
/// selecting this completion.
/// If label details are provided the label itself should be an unqualified
/// name of the completion item.
@override final  String label;
/// Additional details for the label
/// @since 3.17.0
@override final  CompletionItemLabelDetails? labelDetails;
/// Select this item when showing.
/// *Note* that only one completion item can be selected and that the tool
/// / client decides which item that is. The rule is that the *first* item
/// of those that match best is selected.
@override final  bool? preselect;
/// A string that should be used when comparing this item with other items.
/// When `falsy` the {@link CompletionItem.label label} is used.
@override final  String? sortText;
/// Tags for this completion item.
/// @since 3.15.0
 final  List<CompletionItemTag>? _tags;
/// Tags for this completion item.
/// @since 3.15.0
@override List<CompletionItemTag>? get tags {
  final value = _tags;
  if (value == null) return null;
  if (_tags is EqualUnmodifiableListView) return _tags;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

/// An {@link TextEdit edit} which is applied to a document when selecting
/// this completion. When an edit is provided the value of {@link
/// CompletionItem.insertText insertText} is ignored.
/// Most editors support two different operations when accepting a
/// completion item. One is to insert a completion text and the other is to
/// replace an existing text with a completion text. Since this can usually
/// not be predetermined by a server it can report both ranges. Clients
/// need to signal support for `InsertReplaceEdits` via the
/// `textDocument.completion.insertReplaceSupport` client capability
/// property.
/// *Note 1:* The text edit's range as well as both ranges from an insert
/// replace edit must be a [single line] and they must contain the position
/// at which completion has been requested. *Note 2:* If an
/// `InsertReplaceEdit` is returned the edit's insert range must be a
/// prefix of the edit's replace range, that means it must be contained and
/// starting at the same position.
/// @since 3.16.0 additional type `InsertReplaceEdit`
@override final  Sealed21? textEdit;
/// The edit text used if the completion item is part of a CompletionList
/// and CompletionList defines an item default for the text edit range.
/// Clients will only honor this property if they opt into completion list
/// item defaults using the capability `completionList.itemDefaults`.
/// If not provided and a list's default range is provided the label
/// property is used as a text.
/// @since 3.17.0
@override final  String? textEditText;

/// Create a copy of CompletionItem
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CompletionItemCopyWith<_CompletionItem> get copyWith => __$CompletionItemCopyWithImpl<_CompletionItem>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CompletionItemToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CompletionItem&&const DeepCollectionEquality().equals(other._additionalTextEdits, _additionalTextEdits)&&(identical(other.command, command) || other.command == command)&&const DeepCollectionEquality().equals(other._commitCharacters, _commitCharacters)&&(identical(other.data, data) || other.data == data)&&(identical(other.deprecated, deprecated) || other.deprecated == deprecated)&&(identical(other.detail, detail) || other.detail == detail)&&(identical(other.documentation, documentation) || other.documentation == documentation)&&(identical(other.filterText, filterText) || other.filterText == filterText)&&(identical(other.insertText, insertText) || other.insertText == insertText)&&(identical(other.insertTextFormat, insertTextFormat) || other.insertTextFormat == insertTextFormat)&&(identical(other.insertTextMode, insertTextMode) || other.insertTextMode == insertTextMode)&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.label, label) || other.label == label)&&(identical(other.labelDetails, labelDetails) || other.labelDetails == labelDetails)&&(identical(other.preselect, preselect) || other.preselect == preselect)&&(identical(other.sortText, sortText) || other.sortText == sortText)&&const DeepCollectionEquality().equals(other._tags, _tags)&&(identical(other.textEdit, textEdit) || other.textEdit == textEdit)&&(identical(other.textEditText, textEditText) || other.textEditText == textEditText));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hashAll([runtimeType,const DeepCollectionEquality().hash(_additionalTextEdits),command,const DeepCollectionEquality().hash(_commitCharacters),data,deprecated,detail,documentation,filterText,insertText,insertTextFormat,insertTextMode,kind,label,labelDetails,preselect,sortText,const DeepCollectionEquality().hash(_tags),textEdit,textEditText]);

@override
String toString() {
  return 'CompletionItem(additionalTextEdits: $additionalTextEdits, command: $command, commitCharacters: $commitCharacters, data: $data, deprecated: $deprecated, detail: $detail, documentation: $documentation, filterText: $filterText, insertText: $insertText, insertTextFormat: $insertTextFormat, insertTextMode: $insertTextMode, kind: $kind, label: $label, labelDetails: $labelDetails, preselect: $preselect, sortText: $sortText, tags: $tags, textEdit: $textEdit, textEditText: $textEditText)';
}


}

/// @nodoc
abstract mixin class _$CompletionItemCopyWith<$Res> implements $CompletionItemCopyWith<$Res> {
  factory _$CompletionItemCopyWith(_CompletionItem value, $Res Function(_CompletionItem) _then) = __$CompletionItemCopyWithImpl;
@override @useResult
$Res call({
 List<TextEdit>? additionalTextEdits, Command? command, List<String>? commitCharacters, LSPAny? data, bool? deprecated, String? detail, Sealed17? documentation, String? filterText, String? insertText, InsertTextFormat? insertTextFormat, InsertTextMode? insertTextMode, CompletionItemKind? kind, String label, CompletionItemLabelDetails? labelDetails, bool? preselect, String? sortText, List<CompletionItemTag>? tags, Sealed21? textEdit, String? textEditText
});


@override $CommandCopyWith<$Res>? get command;@override $CompletionItemLabelDetailsCopyWith<$Res>? get labelDetails;

}
/// @nodoc
class __$CompletionItemCopyWithImpl<$Res>
    implements _$CompletionItemCopyWith<$Res> {
  __$CompletionItemCopyWithImpl(this._self, this._then);

  final _CompletionItem _self;
  final $Res Function(_CompletionItem) _then;

/// Create a copy of CompletionItem
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? additionalTextEdits = freezed,Object? command = freezed,Object? commitCharacters = freezed,Object? data = freezed,Object? deprecated = freezed,Object? detail = freezed,Object? documentation = freezed,Object? filterText = freezed,Object? insertText = freezed,Object? insertTextFormat = freezed,Object? insertTextMode = freezed,Object? kind = freezed,Object? label = null,Object? labelDetails = freezed,Object? preselect = freezed,Object? sortText = freezed,Object? tags = freezed,Object? textEdit = freezed,Object? textEditText = freezed,}) {
  return _then(_CompletionItem(
additionalTextEdits: freezed == additionalTextEdits ? _self._additionalTextEdits : additionalTextEdits // ignore: cast_nullable_to_non_nullable
as List<TextEdit>?,command: freezed == command ? _self.command : command // ignore: cast_nullable_to_non_nullable
as Command?,commitCharacters: freezed == commitCharacters ? _self._commitCharacters : commitCharacters // ignore: cast_nullable_to_non_nullable
as List<String>?,data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LSPAny?,deprecated: freezed == deprecated ? _self.deprecated : deprecated // ignore: cast_nullable_to_non_nullable
as bool?,detail: freezed == detail ? _self.detail : detail // ignore: cast_nullable_to_non_nullable
as String?,documentation: freezed == documentation ? _self.documentation : documentation // ignore: cast_nullable_to_non_nullable
as Sealed17?,filterText: freezed == filterText ? _self.filterText : filterText // ignore: cast_nullable_to_non_nullable
as String?,insertText: freezed == insertText ? _self.insertText : insertText // ignore: cast_nullable_to_non_nullable
as String?,insertTextFormat: freezed == insertTextFormat ? _self.insertTextFormat : insertTextFormat // ignore: cast_nullable_to_non_nullable
as InsertTextFormat?,insertTextMode: freezed == insertTextMode ? _self.insertTextMode : insertTextMode // ignore: cast_nullable_to_non_nullable
as InsertTextMode?,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as CompletionItemKind?,label: null == label ? _self.label : label // ignore: cast_nullable_to_non_nullable
as String,labelDetails: freezed == labelDetails ? _self.labelDetails : labelDetails // ignore: cast_nullable_to_non_nullable
as CompletionItemLabelDetails?,preselect: freezed == preselect ? _self.preselect : preselect // ignore: cast_nullable_to_non_nullable
as bool?,sortText: freezed == sortText ? _self.sortText : sortText // ignore: cast_nullable_to_non_nullable
as String?,tags: freezed == tags ? _self._tags : tags // ignore: cast_nullable_to_non_nullable
as List<CompletionItemTag>?,textEdit: freezed == textEdit ? _self.textEdit : textEdit // ignore: cast_nullable_to_non_nullable
as Sealed21?,textEditText: freezed == textEditText ? _self.textEditText : textEditText // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

/// Create a copy of CompletionItem
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CommandCopyWith<$Res>? get command {
    if (_self.command == null) {
    return null;
  }

  return $CommandCopyWith<$Res>(_self.command!, (value) {
    return _then(_self.copyWith(command: value));
  });
}/// Create a copy of CompletionItem
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CompletionItemLabelDetailsCopyWith<$Res>? get labelDetails {
    if (_self.labelDetails == null) {
    return null;
  }

  return $CompletionItemLabelDetailsCopyWith<$Res>(_self.labelDetails!, (value) {
    return _then(_self.copyWith(labelDetails: value));
  });
}
}


/// @nodoc
mixin _$CompletionList {

/// This list it not complete. Further typing results in recomputing this
/// list.
/// Recomputed lists have all their items replaced (not appended) in the
/// incomplete completion sessions.
 bool get isIncomplete;/// In many cases the items of an actual completion result share the same
/// value for properties like `commitCharacters` or the range of a text
/// edit. A completion list can therefore define item defaults which will
/// be used if a completion item itself doesn't specify the value.
/// If a completion list specifies a default value and a completion item
/// also specifies a corresponding value the one from the item is used.
/// Servers are only allowed to return default values if the client signals
/// support for this via the `completionList.itemDefaults` capability.
/// @since 3.17.0
 InsertTextFormatInsertTextFormatInsertTextModeInsertTextModeLSPAnyDataRangeOrRangeInsertRangeReplaceEditRangeStringsCommitCharacters? get itemDefaults;/// The completion items.
 List<CompletionItem> get items;
/// Create a copy of CompletionList
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CompletionListCopyWith<CompletionList> get copyWith => _$CompletionListCopyWithImpl<CompletionList>(this as CompletionList, _$identity);

  /// Serializes this CompletionList to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CompletionList&&(identical(other.isIncomplete, isIncomplete) || other.isIncomplete == isIncomplete)&&const DeepCollectionEquality().equals(other.itemDefaults, itemDefaults)&&const DeepCollectionEquality().equals(other.items, items));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,isIncomplete,const DeepCollectionEquality().hash(itemDefaults),const DeepCollectionEquality().hash(items));

@override
String toString() {
  return 'CompletionList(isIncomplete: $isIncomplete, itemDefaults: $itemDefaults, items: $items)';
}


}

/// @nodoc
abstract mixin class $CompletionListCopyWith<$Res>  {
  factory $CompletionListCopyWith(CompletionList value, $Res Function(CompletionList) _then) = _$CompletionListCopyWithImpl;
@useResult
$Res call({
 bool isIncomplete, InsertTextFormatInsertTextFormatInsertTextModeInsertTextModeLSPAnyDataRangeOrRangeInsertRangeReplaceEditRangeStringsCommitCharacters? itemDefaults, List<CompletionItem> items
});




}
/// @nodoc
class _$CompletionListCopyWithImpl<$Res>
    implements $CompletionListCopyWith<$Res> {
  _$CompletionListCopyWithImpl(this._self, this._then);

  final CompletionList _self;
  final $Res Function(CompletionList) _then;

/// Create a copy of CompletionList
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? isIncomplete = null,Object? itemDefaults = freezed,Object? items = null,}) {
  return _then(_self.copyWith(
isIncomplete: null == isIncomplete ? _self.isIncomplete : isIncomplete // ignore: cast_nullable_to_non_nullable
as bool,itemDefaults: freezed == itemDefaults ? _self.itemDefaults : itemDefaults // ignore: cast_nullable_to_non_nullable
as InsertTextFormatInsertTextFormatInsertTextModeInsertTextModeLSPAnyDataRangeOrRangeInsertRangeReplaceEditRangeStringsCommitCharacters?,items: null == items ? _self.items : items // ignore: cast_nullable_to_non_nullable
as List<CompletionItem>,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _CompletionList implements CompletionList {
  const _CompletionList({required this.isIncomplete, this.itemDefaults, required final  List<CompletionItem> items}): _items = items;
  factory _CompletionList.fromJson(Map<String, dynamic> json) => _$CompletionListFromJson(json);

/// This list it not complete. Further typing results in recomputing this
/// list.
/// Recomputed lists have all their items replaced (not appended) in the
/// incomplete completion sessions.
@override final  bool isIncomplete;
/// In many cases the items of an actual completion result share the same
/// value for properties like `commitCharacters` or the range of a text
/// edit. A completion list can therefore define item defaults which will
/// be used if a completion item itself doesn't specify the value.
/// If a completion list specifies a default value and a completion item
/// also specifies a corresponding value the one from the item is used.
/// Servers are only allowed to return default values if the client signals
/// support for this via the `completionList.itemDefaults` capability.
/// @since 3.17.0
@override final  InsertTextFormatInsertTextFormatInsertTextModeInsertTextModeLSPAnyDataRangeOrRangeInsertRangeReplaceEditRangeStringsCommitCharacters? itemDefaults;
/// The completion items.
 final  List<CompletionItem> _items;
/// The completion items.
@override List<CompletionItem> get items {
  if (_items is EqualUnmodifiableListView) return _items;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_items);
}


/// Create a copy of CompletionList
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CompletionListCopyWith<_CompletionList> get copyWith => __$CompletionListCopyWithImpl<_CompletionList>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CompletionListToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CompletionList&&(identical(other.isIncomplete, isIncomplete) || other.isIncomplete == isIncomplete)&&const DeepCollectionEquality().equals(other.itemDefaults, itemDefaults)&&const DeepCollectionEquality().equals(other._items, _items));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,isIncomplete,const DeepCollectionEquality().hash(itemDefaults),const DeepCollectionEquality().hash(_items));

@override
String toString() {
  return 'CompletionList(isIncomplete: $isIncomplete, itemDefaults: $itemDefaults, items: $items)';
}


}

/// @nodoc
abstract mixin class _$CompletionListCopyWith<$Res> implements $CompletionListCopyWith<$Res> {
  factory _$CompletionListCopyWith(_CompletionList value, $Res Function(_CompletionList) _then) = __$CompletionListCopyWithImpl;
@override @useResult
$Res call({
 bool isIncomplete, InsertTextFormatInsertTextFormatInsertTextModeInsertTextModeLSPAnyDataRangeOrRangeInsertRangeReplaceEditRangeStringsCommitCharacters? itemDefaults, List<CompletionItem> items
});




}
/// @nodoc
class __$CompletionListCopyWithImpl<$Res>
    implements _$CompletionListCopyWith<$Res> {
  __$CompletionListCopyWithImpl(this._self, this._then);

  final _CompletionList _self;
  final $Res Function(_CompletionList) _then;

/// Create a copy of CompletionList
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? isIncomplete = null,Object? itemDefaults = freezed,Object? items = null,}) {
  return _then(_CompletionList(
isIncomplete: null == isIncomplete ? _self.isIncomplete : isIncomplete // ignore: cast_nullable_to_non_nullable
as bool,itemDefaults: freezed == itemDefaults ? _self.itemDefaults : itemDefaults // ignore: cast_nullable_to_non_nullable
as InsertTextFormatInsertTextFormatInsertTextModeInsertTextModeLSPAnyDataRangeOrRangeInsertRangeReplaceEditRangeStringsCommitCharacters?,items: null == items ? _self._items : items // ignore: cast_nullable_to_non_nullable
as List<CompletionItem>,
  ));
}


}


/// @nodoc
mixin _$CompletionRegistrationOptions {

/// The list of all possible characters that commit a completion. This
/// field can be used if clients don't support individual commit characters
/// per completion item. See
/// `ClientCapabilities.textDocument.completion.completionItem.commitCharactersSupport`
/// If a server provides both `allCommitCharacters` and commit characters
/// on an individual completion item the ones on the completion item win.
/// @since 3.2.0
 List<String>? get allCommitCharacters;/// The server supports the following `CompletionItem` specific
/// capabilities.
/// @since 3.17.0
 BoolLabelDetailsSupport? get completionItem;/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
 Sealed14 get documentSelector;/// The server provides support to resolve additional information for a
/// completion item.
 bool? get resolveProvider;/// Most tools trigger completion request automatically without explicitly
/// requesting it using a keyboard shortcut (e.g. Ctrl+Space). Typically
/// they do so when the user starts to type an identifier. For example if
/// the user types `c` in a JavaScript file code complete will
/// automatically pop up present `console` besides others as a completion
/// item. Characters that make up identifiers don't need to be listed here.
/// If code complete should automatically be trigger on characters not
/// being valid inside an identifier (for example `.` in JavaScript) list
/// them in `triggerCharacters`.
 List<String>? get triggerCharacters;
/// Create a copy of CompletionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CompletionRegistrationOptionsCopyWith<CompletionRegistrationOptions> get copyWith => _$CompletionRegistrationOptionsCopyWithImpl<CompletionRegistrationOptions>(this as CompletionRegistrationOptions, _$identity);

  /// Serializes this CompletionRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CompletionRegistrationOptions&&const DeepCollectionEquality().equals(other.allCommitCharacters, allCommitCharacters)&&const DeepCollectionEquality().equals(other.completionItem, completionItem)&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider)&&const DeepCollectionEquality().equals(other.triggerCharacters, triggerCharacters));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(allCommitCharacters),const DeepCollectionEquality().hash(completionItem),documentSelector,resolveProvider,const DeepCollectionEquality().hash(triggerCharacters));

@override
String toString() {
  return 'CompletionRegistrationOptions(allCommitCharacters: $allCommitCharacters, completionItem: $completionItem, documentSelector: $documentSelector, resolveProvider: $resolveProvider, triggerCharacters: $triggerCharacters)';
}


}

/// @nodoc
abstract mixin class $CompletionRegistrationOptionsCopyWith<$Res>  {
  factory $CompletionRegistrationOptionsCopyWith(CompletionRegistrationOptions value, $Res Function(CompletionRegistrationOptions) _then) = _$CompletionRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 List<String>? allCommitCharacters, BoolLabelDetailsSupport? completionItem, Sealed14 documentSelector, bool? resolveProvider, List<String>? triggerCharacters
});




}
/// @nodoc
class _$CompletionRegistrationOptionsCopyWithImpl<$Res>
    implements $CompletionRegistrationOptionsCopyWith<$Res> {
  _$CompletionRegistrationOptionsCopyWithImpl(this._self, this._then);

  final CompletionRegistrationOptions _self;
  final $Res Function(CompletionRegistrationOptions) _then;

/// Create a copy of CompletionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? allCommitCharacters = freezed,Object? completionItem = freezed,Object? documentSelector = null,Object? resolveProvider = freezed,Object? triggerCharacters = freezed,}) {
  return _then(_self.copyWith(
allCommitCharacters: freezed == allCommitCharacters ? _self.allCommitCharacters : allCommitCharacters // ignore: cast_nullable_to_non_nullable
as List<String>?,completionItem: freezed == completionItem ? _self.completionItem : completionItem // ignore: cast_nullable_to_non_nullable
as BoolLabelDetailsSupport?,documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,triggerCharacters: freezed == triggerCharacters ? _self.triggerCharacters : triggerCharacters // ignore: cast_nullable_to_non_nullable
as List<String>?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _CompletionRegistrationOptions implements CompletionRegistrationOptions {
  const _CompletionRegistrationOptions({final  List<String>? allCommitCharacters, this.completionItem, required this.documentSelector, this.resolveProvider, final  List<String>? triggerCharacters}): _allCommitCharacters = allCommitCharacters,_triggerCharacters = triggerCharacters;
  factory _CompletionRegistrationOptions.fromJson(Map<String, dynamic> json) => _$CompletionRegistrationOptionsFromJson(json);

/// The list of all possible characters that commit a completion. This
/// field can be used if clients don't support individual commit characters
/// per completion item. See
/// `ClientCapabilities.textDocument.completion.completionItem.commitCharactersSupport`
/// If a server provides both `allCommitCharacters` and commit characters
/// on an individual completion item the ones on the completion item win.
/// @since 3.2.0
 final  List<String>? _allCommitCharacters;
/// The list of all possible characters that commit a completion. This
/// field can be used if clients don't support individual commit characters
/// per completion item. See
/// `ClientCapabilities.textDocument.completion.completionItem.commitCharactersSupport`
/// If a server provides both `allCommitCharacters` and commit characters
/// on an individual completion item the ones on the completion item win.
/// @since 3.2.0
@override List<String>? get allCommitCharacters {
  final value = _allCommitCharacters;
  if (value == null) return null;
  if (_allCommitCharacters is EqualUnmodifiableListView) return _allCommitCharacters;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

/// The server supports the following `CompletionItem` specific
/// capabilities.
/// @since 3.17.0
@override final  BoolLabelDetailsSupport? completionItem;
/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
@override final  Sealed14 documentSelector;
/// The server provides support to resolve additional information for a
/// completion item.
@override final  bool? resolveProvider;
/// Most tools trigger completion request automatically without explicitly
/// requesting it using a keyboard shortcut (e.g. Ctrl+Space). Typically
/// they do so when the user starts to type an identifier. For example if
/// the user types `c` in a JavaScript file code complete will
/// automatically pop up present `console` besides others as a completion
/// item. Characters that make up identifiers don't need to be listed here.
/// If code complete should automatically be trigger on characters not
/// being valid inside an identifier (for example `.` in JavaScript) list
/// them in `triggerCharacters`.
 final  List<String>? _triggerCharacters;
/// Most tools trigger completion request automatically without explicitly
/// requesting it using a keyboard shortcut (e.g. Ctrl+Space). Typically
/// they do so when the user starts to type an identifier. For example if
/// the user types `c` in a JavaScript file code complete will
/// automatically pop up present `console` besides others as a completion
/// item. Characters that make up identifiers don't need to be listed here.
/// If code complete should automatically be trigger on characters not
/// being valid inside an identifier (for example `.` in JavaScript) list
/// them in `triggerCharacters`.
@override List<String>? get triggerCharacters {
  final value = _triggerCharacters;
  if (value == null) return null;
  if (_triggerCharacters is EqualUnmodifiableListView) return _triggerCharacters;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}


/// Create a copy of CompletionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CompletionRegistrationOptionsCopyWith<_CompletionRegistrationOptions> get copyWith => __$CompletionRegistrationOptionsCopyWithImpl<_CompletionRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CompletionRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CompletionRegistrationOptions&&const DeepCollectionEquality().equals(other._allCommitCharacters, _allCommitCharacters)&&const DeepCollectionEquality().equals(other.completionItem, completionItem)&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider)&&const DeepCollectionEquality().equals(other._triggerCharacters, _triggerCharacters));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_allCommitCharacters),const DeepCollectionEquality().hash(completionItem),documentSelector,resolveProvider,const DeepCollectionEquality().hash(_triggerCharacters));

@override
String toString() {
  return 'CompletionRegistrationOptions(allCommitCharacters: $allCommitCharacters, completionItem: $completionItem, documentSelector: $documentSelector, resolveProvider: $resolveProvider, triggerCharacters: $triggerCharacters)';
}


}

/// @nodoc
abstract mixin class _$CompletionRegistrationOptionsCopyWith<$Res> implements $CompletionRegistrationOptionsCopyWith<$Res> {
  factory _$CompletionRegistrationOptionsCopyWith(_CompletionRegistrationOptions value, $Res Function(_CompletionRegistrationOptions) _then) = __$CompletionRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 List<String>? allCommitCharacters, BoolLabelDetailsSupport? completionItem, Sealed14 documentSelector, bool? resolveProvider, List<String>? triggerCharacters
});




}
/// @nodoc
class __$CompletionRegistrationOptionsCopyWithImpl<$Res>
    implements _$CompletionRegistrationOptionsCopyWith<$Res> {
  __$CompletionRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _CompletionRegistrationOptions _self;
  final $Res Function(_CompletionRegistrationOptions) _then;

/// Create a copy of CompletionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? allCommitCharacters = freezed,Object? completionItem = freezed,Object? documentSelector = null,Object? resolveProvider = freezed,Object? triggerCharacters = freezed,}) {
  return _then(_CompletionRegistrationOptions(
allCommitCharacters: freezed == allCommitCharacters ? _self._allCommitCharacters : allCommitCharacters // ignore: cast_nullable_to_non_nullable
as List<String>?,completionItem: freezed == completionItem ? _self.completionItem : completionItem // ignore: cast_nullable_to_non_nullable
as BoolLabelDetailsSupport?,documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,triggerCharacters: freezed == triggerCharacters ? _self._triggerCharacters : triggerCharacters // ignore: cast_nullable_to_non_nullable
as List<String>?,
  ));
}


}


/// @nodoc
mixin _$HoverParams {

/// The position inside the text document.
 Position get position;/// The text document.
 TextDocumentIdentifier get textDocument;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of HoverParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$HoverParamsCopyWith<HoverParams> get copyWith => _$HoverParamsCopyWithImpl<HoverParams>(this as HoverParams, _$identity);

  /// Serializes this HoverParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is HoverParams&&(identical(other.position, position) || other.position == position)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,position,textDocument,workDoneToken);

@override
String toString() {
  return 'HoverParams(position: $position, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $HoverParamsCopyWith<$Res>  {
  factory $HoverParamsCopyWith(HoverParams value, $Res Function(HoverParams) _then) = _$HoverParamsCopyWithImpl;
@useResult
$Res call({
 Position position, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


$PositionCopyWith<$Res> get position;$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$HoverParamsCopyWithImpl<$Res>
    implements $HoverParamsCopyWith<$Res> {
  _$HoverParamsCopyWithImpl(this._self, this._then);

  final HoverParams _self;
  final $Res Function(HoverParams) _then;

/// Create a copy of HoverParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? position = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of HoverParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of HoverParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _HoverParams implements HoverParams {
  const _HoverParams({required this.position, required this.textDocument, this.workDoneToken});
  factory _HoverParams.fromJson(Map<String, dynamic> json) => _$HoverParamsFromJson(json);

/// The position inside the text document.
@override final  Position position;
/// The text document.
@override final  TextDocumentIdentifier textDocument;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of HoverParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$HoverParamsCopyWith<_HoverParams> get copyWith => __$HoverParamsCopyWithImpl<_HoverParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$HoverParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _HoverParams&&(identical(other.position, position) || other.position == position)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,position,textDocument,workDoneToken);

@override
String toString() {
  return 'HoverParams(position: $position, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$HoverParamsCopyWith<$Res> implements $HoverParamsCopyWith<$Res> {
  factory _$HoverParamsCopyWith(_HoverParams value, $Res Function(_HoverParams) _then) = __$HoverParamsCopyWithImpl;
@override @useResult
$Res call({
 Position position, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


@override $PositionCopyWith<$Res> get position;@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$HoverParamsCopyWithImpl<$Res>
    implements _$HoverParamsCopyWith<$Res> {
  __$HoverParamsCopyWithImpl(this._self, this._then);

  final _HoverParams _self;
  final $Res Function(_HoverParams) _then;

/// Create a copy of HoverParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? position = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_HoverParams(
position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of HoverParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of HoverParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$Hover {

/// The hover's content
 Sealed23 get contents;/// An optional range inside the text document that is used to visualize
/// the hover, e.g. by changing the background color.
 Range? get range;
/// Create a copy of Hover
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$HoverCopyWith<Hover> get copyWith => _$HoverCopyWithImpl<Hover>(this as Hover, _$identity);

  /// Serializes this Hover to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Hover&&(identical(other.contents, contents) || other.contents == contents)&&(identical(other.range, range) || other.range == range));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,contents,range);

@override
String toString() {
  return 'Hover(contents: $contents, range: $range)';
}


}

/// @nodoc
abstract mixin class $HoverCopyWith<$Res>  {
  factory $HoverCopyWith(Hover value, $Res Function(Hover) _then) = _$HoverCopyWithImpl;
@useResult
$Res call({
 Sealed23 contents, Range? range
});


$RangeCopyWith<$Res>? get range;

}
/// @nodoc
class _$HoverCopyWithImpl<$Res>
    implements $HoverCopyWith<$Res> {
  _$HoverCopyWithImpl(this._self, this._then);

  final Hover _self;
  final $Res Function(Hover) _then;

/// Create a copy of Hover
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? contents = null,Object? range = freezed,}) {
  return _then(_self.copyWith(
contents: null == contents ? _self.contents : contents // ignore: cast_nullable_to_non_nullable
as Sealed23,range: freezed == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range?,
  ));
}
/// Create a copy of Hover
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res>? get range {
    if (_self.range == null) {
    return null;
  }

  return $RangeCopyWith<$Res>(_self.range!, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _Hover implements Hover {
  const _Hover({required this.contents, this.range});
  factory _Hover.fromJson(Map<String, dynamic> json) => _$HoverFromJson(json);

/// The hover's content
@override final  Sealed23 contents;
/// An optional range inside the text document that is used to visualize
/// the hover, e.g. by changing the background color.
@override final  Range? range;

/// Create a copy of Hover
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$HoverCopyWith<_Hover> get copyWith => __$HoverCopyWithImpl<_Hover>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$HoverToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _Hover&&(identical(other.contents, contents) || other.contents == contents)&&(identical(other.range, range) || other.range == range));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,contents,range);

@override
String toString() {
  return 'Hover(contents: $contents, range: $range)';
}


}

/// @nodoc
abstract mixin class _$HoverCopyWith<$Res> implements $HoverCopyWith<$Res> {
  factory _$HoverCopyWith(_Hover value, $Res Function(_Hover) _then) = __$HoverCopyWithImpl;
@override @useResult
$Res call({
 Sealed23 contents, Range? range
});


@override $RangeCopyWith<$Res>? get range;

}
/// @nodoc
class __$HoverCopyWithImpl<$Res>
    implements _$HoverCopyWith<$Res> {
  __$HoverCopyWithImpl(this._self, this._then);

  final _Hover _self;
  final $Res Function(_Hover) _then;

/// Create a copy of Hover
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? contents = null,Object? range = freezed,}) {
  return _then(_Hover(
contents: null == contents ? _self.contents : contents // ignore: cast_nullable_to_non_nullable
as Sealed23,range: freezed == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range?,
  ));
}

/// Create a copy of Hover
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res>? get range {
    if (_self.range == null) {
    return null;
  }

  return $RangeCopyWith<$Res>(_self.range!, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}


/// @nodoc
mixin _$HoverRegistrationOptions {

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
 Sealed14 get documentSelector;
/// Create a copy of HoverRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$HoverRegistrationOptionsCopyWith<HoverRegistrationOptions> get copyWith => _$HoverRegistrationOptionsCopyWithImpl<HoverRegistrationOptions>(this as HoverRegistrationOptions, _$identity);

  /// Serializes this HoverRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is HoverRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector);

@override
String toString() {
  return 'HoverRegistrationOptions(documentSelector: $documentSelector)';
}


}

/// @nodoc
abstract mixin class $HoverRegistrationOptionsCopyWith<$Res>  {
  factory $HoverRegistrationOptionsCopyWith(HoverRegistrationOptions value, $Res Function(HoverRegistrationOptions) _then) = _$HoverRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 Sealed14 documentSelector
});




}
/// @nodoc
class _$HoverRegistrationOptionsCopyWithImpl<$Res>
    implements $HoverRegistrationOptionsCopyWith<$Res> {
  _$HoverRegistrationOptionsCopyWithImpl(this._self, this._then);

  final HoverRegistrationOptions _self;
  final $Res Function(HoverRegistrationOptions) _then;

/// Create a copy of HoverRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = null,}) {
  return _then(_self.copyWith(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _HoverRegistrationOptions implements HoverRegistrationOptions {
  const _HoverRegistrationOptions({required this.documentSelector});
  factory _HoverRegistrationOptions.fromJson(Map<String, dynamic> json) => _$HoverRegistrationOptionsFromJson(json);

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
@override final  Sealed14 documentSelector;

/// Create a copy of HoverRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$HoverRegistrationOptionsCopyWith<_HoverRegistrationOptions> get copyWith => __$HoverRegistrationOptionsCopyWithImpl<_HoverRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$HoverRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _HoverRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector);

@override
String toString() {
  return 'HoverRegistrationOptions(documentSelector: $documentSelector)';
}


}

/// @nodoc
abstract mixin class _$HoverRegistrationOptionsCopyWith<$Res> implements $HoverRegistrationOptionsCopyWith<$Res> {
  factory _$HoverRegistrationOptionsCopyWith(_HoverRegistrationOptions value, $Res Function(_HoverRegistrationOptions) _then) = __$HoverRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 Sealed14 documentSelector
});




}
/// @nodoc
class __$HoverRegistrationOptionsCopyWithImpl<$Res>
    implements _$HoverRegistrationOptionsCopyWith<$Res> {
  __$HoverRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _HoverRegistrationOptions _self;
  final $Res Function(_HoverRegistrationOptions) _then;

/// Create a copy of HoverRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = null,}) {
  return _then(_HoverRegistrationOptions(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,
  ));
}


}


/// @nodoc
mixin _$SignatureHelpParams {

/// The signature help context. This is only available if the client
/// specifies to send this using the client capability
/// `textDocument.signatureHelp.contextSupport === true`
/// @since 3.15.0
 SignatureHelpContext? get context;/// The position inside the text document.
 Position get position;/// The text document.
 TextDocumentIdentifier get textDocument;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of SignatureHelpParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SignatureHelpParamsCopyWith<SignatureHelpParams> get copyWith => _$SignatureHelpParamsCopyWithImpl<SignatureHelpParams>(this as SignatureHelpParams, _$identity);

  /// Serializes this SignatureHelpParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SignatureHelpParams&&(identical(other.context, context) || other.context == context)&&(identical(other.position, position) || other.position == position)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,context,position,textDocument,workDoneToken);

@override
String toString() {
  return 'SignatureHelpParams(context: $context, position: $position, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $SignatureHelpParamsCopyWith<$Res>  {
  factory $SignatureHelpParamsCopyWith(SignatureHelpParams value, $Res Function(SignatureHelpParams) _then) = _$SignatureHelpParamsCopyWithImpl;
@useResult
$Res call({
 SignatureHelpContext? context, Position position, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


$SignatureHelpContextCopyWith<$Res>? get context;$PositionCopyWith<$Res> get position;$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$SignatureHelpParamsCopyWithImpl<$Res>
    implements $SignatureHelpParamsCopyWith<$Res> {
  _$SignatureHelpParamsCopyWithImpl(this._self, this._then);

  final SignatureHelpParams _self;
  final $Res Function(SignatureHelpParams) _then;

/// Create a copy of SignatureHelpParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? context = freezed,Object? position = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
context: freezed == context ? _self.context : context // ignore: cast_nullable_to_non_nullable
as SignatureHelpContext?,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of SignatureHelpParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SignatureHelpContextCopyWith<$Res>? get context {
    if (_self.context == null) {
    return null;
  }

  return $SignatureHelpContextCopyWith<$Res>(_self.context!, (value) {
    return _then(_self.copyWith(context: value));
  });
}/// Create a copy of SignatureHelpParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of SignatureHelpParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _SignatureHelpParams implements SignatureHelpParams {
  const _SignatureHelpParams({this.context, required this.position, required this.textDocument, this.workDoneToken});
  factory _SignatureHelpParams.fromJson(Map<String, dynamic> json) => _$SignatureHelpParamsFromJson(json);

/// The signature help context. This is only available if the client
/// specifies to send this using the client capability
/// `textDocument.signatureHelp.contextSupport === true`
/// @since 3.15.0
@override final  SignatureHelpContext? context;
/// The position inside the text document.
@override final  Position position;
/// The text document.
@override final  TextDocumentIdentifier textDocument;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of SignatureHelpParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SignatureHelpParamsCopyWith<_SignatureHelpParams> get copyWith => __$SignatureHelpParamsCopyWithImpl<_SignatureHelpParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SignatureHelpParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SignatureHelpParams&&(identical(other.context, context) || other.context == context)&&(identical(other.position, position) || other.position == position)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,context,position,textDocument,workDoneToken);

@override
String toString() {
  return 'SignatureHelpParams(context: $context, position: $position, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$SignatureHelpParamsCopyWith<$Res> implements $SignatureHelpParamsCopyWith<$Res> {
  factory _$SignatureHelpParamsCopyWith(_SignatureHelpParams value, $Res Function(_SignatureHelpParams) _then) = __$SignatureHelpParamsCopyWithImpl;
@override @useResult
$Res call({
 SignatureHelpContext? context, Position position, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


@override $SignatureHelpContextCopyWith<$Res>? get context;@override $PositionCopyWith<$Res> get position;@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$SignatureHelpParamsCopyWithImpl<$Res>
    implements _$SignatureHelpParamsCopyWith<$Res> {
  __$SignatureHelpParamsCopyWithImpl(this._self, this._then);

  final _SignatureHelpParams _self;
  final $Res Function(_SignatureHelpParams) _then;

/// Create a copy of SignatureHelpParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? context = freezed,Object? position = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_SignatureHelpParams(
context: freezed == context ? _self.context : context // ignore: cast_nullable_to_non_nullable
as SignatureHelpContext?,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of SignatureHelpParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SignatureHelpContextCopyWith<$Res>? get context {
    if (_self.context == null) {
    return null;
  }

  return $SignatureHelpContextCopyWith<$Res>(_self.context!, (value) {
    return _then(_self.copyWith(context: value));
  });
}/// Create a copy of SignatureHelpParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of SignatureHelpParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$SignatureHelp {

/// The active parameter of the active signature. If omitted or the value
/// lies outside the range of `signatures[activeSignature].parameters`
/// defaults to 0 if the active signature has parameters. If the active
/// signature has no parameters it is ignored. In future version of the
/// protocol this property might become mandatory to better express the
/// active parameter if the active signature does have any.
 int? get activeParameter;/// The active signature. If omitted or the value lies outside the range of
/// `signatures` the value defaults to zero or is ignored if the
/// `SignatureHelp` has no signatures.
/// Whenever possible implementors should make an active decision about the
/// active signature and shouldn't rely on a default value.
/// In future version of the protocol this property might become mandatory
/// to better express this.
 int? get activeSignature;/// One or more signatures.
 List<SignatureInformation> get signatures;
/// Create a copy of SignatureHelp
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SignatureHelpCopyWith<SignatureHelp> get copyWith => _$SignatureHelpCopyWithImpl<SignatureHelp>(this as SignatureHelp, _$identity);

  /// Serializes this SignatureHelp to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SignatureHelp&&(identical(other.activeParameter, activeParameter) || other.activeParameter == activeParameter)&&(identical(other.activeSignature, activeSignature) || other.activeSignature == activeSignature)&&const DeepCollectionEquality().equals(other.signatures, signatures));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,activeParameter,activeSignature,const DeepCollectionEquality().hash(signatures));

@override
String toString() {
  return 'SignatureHelp(activeParameter: $activeParameter, activeSignature: $activeSignature, signatures: $signatures)';
}


}

/// @nodoc
abstract mixin class $SignatureHelpCopyWith<$Res>  {
  factory $SignatureHelpCopyWith(SignatureHelp value, $Res Function(SignatureHelp) _then) = _$SignatureHelpCopyWithImpl;
@useResult
$Res call({
 int? activeParameter, int? activeSignature, List<SignatureInformation> signatures
});




}
/// @nodoc
class _$SignatureHelpCopyWithImpl<$Res>
    implements $SignatureHelpCopyWith<$Res> {
  _$SignatureHelpCopyWithImpl(this._self, this._then);

  final SignatureHelp _self;
  final $Res Function(SignatureHelp) _then;

/// Create a copy of SignatureHelp
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? activeParameter = freezed,Object? activeSignature = freezed,Object? signatures = null,}) {
  return _then(_self.copyWith(
activeParameter: freezed == activeParameter ? _self.activeParameter : activeParameter // ignore: cast_nullable_to_non_nullable
as int?,activeSignature: freezed == activeSignature ? _self.activeSignature : activeSignature // ignore: cast_nullable_to_non_nullable
as int?,signatures: null == signatures ? _self.signatures : signatures // ignore: cast_nullable_to_non_nullable
as List<SignatureInformation>,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _SignatureHelp implements SignatureHelp {
  const _SignatureHelp({this.activeParameter, this.activeSignature, required final  List<SignatureInformation> signatures}): _signatures = signatures;
  factory _SignatureHelp.fromJson(Map<String, dynamic> json) => _$SignatureHelpFromJson(json);

/// The active parameter of the active signature. If omitted or the value
/// lies outside the range of `signatures[activeSignature].parameters`
/// defaults to 0 if the active signature has parameters. If the active
/// signature has no parameters it is ignored. In future version of the
/// protocol this property might become mandatory to better express the
/// active parameter if the active signature does have any.
@override final  int? activeParameter;
/// The active signature. If omitted or the value lies outside the range of
/// `signatures` the value defaults to zero or is ignored if the
/// `SignatureHelp` has no signatures.
/// Whenever possible implementors should make an active decision about the
/// active signature and shouldn't rely on a default value.
/// In future version of the protocol this property might become mandatory
/// to better express this.
@override final  int? activeSignature;
/// One or more signatures.
 final  List<SignatureInformation> _signatures;
/// One or more signatures.
@override List<SignatureInformation> get signatures {
  if (_signatures is EqualUnmodifiableListView) return _signatures;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_signatures);
}


/// Create a copy of SignatureHelp
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SignatureHelpCopyWith<_SignatureHelp> get copyWith => __$SignatureHelpCopyWithImpl<_SignatureHelp>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SignatureHelpToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SignatureHelp&&(identical(other.activeParameter, activeParameter) || other.activeParameter == activeParameter)&&(identical(other.activeSignature, activeSignature) || other.activeSignature == activeSignature)&&const DeepCollectionEquality().equals(other._signatures, _signatures));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,activeParameter,activeSignature,const DeepCollectionEquality().hash(_signatures));

@override
String toString() {
  return 'SignatureHelp(activeParameter: $activeParameter, activeSignature: $activeSignature, signatures: $signatures)';
}


}

/// @nodoc
abstract mixin class _$SignatureHelpCopyWith<$Res> implements $SignatureHelpCopyWith<$Res> {
  factory _$SignatureHelpCopyWith(_SignatureHelp value, $Res Function(_SignatureHelp) _then) = __$SignatureHelpCopyWithImpl;
@override @useResult
$Res call({
 int? activeParameter, int? activeSignature, List<SignatureInformation> signatures
});




}
/// @nodoc
class __$SignatureHelpCopyWithImpl<$Res>
    implements _$SignatureHelpCopyWith<$Res> {
  __$SignatureHelpCopyWithImpl(this._self, this._then);

  final _SignatureHelp _self;
  final $Res Function(_SignatureHelp) _then;

/// Create a copy of SignatureHelp
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? activeParameter = freezed,Object? activeSignature = freezed,Object? signatures = null,}) {
  return _then(_SignatureHelp(
activeParameter: freezed == activeParameter ? _self.activeParameter : activeParameter // ignore: cast_nullable_to_non_nullable
as int?,activeSignature: freezed == activeSignature ? _self.activeSignature : activeSignature // ignore: cast_nullable_to_non_nullable
as int?,signatures: null == signatures ? _self._signatures : signatures // ignore: cast_nullable_to_non_nullable
as List<SignatureInformation>,
  ));
}


}


/// @nodoc
mixin _$SignatureHelpRegistrationOptions {

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
 Sealed14 get documentSelector;/// List of characters that re-trigger signature help.
/// These trigger characters are only active when signature help is already
/// showing. All trigger characters are also counted as re-trigger
/// characters.
/// @since 3.15.0
 List<String>? get retriggerCharacters;/// List of characters that trigger signature help automatically.
 List<String>? get triggerCharacters;
/// Create a copy of SignatureHelpRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SignatureHelpRegistrationOptionsCopyWith<SignatureHelpRegistrationOptions> get copyWith => _$SignatureHelpRegistrationOptionsCopyWithImpl<SignatureHelpRegistrationOptions>(this as SignatureHelpRegistrationOptions, _$identity);

  /// Serializes this SignatureHelpRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SignatureHelpRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&const DeepCollectionEquality().equals(other.retriggerCharacters, retriggerCharacters)&&const DeepCollectionEquality().equals(other.triggerCharacters, triggerCharacters));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,const DeepCollectionEquality().hash(retriggerCharacters),const DeepCollectionEquality().hash(triggerCharacters));

@override
String toString() {
  return 'SignatureHelpRegistrationOptions(documentSelector: $documentSelector, retriggerCharacters: $retriggerCharacters, triggerCharacters: $triggerCharacters)';
}


}

/// @nodoc
abstract mixin class $SignatureHelpRegistrationOptionsCopyWith<$Res>  {
  factory $SignatureHelpRegistrationOptionsCopyWith(SignatureHelpRegistrationOptions value, $Res Function(SignatureHelpRegistrationOptions) _then) = _$SignatureHelpRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 Sealed14 documentSelector, List<String>? retriggerCharacters, List<String>? triggerCharacters
});




}
/// @nodoc
class _$SignatureHelpRegistrationOptionsCopyWithImpl<$Res>
    implements $SignatureHelpRegistrationOptionsCopyWith<$Res> {
  _$SignatureHelpRegistrationOptionsCopyWithImpl(this._self, this._then);

  final SignatureHelpRegistrationOptions _self;
  final $Res Function(SignatureHelpRegistrationOptions) _then;

/// Create a copy of SignatureHelpRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = null,Object? retriggerCharacters = freezed,Object? triggerCharacters = freezed,}) {
  return _then(_self.copyWith(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,retriggerCharacters: freezed == retriggerCharacters ? _self.retriggerCharacters : retriggerCharacters // ignore: cast_nullable_to_non_nullable
as List<String>?,triggerCharacters: freezed == triggerCharacters ? _self.triggerCharacters : triggerCharacters // ignore: cast_nullable_to_non_nullable
as List<String>?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _SignatureHelpRegistrationOptions implements SignatureHelpRegistrationOptions {
  const _SignatureHelpRegistrationOptions({required this.documentSelector, final  List<String>? retriggerCharacters, final  List<String>? triggerCharacters}): _retriggerCharacters = retriggerCharacters,_triggerCharacters = triggerCharacters;
  factory _SignatureHelpRegistrationOptions.fromJson(Map<String, dynamic> json) => _$SignatureHelpRegistrationOptionsFromJson(json);

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
@override final  Sealed14 documentSelector;
/// List of characters that re-trigger signature help.
/// These trigger characters are only active when signature help is already
/// showing. All trigger characters are also counted as re-trigger
/// characters.
/// @since 3.15.0
 final  List<String>? _retriggerCharacters;
/// List of characters that re-trigger signature help.
/// These trigger characters are only active when signature help is already
/// showing. All trigger characters are also counted as re-trigger
/// characters.
/// @since 3.15.0
@override List<String>? get retriggerCharacters {
  final value = _retriggerCharacters;
  if (value == null) return null;
  if (_retriggerCharacters is EqualUnmodifiableListView) return _retriggerCharacters;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

/// List of characters that trigger signature help automatically.
 final  List<String>? _triggerCharacters;
/// List of characters that trigger signature help automatically.
@override List<String>? get triggerCharacters {
  final value = _triggerCharacters;
  if (value == null) return null;
  if (_triggerCharacters is EqualUnmodifiableListView) return _triggerCharacters;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}


/// Create a copy of SignatureHelpRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SignatureHelpRegistrationOptionsCopyWith<_SignatureHelpRegistrationOptions> get copyWith => __$SignatureHelpRegistrationOptionsCopyWithImpl<_SignatureHelpRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SignatureHelpRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SignatureHelpRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&const DeepCollectionEquality().equals(other._retriggerCharacters, _retriggerCharacters)&&const DeepCollectionEquality().equals(other._triggerCharacters, _triggerCharacters));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,const DeepCollectionEquality().hash(_retriggerCharacters),const DeepCollectionEquality().hash(_triggerCharacters));

@override
String toString() {
  return 'SignatureHelpRegistrationOptions(documentSelector: $documentSelector, retriggerCharacters: $retriggerCharacters, triggerCharacters: $triggerCharacters)';
}


}

/// @nodoc
abstract mixin class _$SignatureHelpRegistrationOptionsCopyWith<$Res> implements $SignatureHelpRegistrationOptionsCopyWith<$Res> {
  factory _$SignatureHelpRegistrationOptionsCopyWith(_SignatureHelpRegistrationOptions value, $Res Function(_SignatureHelpRegistrationOptions) _then) = __$SignatureHelpRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 Sealed14 documentSelector, List<String>? retriggerCharacters, List<String>? triggerCharacters
});




}
/// @nodoc
class __$SignatureHelpRegistrationOptionsCopyWithImpl<$Res>
    implements _$SignatureHelpRegistrationOptionsCopyWith<$Res> {
  __$SignatureHelpRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _SignatureHelpRegistrationOptions _self;
  final $Res Function(_SignatureHelpRegistrationOptions) _then;

/// Create a copy of SignatureHelpRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = null,Object? retriggerCharacters = freezed,Object? triggerCharacters = freezed,}) {
  return _then(_SignatureHelpRegistrationOptions(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,retriggerCharacters: freezed == retriggerCharacters ? _self._retriggerCharacters : retriggerCharacters // ignore: cast_nullable_to_non_nullable
as List<String>?,triggerCharacters: freezed == triggerCharacters ? _self._triggerCharacters : triggerCharacters // ignore: cast_nullable_to_non_nullable
as List<String>?,
  ));
}


}


/// @nodoc
mixin _$DefinitionParams {

/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
 ProgressToken? get partialResultToken;/// The position inside the text document.
 Position get position;/// The text document.
 TextDocumentIdentifier get textDocument;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of DefinitionParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DefinitionParamsCopyWith<DefinitionParams> get copyWith => _$DefinitionParamsCopyWithImpl<DefinitionParams>(this as DefinitionParams, _$identity);

  /// Serializes this DefinitionParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DefinitionParams&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.position, position) || other.position == position)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,partialResultToken,position,textDocument,workDoneToken);

@override
String toString() {
  return 'DefinitionParams(partialResultToken: $partialResultToken, position: $position, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $DefinitionParamsCopyWith<$Res>  {
  factory $DefinitionParamsCopyWith(DefinitionParams value, $Res Function(DefinitionParams) _then) = _$DefinitionParamsCopyWithImpl;
@useResult
$Res call({
 ProgressToken? partialResultToken, Position position, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


$PositionCopyWith<$Res> get position;$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$DefinitionParamsCopyWithImpl<$Res>
    implements $DefinitionParamsCopyWith<$Res> {
  _$DefinitionParamsCopyWithImpl(this._self, this._then);

  final DefinitionParams _self;
  final $Res Function(DefinitionParams) _then;

/// Create a copy of DefinitionParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? partialResultToken = freezed,Object? position = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of DefinitionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of DefinitionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _DefinitionParams implements DefinitionParams {
  const _DefinitionParams({this.partialResultToken, required this.position, required this.textDocument, this.workDoneToken});
  factory _DefinitionParams.fromJson(Map<String, dynamic> json) => _$DefinitionParamsFromJson(json);

/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
@override final  ProgressToken? partialResultToken;
/// The position inside the text document.
@override final  Position position;
/// The text document.
@override final  TextDocumentIdentifier textDocument;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of DefinitionParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DefinitionParamsCopyWith<_DefinitionParams> get copyWith => __$DefinitionParamsCopyWithImpl<_DefinitionParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DefinitionParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DefinitionParams&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.position, position) || other.position == position)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,partialResultToken,position,textDocument,workDoneToken);

@override
String toString() {
  return 'DefinitionParams(partialResultToken: $partialResultToken, position: $position, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$DefinitionParamsCopyWith<$Res> implements $DefinitionParamsCopyWith<$Res> {
  factory _$DefinitionParamsCopyWith(_DefinitionParams value, $Res Function(_DefinitionParams) _then) = __$DefinitionParamsCopyWithImpl;
@override @useResult
$Res call({
 ProgressToken? partialResultToken, Position position, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


@override $PositionCopyWith<$Res> get position;@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$DefinitionParamsCopyWithImpl<$Res>
    implements _$DefinitionParamsCopyWith<$Res> {
  __$DefinitionParamsCopyWithImpl(this._self, this._then);

  final _DefinitionParams _self;
  final $Res Function(_DefinitionParams) _then;

/// Create a copy of DefinitionParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? partialResultToken = freezed,Object? position = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_DefinitionParams(
partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of DefinitionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of DefinitionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$DefinitionRegistrationOptions {

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
 Sealed14 get documentSelector;
/// Create a copy of DefinitionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DefinitionRegistrationOptionsCopyWith<DefinitionRegistrationOptions> get copyWith => _$DefinitionRegistrationOptionsCopyWithImpl<DefinitionRegistrationOptions>(this as DefinitionRegistrationOptions, _$identity);

  /// Serializes this DefinitionRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DefinitionRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector);

@override
String toString() {
  return 'DefinitionRegistrationOptions(documentSelector: $documentSelector)';
}


}

/// @nodoc
abstract mixin class $DefinitionRegistrationOptionsCopyWith<$Res>  {
  factory $DefinitionRegistrationOptionsCopyWith(DefinitionRegistrationOptions value, $Res Function(DefinitionRegistrationOptions) _then) = _$DefinitionRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 Sealed14 documentSelector
});




}
/// @nodoc
class _$DefinitionRegistrationOptionsCopyWithImpl<$Res>
    implements $DefinitionRegistrationOptionsCopyWith<$Res> {
  _$DefinitionRegistrationOptionsCopyWithImpl(this._self, this._then);

  final DefinitionRegistrationOptions _self;
  final $Res Function(DefinitionRegistrationOptions) _then;

/// Create a copy of DefinitionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = null,}) {
  return _then(_self.copyWith(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DefinitionRegistrationOptions implements DefinitionRegistrationOptions {
  const _DefinitionRegistrationOptions({required this.documentSelector});
  factory _DefinitionRegistrationOptions.fromJson(Map<String, dynamic> json) => _$DefinitionRegistrationOptionsFromJson(json);

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
@override final  Sealed14 documentSelector;

/// Create a copy of DefinitionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DefinitionRegistrationOptionsCopyWith<_DefinitionRegistrationOptions> get copyWith => __$DefinitionRegistrationOptionsCopyWithImpl<_DefinitionRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DefinitionRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DefinitionRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector);

@override
String toString() {
  return 'DefinitionRegistrationOptions(documentSelector: $documentSelector)';
}


}

/// @nodoc
abstract mixin class _$DefinitionRegistrationOptionsCopyWith<$Res> implements $DefinitionRegistrationOptionsCopyWith<$Res> {
  factory _$DefinitionRegistrationOptionsCopyWith(_DefinitionRegistrationOptions value, $Res Function(_DefinitionRegistrationOptions) _then) = __$DefinitionRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 Sealed14 documentSelector
});




}
/// @nodoc
class __$DefinitionRegistrationOptionsCopyWithImpl<$Res>
    implements _$DefinitionRegistrationOptionsCopyWith<$Res> {
  __$DefinitionRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _DefinitionRegistrationOptions _self;
  final $Res Function(_DefinitionRegistrationOptions) _then;

/// Create a copy of DefinitionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = null,}) {
  return _then(_DefinitionRegistrationOptions(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,
  ));
}


}


/// @nodoc
mixin _$ReferenceParams {

 ReferenceContext get context;/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
 ProgressToken? get partialResultToken;/// The position inside the text document.
 Position get position;/// The text document.
 TextDocumentIdentifier get textDocument;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of ReferenceParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ReferenceParamsCopyWith<ReferenceParams> get copyWith => _$ReferenceParamsCopyWithImpl<ReferenceParams>(this as ReferenceParams, _$identity);

  /// Serializes this ReferenceParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ReferenceParams&&(identical(other.context, context) || other.context == context)&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.position, position) || other.position == position)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,context,partialResultToken,position,textDocument,workDoneToken);

@override
String toString() {
  return 'ReferenceParams(context: $context, partialResultToken: $partialResultToken, position: $position, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $ReferenceParamsCopyWith<$Res>  {
  factory $ReferenceParamsCopyWith(ReferenceParams value, $Res Function(ReferenceParams) _then) = _$ReferenceParamsCopyWithImpl;
@useResult
$Res call({
 ReferenceContext context, ProgressToken? partialResultToken, Position position, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


$ReferenceContextCopyWith<$Res> get context;$PositionCopyWith<$Res> get position;$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$ReferenceParamsCopyWithImpl<$Res>
    implements $ReferenceParamsCopyWith<$Res> {
  _$ReferenceParamsCopyWithImpl(this._self, this._then);

  final ReferenceParams _self;
  final $Res Function(ReferenceParams) _then;

/// Create a copy of ReferenceParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? context = null,Object? partialResultToken = freezed,Object? position = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
context: null == context ? _self.context : context // ignore: cast_nullable_to_non_nullable
as ReferenceContext,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of ReferenceParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ReferenceContextCopyWith<$Res> get context {
  
  return $ReferenceContextCopyWith<$Res>(_self.context, (value) {
    return _then(_self.copyWith(context: value));
  });
}/// Create a copy of ReferenceParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of ReferenceParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _ReferenceParams implements ReferenceParams {
  const _ReferenceParams({required this.context, this.partialResultToken, required this.position, required this.textDocument, this.workDoneToken});
  factory _ReferenceParams.fromJson(Map<String, dynamic> json) => _$ReferenceParamsFromJson(json);

@override final  ReferenceContext context;
/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
@override final  ProgressToken? partialResultToken;
/// The position inside the text document.
@override final  Position position;
/// The text document.
@override final  TextDocumentIdentifier textDocument;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of ReferenceParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ReferenceParamsCopyWith<_ReferenceParams> get copyWith => __$ReferenceParamsCopyWithImpl<_ReferenceParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ReferenceParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ReferenceParams&&(identical(other.context, context) || other.context == context)&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.position, position) || other.position == position)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,context,partialResultToken,position,textDocument,workDoneToken);

@override
String toString() {
  return 'ReferenceParams(context: $context, partialResultToken: $partialResultToken, position: $position, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$ReferenceParamsCopyWith<$Res> implements $ReferenceParamsCopyWith<$Res> {
  factory _$ReferenceParamsCopyWith(_ReferenceParams value, $Res Function(_ReferenceParams) _then) = __$ReferenceParamsCopyWithImpl;
@override @useResult
$Res call({
 ReferenceContext context, ProgressToken? partialResultToken, Position position, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


@override $ReferenceContextCopyWith<$Res> get context;@override $PositionCopyWith<$Res> get position;@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$ReferenceParamsCopyWithImpl<$Res>
    implements _$ReferenceParamsCopyWith<$Res> {
  __$ReferenceParamsCopyWithImpl(this._self, this._then);

  final _ReferenceParams _self;
  final $Res Function(_ReferenceParams) _then;

/// Create a copy of ReferenceParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? context = null,Object? partialResultToken = freezed,Object? position = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_ReferenceParams(
context: null == context ? _self.context : context // ignore: cast_nullable_to_non_nullable
as ReferenceContext,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of ReferenceParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ReferenceContextCopyWith<$Res> get context {
  
  return $ReferenceContextCopyWith<$Res>(_self.context, (value) {
    return _then(_self.copyWith(context: value));
  });
}/// Create a copy of ReferenceParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of ReferenceParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$ReferenceRegistrationOptions {

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
 Sealed14 get documentSelector;
/// Create a copy of ReferenceRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ReferenceRegistrationOptionsCopyWith<ReferenceRegistrationOptions> get copyWith => _$ReferenceRegistrationOptionsCopyWithImpl<ReferenceRegistrationOptions>(this as ReferenceRegistrationOptions, _$identity);

  /// Serializes this ReferenceRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ReferenceRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector);

@override
String toString() {
  return 'ReferenceRegistrationOptions(documentSelector: $documentSelector)';
}


}

/// @nodoc
abstract mixin class $ReferenceRegistrationOptionsCopyWith<$Res>  {
  factory $ReferenceRegistrationOptionsCopyWith(ReferenceRegistrationOptions value, $Res Function(ReferenceRegistrationOptions) _then) = _$ReferenceRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 Sealed14 documentSelector
});




}
/// @nodoc
class _$ReferenceRegistrationOptionsCopyWithImpl<$Res>
    implements $ReferenceRegistrationOptionsCopyWith<$Res> {
  _$ReferenceRegistrationOptionsCopyWithImpl(this._self, this._then);

  final ReferenceRegistrationOptions _self;
  final $Res Function(ReferenceRegistrationOptions) _then;

/// Create a copy of ReferenceRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = null,}) {
  return _then(_self.copyWith(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _ReferenceRegistrationOptions implements ReferenceRegistrationOptions {
  const _ReferenceRegistrationOptions({required this.documentSelector});
  factory _ReferenceRegistrationOptions.fromJson(Map<String, dynamic> json) => _$ReferenceRegistrationOptionsFromJson(json);

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
@override final  Sealed14 documentSelector;

/// Create a copy of ReferenceRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ReferenceRegistrationOptionsCopyWith<_ReferenceRegistrationOptions> get copyWith => __$ReferenceRegistrationOptionsCopyWithImpl<_ReferenceRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ReferenceRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ReferenceRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector);

@override
String toString() {
  return 'ReferenceRegistrationOptions(documentSelector: $documentSelector)';
}


}

/// @nodoc
abstract mixin class _$ReferenceRegistrationOptionsCopyWith<$Res> implements $ReferenceRegistrationOptionsCopyWith<$Res> {
  factory _$ReferenceRegistrationOptionsCopyWith(_ReferenceRegistrationOptions value, $Res Function(_ReferenceRegistrationOptions) _then) = __$ReferenceRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 Sealed14 documentSelector
});




}
/// @nodoc
class __$ReferenceRegistrationOptionsCopyWithImpl<$Res>
    implements _$ReferenceRegistrationOptionsCopyWith<$Res> {
  __$ReferenceRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _ReferenceRegistrationOptions _self;
  final $Res Function(_ReferenceRegistrationOptions) _then;

/// Create a copy of ReferenceRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = null,}) {
  return _then(_ReferenceRegistrationOptions(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,
  ));
}


}


/// @nodoc
mixin _$DocumentHighlightParams {

/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
 ProgressToken? get partialResultToken;/// The position inside the text document.
 Position get position;/// The text document.
 TextDocumentIdentifier get textDocument;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of DocumentHighlightParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentHighlightParamsCopyWith<DocumentHighlightParams> get copyWith => _$DocumentHighlightParamsCopyWithImpl<DocumentHighlightParams>(this as DocumentHighlightParams, _$identity);

  /// Serializes this DocumentHighlightParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentHighlightParams&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.position, position) || other.position == position)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,partialResultToken,position,textDocument,workDoneToken);

@override
String toString() {
  return 'DocumentHighlightParams(partialResultToken: $partialResultToken, position: $position, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $DocumentHighlightParamsCopyWith<$Res>  {
  factory $DocumentHighlightParamsCopyWith(DocumentHighlightParams value, $Res Function(DocumentHighlightParams) _then) = _$DocumentHighlightParamsCopyWithImpl;
@useResult
$Res call({
 ProgressToken? partialResultToken, Position position, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


$PositionCopyWith<$Res> get position;$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$DocumentHighlightParamsCopyWithImpl<$Res>
    implements $DocumentHighlightParamsCopyWith<$Res> {
  _$DocumentHighlightParamsCopyWithImpl(this._self, this._then);

  final DocumentHighlightParams _self;
  final $Res Function(DocumentHighlightParams) _then;

/// Create a copy of DocumentHighlightParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? partialResultToken = freezed,Object? position = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of DocumentHighlightParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of DocumentHighlightParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _DocumentHighlightParams implements DocumentHighlightParams {
  const _DocumentHighlightParams({this.partialResultToken, required this.position, required this.textDocument, this.workDoneToken});
  factory _DocumentHighlightParams.fromJson(Map<String, dynamic> json) => _$DocumentHighlightParamsFromJson(json);

/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
@override final  ProgressToken? partialResultToken;
/// The position inside the text document.
@override final  Position position;
/// The text document.
@override final  TextDocumentIdentifier textDocument;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of DocumentHighlightParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentHighlightParamsCopyWith<_DocumentHighlightParams> get copyWith => __$DocumentHighlightParamsCopyWithImpl<_DocumentHighlightParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentHighlightParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentHighlightParams&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.position, position) || other.position == position)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,partialResultToken,position,textDocument,workDoneToken);

@override
String toString() {
  return 'DocumentHighlightParams(partialResultToken: $partialResultToken, position: $position, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$DocumentHighlightParamsCopyWith<$Res> implements $DocumentHighlightParamsCopyWith<$Res> {
  factory _$DocumentHighlightParamsCopyWith(_DocumentHighlightParams value, $Res Function(_DocumentHighlightParams) _then) = __$DocumentHighlightParamsCopyWithImpl;
@override @useResult
$Res call({
 ProgressToken? partialResultToken, Position position, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


@override $PositionCopyWith<$Res> get position;@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$DocumentHighlightParamsCopyWithImpl<$Res>
    implements _$DocumentHighlightParamsCopyWith<$Res> {
  __$DocumentHighlightParamsCopyWithImpl(this._self, this._then);

  final _DocumentHighlightParams _self;
  final $Res Function(_DocumentHighlightParams) _then;

/// Create a copy of DocumentHighlightParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? partialResultToken = freezed,Object? position = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_DocumentHighlightParams(
partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of DocumentHighlightParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of DocumentHighlightParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$DocumentHighlight {

/// The highlight kind, default is {@link DocumentHighlightKind.Text text}.
 DocumentHighlightKind? get kind;/// The range this highlight applies to.
 Range get range;
/// Create a copy of DocumentHighlight
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentHighlightCopyWith<DocumentHighlight> get copyWith => _$DocumentHighlightCopyWithImpl<DocumentHighlight>(this as DocumentHighlight, _$identity);

  /// Serializes this DocumentHighlight to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentHighlight&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.range, range) || other.range == range));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,kind,range);

@override
String toString() {
  return 'DocumentHighlight(kind: $kind, range: $range)';
}


}

/// @nodoc
abstract mixin class $DocumentHighlightCopyWith<$Res>  {
  factory $DocumentHighlightCopyWith(DocumentHighlight value, $Res Function(DocumentHighlight) _then) = _$DocumentHighlightCopyWithImpl;
@useResult
$Res call({
 DocumentHighlightKind? kind, Range range
});


$RangeCopyWith<$Res> get range;

}
/// @nodoc
class _$DocumentHighlightCopyWithImpl<$Res>
    implements $DocumentHighlightCopyWith<$Res> {
  _$DocumentHighlightCopyWithImpl(this._self, this._then);

  final DocumentHighlight _self;
  final $Res Function(DocumentHighlight) _then;

/// Create a copy of DocumentHighlight
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? kind = freezed,Object? range = null,}) {
  return _then(_self.copyWith(
kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as DocumentHighlightKind?,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,
  ));
}
/// Create a copy of DocumentHighlight
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _DocumentHighlight implements DocumentHighlight {
  const _DocumentHighlight({this.kind, required this.range});
  factory _DocumentHighlight.fromJson(Map<String, dynamic> json) => _$DocumentHighlightFromJson(json);

/// The highlight kind, default is {@link DocumentHighlightKind.Text text}.
@override final  DocumentHighlightKind? kind;
/// The range this highlight applies to.
@override final  Range range;

/// Create a copy of DocumentHighlight
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentHighlightCopyWith<_DocumentHighlight> get copyWith => __$DocumentHighlightCopyWithImpl<_DocumentHighlight>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentHighlightToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentHighlight&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.range, range) || other.range == range));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,kind,range);

@override
String toString() {
  return 'DocumentHighlight(kind: $kind, range: $range)';
}


}

/// @nodoc
abstract mixin class _$DocumentHighlightCopyWith<$Res> implements $DocumentHighlightCopyWith<$Res> {
  factory _$DocumentHighlightCopyWith(_DocumentHighlight value, $Res Function(_DocumentHighlight) _then) = __$DocumentHighlightCopyWithImpl;
@override @useResult
$Res call({
 DocumentHighlightKind? kind, Range range
});


@override $RangeCopyWith<$Res> get range;

}
/// @nodoc
class __$DocumentHighlightCopyWithImpl<$Res>
    implements _$DocumentHighlightCopyWith<$Res> {
  __$DocumentHighlightCopyWithImpl(this._self, this._then);

  final _DocumentHighlight _self;
  final $Res Function(_DocumentHighlight) _then;

/// Create a copy of DocumentHighlight
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? kind = freezed,Object? range = null,}) {
  return _then(_DocumentHighlight(
kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as DocumentHighlightKind?,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,
  ));
}

/// Create a copy of DocumentHighlight
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}


/// @nodoc
mixin _$DocumentHighlightRegistrationOptions {

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
 Sealed14 get documentSelector;
/// Create a copy of DocumentHighlightRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentHighlightRegistrationOptionsCopyWith<DocumentHighlightRegistrationOptions> get copyWith => _$DocumentHighlightRegistrationOptionsCopyWithImpl<DocumentHighlightRegistrationOptions>(this as DocumentHighlightRegistrationOptions, _$identity);

  /// Serializes this DocumentHighlightRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentHighlightRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector);

@override
String toString() {
  return 'DocumentHighlightRegistrationOptions(documentSelector: $documentSelector)';
}


}

/// @nodoc
abstract mixin class $DocumentHighlightRegistrationOptionsCopyWith<$Res>  {
  factory $DocumentHighlightRegistrationOptionsCopyWith(DocumentHighlightRegistrationOptions value, $Res Function(DocumentHighlightRegistrationOptions) _then) = _$DocumentHighlightRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 Sealed14 documentSelector
});




}
/// @nodoc
class _$DocumentHighlightRegistrationOptionsCopyWithImpl<$Res>
    implements $DocumentHighlightRegistrationOptionsCopyWith<$Res> {
  _$DocumentHighlightRegistrationOptionsCopyWithImpl(this._self, this._then);

  final DocumentHighlightRegistrationOptions _self;
  final $Res Function(DocumentHighlightRegistrationOptions) _then;

/// Create a copy of DocumentHighlightRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = null,}) {
  return _then(_self.copyWith(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DocumentHighlightRegistrationOptions implements DocumentHighlightRegistrationOptions {
  const _DocumentHighlightRegistrationOptions({required this.documentSelector});
  factory _DocumentHighlightRegistrationOptions.fromJson(Map<String, dynamic> json) => _$DocumentHighlightRegistrationOptionsFromJson(json);

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
@override final  Sealed14 documentSelector;

/// Create a copy of DocumentHighlightRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentHighlightRegistrationOptionsCopyWith<_DocumentHighlightRegistrationOptions> get copyWith => __$DocumentHighlightRegistrationOptionsCopyWithImpl<_DocumentHighlightRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentHighlightRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentHighlightRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector);

@override
String toString() {
  return 'DocumentHighlightRegistrationOptions(documentSelector: $documentSelector)';
}


}

/// @nodoc
abstract mixin class _$DocumentHighlightRegistrationOptionsCopyWith<$Res> implements $DocumentHighlightRegistrationOptionsCopyWith<$Res> {
  factory _$DocumentHighlightRegistrationOptionsCopyWith(_DocumentHighlightRegistrationOptions value, $Res Function(_DocumentHighlightRegistrationOptions) _then) = __$DocumentHighlightRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 Sealed14 documentSelector
});




}
/// @nodoc
class __$DocumentHighlightRegistrationOptionsCopyWithImpl<$Res>
    implements _$DocumentHighlightRegistrationOptionsCopyWith<$Res> {
  __$DocumentHighlightRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _DocumentHighlightRegistrationOptions _self;
  final $Res Function(_DocumentHighlightRegistrationOptions) _then;

/// Create a copy of DocumentHighlightRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = null,}) {
  return _then(_DocumentHighlightRegistrationOptions(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,
  ));
}


}


/// @nodoc
mixin _$DocumentSymbolParams {

/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
 ProgressToken? get partialResultToken;/// The text document.
 TextDocumentIdentifier get textDocument;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of DocumentSymbolParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentSymbolParamsCopyWith<DocumentSymbolParams> get copyWith => _$DocumentSymbolParamsCopyWithImpl<DocumentSymbolParams>(this as DocumentSymbolParams, _$identity);

  /// Serializes this DocumentSymbolParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentSymbolParams&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,partialResultToken,textDocument,workDoneToken);

@override
String toString() {
  return 'DocumentSymbolParams(partialResultToken: $partialResultToken, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $DocumentSymbolParamsCopyWith<$Res>  {
  factory $DocumentSymbolParamsCopyWith(DocumentSymbolParams value, $Res Function(DocumentSymbolParams) _then) = _$DocumentSymbolParamsCopyWithImpl;
@useResult
$Res call({
 ProgressToken? partialResultToken, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$DocumentSymbolParamsCopyWithImpl<$Res>
    implements $DocumentSymbolParamsCopyWith<$Res> {
  _$DocumentSymbolParamsCopyWithImpl(this._self, this._then);

  final DocumentSymbolParams _self;
  final $Res Function(DocumentSymbolParams) _then;

/// Create a copy of DocumentSymbolParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? partialResultToken = freezed,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of DocumentSymbolParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _DocumentSymbolParams implements DocumentSymbolParams {
  const _DocumentSymbolParams({this.partialResultToken, required this.textDocument, this.workDoneToken});
  factory _DocumentSymbolParams.fromJson(Map<String, dynamic> json) => _$DocumentSymbolParamsFromJson(json);

/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
@override final  ProgressToken? partialResultToken;
/// The text document.
@override final  TextDocumentIdentifier textDocument;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of DocumentSymbolParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentSymbolParamsCopyWith<_DocumentSymbolParams> get copyWith => __$DocumentSymbolParamsCopyWithImpl<_DocumentSymbolParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentSymbolParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentSymbolParams&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,partialResultToken,textDocument,workDoneToken);

@override
String toString() {
  return 'DocumentSymbolParams(partialResultToken: $partialResultToken, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$DocumentSymbolParamsCopyWith<$Res> implements $DocumentSymbolParamsCopyWith<$Res> {
  factory _$DocumentSymbolParamsCopyWith(_DocumentSymbolParams value, $Res Function(_DocumentSymbolParams) _then) = __$DocumentSymbolParamsCopyWithImpl;
@override @useResult
$Res call({
 ProgressToken? partialResultToken, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$DocumentSymbolParamsCopyWithImpl<$Res>
    implements _$DocumentSymbolParamsCopyWith<$Res> {
  __$DocumentSymbolParamsCopyWithImpl(this._self, this._then);

  final _DocumentSymbolParams _self;
  final $Res Function(_DocumentSymbolParams) _then;

/// Create a copy of DocumentSymbolParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? partialResultToken = freezed,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_DocumentSymbolParams(
partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of DocumentSymbolParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$SymbolInformation {

/// The name of the symbol containing this symbol. This information is for
/// user interface purposes (e.g. to render a qualifier in the user
/// interface if necessary). It can't be used to re-infer a hierarchy for
/// the document symbols.
 String? get containerName;/// Indicates if this symbol is deprecated.
/// @deprecated Use tags instead
 bool? get deprecated;/// The kind of this symbol.
 SymbolKind get kind;/// The location of this symbol. The location's range is used by a tool to
/// reveal the location in the editor. If the symbol is selected in the
/// tool the range's start information is used to position the cursor. So
/// the range usually spans more than the actual symbol's name and does
/// normally include things like visibility modifiers.
/// The range doesn't have to denote a node range in the sense of an
/// abstract syntax tree. It can therefore not be used to re-construct a
/// hierarchy of the symbols.
 Location get location;/// The name of this symbol.
 String get name;/// Tags for this symbol.
/// @since 3.16.0
 List<SymbolTag>? get tags;
/// Create a copy of SymbolInformation
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SymbolInformationCopyWith<SymbolInformation> get copyWith => _$SymbolInformationCopyWithImpl<SymbolInformation>(this as SymbolInformation, _$identity);

  /// Serializes this SymbolInformation to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SymbolInformation&&(identical(other.containerName, containerName) || other.containerName == containerName)&&(identical(other.deprecated, deprecated) || other.deprecated == deprecated)&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.location, location) || other.location == location)&&(identical(other.name, name) || other.name == name)&&const DeepCollectionEquality().equals(other.tags, tags));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,containerName,deprecated,kind,location,name,const DeepCollectionEquality().hash(tags));

@override
String toString() {
  return 'SymbolInformation(containerName: $containerName, deprecated: $deprecated, kind: $kind, location: $location, name: $name, tags: $tags)';
}


}

/// @nodoc
abstract mixin class $SymbolInformationCopyWith<$Res>  {
  factory $SymbolInformationCopyWith(SymbolInformation value, $Res Function(SymbolInformation) _then) = _$SymbolInformationCopyWithImpl;
@useResult
$Res call({
 String? containerName, bool? deprecated, SymbolKind kind, Location location, String name, List<SymbolTag>? tags
});


$LocationCopyWith<$Res> get location;

}
/// @nodoc
class _$SymbolInformationCopyWithImpl<$Res>
    implements $SymbolInformationCopyWith<$Res> {
  _$SymbolInformationCopyWithImpl(this._self, this._then);

  final SymbolInformation _self;
  final $Res Function(SymbolInformation) _then;

/// Create a copy of SymbolInformation
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? containerName = freezed,Object? deprecated = freezed,Object? kind = null,Object? location = null,Object? name = null,Object? tags = freezed,}) {
  return _then(_self.copyWith(
containerName: freezed == containerName ? _self.containerName : containerName // ignore: cast_nullable_to_non_nullable
as String?,deprecated: freezed == deprecated ? _self.deprecated : deprecated // ignore: cast_nullable_to_non_nullable
as bool?,kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as SymbolKind,location: null == location ? _self.location : location // ignore: cast_nullable_to_non_nullable
as Location,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,tags: freezed == tags ? _self.tags : tags // ignore: cast_nullable_to_non_nullable
as List<SymbolTag>?,
  ));
}
/// Create a copy of SymbolInformation
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$LocationCopyWith<$Res> get location {
  
  return $LocationCopyWith<$Res>(_self.location, (value) {
    return _then(_self.copyWith(location: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _SymbolInformation implements SymbolInformation {
  const _SymbolInformation({this.containerName, this.deprecated, required this.kind, required this.location, required this.name, final  List<SymbolTag>? tags}): _tags = tags;
  factory _SymbolInformation.fromJson(Map<String, dynamic> json) => _$SymbolInformationFromJson(json);

/// The name of the symbol containing this symbol. This information is for
/// user interface purposes (e.g. to render a qualifier in the user
/// interface if necessary). It can't be used to re-infer a hierarchy for
/// the document symbols.
@override final  String? containerName;
/// Indicates if this symbol is deprecated.
/// @deprecated Use tags instead
@override final  bool? deprecated;
/// The kind of this symbol.
@override final  SymbolKind kind;
/// The location of this symbol. The location's range is used by a tool to
/// reveal the location in the editor. If the symbol is selected in the
/// tool the range's start information is used to position the cursor. So
/// the range usually spans more than the actual symbol's name and does
/// normally include things like visibility modifiers.
/// The range doesn't have to denote a node range in the sense of an
/// abstract syntax tree. It can therefore not be used to re-construct a
/// hierarchy of the symbols.
@override final  Location location;
/// The name of this symbol.
@override final  String name;
/// Tags for this symbol.
/// @since 3.16.0
 final  List<SymbolTag>? _tags;
/// Tags for this symbol.
/// @since 3.16.0
@override List<SymbolTag>? get tags {
  final value = _tags;
  if (value == null) return null;
  if (_tags is EqualUnmodifiableListView) return _tags;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}


/// Create a copy of SymbolInformation
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SymbolInformationCopyWith<_SymbolInformation> get copyWith => __$SymbolInformationCopyWithImpl<_SymbolInformation>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SymbolInformationToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SymbolInformation&&(identical(other.containerName, containerName) || other.containerName == containerName)&&(identical(other.deprecated, deprecated) || other.deprecated == deprecated)&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.location, location) || other.location == location)&&(identical(other.name, name) || other.name == name)&&const DeepCollectionEquality().equals(other._tags, _tags));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,containerName,deprecated,kind,location,name,const DeepCollectionEquality().hash(_tags));

@override
String toString() {
  return 'SymbolInformation(containerName: $containerName, deprecated: $deprecated, kind: $kind, location: $location, name: $name, tags: $tags)';
}


}

/// @nodoc
abstract mixin class _$SymbolInformationCopyWith<$Res> implements $SymbolInformationCopyWith<$Res> {
  factory _$SymbolInformationCopyWith(_SymbolInformation value, $Res Function(_SymbolInformation) _then) = __$SymbolInformationCopyWithImpl;
@override @useResult
$Res call({
 String? containerName, bool? deprecated, SymbolKind kind, Location location, String name, List<SymbolTag>? tags
});


@override $LocationCopyWith<$Res> get location;

}
/// @nodoc
class __$SymbolInformationCopyWithImpl<$Res>
    implements _$SymbolInformationCopyWith<$Res> {
  __$SymbolInformationCopyWithImpl(this._self, this._then);

  final _SymbolInformation _self;
  final $Res Function(_SymbolInformation) _then;

/// Create a copy of SymbolInformation
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? containerName = freezed,Object? deprecated = freezed,Object? kind = null,Object? location = null,Object? name = null,Object? tags = freezed,}) {
  return _then(_SymbolInformation(
containerName: freezed == containerName ? _self.containerName : containerName // ignore: cast_nullable_to_non_nullable
as String?,deprecated: freezed == deprecated ? _self.deprecated : deprecated // ignore: cast_nullable_to_non_nullable
as bool?,kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as SymbolKind,location: null == location ? _self.location : location // ignore: cast_nullable_to_non_nullable
as Location,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,tags: freezed == tags ? _self._tags : tags // ignore: cast_nullable_to_non_nullable
as List<SymbolTag>?,
  ));
}

/// Create a copy of SymbolInformation
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$LocationCopyWith<$Res> get location {
  
  return $LocationCopyWith<$Res>(_self.location, (value) {
    return _then(_self.copyWith(location: value));
  });
}
}


/// @nodoc
mixin _$DocumentSymbol {

/// Children of this symbol, e.g. properties of a class.
 List<DocumentSymbol>? get children;/// Indicates if this symbol is deprecated.
/// @deprecated Use tags instead
 bool? get deprecated;/// More detail for this symbol, e.g the signature of a function.
 String? get detail;/// The kind of this symbol.
 SymbolKind get kind;/// The name of this symbol. Will be displayed in the user interface and
/// therefore must not be an empty string or a string only consisting of
/// white spaces.
 String get name;/// The range enclosing this symbol not including leading/trailing
/// whitespace but everything else like comments. This information is
/// typically used to determine if the clients cursor is inside the symbol
/// to reveal in the symbol in the UI.
 Range get range;/// The range that should be selected and revealed when this symbol is
/// being picked, e.g the name of a function. Must be contained by the
/// `range`.
 Range get selectionRange;/// Tags for this document symbol.
/// @since 3.16.0
 List<SymbolTag>? get tags;
/// Create a copy of DocumentSymbol
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentSymbolCopyWith<DocumentSymbol> get copyWith => _$DocumentSymbolCopyWithImpl<DocumentSymbol>(this as DocumentSymbol, _$identity);

  /// Serializes this DocumentSymbol to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentSymbol&&const DeepCollectionEquality().equals(other.children, children)&&(identical(other.deprecated, deprecated) || other.deprecated == deprecated)&&(identical(other.detail, detail) || other.detail == detail)&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.name, name) || other.name == name)&&(identical(other.range, range) || other.range == range)&&(identical(other.selectionRange, selectionRange) || other.selectionRange == selectionRange)&&const DeepCollectionEquality().equals(other.tags, tags));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(children),deprecated,detail,kind,name,range,selectionRange,const DeepCollectionEquality().hash(tags));

@override
String toString() {
  return 'DocumentSymbol(children: $children, deprecated: $deprecated, detail: $detail, kind: $kind, name: $name, range: $range, selectionRange: $selectionRange, tags: $tags)';
}


}

/// @nodoc
abstract mixin class $DocumentSymbolCopyWith<$Res>  {
  factory $DocumentSymbolCopyWith(DocumentSymbol value, $Res Function(DocumentSymbol) _then) = _$DocumentSymbolCopyWithImpl;
@useResult
$Res call({
 List<DocumentSymbol>? children, bool? deprecated, String? detail, SymbolKind kind, String name, Range range, Range selectionRange, List<SymbolTag>? tags
});


$RangeCopyWith<$Res> get range;$RangeCopyWith<$Res> get selectionRange;

}
/// @nodoc
class _$DocumentSymbolCopyWithImpl<$Res>
    implements $DocumentSymbolCopyWith<$Res> {
  _$DocumentSymbolCopyWithImpl(this._self, this._then);

  final DocumentSymbol _self;
  final $Res Function(DocumentSymbol) _then;

/// Create a copy of DocumentSymbol
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? children = freezed,Object? deprecated = freezed,Object? detail = freezed,Object? kind = null,Object? name = null,Object? range = null,Object? selectionRange = null,Object? tags = freezed,}) {
  return _then(_self.copyWith(
children: freezed == children ? _self.children : children // ignore: cast_nullable_to_non_nullable
as List<DocumentSymbol>?,deprecated: freezed == deprecated ? _self.deprecated : deprecated // ignore: cast_nullable_to_non_nullable
as bool?,detail: freezed == detail ? _self.detail : detail // ignore: cast_nullable_to_non_nullable
as String?,kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as SymbolKind,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,selectionRange: null == selectionRange ? _self.selectionRange : selectionRange // ignore: cast_nullable_to_non_nullable
as Range,tags: freezed == tags ? _self.tags : tags // ignore: cast_nullable_to_non_nullable
as List<SymbolTag>?,
  ));
}
/// Create a copy of DocumentSymbol
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}/// Create a copy of DocumentSymbol
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get selectionRange {
  
  return $RangeCopyWith<$Res>(_self.selectionRange, (value) {
    return _then(_self.copyWith(selectionRange: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _DocumentSymbol implements DocumentSymbol {
  const _DocumentSymbol({final  List<DocumentSymbol>? children, this.deprecated, this.detail, required this.kind, required this.name, required this.range, required this.selectionRange, final  List<SymbolTag>? tags}): _children = children,_tags = tags;
  factory _DocumentSymbol.fromJson(Map<String, dynamic> json) => _$DocumentSymbolFromJson(json);

/// Children of this symbol, e.g. properties of a class.
 final  List<DocumentSymbol>? _children;
/// Children of this symbol, e.g. properties of a class.
@override List<DocumentSymbol>? get children {
  final value = _children;
  if (value == null) return null;
  if (_children is EqualUnmodifiableListView) return _children;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

/// Indicates if this symbol is deprecated.
/// @deprecated Use tags instead
@override final  bool? deprecated;
/// More detail for this symbol, e.g the signature of a function.
@override final  String? detail;
/// The kind of this symbol.
@override final  SymbolKind kind;
/// The name of this symbol. Will be displayed in the user interface and
/// therefore must not be an empty string or a string only consisting of
/// white spaces.
@override final  String name;
/// The range enclosing this symbol not including leading/trailing
/// whitespace but everything else like comments. This information is
/// typically used to determine if the clients cursor is inside the symbol
/// to reveal in the symbol in the UI.
@override final  Range range;
/// The range that should be selected and revealed when this symbol is
/// being picked, e.g the name of a function. Must be contained by the
/// `range`.
@override final  Range selectionRange;
/// Tags for this document symbol.
/// @since 3.16.0
 final  List<SymbolTag>? _tags;
/// Tags for this document symbol.
/// @since 3.16.0
@override List<SymbolTag>? get tags {
  final value = _tags;
  if (value == null) return null;
  if (_tags is EqualUnmodifiableListView) return _tags;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}


/// Create a copy of DocumentSymbol
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentSymbolCopyWith<_DocumentSymbol> get copyWith => __$DocumentSymbolCopyWithImpl<_DocumentSymbol>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentSymbolToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentSymbol&&const DeepCollectionEquality().equals(other._children, _children)&&(identical(other.deprecated, deprecated) || other.deprecated == deprecated)&&(identical(other.detail, detail) || other.detail == detail)&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.name, name) || other.name == name)&&(identical(other.range, range) || other.range == range)&&(identical(other.selectionRange, selectionRange) || other.selectionRange == selectionRange)&&const DeepCollectionEquality().equals(other._tags, _tags));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_children),deprecated,detail,kind,name,range,selectionRange,const DeepCollectionEquality().hash(_tags));

@override
String toString() {
  return 'DocumentSymbol(children: $children, deprecated: $deprecated, detail: $detail, kind: $kind, name: $name, range: $range, selectionRange: $selectionRange, tags: $tags)';
}


}

/// @nodoc
abstract mixin class _$DocumentSymbolCopyWith<$Res> implements $DocumentSymbolCopyWith<$Res> {
  factory _$DocumentSymbolCopyWith(_DocumentSymbol value, $Res Function(_DocumentSymbol) _then) = __$DocumentSymbolCopyWithImpl;
@override @useResult
$Res call({
 List<DocumentSymbol>? children, bool? deprecated, String? detail, SymbolKind kind, String name, Range range, Range selectionRange, List<SymbolTag>? tags
});


@override $RangeCopyWith<$Res> get range;@override $RangeCopyWith<$Res> get selectionRange;

}
/// @nodoc
class __$DocumentSymbolCopyWithImpl<$Res>
    implements _$DocumentSymbolCopyWith<$Res> {
  __$DocumentSymbolCopyWithImpl(this._self, this._then);

  final _DocumentSymbol _self;
  final $Res Function(_DocumentSymbol) _then;

/// Create a copy of DocumentSymbol
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? children = freezed,Object? deprecated = freezed,Object? detail = freezed,Object? kind = null,Object? name = null,Object? range = null,Object? selectionRange = null,Object? tags = freezed,}) {
  return _then(_DocumentSymbol(
children: freezed == children ? _self._children : children // ignore: cast_nullable_to_non_nullable
as List<DocumentSymbol>?,deprecated: freezed == deprecated ? _self.deprecated : deprecated // ignore: cast_nullable_to_non_nullable
as bool?,detail: freezed == detail ? _self.detail : detail // ignore: cast_nullable_to_non_nullable
as String?,kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as SymbolKind,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,selectionRange: null == selectionRange ? _self.selectionRange : selectionRange // ignore: cast_nullable_to_non_nullable
as Range,tags: freezed == tags ? _self._tags : tags // ignore: cast_nullable_to_non_nullable
as List<SymbolTag>?,
  ));
}

/// Create a copy of DocumentSymbol
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}/// Create a copy of DocumentSymbol
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get selectionRange {
  
  return $RangeCopyWith<$Res>(_self.selectionRange, (value) {
    return _then(_self.copyWith(selectionRange: value));
  });
}
}


/// @nodoc
mixin _$DocumentSymbolRegistrationOptions {

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
 Sealed14 get documentSelector;/// A human-readable string that is shown when multiple outlines trees are
/// shown for the same document.
/// @since 3.16.0
 String? get label;
/// Create a copy of DocumentSymbolRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentSymbolRegistrationOptionsCopyWith<DocumentSymbolRegistrationOptions> get copyWith => _$DocumentSymbolRegistrationOptionsCopyWithImpl<DocumentSymbolRegistrationOptions>(this as DocumentSymbolRegistrationOptions, _$identity);

  /// Serializes this DocumentSymbolRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentSymbolRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.label, label) || other.label == label));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,label);

@override
String toString() {
  return 'DocumentSymbolRegistrationOptions(documentSelector: $documentSelector, label: $label)';
}


}

/// @nodoc
abstract mixin class $DocumentSymbolRegistrationOptionsCopyWith<$Res>  {
  factory $DocumentSymbolRegistrationOptionsCopyWith(DocumentSymbolRegistrationOptions value, $Res Function(DocumentSymbolRegistrationOptions) _then) = _$DocumentSymbolRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 Sealed14 documentSelector, String? label
});




}
/// @nodoc
class _$DocumentSymbolRegistrationOptionsCopyWithImpl<$Res>
    implements $DocumentSymbolRegistrationOptionsCopyWith<$Res> {
  _$DocumentSymbolRegistrationOptionsCopyWithImpl(this._self, this._then);

  final DocumentSymbolRegistrationOptions _self;
  final $Res Function(DocumentSymbolRegistrationOptions) _then;

/// Create a copy of DocumentSymbolRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = null,Object? label = freezed,}) {
  return _then(_self.copyWith(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,label: freezed == label ? _self.label : label // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DocumentSymbolRegistrationOptions implements DocumentSymbolRegistrationOptions {
  const _DocumentSymbolRegistrationOptions({required this.documentSelector, this.label});
  factory _DocumentSymbolRegistrationOptions.fromJson(Map<String, dynamic> json) => _$DocumentSymbolRegistrationOptionsFromJson(json);

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
@override final  Sealed14 documentSelector;
/// A human-readable string that is shown when multiple outlines trees are
/// shown for the same document.
/// @since 3.16.0
@override final  String? label;

/// Create a copy of DocumentSymbolRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentSymbolRegistrationOptionsCopyWith<_DocumentSymbolRegistrationOptions> get copyWith => __$DocumentSymbolRegistrationOptionsCopyWithImpl<_DocumentSymbolRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentSymbolRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentSymbolRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.label, label) || other.label == label));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,label);

@override
String toString() {
  return 'DocumentSymbolRegistrationOptions(documentSelector: $documentSelector, label: $label)';
}


}

/// @nodoc
abstract mixin class _$DocumentSymbolRegistrationOptionsCopyWith<$Res> implements $DocumentSymbolRegistrationOptionsCopyWith<$Res> {
  factory _$DocumentSymbolRegistrationOptionsCopyWith(_DocumentSymbolRegistrationOptions value, $Res Function(_DocumentSymbolRegistrationOptions) _then) = __$DocumentSymbolRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 Sealed14 documentSelector, String? label
});




}
/// @nodoc
class __$DocumentSymbolRegistrationOptionsCopyWithImpl<$Res>
    implements _$DocumentSymbolRegistrationOptionsCopyWith<$Res> {
  __$DocumentSymbolRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _DocumentSymbolRegistrationOptions _self;
  final $Res Function(_DocumentSymbolRegistrationOptions) _then;

/// Create a copy of DocumentSymbolRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = null,Object? label = freezed,}) {
  return _then(_DocumentSymbolRegistrationOptions(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,label: freezed == label ? _self.label : label // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$CodeActionParams {

/// Context carrying additional information.
 CodeActionContext get context;/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
 ProgressToken? get partialResultToken;/// The range for which the command was invoked.
 Range get range;/// The document in which the command was invoked.
 TextDocumentIdentifier get textDocument;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of CodeActionParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CodeActionParamsCopyWith<CodeActionParams> get copyWith => _$CodeActionParamsCopyWithImpl<CodeActionParams>(this as CodeActionParams, _$identity);

  /// Serializes this CodeActionParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CodeActionParams&&(identical(other.context, context) || other.context == context)&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.range, range) || other.range == range)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,context,partialResultToken,range,textDocument,workDoneToken);

@override
String toString() {
  return 'CodeActionParams(context: $context, partialResultToken: $partialResultToken, range: $range, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $CodeActionParamsCopyWith<$Res>  {
  factory $CodeActionParamsCopyWith(CodeActionParams value, $Res Function(CodeActionParams) _then) = _$CodeActionParamsCopyWithImpl;
@useResult
$Res call({
 CodeActionContext context, ProgressToken? partialResultToken, Range range, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


$CodeActionContextCopyWith<$Res> get context;$RangeCopyWith<$Res> get range;$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$CodeActionParamsCopyWithImpl<$Res>
    implements $CodeActionParamsCopyWith<$Res> {
  _$CodeActionParamsCopyWithImpl(this._self, this._then);

  final CodeActionParams _self;
  final $Res Function(CodeActionParams) _then;

/// Create a copy of CodeActionParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? context = null,Object? partialResultToken = freezed,Object? range = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
context: null == context ? _self.context : context // ignore: cast_nullable_to_non_nullable
as CodeActionContext,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of CodeActionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CodeActionContextCopyWith<$Res> get context {
  
  return $CodeActionContextCopyWith<$Res>(_self.context, (value) {
    return _then(_self.copyWith(context: value));
  });
}/// Create a copy of CodeActionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}/// Create a copy of CodeActionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _CodeActionParams implements CodeActionParams {
  const _CodeActionParams({required this.context, this.partialResultToken, required this.range, required this.textDocument, this.workDoneToken});
  factory _CodeActionParams.fromJson(Map<String, dynamic> json) => _$CodeActionParamsFromJson(json);

/// Context carrying additional information.
@override final  CodeActionContext context;
/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
@override final  ProgressToken? partialResultToken;
/// The range for which the command was invoked.
@override final  Range range;
/// The document in which the command was invoked.
@override final  TextDocumentIdentifier textDocument;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of CodeActionParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CodeActionParamsCopyWith<_CodeActionParams> get copyWith => __$CodeActionParamsCopyWithImpl<_CodeActionParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CodeActionParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CodeActionParams&&(identical(other.context, context) || other.context == context)&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.range, range) || other.range == range)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,context,partialResultToken,range,textDocument,workDoneToken);

@override
String toString() {
  return 'CodeActionParams(context: $context, partialResultToken: $partialResultToken, range: $range, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$CodeActionParamsCopyWith<$Res> implements $CodeActionParamsCopyWith<$Res> {
  factory _$CodeActionParamsCopyWith(_CodeActionParams value, $Res Function(_CodeActionParams) _then) = __$CodeActionParamsCopyWithImpl;
@override @useResult
$Res call({
 CodeActionContext context, ProgressToken? partialResultToken, Range range, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


@override $CodeActionContextCopyWith<$Res> get context;@override $RangeCopyWith<$Res> get range;@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$CodeActionParamsCopyWithImpl<$Res>
    implements _$CodeActionParamsCopyWith<$Res> {
  __$CodeActionParamsCopyWithImpl(this._self, this._then);

  final _CodeActionParams _self;
  final $Res Function(_CodeActionParams) _then;

/// Create a copy of CodeActionParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? context = null,Object? partialResultToken = freezed,Object? range = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_CodeActionParams(
context: null == context ? _self.context : context // ignore: cast_nullable_to_non_nullable
as CodeActionContext,partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of CodeActionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CodeActionContextCopyWith<$Res> get context {
  
  return $CodeActionContextCopyWith<$Res>(_self.context, (value) {
    return _then(_self.copyWith(context: value));
  });
}/// Create a copy of CodeActionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}/// Create a copy of CodeActionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$Command {

/// Arguments that the command handler should be invoked with.
 List<LSPAny>? get arguments;/// The identifier of the actual command handler.
 String get command;/// Title of the command, like `save`.
 String get title;
/// Create a copy of Command
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CommandCopyWith<Command> get copyWith => _$CommandCopyWithImpl<Command>(this as Command, _$identity);

  /// Serializes this Command to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Command&&const DeepCollectionEquality().equals(other.arguments, arguments)&&(identical(other.command, command) || other.command == command)&&(identical(other.title, title) || other.title == title));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(arguments),command,title);

@override
String toString() {
  return 'Command(arguments: $arguments, command: $command, title: $title)';
}


}

/// @nodoc
abstract mixin class $CommandCopyWith<$Res>  {
  factory $CommandCopyWith(Command value, $Res Function(Command) _then) = _$CommandCopyWithImpl;
@useResult
$Res call({
 List<LSPAny>? arguments, String command, String title
});




}
/// @nodoc
class _$CommandCopyWithImpl<$Res>
    implements $CommandCopyWith<$Res> {
  _$CommandCopyWithImpl(this._self, this._then);

  final Command _self;
  final $Res Function(Command) _then;

/// Create a copy of Command
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? arguments = freezed,Object? command = null,Object? title = null,}) {
  return _then(_self.copyWith(
arguments: freezed == arguments ? _self.arguments : arguments // ignore: cast_nullable_to_non_nullable
as List<LSPAny>?,command: null == command ? _self.command : command // ignore: cast_nullable_to_non_nullable
as String,title: null == title ? _self.title : title // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _Command implements Command {
  const _Command({final  List<LSPAny>? arguments, required this.command, required this.title}): _arguments = arguments;
  factory _Command.fromJson(Map<String, dynamic> json) => _$CommandFromJson(json);

/// Arguments that the command handler should be invoked with.
 final  List<LSPAny>? _arguments;
/// Arguments that the command handler should be invoked with.
@override List<LSPAny>? get arguments {
  final value = _arguments;
  if (value == null) return null;
  if (_arguments is EqualUnmodifiableListView) return _arguments;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

/// The identifier of the actual command handler.
@override final  String command;
/// Title of the command, like `save`.
@override final  String title;

/// Create a copy of Command
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CommandCopyWith<_Command> get copyWith => __$CommandCopyWithImpl<_Command>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CommandToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _Command&&const DeepCollectionEquality().equals(other._arguments, _arguments)&&(identical(other.command, command) || other.command == command)&&(identical(other.title, title) || other.title == title));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_arguments),command,title);

@override
String toString() {
  return 'Command(arguments: $arguments, command: $command, title: $title)';
}


}

/// @nodoc
abstract mixin class _$CommandCopyWith<$Res> implements $CommandCopyWith<$Res> {
  factory _$CommandCopyWith(_Command value, $Res Function(_Command) _then) = __$CommandCopyWithImpl;
@override @useResult
$Res call({
 List<LSPAny>? arguments, String command, String title
});




}
/// @nodoc
class __$CommandCopyWithImpl<$Res>
    implements _$CommandCopyWith<$Res> {
  __$CommandCopyWithImpl(this._self, this._then);

  final _Command _self;
  final $Res Function(_Command) _then;

/// Create a copy of Command
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? arguments = freezed,Object? command = null,Object? title = null,}) {
  return _then(_Command(
arguments: freezed == arguments ? _self._arguments : arguments // ignore: cast_nullable_to_non_nullable
as List<LSPAny>?,command: null == command ? _self.command : command // ignore: cast_nullable_to_non_nullable
as String,title: null == title ? _self.title : title // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}


/// @nodoc
mixin _$CodeAction {

/// A command this code action executes. If a code action provides an edit
/// and a command, first the edit is executed and then the command.
 Command? get command;/// A data entry field that is preserved on a code action between a
/// `textDocument/codeAction` and a `codeAction/resolve` request.
/// @since 3.16.0
 LSPAny? get data;/// The diagnostics that this code action resolves.
 List<Diagnostic>? get diagnostics;/// Marks that the code action cannot currently be applied.
/// Clients should follow the following guidelines regarding disabled code
/// actions:
/// - Disabled code actions are not shown in automatic
/// [lightbulbs](https://code.visualstudio.com/docs/editor/editingevolved#_code-action)
/// code action menus.
/// - Disabled actions are shown as faded out in the code action menu when
/// the user requests a more specific type of code action, such as
/// refactorings.
/// - If the user has a
/// [keybinding](https://code.visualstudio.com/docs/editor/refactoring#_keybindings-for-code-actions)
/// that auto applies a code action and only disabled code actions are
/// returned, the client should show the user an error message with
/// `reason` in the editor.
/// @since 3.16.0
 StringReason? get disabled;/// The workspace edit this code action performs.
 WorkspaceEdit? get edit;/// Marks this as a preferred action. Preferred actions are used by the
/// `auto fix` command and can be targeted by keybindings.
/// A quick fix should be marked preferred if it properly addresses the
/// underlying error. A refactoring should be marked preferred if it is the
/// most reasonable choice of actions to take.
/// @since 3.15.0
 bool? get isPreferred;/// The kind of the code action.
/// Used to filter code actions.
 CodeActionKind? get kind;/// A short, human-readable, title for this code action.
 String get title;
/// Create a copy of CodeAction
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CodeActionCopyWith<CodeAction> get copyWith => _$CodeActionCopyWithImpl<CodeAction>(this as CodeAction, _$identity);

  /// Serializes this CodeAction to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CodeAction&&(identical(other.command, command) || other.command == command)&&(identical(other.data, data) || other.data == data)&&const DeepCollectionEquality().equals(other.diagnostics, diagnostics)&&const DeepCollectionEquality().equals(other.disabled, disabled)&&(identical(other.edit, edit) || other.edit == edit)&&(identical(other.isPreferred, isPreferred) || other.isPreferred == isPreferred)&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.title, title) || other.title == title));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,command,data,const DeepCollectionEquality().hash(diagnostics),const DeepCollectionEquality().hash(disabled),edit,isPreferred,kind,title);

@override
String toString() {
  return 'CodeAction(command: $command, data: $data, diagnostics: $diagnostics, disabled: $disabled, edit: $edit, isPreferred: $isPreferred, kind: $kind, title: $title)';
}


}

/// @nodoc
abstract mixin class $CodeActionCopyWith<$Res>  {
  factory $CodeActionCopyWith(CodeAction value, $Res Function(CodeAction) _then) = _$CodeActionCopyWithImpl;
@useResult
$Res call({
 Command? command, LSPAny? data, List<Diagnostic>? diagnostics, StringReason? disabled, WorkspaceEdit? edit, bool? isPreferred, CodeActionKind? kind, String title
});


$CommandCopyWith<$Res>? get command;$WorkspaceEditCopyWith<$Res>? get edit;

}
/// @nodoc
class _$CodeActionCopyWithImpl<$Res>
    implements $CodeActionCopyWith<$Res> {
  _$CodeActionCopyWithImpl(this._self, this._then);

  final CodeAction _self;
  final $Res Function(CodeAction) _then;

/// Create a copy of CodeAction
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? command = freezed,Object? data = freezed,Object? diagnostics = freezed,Object? disabled = freezed,Object? edit = freezed,Object? isPreferred = freezed,Object? kind = freezed,Object? title = null,}) {
  return _then(_self.copyWith(
command: freezed == command ? _self.command : command // ignore: cast_nullable_to_non_nullable
as Command?,data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LSPAny?,diagnostics: freezed == diagnostics ? _self.diagnostics : diagnostics // ignore: cast_nullable_to_non_nullable
as List<Diagnostic>?,disabled: freezed == disabled ? _self.disabled : disabled // ignore: cast_nullable_to_non_nullable
as StringReason?,edit: freezed == edit ? _self.edit : edit // ignore: cast_nullable_to_non_nullable
as WorkspaceEdit?,isPreferred: freezed == isPreferred ? _self.isPreferred : isPreferred // ignore: cast_nullable_to_non_nullable
as bool?,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as CodeActionKind?,title: null == title ? _self.title : title // ignore: cast_nullable_to_non_nullable
as String,
  ));
}
/// Create a copy of CodeAction
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CommandCopyWith<$Res>? get command {
    if (_self.command == null) {
    return null;
  }

  return $CommandCopyWith<$Res>(_self.command!, (value) {
    return _then(_self.copyWith(command: value));
  });
}/// Create a copy of CodeAction
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$WorkspaceEditCopyWith<$Res>? get edit {
    if (_self.edit == null) {
    return null;
  }

  return $WorkspaceEditCopyWith<$Res>(_self.edit!, (value) {
    return _then(_self.copyWith(edit: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _CodeAction implements CodeAction {
  const _CodeAction({this.command, this.data, final  List<Diagnostic>? diagnostics, this.disabled, this.edit, this.isPreferred, this.kind, required this.title}): _diagnostics = diagnostics;
  factory _CodeAction.fromJson(Map<String, dynamic> json) => _$CodeActionFromJson(json);

/// A command this code action executes. If a code action provides an edit
/// and a command, first the edit is executed and then the command.
@override final  Command? command;
/// A data entry field that is preserved on a code action between a
/// `textDocument/codeAction` and a `codeAction/resolve` request.
/// @since 3.16.0
@override final  LSPAny? data;
/// The diagnostics that this code action resolves.
 final  List<Diagnostic>? _diagnostics;
/// The diagnostics that this code action resolves.
@override List<Diagnostic>? get diagnostics {
  final value = _diagnostics;
  if (value == null) return null;
  if (_diagnostics is EqualUnmodifiableListView) return _diagnostics;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

/// Marks that the code action cannot currently be applied.
/// Clients should follow the following guidelines regarding disabled code
/// actions:
/// - Disabled code actions are not shown in automatic
/// [lightbulbs](https://code.visualstudio.com/docs/editor/editingevolved#_code-action)
/// code action menus.
/// - Disabled actions are shown as faded out in the code action menu when
/// the user requests a more specific type of code action, such as
/// refactorings.
/// - If the user has a
/// [keybinding](https://code.visualstudio.com/docs/editor/refactoring#_keybindings-for-code-actions)
/// that auto applies a code action and only disabled code actions are
/// returned, the client should show the user an error message with
/// `reason` in the editor.
/// @since 3.16.0
@override final  StringReason? disabled;
/// The workspace edit this code action performs.
@override final  WorkspaceEdit? edit;
/// Marks this as a preferred action. Preferred actions are used by the
/// `auto fix` command and can be targeted by keybindings.
/// A quick fix should be marked preferred if it properly addresses the
/// underlying error. A refactoring should be marked preferred if it is the
/// most reasonable choice of actions to take.
/// @since 3.15.0
@override final  bool? isPreferred;
/// The kind of the code action.
/// Used to filter code actions.
@override final  CodeActionKind? kind;
/// A short, human-readable, title for this code action.
@override final  String title;

/// Create a copy of CodeAction
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CodeActionCopyWith<_CodeAction> get copyWith => __$CodeActionCopyWithImpl<_CodeAction>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CodeActionToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CodeAction&&(identical(other.command, command) || other.command == command)&&(identical(other.data, data) || other.data == data)&&const DeepCollectionEquality().equals(other._diagnostics, _diagnostics)&&const DeepCollectionEquality().equals(other.disabled, disabled)&&(identical(other.edit, edit) || other.edit == edit)&&(identical(other.isPreferred, isPreferred) || other.isPreferred == isPreferred)&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.title, title) || other.title == title));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,command,data,const DeepCollectionEquality().hash(_diagnostics),const DeepCollectionEquality().hash(disabled),edit,isPreferred,kind,title);

@override
String toString() {
  return 'CodeAction(command: $command, data: $data, diagnostics: $diagnostics, disabled: $disabled, edit: $edit, isPreferred: $isPreferred, kind: $kind, title: $title)';
}


}

/// @nodoc
abstract mixin class _$CodeActionCopyWith<$Res> implements $CodeActionCopyWith<$Res> {
  factory _$CodeActionCopyWith(_CodeAction value, $Res Function(_CodeAction) _then) = __$CodeActionCopyWithImpl;
@override @useResult
$Res call({
 Command? command, LSPAny? data, List<Diagnostic>? diagnostics, StringReason? disabled, WorkspaceEdit? edit, bool? isPreferred, CodeActionKind? kind, String title
});


@override $CommandCopyWith<$Res>? get command;@override $WorkspaceEditCopyWith<$Res>? get edit;

}
/// @nodoc
class __$CodeActionCopyWithImpl<$Res>
    implements _$CodeActionCopyWith<$Res> {
  __$CodeActionCopyWithImpl(this._self, this._then);

  final _CodeAction _self;
  final $Res Function(_CodeAction) _then;

/// Create a copy of CodeAction
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? command = freezed,Object? data = freezed,Object? diagnostics = freezed,Object? disabled = freezed,Object? edit = freezed,Object? isPreferred = freezed,Object? kind = freezed,Object? title = null,}) {
  return _then(_CodeAction(
command: freezed == command ? _self.command : command // ignore: cast_nullable_to_non_nullable
as Command?,data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LSPAny?,diagnostics: freezed == diagnostics ? _self._diagnostics : diagnostics // ignore: cast_nullable_to_non_nullable
as List<Diagnostic>?,disabled: freezed == disabled ? _self.disabled : disabled // ignore: cast_nullable_to_non_nullable
as StringReason?,edit: freezed == edit ? _self.edit : edit // ignore: cast_nullable_to_non_nullable
as WorkspaceEdit?,isPreferred: freezed == isPreferred ? _self.isPreferred : isPreferred // ignore: cast_nullable_to_non_nullable
as bool?,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as CodeActionKind?,title: null == title ? _self.title : title // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

/// Create a copy of CodeAction
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CommandCopyWith<$Res>? get command {
    if (_self.command == null) {
    return null;
  }

  return $CommandCopyWith<$Res>(_self.command!, (value) {
    return _then(_self.copyWith(command: value));
  });
}/// Create a copy of CodeAction
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$WorkspaceEditCopyWith<$Res>? get edit {
    if (_self.edit == null) {
    return null;
  }

  return $WorkspaceEditCopyWith<$Res>(_self.edit!, (value) {
    return _then(_self.copyWith(edit: value));
  });
}
}


/// @nodoc
mixin _$CodeActionRegistrationOptions {

/// CodeActionKinds that this server may return.
/// The list of kinds may be generic, such as `CodeActionKind.Refactor`, or
/// the server may list out every specific kind they provide.
 List<CodeActionKind>? get codeActionKinds;/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
 Sealed14 get documentSelector;/// The server provides support to resolve additional information for a
/// code action.
/// @since 3.16.0
 bool? get resolveProvider;
/// Create a copy of CodeActionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CodeActionRegistrationOptionsCopyWith<CodeActionRegistrationOptions> get copyWith => _$CodeActionRegistrationOptionsCopyWithImpl<CodeActionRegistrationOptions>(this as CodeActionRegistrationOptions, _$identity);

  /// Serializes this CodeActionRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CodeActionRegistrationOptions&&const DeepCollectionEquality().equals(other.codeActionKinds, codeActionKinds)&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(codeActionKinds),documentSelector,resolveProvider);

@override
String toString() {
  return 'CodeActionRegistrationOptions(codeActionKinds: $codeActionKinds, documentSelector: $documentSelector, resolveProvider: $resolveProvider)';
}


}

/// @nodoc
abstract mixin class $CodeActionRegistrationOptionsCopyWith<$Res>  {
  factory $CodeActionRegistrationOptionsCopyWith(CodeActionRegistrationOptions value, $Res Function(CodeActionRegistrationOptions) _then) = _$CodeActionRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 List<CodeActionKind>? codeActionKinds, Sealed14 documentSelector, bool? resolveProvider
});




}
/// @nodoc
class _$CodeActionRegistrationOptionsCopyWithImpl<$Res>
    implements $CodeActionRegistrationOptionsCopyWith<$Res> {
  _$CodeActionRegistrationOptionsCopyWithImpl(this._self, this._then);

  final CodeActionRegistrationOptions _self;
  final $Res Function(CodeActionRegistrationOptions) _then;

/// Create a copy of CodeActionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? codeActionKinds = freezed,Object? documentSelector = null,Object? resolveProvider = freezed,}) {
  return _then(_self.copyWith(
codeActionKinds: freezed == codeActionKinds ? _self.codeActionKinds : codeActionKinds // ignore: cast_nullable_to_non_nullable
as List<CodeActionKind>?,documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _CodeActionRegistrationOptions implements CodeActionRegistrationOptions {
  const _CodeActionRegistrationOptions({final  List<CodeActionKind>? codeActionKinds, required this.documentSelector, this.resolveProvider}): _codeActionKinds = codeActionKinds;
  factory _CodeActionRegistrationOptions.fromJson(Map<String, dynamic> json) => _$CodeActionRegistrationOptionsFromJson(json);

/// CodeActionKinds that this server may return.
/// The list of kinds may be generic, such as `CodeActionKind.Refactor`, or
/// the server may list out every specific kind they provide.
 final  List<CodeActionKind>? _codeActionKinds;
/// CodeActionKinds that this server may return.
/// The list of kinds may be generic, such as `CodeActionKind.Refactor`, or
/// the server may list out every specific kind they provide.
@override List<CodeActionKind>? get codeActionKinds {
  final value = _codeActionKinds;
  if (value == null) return null;
  if (_codeActionKinds is EqualUnmodifiableListView) return _codeActionKinds;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
@override final  Sealed14 documentSelector;
/// The server provides support to resolve additional information for a
/// code action.
/// @since 3.16.0
@override final  bool? resolveProvider;

/// Create a copy of CodeActionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CodeActionRegistrationOptionsCopyWith<_CodeActionRegistrationOptions> get copyWith => __$CodeActionRegistrationOptionsCopyWithImpl<_CodeActionRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CodeActionRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CodeActionRegistrationOptions&&const DeepCollectionEquality().equals(other._codeActionKinds, _codeActionKinds)&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_codeActionKinds),documentSelector,resolveProvider);

@override
String toString() {
  return 'CodeActionRegistrationOptions(codeActionKinds: $codeActionKinds, documentSelector: $documentSelector, resolveProvider: $resolveProvider)';
}


}

/// @nodoc
abstract mixin class _$CodeActionRegistrationOptionsCopyWith<$Res> implements $CodeActionRegistrationOptionsCopyWith<$Res> {
  factory _$CodeActionRegistrationOptionsCopyWith(_CodeActionRegistrationOptions value, $Res Function(_CodeActionRegistrationOptions) _then) = __$CodeActionRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 List<CodeActionKind>? codeActionKinds, Sealed14 documentSelector, bool? resolveProvider
});




}
/// @nodoc
class __$CodeActionRegistrationOptionsCopyWithImpl<$Res>
    implements _$CodeActionRegistrationOptionsCopyWith<$Res> {
  __$CodeActionRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _CodeActionRegistrationOptions _self;
  final $Res Function(_CodeActionRegistrationOptions) _then;

/// Create a copy of CodeActionRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? codeActionKinds = freezed,Object? documentSelector = null,Object? resolveProvider = freezed,}) {
  return _then(_CodeActionRegistrationOptions(
codeActionKinds: freezed == codeActionKinds ? _self._codeActionKinds : codeActionKinds // ignore: cast_nullable_to_non_nullable
as List<CodeActionKind>?,documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$WorkspaceSymbolParams {

/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
 ProgressToken? get partialResultToken;/// A query string to filter symbols by. Clients may send an empty string
/// here to request all symbols.
 String get query;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of WorkspaceSymbolParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkspaceSymbolParamsCopyWith<WorkspaceSymbolParams> get copyWith => _$WorkspaceSymbolParamsCopyWithImpl<WorkspaceSymbolParams>(this as WorkspaceSymbolParams, _$identity);

  /// Serializes this WorkspaceSymbolParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkspaceSymbolParams&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.query, query) || other.query == query)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,partialResultToken,query,workDoneToken);

@override
String toString() {
  return 'WorkspaceSymbolParams(partialResultToken: $partialResultToken, query: $query, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $WorkspaceSymbolParamsCopyWith<$Res>  {
  factory $WorkspaceSymbolParamsCopyWith(WorkspaceSymbolParams value, $Res Function(WorkspaceSymbolParams) _then) = _$WorkspaceSymbolParamsCopyWithImpl;
@useResult
$Res call({
 ProgressToken? partialResultToken, String query, ProgressToken? workDoneToken
});




}
/// @nodoc
class _$WorkspaceSymbolParamsCopyWithImpl<$Res>
    implements $WorkspaceSymbolParamsCopyWith<$Res> {
  _$WorkspaceSymbolParamsCopyWithImpl(this._self, this._then);

  final WorkspaceSymbolParams _self;
  final $Res Function(WorkspaceSymbolParams) _then;

/// Create a copy of WorkspaceSymbolParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? partialResultToken = freezed,Object? query = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,query: null == query ? _self.query : query // ignore: cast_nullable_to_non_nullable
as String,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _WorkspaceSymbolParams implements WorkspaceSymbolParams {
  const _WorkspaceSymbolParams({this.partialResultToken, required this.query, this.workDoneToken});
  factory _WorkspaceSymbolParams.fromJson(Map<String, dynamic> json) => _$WorkspaceSymbolParamsFromJson(json);

/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
@override final  ProgressToken? partialResultToken;
/// A query string to filter symbols by. Clients may send an empty string
/// here to request all symbols.
@override final  String query;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of WorkspaceSymbolParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkspaceSymbolParamsCopyWith<_WorkspaceSymbolParams> get copyWith => __$WorkspaceSymbolParamsCopyWithImpl<_WorkspaceSymbolParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkspaceSymbolParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkspaceSymbolParams&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.query, query) || other.query == query)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,partialResultToken,query,workDoneToken);

@override
String toString() {
  return 'WorkspaceSymbolParams(partialResultToken: $partialResultToken, query: $query, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$WorkspaceSymbolParamsCopyWith<$Res> implements $WorkspaceSymbolParamsCopyWith<$Res> {
  factory _$WorkspaceSymbolParamsCopyWith(_WorkspaceSymbolParams value, $Res Function(_WorkspaceSymbolParams) _then) = __$WorkspaceSymbolParamsCopyWithImpl;
@override @useResult
$Res call({
 ProgressToken? partialResultToken, String query, ProgressToken? workDoneToken
});




}
/// @nodoc
class __$WorkspaceSymbolParamsCopyWithImpl<$Res>
    implements _$WorkspaceSymbolParamsCopyWith<$Res> {
  __$WorkspaceSymbolParamsCopyWithImpl(this._self, this._then);

  final _WorkspaceSymbolParams _self;
  final $Res Function(_WorkspaceSymbolParams) _then;

/// Create a copy of WorkspaceSymbolParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? partialResultToken = freezed,Object? query = null,Object? workDoneToken = freezed,}) {
  return _then(_WorkspaceSymbolParams(
partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,query: null == query ? _self.query : query // ignore: cast_nullable_to_non_nullable
as String,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}


}


/// @nodoc
mixin _$WorkspaceSymbol {

/// The name of the symbol containing this symbol. This information is for
/// user interface purposes (e.g. to render a qualifier in the user
/// interface if necessary). It can't be used to re-infer a hierarchy for
/// the document symbols.
 String? get containerName;/// A data entry field that is preserved on a workspace symbol between a
/// workspace symbol request and a workspace symbol resolve request.
 LSPAny? get data;/// The kind of this symbol.
 SymbolKind get kind;/// The location of the symbol. Whether a server is allowed to return a
/// location without a range depends on the client capability
/// `workspace.symbol.resolveSupport`.
/// See SymbolInformation#location for more details.
 Sealed24 get location;/// The name of this symbol.
 String get name;/// Tags for this symbol.
/// @since 3.16.0
 List<SymbolTag>? get tags;
/// Create a copy of WorkspaceSymbol
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkspaceSymbolCopyWith<WorkspaceSymbol> get copyWith => _$WorkspaceSymbolCopyWithImpl<WorkspaceSymbol>(this as WorkspaceSymbol, _$identity);

  /// Serializes this WorkspaceSymbol to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkspaceSymbol&&(identical(other.containerName, containerName) || other.containerName == containerName)&&(identical(other.data, data) || other.data == data)&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.location, location) || other.location == location)&&(identical(other.name, name) || other.name == name)&&const DeepCollectionEquality().equals(other.tags, tags));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,containerName,data,kind,location,name,const DeepCollectionEquality().hash(tags));

@override
String toString() {
  return 'WorkspaceSymbol(containerName: $containerName, data: $data, kind: $kind, location: $location, name: $name, tags: $tags)';
}


}

/// @nodoc
abstract mixin class $WorkspaceSymbolCopyWith<$Res>  {
  factory $WorkspaceSymbolCopyWith(WorkspaceSymbol value, $Res Function(WorkspaceSymbol) _then) = _$WorkspaceSymbolCopyWithImpl;
@useResult
$Res call({
 String? containerName, LSPAny? data, SymbolKind kind, Sealed24 location, String name, List<SymbolTag>? tags
});




}
/// @nodoc
class _$WorkspaceSymbolCopyWithImpl<$Res>
    implements $WorkspaceSymbolCopyWith<$Res> {
  _$WorkspaceSymbolCopyWithImpl(this._self, this._then);

  final WorkspaceSymbol _self;
  final $Res Function(WorkspaceSymbol) _then;

/// Create a copy of WorkspaceSymbol
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? containerName = freezed,Object? data = freezed,Object? kind = null,Object? location = null,Object? name = null,Object? tags = freezed,}) {
  return _then(_self.copyWith(
containerName: freezed == containerName ? _self.containerName : containerName // ignore: cast_nullable_to_non_nullable
as String?,data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LSPAny?,kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as SymbolKind,location: null == location ? _self.location : location // ignore: cast_nullable_to_non_nullable
as Sealed24,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,tags: freezed == tags ? _self.tags : tags // ignore: cast_nullable_to_non_nullable
as List<SymbolTag>?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _WorkspaceSymbol implements WorkspaceSymbol {
  const _WorkspaceSymbol({this.containerName, this.data, required this.kind, required this.location, required this.name, final  List<SymbolTag>? tags}): _tags = tags;
  factory _WorkspaceSymbol.fromJson(Map<String, dynamic> json) => _$WorkspaceSymbolFromJson(json);

/// The name of the symbol containing this symbol. This information is for
/// user interface purposes (e.g. to render a qualifier in the user
/// interface if necessary). It can't be used to re-infer a hierarchy for
/// the document symbols.
@override final  String? containerName;
/// A data entry field that is preserved on a workspace symbol between a
/// workspace symbol request and a workspace symbol resolve request.
@override final  LSPAny? data;
/// The kind of this symbol.
@override final  SymbolKind kind;
/// The location of the symbol. Whether a server is allowed to return a
/// location without a range depends on the client capability
/// `workspace.symbol.resolveSupport`.
/// See SymbolInformation#location for more details.
@override final  Sealed24 location;
/// The name of this symbol.
@override final  String name;
/// Tags for this symbol.
/// @since 3.16.0
 final  List<SymbolTag>? _tags;
/// Tags for this symbol.
/// @since 3.16.0
@override List<SymbolTag>? get tags {
  final value = _tags;
  if (value == null) return null;
  if (_tags is EqualUnmodifiableListView) return _tags;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}


/// Create a copy of WorkspaceSymbol
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkspaceSymbolCopyWith<_WorkspaceSymbol> get copyWith => __$WorkspaceSymbolCopyWithImpl<_WorkspaceSymbol>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkspaceSymbolToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkspaceSymbol&&(identical(other.containerName, containerName) || other.containerName == containerName)&&(identical(other.data, data) || other.data == data)&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.location, location) || other.location == location)&&(identical(other.name, name) || other.name == name)&&const DeepCollectionEquality().equals(other._tags, _tags));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,containerName,data,kind,location,name,const DeepCollectionEquality().hash(_tags));

@override
String toString() {
  return 'WorkspaceSymbol(containerName: $containerName, data: $data, kind: $kind, location: $location, name: $name, tags: $tags)';
}


}

/// @nodoc
abstract mixin class _$WorkspaceSymbolCopyWith<$Res> implements $WorkspaceSymbolCopyWith<$Res> {
  factory _$WorkspaceSymbolCopyWith(_WorkspaceSymbol value, $Res Function(_WorkspaceSymbol) _then) = __$WorkspaceSymbolCopyWithImpl;
@override @useResult
$Res call({
 String? containerName, LSPAny? data, SymbolKind kind, Sealed24 location, String name, List<SymbolTag>? tags
});




}
/// @nodoc
class __$WorkspaceSymbolCopyWithImpl<$Res>
    implements _$WorkspaceSymbolCopyWith<$Res> {
  __$WorkspaceSymbolCopyWithImpl(this._self, this._then);

  final _WorkspaceSymbol _self;
  final $Res Function(_WorkspaceSymbol) _then;

/// Create a copy of WorkspaceSymbol
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? containerName = freezed,Object? data = freezed,Object? kind = null,Object? location = null,Object? name = null,Object? tags = freezed,}) {
  return _then(_WorkspaceSymbol(
containerName: freezed == containerName ? _self.containerName : containerName // ignore: cast_nullable_to_non_nullable
as String?,data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LSPAny?,kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as SymbolKind,location: null == location ? _self.location : location // ignore: cast_nullable_to_non_nullable
as Sealed24,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,tags: freezed == tags ? _self._tags : tags // ignore: cast_nullable_to_non_nullable
as List<SymbolTag>?,
  ));
}


}


/// @nodoc
mixin _$WorkspaceSymbolRegistrationOptions {

/// The server provides support to resolve additional information for a
/// workspace symbol.
/// @since 3.17.0
 bool? get resolveProvider;
/// Create a copy of WorkspaceSymbolRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkspaceSymbolRegistrationOptionsCopyWith<WorkspaceSymbolRegistrationOptions> get copyWith => _$WorkspaceSymbolRegistrationOptionsCopyWithImpl<WorkspaceSymbolRegistrationOptions>(this as WorkspaceSymbolRegistrationOptions, _$identity);

  /// Serializes this WorkspaceSymbolRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkspaceSymbolRegistrationOptions&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,resolveProvider);

@override
String toString() {
  return 'WorkspaceSymbolRegistrationOptions(resolveProvider: $resolveProvider)';
}


}

/// @nodoc
abstract mixin class $WorkspaceSymbolRegistrationOptionsCopyWith<$Res>  {
  factory $WorkspaceSymbolRegistrationOptionsCopyWith(WorkspaceSymbolRegistrationOptions value, $Res Function(WorkspaceSymbolRegistrationOptions) _then) = _$WorkspaceSymbolRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 bool? resolveProvider
});




}
/// @nodoc
class _$WorkspaceSymbolRegistrationOptionsCopyWithImpl<$Res>
    implements $WorkspaceSymbolRegistrationOptionsCopyWith<$Res> {
  _$WorkspaceSymbolRegistrationOptionsCopyWithImpl(this._self, this._then);

  final WorkspaceSymbolRegistrationOptions _self;
  final $Res Function(WorkspaceSymbolRegistrationOptions) _then;

/// Create a copy of WorkspaceSymbolRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? resolveProvider = freezed,}) {
  return _then(_self.copyWith(
resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _WorkspaceSymbolRegistrationOptions implements WorkspaceSymbolRegistrationOptions {
  const _WorkspaceSymbolRegistrationOptions({this.resolveProvider});
  factory _WorkspaceSymbolRegistrationOptions.fromJson(Map<String, dynamic> json) => _$WorkspaceSymbolRegistrationOptionsFromJson(json);

/// The server provides support to resolve additional information for a
/// workspace symbol.
/// @since 3.17.0
@override final  bool? resolveProvider;

/// Create a copy of WorkspaceSymbolRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkspaceSymbolRegistrationOptionsCopyWith<_WorkspaceSymbolRegistrationOptions> get copyWith => __$WorkspaceSymbolRegistrationOptionsCopyWithImpl<_WorkspaceSymbolRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkspaceSymbolRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkspaceSymbolRegistrationOptions&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,resolveProvider);

@override
String toString() {
  return 'WorkspaceSymbolRegistrationOptions(resolveProvider: $resolveProvider)';
}


}

/// @nodoc
abstract mixin class _$WorkspaceSymbolRegistrationOptionsCopyWith<$Res> implements $WorkspaceSymbolRegistrationOptionsCopyWith<$Res> {
  factory _$WorkspaceSymbolRegistrationOptionsCopyWith(_WorkspaceSymbolRegistrationOptions value, $Res Function(_WorkspaceSymbolRegistrationOptions) _then) = __$WorkspaceSymbolRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? resolveProvider
});




}
/// @nodoc
class __$WorkspaceSymbolRegistrationOptionsCopyWithImpl<$Res>
    implements _$WorkspaceSymbolRegistrationOptionsCopyWith<$Res> {
  __$WorkspaceSymbolRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _WorkspaceSymbolRegistrationOptions _self;
  final $Res Function(_WorkspaceSymbolRegistrationOptions) _then;

/// Create a copy of WorkspaceSymbolRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? resolveProvider = freezed,}) {
  return _then(_WorkspaceSymbolRegistrationOptions(
resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$CodeLensParams {

/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
 ProgressToken? get partialResultToken;/// The document to request code lens for.
 TextDocumentIdentifier get textDocument;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of CodeLensParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CodeLensParamsCopyWith<CodeLensParams> get copyWith => _$CodeLensParamsCopyWithImpl<CodeLensParams>(this as CodeLensParams, _$identity);

  /// Serializes this CodeLensParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CodeLensParams&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,partialResultToken,textDocument,workDoneToken);

@override
String toString() {
  return 'CodeLensParams(partialResultToken: $partialResultToken, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $CodeLensParamsCopyWith<$Res>  {
  factory $CodeLensParamsCopyWith(CodeLensParams value, $Res Function(CodeLensParams) _then) = _$CodeLensParamsCopyWithImpl;
@useResult
$Res call({
 ProgressToken? partialResultToken, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$CodeLensParamsCopyWithImpl<$Res>
    implements $CodeLensParamsCopyWith<$Res> {
  _$CodeLensParamsCopyWithImpl(this._self, this._then);

  final CodeLensParams _self;
  final $Res Function(CodeLensParams) _then;

/// Create a copy of CodeLensParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? partialResultToken = freezed,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of CodeLensParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _CodeLensParams implements CodeLensParams {
  const _CodeLensParams({this.partialResultToken, required this.textDocument, this.workDoneToken});
  factory _CodeLensParams.fromJson(Map<String, dynamic> json) => _$CodeLensParamsFromJson(json);

/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
@override final  ProgressToken? partialResultToken;
/// The document to request code lens for.
@override final  TextDocumentIdentifier textDocument;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of CodeLensParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CodeLensParamsCopyWith<_CodeLensParams> get copyWith => __$CodeLensParamsCopyWithImpl<_CodeLensParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CodeLensParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CodeLensParams&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,partialResultToken,textDocument,workDoneToken);

@override
String toString() {
  return 'CodeLensParams(partialResultToken: $partialResultToken, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$CodeLensParamsCopyWith<$Res> implements $CodeLensParamsCopyWith<$Res> {
  factory _$CodeLensParamsCopyWith(_CodeLensParams value, $Res Function(_CodeLensParams) _then) = __$CodeLensParamsCopyWithImpl;
@override @useResult
$Res call({
 ProgressToken? partialResultToken, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$CodeLensParamsCopyWithImpl<$Res>
    implements _$CodeLensParamsCopyWith<$Res> {
  __$CodeLensParamsCopyWithImpl(this._self, this._then);

  final _CodeLensParams _self;
  final $Res Function(_CodeLensParams) _then;

/// Create a copy of CodeLensParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? partialResultToken = freezed,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_CodeLensParams(
partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of CodeLensParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$CodeLens {

/// The command this code lens represents.
 Command? get command;/// A data entry field that is preserved on a code lens item between a
/// {@link CodeLensRequest} and a {@link CodeLensResolveRequest}
 LSPAny? get data;/// The range in which this code lens is valid. Should only span a single
/// line.
 Range get range;
/// Create a copy of CodeLens
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CodeLensCopyWith<CodeLens> get copyWith => _$CodeLensCopyWithImpl<CodeLens>(this as CodeLens, _$identity);

  /// Serializes this CodeLens to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CodeLens&&(identical(other.command, command) || other.command == command)&&(identical(other.data, data) || other.data == data)&&(identical(other.range, range) || other.range == range));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,command,data,range);

@override
String toString() {
  return 'CodeLens(command: $command, data: $data, range: $range)';
}


}

/// @nodoc
abstract mixin class $CodeLensCopyWith<$Res>  {
  factory $CodeLensCopyWith(CodeLens value, $Res Function(CodeLens) _then) = _$CodeLensCopyWithImpl;
@useResult
$Res call({
 Command? command, LSPAny? data, Range range
});


$CommandCopyWith<$Res>? get command;$RangeCopyWith<$Res> get range;

}
/// @nodoc
class _$CodeLensCopyWithImpl<$Res>
    implements $CodeLensCopyWith<$Res> {
  _$CodeLensCopyWithImpl(this._self, this._then);

  final CodeLens _self;
  final $Res Function(CodeLens) _then;

/// Create a copy of CodeLens
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? command = freezed,Object? data = freezed,Object? range = null,}) {
  return _then(_self.copyWith(
command: freezed == command ? _self.command : command // ignore: cast_nullable_to_non_nullable
as Command?,data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LSPAny?,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,
  ));
}
/// Create a copy of CodeLens
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CommandCopyWith<$Res>? get command {
    if (_self.command == null) {
    return null;
  }

  return $CommandCopyWith<$Res>(_self.command!, (value) {
    return _then(_self.copyWith(command: value));
  });
}/// Create a copy of CodeLens
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _CodeLens implements CodeLens {
  const _CodeLens({this.command, this.data, required this.range});
  factory _CodeLens.fromJson(Map<String, dynamic> json) => _$CodeLensFromJson(json);

/// The command this code lens represents.
@override final  Command? command;
/// A data entry field that is preserved on a code lens item between a
/// {@link CodeLensRequest} and a {@link CodeLensResolveRequest}
@override final  LSPAny? data;
/// The range in which this code lens is valid. Should only span a single
/// line.
@override final  Range range;

/// Create a copy of CodeLens
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CodeLensCopyWith<_CodeLens> get copyWith => __$CodeLensCopyWithImpl<_CodeLens>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CodeLensToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CodeLens&&(identical(other.command, command) || other.command == command)&&(identical(other.data, data) || other.data == data)&&(identical(other.range, range) || other.range == range));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,command,data,range);

@override
String toString() {
  return 'CodeLens(command: $command, data: $data, range: $range)';
}


}

/// @nodoc
abstract mixin class _$CodeLensCopyWith<$Res> implements $CodeLensCopyWith<$Res> {
  factory _$CodeLensCopyWith(_CodeLens value, $Res Function(_CodeLens) _then) = __$CodeLensCopyWithImpl;
@override @useResult
$Res call({
 Command? command, LSPAny? data, Range range
});


@override $CommandCopyWith<$Res>? get command;@override $RangeCopyWith<$Res> get range;

}
/// @nodoc
class __$CodeLensCopyWithImpl<$Res>
    implements _$CodeLensCopyWith<$Res> {
  __$CodeLensCopyWithImpl(this._self, this._then);

  final _CodeLens _self;
  final $Res Function(_CodeLens) _then;

/// Create a copy of CodeLens
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? command = freezed,Object? data = freezed,Object? range = null,}) {
  return _then(_CodeLens(
command: freezed == command ? _self.command : command // ignore: cast_nullable_to_non_nullable
as Command?,data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LSPAny?,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,
  ));
}

/// Create a copy of CodeLens
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CommandCopyWith<$Res>? get command {
    if (_self.command == null) {
    return null;
  }

  return $CommandCopyWith<$Res>(_self.command!, (value) {
    return _then(_self.copyWith(command: value));
  });
}/// Create a copy of CodeLens
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}


/// @nodoc
mixin _$CodeLensRegistrationOptions {

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
 Sealed14 get documentSelector;/// Code lens has a resolve provider as well.
 bool? get resolveProvider;
/// Create a copy of CodeLensRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CodeLensRegistrationOptionsCopyWith<CodeLensRegistrationOptions> get copyWith => _$CodeLensRegistrationOptionsCopyWithImpl<CodeLensRegistrationOptions>(this as CodeLensRegistrationOptions, _$identity);

  /// Serializes this CodeLensRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CodeLensRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,resolveProvider);

@override
String toString() {
  return 'CodeLensRegistrationOptions(documentSelector: $documentSelector, resolveProvider: $resolveProvider)';
}


}

/// @nodoc
abstract mixin class $CodeLensRegistrationOptionsCopyWith<$Res>  {
  factory $CodeLensRegistrationOptionsCopyWith(CodeLensRegistrationOptions value, $Res Function(CodeLensRegistrationOptions) _then) = _$CodeLensRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 Sealed14 documentSelector, bool? resolveProvider
});




}
/// @nodoc
class _$CodeLensRegistrationOptionsCopyWithImpl<$Res>
    implements $CodeLensRegistrationOptionsCopyWith<$Res> {
  _$CodeLensRegistrationOptionsCopyWithImpl(this._self, this._then);

  final CodeLensRegistrationOptions _self;
  final $Res Function(CodeLensRegistrationOptions) _then;

/// Create a copy of CodeLensRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = null,Object? resolveProvider = freezed,}) {
  return _then(_self.copyWith(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _CodeLensRegistrationOptions implements CodeLensRegistrationOptions {
  const _CodeLensRegistrationOptions({required this.documentSelector, this.resolveProvider});
  factory _CodeLensRegistrationOptions.fromJson(Map<String, dynamic> json) => _$CodeLensRegistrationOptionsFromJson(json);

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
@override final  Sealed14 documentSelector;
/// Code lens has a resolve provider as well.
@override final  bool? resolveProvider;

/// Create a copy of CodeLensRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CodeLensRegistrationOptionsCopyWith<_CodeLensRegistrationOptions> get copyWith => __$CodeLensRegistrationOptionsCopyWithImpl<_CodeLensRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CodeLensRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CodeLensRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,resolveProvider);

@override
String toString() {
  return 'CodeLensRegistrationOptions(documentSelector: $documentSelector, resolveProvider: $resolveProvider)';
}


}

/// @nodoc
abstract mixin class _$CodeLensRegistrationOptionsCopyWith<$Res> implements $CodeLensRegistrationOptionsCopyWith<$Res> {
  factory _$CodeLensRegistrationOptionsCopyWith(_CodeLensRegistrationOptions value, $Res Function(_CodeLensRegistrationOptions) _then) = __$CodeLensRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 Sealed14 documentSelector, bool? resolveProvider
});




}
/// @nodoc
class __$CodeLensRegistrationOptionsCopyWithImpl<$Res>
    implements _$CodeLensRegistrationOptionsCopyWith<$Res> {
  __$CodeLensRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _CodeLensRegistrationOptions _self;
  final $Res Function(_CodeLensRegistrationOptions) _then;

/// Create a copy of CodeLensRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = null,Object? resolveProvider = freezed,}) {
  return _then(_CodeLensRegistrationOptions(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DocumentLinkParams {

/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
 ProgressToken? get partialResultToken;/// The document to provide document links for.
 TextDocumentIdentifier get textDocument;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of DocumentLinkParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentLinkParamsCopyWith<DocumentLinkParams> get copyWith => _$DocumentLinkParamsCopyWithImpl<DocumentLinkParams>(this as DocumentLinkParams, _$identity);

  /// Serializes this DocumentLinkParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentLinkParams&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,partialResultToken,textDocument,workDoneToken);

@override
String toString() {
  return 'DocumentLinkParams(partialResultToken: $partialResultToken, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $DocumentLinkParamsCopyWith<$Res>  {
  factory $DocumentLinkParamsCopyWith(DocumentLinkParams value, $Res Function(DocumentLinkParams) _then) = _$DocumentLinkParamsCopyWithImpl;
@useResult
$Res call({
 ProgressToken? partialResultToken, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$DocumentLinkParamsCopyWithImpl<$Res>
    implements $DocumentLinkParamsCopyWith<$Res> {
  _$DocumentLinkParamsCopyWithImpl(this._self, this._then);

  final DocumentLinkParams _self;
  final $Res Function(DocumentLinkParams) _then;

/// Create a copy of DocumentLinkParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? partialResultToken = freezed,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of DocumentLinkParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _DocumentLinkParams implements DocumentLinkParams {
  const _DocumentLinkParams({this.partialResultToken, required this.textDocument, this.workDoneToken});
  factory _DocumentLinkParams.fromJson(Map<String, dynamic> json) => _$DocumentLinkParamsFromJson(json);

/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
@override final  ProgressToken? partialResultToken;
/// The document to provide document links for.
@override final  TextDocumentIdentifier textDocument;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of DocumentLinkParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentLinkParamsCopyWith<_DocumentLinkParams> get copyWith => __$DocumentLinkParamsCopyWithImpl<_DocumentLinkParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentLinkParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentLinkParams&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,partialResultToken,textDocument,workDoneToken);

@override
String toString() {
  return 'DocumentLinkParams(partialResultToken: $partialResultToken, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$DocumentLinkParamsCopyWith<$Res> implements $DocumentLinkParamsCopyWith<$Res> {
  factory _$DocumentLinkParamsCopyWith(_DocumentLinkParams value, $Res Function(_DocumentLinkParams) _then) = __$DocumentLinkParamsCopyWithImpl;
@override @useResult
$Res call({
 ProgressToken? partialResultToken, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$DocumentLinkParamsCopyWithImpl<$Res>
    implements _$DocumentLinkParamsCopyWith<$Res> {
  __$DocumentLinkParamsCopyWithImpl(this._self, this._then);

  final _DocumentLinkParams _self;
  final $Res Function(_DocumentLinkParams) _then;

/// Create a copy of DocumentLinkParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? partialResultToken = freezed,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_DocumentLinkParams(
partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of DocumentLinkParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$DocumentLink {

/// A data entry field that is preserved on a document link between a
/// DocumentLinkRequest and a DocumentLinkResolveRequest.
 LSPAny? get data;/// The range this link applies to.
 Range get range;/// The uri this link points to. If missing a resolve request is sent later.
 String? get target;/// The tooltip text when you hover over this link.
/// If a tooltip is provided, is will be displayed in a string that
/// includes instructions on how to trigger the link, such as `{0} (ctrl +
/// click)`. The specific instructions vary depending on OS, user settings,
/// and localization.
/// @since 3.15.0
 String? get tooltip;
/// Create a copy of DocumentLink
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentLinkCopyWith<DocumentLink> get copyWith => _$DocumentLinkCopyWithImpl<DocumentLink>(this as DocumentLink, _$identity);

  /// Serializes this DocumentLink to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentLink&&(identical(other.data, data) || other.data == data)&&(identical(other.range, range) || other.range == range)&&(identical(other.target, target) || other.target == target)&&(identical(other.tooltip, tooltip) || other.tooltip == tooltip));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,data,range,target,tooltip);

@override
String toString() {
  return 'DocumentLink(data: $data, range: $range, target: $target, tooltip: $tooltip)';
}


}

/// @nodoc
abstract mixin class $DocumentLinkCopyWith<$Res>  {
  factory $DocumentLinkCopyWith(DocumentLink value, $Res Function(DocumentLink) _then) = _$DocumentLinkCopyWithImpl;
@useResult
$Res call({
 LSPAny? data, Range range, String? target, String? tooltip
});


$RangeCopyWith<$Res> get range;

}
/// @nodoc
class _$DocumentLinkCopyWithImpl<$Res>
    implements $DocumentLinkCopyWith<$Res> {
  _$DocumentLinkCopyWithImpl(this._self, this._then);

  final DocumentLink _self;
  final $Res Function(DocumentLink) _then;

/// Create a copy of DocumentLink
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? data = freezed,Object? range = null,Object? target = freezed,Object? tooltip = freezed,}) {
  return _then(_self.copyWith(
data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LSPAny?,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,target: freezed == target ? _self.target : target // ignore: cast_nullable_to_non_nullable
as String?,tooltip: freezed == tooltip ? _self.tooltip : tooltip // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}
/// Create a copy of DocumentLink
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _DocumentLink implements DocumentLink {
  const _DocumentLink({this.data, required this.range, this.target, this.tooltip});
  factory _DocumentLink.fromJson(Map<String, dynamic> json) => _$DocumentLinkFromJson(json);

/// A data entry field that is preserved on a document link between a
/// DocumentLinkRequest and a DocumentLinkResolveRequest.
@override final  LSPAny? data;
/// The range this link applies to.
@override final  Range range;
/// The uri this link points to. If missing a resolve request is sent later.
@override final  String? target;
/// The tooltip text when you hover over this link.
/// If a tooltip is provided, is will be displayed in a string that
/// includes instructions on how to trigger the link, such as `{0} (ctrl +
/// click)`. The specific instructions vary depending on OS, user settings,
/// and localization.
/// @since 3.15.0
@override final  String? tooltip;

/// Create a copy of DocumentLink
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentLinkCopyWith<_DocumentLink> get copyWith => __$DocumentLinkCopyWithImpl<_DocumentLink>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentLinkToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentLink&&(identical(other.data, data) || other.data == data)&&(identical(other.range, range) || other.range == range)&&(identical(other.target, target) || other.target == target)&&(identical(other.tooltip, tooltip) || other.tooltip == tooltip));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,data,range,target,tooltip);

@override
String toString() {
  return 'DocumentLink(data: $data, range: $range, target: $target, tooltip: $tooltip)';
}


}

/// @nodoc
abstract mixin class _$DocumentLinkCopyWith<$Res> implements $DocumentLinkCopyWith<$Res> {
  factory _$DocumentLinkCopyWith(_DocumentLink value, $Res Function(_DocumentLink) _then) = __$DocumentLinkCopyWithImpl;
@override @useResult
$Res call({
 LSPAny? data, Range range, String? target, String? tooltip
});


@override $RangeCopyWith<$Res> get range;

}
/// @nodoc
class __$DocumentLinkCopyWithImpl<$Res>
    implements _$DocumentLinkCopyWith<$Res> {
  __$DocumentLinkCopyWithImpl(this._self, this._then);

  final _DocumentLink _self;
  final $Res Function(_DocumentLink) _then;

/// Create a copy of DocumentLink
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? data = freezed,Object? range = null,Object? target = freezed,Object? tooltip = freezed,}) {
  return _then(_DocumentLink(
data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LSPAny?,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,target: freezed == target ? _self.target : target // ignore: cast_nullable_to_non_nullable
as String?,tooltip: freezed == tooltip ? _self.tooltip : tooltip // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

/// Create a copy of DocumentLink
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}


/// @nodoc
mixin _$DocumentLinkRegistrationOptions {

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
 Sealed14 get documentSelector;/// Document links have a resolve provider as well.
 bool? get resolveProvider;
/// Create a copy of DocumentLinkRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentLinkRegistrationOptionsCopyWith<DocumentLinkRegistrationOptions> get copyWith => _$DocumentLinkRegistrationOptionsCopyWithImpl<DocumentLinkRegistrationOptions>(this as DocumentLinkRegistrationOptions, _$identity);

  /// Serializes this DocumentLinkRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentLinkRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,resolveProvider);

@override
String toString() {
  return 'DocumentLinkRegistrationOptions(documentSelector: $documentSelector, resolveProvider: $resolveProvider)';
}


}

/// @nodoc
abstract mixin class $DocumentLinkRegistrationOptionsCopyWith<$Res>  {
  factory $DocumentLinkRegistrationOptionsCopyWith(DocumentLinkRegistrationOptions value, $Res Function(DocumentLinkRegistrationOptions) _then) = _$DocumentLinkRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 Sealed14 documentSelector, bool? resolveProvider
});




}
/// @nodoc
class _$DocumentLinkRegistrationOptionsCopyWithImpl<$Res>
    implements $DocumentLinkRegistrationOptionsCopyWith<$Res> {
  _$DocumentLinkRegistrationOptionsCopyWithImpl(this._self, this._then);

  final DocumentLinkRegistrationOptions _self;
  final $Res Function(DocumentLinkRegistrationOptions) _then;

/// Create a copy of DocumentLinkRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = null,Object? resolveProvider = freezed,}) {
  return _then(_self.copyWith(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DocumentLinkRegistrationOptions implements DocumentLinkRegistrationOptions {
  const _DocumentLinkRegistrationOptions({required this.documentSelector, this.resolveProvider});
  factory _DocumentLinkRegistrationOptions.fromJson(Map<String, dynamic> json) => _$DocumentLinkRegistrationOptionsFromJson(json);

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
@override final  Sealed14 documentSelector;
/// Document links have a resolve provider as well.
@override final  bool? resolveProvider;

/// Create a copy of DocumentLinkRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentLinkRegistrationOptionsCopyWith<_DocumentLinkRegistrationOptions> get copyWith => __$DocumentLinkRegistrationOptionsCopyWithImpl<_DocumentLinkRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentLinkRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentLinkRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,resolveProvider);

@override
String toString() {
  return 'DocumentLinkRegistrationOptions(documentSelector: $documentSelector, resolveProvider: $resolveProvider)';
}


}

/// @nodoc
abstract mixin class _$DocumentLinkRegistrationOptionsCopyWith<$Res> implements $DocumentLinkRegistrationOptionsCopyWith<$Res> {
  factory _$DocumentLinkRegistrationOptionsCopyWith(_DocumentLinkRegistrationOptions value, $Res Function(_DocumentLinkRegistrationOptions) _then) = __$DocumentLinkRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 Sealed14 documentSelector, bool? resolveProvider
});




}
/// @nodoc
class __$DocumentLinkRegistrationOptionsCopyWithImpl<$Res>
    implements _$DocumentLinkRegistrationOptionsCopyWith<$Res> {
  __$DocumentLinkRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _DocumentLinkRegistrationOptions _self;
  final $Res Function(_DocumentLinkRegistrationOptions) _then;

/// Create a copy of DocumentLinkRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = null,Object? resolveProvider = freezed,}) {
  return _then(_DocumentLinkRegistrationOptions(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DocumentFormattingParams {

/// The format options.
 FormattingOptions get options;/// The document to format.
 TextDocumentIdentifier get textDocument;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of DocumentFormattingParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentFormattingParamsCopyWith<DocumentFormattingParams> get copyWith => _$DocumentFormattingParamsCopyWithImpl<DocumentFormattingParams>(this as DocumentFormattingParams, _$identity);

  /// Serializes this DocumentFormattingParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentFormattingParams&&(identical(other.options, options) || other.options == options)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,options,textDocument,workDoneToken);

@override
String toString() {
  return 'DocumentFormattingParams(options: $options, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $DocumentFormattingParamsCopyWith<$Res>  {
  factory $DocumentFormattingParamsCopyWith(DocumentFormattingParams value, $Res Function(DocumentFormattingParams) _then) = _$DocumentFormattingParamsCopyWithImpl;
@useResult
$Res call({
 FormattingOptions options, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


$FormattingOptionsCopyWith<$Res> get options;$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$DocumentFormattingParamsCopyWithImpl<$Res>
    implements $DocumentFormattingParamsCopyWith<$Res> {
  _$DocumentFormattingParamsCopyWithImpl(this._self, this._then);

  final DocumentFormattingParams _self;
  final $Res Function(DocumentFormattingParams) _then;

/// Create a copy of DocumentFormattingParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? options = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
options: null == options ? _self.options : options // ignore: cast_nullable_to_non_nullable
as FormattingOptions,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of DocumentFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FormattingOptionsCopyWith<$Res> get options {
  
  return $FormattingOptionsCopyWith<$Res>(_self.options, (value) {
    return _then(_self.copyWith(options: value));
  });
}/// Create a copy of DocumentFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _DocumentFormattingParams implements DocumentFormattingParams {
  const _DocumentFormattingParams({required this.options, required this.textDocument, this.workDoneToken});
  factory _DocumentFormattingParams.fromJson(Map<String, dynamic> json) => _$DocumentFormattingParamsFromJson(json);

/// The format options.
@override final  FormattingOptions options;
/// The document to format.
@override final  TextDocumentIdentifier textDocument;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of DocumentFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentFormattingParamsCopyWith<_DocumentFormattingParams> get copyWith => __$DocumentFormattingParamsCopyWithImpl<_DocumentFormattingParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentFormattingParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentFormattingParams&&(identical(other.options, options) || other.options == options)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,options,textDocument,workDoneToken);

@override
String toString() {
  return 'DocumentFormattingParams(options: $options, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$DocumentFormattingParamsCopyWith<$Res> implements $DocumentFormattingParamsCopyWith<$Res> {
  factory _$DocumentFormattingParamsCopyWith(_DocumentFormattingParams value, $Res Function(_DocumentFormattingParams) _then) = __$DocumentFormattingParamsCopyWithImpl;
@override @useResult
$Res call({
 FormattingOptions options, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


@override $FormattingOptionsCopyWith<$Res> get options;@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$DocumentFormattingParamsCopyWithImpl<$Res>
    implements _$DocumentFormattingParamsCopyWith<$Res> {
  __$DocumentFormattingParamsCopyWithImpl(this._self, this._then);

  final _DocumentFormattingParams _self;
  final $Res Function(_DocumentFormattingParams) _then;

/// Create a copy of DocumentFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? options = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_DocumentFormattingParams(
options: null == options ? _self.options : options // ignore: cast_nullable_to_non_nullable
as FormattingOptions,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of DocumentFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FormattingOptionsCopyWith<$Res> get options {
  
  return $FormattingOptionsCopyWith<$Res>(_self.options, (value) {
    return _then(_self.copyWith(options: value));
  });
}/// Create a copy of DocumentFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$DocumentFormattingRegistrationOptions {

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
 Sealed14 get documentSelector;
/// Create a copy of DocumentFormattingRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentFormattingRegistrationOptionsCopyWith<DocumentFormattingRegistrationOptions> get copyWith => _$DocumentFormattingRegistrationOptionsCopyWithImpl<DocumentFormattingRegistrationOptions>(this as DocumentFormattingRegistrationOptions, _$identity);

  /// Serializes this DocumentFormattingRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentFormattingRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector);

@override
String toString() {
  return 'DocumentFormattingRegistrationOptions(documentSelector: $documentSelector)';
}


}

/// @nodoc
abstract mixin class $DocumentFormattingRegistrationOptionsCopyWith<$Res>  {
  factory $DocumentFormattingRegistrationOptionsCopyWith(DocumentFormattingRegistrationOptions value, $Res Function(DocumentFormattingRegistrationOptions) _then) = _$DocumentFormattingRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 Sealed14 documentSelector
});




}
/// @nodoc
class _$DocumentFormattingRegistrationOptionsCopyWithImpl<$Res>
    implements $DocumentFormattingRegistrationOptionsCopyWith<$Res> {
  _$DocumentFormattingRegistrationOptionsCopyWithImpl(this._self, this._then);

  final DocumentFormattingRegistrationOptions _self;
  final $Res Function(DocumentFormattingRegistrationOptions) _then;

/// Create a copy of DocumentFormattingRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = null,}) {
  return _then(_self.copyWith(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DocumentFormattingRegistrationOptions implements DocumentFormattingRegistrationOptions {
  const _DocumentFormattingRegistrationOptions({required this.documentSelector});
  factory _DocumentFormattingRegistrationOptions.fromJson(Map<String, dynamic> json) => _$DocumentFormattingRegistrationOptionsFromJson(json);

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
@override final  Sealed14 documentSelector;

/// Create a copy of DocumentFormattingRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentFormattingRegistrationOptionsCopyWith<_DocumentFormattingRegistrationOptions> get copyWith => __$DocumentFormattingRegistrationOptionsCopyWithImpl<_DocumentFormattingRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentFormattingRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentFormattingRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector);

@override
String toString() {
  return 'DocumentFormattingRegistrationOptions(documentSelector: $documentSelector)';
}


}

/// @nodoc
abstract mixin class _$DocumentFormattingRegistrationOptionsCopyWith<$Res> implements $DocumentFormattingRegistrationOptionsCopyWith<$Res> {
  factory _$DocumentFormattingRegistrationOptionsCopyWith(_DocumentFormattingRegistrationOptions value, $Res Function(_DocumentFormattingRegistrationOptions) _then) = __$DocumentFormattingRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 Sealed14 documentSelector
});




}
/// @nodoc
class __$DocumentFormattingRegistrationOptionsCopyWithImpl<$Res>
    implements _$DocumentFormattingRegistrationOptionsCopyWith<$Res> {
  __$DocumentFormattingRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _DocumentFormattingRegistrationOptions _self;
  final $Res Function(_DocumentFormattingRegistrationOptions) _then;

/// Create a copy of DocumentFormattingRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = null,}) {
  return _then(_DocumentFormattingRegistrationOptions(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,
  ));
}


}


/// @nodoc
mixin _$DocumentRangeFormattingParams {

/// The format options
 FormattingOptions get options;/// The range to format
 Range get range;/// The document to format.
 TextDocumentIdentifier get textDocument;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of DocumentRangeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentRangeFormattingParamsCopyWith<DocumentRangeFormattingParams> get copyWith => _$DocumentRangeFormattingParamsCopyWithImpl<DocumentRangeFormattingParams>(this as DocumentRangeFormattingParams, _$identity);

  /// Serializes this DocumentRangeFormattingParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentRangeFormattingParams&&(identical(other.options, options) || other.options == options)&&(identical(other.range, range) || other.range == range)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,options,range,textDocument,workDoneToken);

@override
String toString() {
  return 'DocumentRangeFormattingParams(options: $options, range: $range, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $DocumentRangeFormattingParamsCopyWith<$Res>  {
  factory $DocumentRangeFormattingParamsCopyWith(DocumentRangeFormattingParams value, $Res Function(DocumentRangeFormattingParams) _then) = _$DocumentRangeFormattingParamsCopyWithImpl;
@useResult
$Res call({
 FormattingOptions options, Range range, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


$FormattingOptionsCopyWith<$Res> get options;$RangeCopyWith<$Res> get range;$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$DocumentRangeFormattingParamsCopyWithImpl<$Res>
    implements $DocumentRangeFormattingParamsCopyWith<$Res> {
  _$DocumentRangeFormattingParamsCopyWithImpl(this._self, this._then);

  final DocumentRangeFormattingParams _self;
  final $Res Function(DocumentRangeFormattingParams) _then;

/// Create a copy of DocumentRangeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? options = null,Object? range = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
options: null == options ? _self.options : options // ignore: cast_nullable_to_non_nullable
as FormattingOptions,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of DocumentRangeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FormattingOptionsCopyWith<$Res> get options {
  
  return $FormattingOptionsCopyWith<$Res>(_self.options, (value) {
    return _then(_self.copyWith(options: value));
  });
}/// Create a copy of DocumentRangeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}/// Create a copy of DocumentRangeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _DocumentRangeFormattingParams implements DocumentRangeFormattingParams {
  const _DocumentRangeFormattingParams({required this.options, required this.range, required this.textDocument, this.workDoneToken});
  factory _DocumentRangeFormattingParams.fromJson(Map<String, dynamic> json) => _$DocumentRangeFormattingParamsFromJson(json);

/// The format options
@override final  FormattingOptions options;
/// The range to format
@override final  Range range;
/// The document to format.
@override final  TextDocumentIdentifier textDocument;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of DocumentRangeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentRangeFormattingParamsCopyWith<_DocumentRangeFormattingParams> get copyWith => __$DocumentRangeFormattingParamsCopyWithImpl<_DocumentRangeFormattingParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentRangeFormattingParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentRangeFormattingParams&&(identical(other.options, options) || other.options == options)&&(identical(other.range, range) || other.range == range)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,options,range,textDocument,workDoneToken);

@override
String toString() {
  return 'DocumentRangeFormattingParams(options: $options, range: $range, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$DocumentRangeFormattingParamsCopyWith<$Res> implements $DocumentRangeFormattingParamsCopyWith<$Res> {
  factory _$DocumentRangeFormattingParamsCopyWith(_DocumentRangeFormattingParams value, $Res Function(_DocumentRangeFormattingParams) _then) = __$DocumentRangeFormattingParamsCopyWithImpl;
@override @useResult
$Res call({
 FormattingOptions options, Range range, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


@override $FormattingOptionsCopyWith<$Res> get options;@override $RangeCopyWith<$Res> get range;@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$DocumentRangeFormattingParamsCopyWithImpl<$Res>
    implements _$DocumentRangeFormattingParamsCopyWith<$Res> {
  __$DocumentRangeFormattingParamsCopyWithImpl(this._self, this._then);

  final _DocumentRangeFormattingParams _self;
  final $Res Function(_DocumentRangeFormattingParams) _then;

/// Create a copy of DocumentRangeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? options = null,Object? range = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_DocumentRangeFormattingParams(
options: null == options ? _self.options : options // ignore: cast_nullable_to_non_nullable
as FormattingOptions,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of DocumentRangeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FormattingOptionsCopyWith<$Res> get options {
  
  return $FormattingOptionsCopyWith<$Res>(_self.options, (value) {
    return _then(_self.copyWith(options: value));
  });
}/// Create a copy of DocumentRangeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}/// Create a copy of DocumentRangeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$DocumentRangeFormattingRegistrationOptions {

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
 Sealed14 get documentSelector;/// Whether the server supports formatting multiple ranges at once.
/// @since 3.18.0 @proposed
 bool? get rangesSupport;
/// Create a copy of DocumentRangeFormattingRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentRangeFormattingRegistrationOptionsCopyWith<DocumentRangeFormattingRegistrationOptions> get copyWith => _$DocumentRangeFormattingRegistrationOptionsCopyWithImpl<DocumentRangeFormattingRegistrationOptions>(this as DocumentRangeFormattingRegistrationOptions, _$identity);

  /// Serializes this DocumentRangeFormattingRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentRangeFormattingRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.rangesSupport, rangesSupport) || other.rangesSupport == rangesSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,rangesSupport);

@override
String toString() {
  return 'DocumentRangeFormattingRegistrationOptions(documentSelector: $documentSelector, rangesSupport: $rangesSupport)';
}


}

/// @nodoc
abstract mixin class $DocumentRangeFormattingRegistrationOptionsCopyWith<$Res>  {
  factory $DocumentRangeFormattingRegistrationOptionsCopyWith(DocumentRangeFormattingRegistrationOptions value, $Res Function(DocumentRangeFormattingRegistrationOptions) _then) = _$DocumentRangeFormattingRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 Sealed14 documentSelector, bool? rangesSupport
});




}
/// @nodoc
class _$DocumentRangeFormattingRegistrationOptionsCopyWithImpl<$Res>
    implements $DocumentRangeFormattingRegistrationOptionsCopyWith<$Res> {
  _$DocumentRangeFormattingRegistrationOptionsCopyWithImpl(this._self, this._then);

  final DocumentRangeFormattingRegistrationOptions _self;
  final $Res Function(DocumentRangeFormattingRegistrationOptions) _then;

/// Create a copy of DocumentRangeFormattingRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = null,Object? rangesSupport = freezed,}) {
  return _then(_self.copyWith(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,rangesSupport: freezed == rangesSupport ? _self.rangesSupport : rangesSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DocumentRangeFormattingRegistrationOptions implements DocumentRangeFormattingRegistrationOptions {
  const _DocumentRangeFormattingRegistrationOptions({required this.documentSelector, this.rangesSupport});
  factory _DocumentRangeFormattingRegistrationOptions.fromJson(Map<String, dynamic> json) => _$DocumentRangeFormattingRegistrationOptionsFromJson(json);

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
@override final  Sealed14 documentSelector;
/// Whether the server supports formatting multiple ranges at once.
/// @since 3.18.0 @proposed
@override final  bool? rangesSupport;

/// Create a copy of DocumentRangeFormattingRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentRangeFormattingRegistrationOptionsCopyWith<_DocumentRangeFormattingRegistrationOptions> get copyWith => __$DocumentRangeFormattingRegistrationOptionsCopyWithImpl<_DocumentRangeFormattingRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentRangeFormattingRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentRangeFormattingRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.rangesSupport, rangesSupport) || other.rangesSupport == rangesSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,rangesSupport);

@override
String toString() {
  return 'DocumentRangeFormattingRegistrationOptions(documentSelector: $documentSelector, rangesSupport: $rangesSupport)';
}


}

/// @nodoc
abstract mixin class _$DocumentRangeFormattingRegistrationOptionsCopyWith<$Res> implements $DocumentRangeFormattingRegistrationOptionsCopyWith<$Res> {
  factory _$DocumentRangeFormattingRegistrationOptionsCopyWith(_DocumentRangeFormattingRegistrationOptions value, $Res Function(_DocumentRangeFormattingRegistrationOptions) _then) = __$DocumentRangeFormattingRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 Sealed14 documentSelector, bool? rangesSupport
});




}
/// @nodoc
class __$DocumentRangeFormattingRegistrationOptionsCopyWithImpl<$Res>
    implements _$DocumentRangeFormattingRegistrationOptionsCopyWith<$Res> {
  __$DocumentRangeFormattingRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _DocumentRangeFormattingRegistrationOptions _self;
  final $Res Function(_DocumentRangeFormattingRegistrationOptions) _then;

/// Create a copy of DocumentRangeFormattingRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = null,Object? rangesSupport = freezed,}) {
  return _then(_DocumentRangeFormattingRegistrationOptions(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,rangesSupport: freezed == rangesSupport ? _self.rangesSupport : rangesSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DocumentRangesFormattingParams {

/// The format options
 FormattingOptions get options;/// The ranges to format
 List<Range> get ranges;/// The document to format.
 TextDocumentIdentifier get textDocument;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of DocumentRangesFormattingParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentRangesFormattingParamsCopyWith<DocumentRangesFormattingParams> get copyWith => _$DocumentRangesFormattingParamsCopyWithImpl<DocumentRangesFormattingParams>(this as DocumentRangesFormattingParams, _$identity);

  /// Serializes this DocumentRangesFormattingParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentRangesFormattingParams&&(identical(other.options, options) || other.options == options)&&const DeepCollectionEquality().equals(other.ranges, ranges)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,options,const DeepCollectionEquality().hash(ranges),textDocument,workDoneToken);

@override
String toString() {
  return 'DocumentRangesFormattingParams(options: $options, ranges: $ranges, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $DocumentRangesFormattingParamsCopyWith<$Res>  {
  factory $DocumentRangesFormattingParamsCopyWith(DocumentRangesFormattingParams value, $Res Function(DocumentRangesFormattingParams) _then) = _$DocumentRangesFormattingParamsCopyWithImpl;
@useResult
$Res call({
 FormattingOptions options, List<Range> ranges, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


$FormattingOptionsCopyWith<$Res> get options;$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$DocumentRangesFormattingParamsCopyWithImpl<$Res>
    implements $DocumentRangesFormattingParamsCopyWith<$Res> {
  _$DocumentRangesFormattingParamsCopyWithImpl(this._self, this._then);

  final DocumentRangesFormattingParams _self;
  final $Res Function(DocumentRangesFormattingParams) _then;

/// Create a copy of DocumentRangesFormattingParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? options = null,Object? ranges = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
options: null == options ? _self.options : options // ignore: cast_nullable_to_non_nullable
as FormattingOptions,ranges: null == ranges ? _self.ranges : ranges // ignore: cast_nullable_to_non_nullable
as List<Range>,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of DocumentRangesFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FormattingOptionsCopyWith<$Res> get options {
  
  return $FormattingOptionsCopyWith<$Res>(_self.options, (value) {
    return _then(_self.copyWith(options: value));
  });
}/// Create a copy of DocumentRangesFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _DocumentRangesFormattingParams implements DocumentRangesFormattingParams {
  const _DocumentRangesFormattingParams({required this.options, required final  List<Range> ranges, required this.textDocument, this.workDoneToken}): _ranges = ranges;
  factory _DocumentRangesFormattingParams.fromJson(Map<String, dynamic> json) => _$DocumentRangesFormattingParamsFromJson(json);

/// The format options
@override final  FormattingOptions options;
/// The ranges to format
 final  List<Range> _ranges;
/// The ranges to format
@override List<Range> get ranges {
  if (_ranges is EqualUnmodifiableListView) return _ranges;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_ranges);
}

/// The document to format.
@override final  TextDocumentIdentifier textDocument;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of DocumentRangesFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentRangesFormattingParamsCopyWith<_DocumentRangesFormattingParams> get copyWith => __$DocumentRangesFormattingParamsCopyWithImpl<_DocumentRangesFormattingParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentRangesFormattingParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentRangesFormattingParams&&(identical(other.options, options) || other.options == options)&&const DeepCollectionEquality().equals(other._ranges, _ranges)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,options,const DeepCollectionEquality().hash(_ranges),textDocument,workDoneToken);

@override
String toString() {
  return 'DocumentRangesFormattingParams(options: $options, ranges: $ranges, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$DocumentRangesFormattingParamsCopyWith<$Res> implements $DocumentRangesFormattingParamsCopyWith<$Res> {
  factory _$DocumentRangesFormattingParamsCopyWith(_DocumentRangesFormattingParams value, $Res Function(_DocumentRangesFormattingParams) _then) = __$DocumentRangesFormattingParamsCopyWithImpl;
@override @useResult
$Res call({
 FormattingOptions options, List<Range> ranges, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


@override $FormattingOptionsCopyWith<$Res> get options;@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$DocumentRangesFormattingParamsCopyWithImpl<$Res>
    implements _$DocumentRangesFormattingParamsCopyWith<$Res> {
  __$DocumentRangesFormattingParamsCopyWithImpl(this._self, this._then);

  final _DocumentRangesFormattingParams _self;
  final $Res Function(_DocumentRangesFormattingParams) _then;

/// Create a copy of DocumentRangesFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? options = null,Object? ranges = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_DocumentRangesFormattingParams(
options: null == options ? _self.options : options // ignore: cast_nullable_to_non_nullable
as FormattingOptions,ranges: null == ranges ? _self._ranges : ranges // ignore: cast_nullable_to_non_nullable
as List<Range>,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of DocumentRangesFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FormattingOptionsCopyWith<$Res> get options {
  
  return $FormattingOptionsCopyWith<$Res>(_self.options, (value) {
    return _then(_self.copyWith(options: value));
  });
}/// Create a copy of DocumentRangesFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$DocumentOnTypeFormattingParams {

/// The character that has been typed that triggered the formatting on type
/// request. That is not necessarily the last character that got inserted
/// into the document since the client could auto insert characters as well
/// (e.g. like automatic brace completion).
 String get ch;/// The formatting options.
 FormattingOptions get options;/// The position around which the on type formatting should happen. This is
/// not necessarily the exact position where the character denoted by the
/// property `ch` got typed.
 Position get position;/// The document to format.
 TextDocumentIdentifier get textDocument;
/// Create a copy of DocumentOnTypeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentOnTypeFormattingParamsCopyWith<DocumentOnTypeFormattingParams> get copyWith => _$DocumentOnTypeFormattingParamsCopyWithImpl<DocumentOnTypeFormattingParams>(this as DocumentOnTypeFormattingParams, _$identity);

  /// Serializes this DocumentOnTypeFormattingParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentOnTypeFormattingParams&&(identical(other.ch, ch) || other.ch == ch)&&(identical(other.options, options) || other.options == options)&&(identical(other.position, position) || other.position == position)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,ch,options,position,textDocument);

@override
String toString() {
  return 'DocumentOnTypeFormattingParams(ch: $ch, options: $options, position: $position, textDocument: $textDocument)';
}


}

/// @nodoc
abstract mixin class $DocumentOnTypeFormattingParamsCopyWith<$Res>  {
  factory $DocumentOnTypeFormattingParamsCopyWith(DocumentOnTypeFormattingParams value, $Res Function(DocumentOnTypeFormattingParams) _then) = _$DocumentOnTypeFormattingParamsCopyWithImpl;
@useResult
$Res call({
 String ch, FormattingOptions options, Position position, TextDocumentIdentifier textDocument
});


$FormattingOptionsCopyWith<$Res> get options;$PositionCopyWith<$Res> get position;$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$DocumentOnTypeFormattingParamsCopyWithImpl<$Res>
    implements $DocumentOnTypeFormattingParamsCopyWith<$Res> {
  _$DocumentOnTypeFormattingParamsCopyWithImpl(this._self, this._then);

  final DocumentOnTypeFormattingParams _self;
  final $Res Function(DocumentOnTypeFormattingParams) _then;

/// Create a copy of DocumentOnTypeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? ch = null,Object? options = null,Object? position = null,Object? textDocument = null,}) {
  return _then(_self.copyWith(
ch: null == ch ? _self.ch : ch // ignore: cast_nullable_to_non_nullable
as String,options: null == options ? _self.options : options // ignore: cast_nullable_to_non_nullable
as FormattingOptions,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,
  ));
}
/// Create a copy of DocumentOnTypeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FormattingOptionsCopyWith<$Res> get options {
  
  return $FormattingOptionsCopyWith<$Res>(_self.options, (value) {
    return _then(_self.copyWith(options: value));
  });
}/// Create a copy of DocumentOnTypeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of DocumentOnTypeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _DocumentOnTypeFormattingParams implements DocumentOnTypeFormattingParams {
  const _DocumentOnTypeFormattingParams({required this.ch, required this.options, required this.position, required this.textDocument});
  factory _DocumentOnTypeFormattingParams.fromJson(Map<String, dynamic> json) => _$DocumentOnTypeFormattingParamsFromJson(json);

/// The character that has been typed that triggered the formatting on type
/// request. That is not necessarily the last character that got inserted
/// into the document since the client could auto insert characters as well
/// (e.g. like automatic brace completion).
@override final  String ch;
/// The formatting options.
@override final  FormattingOptions options;
/// The position around which the on type formatting should happen. This is
/// not necessarily the exact position where the character denoted by the
/// property `ch` got typed.
@override final  Position position;
/// The document to format.
@override final  TextDocumentIdentifier textDocument;

/// Create a copy of DocumentOnTypeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentOnTypeFormattingParamsCopyWith<_DocumentOnTypeFormattingParams> get copyWith => __$DocumentOnTypeFormattingParamsCopyWithImpl<_DocumentOnTypeFormattingParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentOnTypeFormattingParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentOnTypeFormattingParams&&(identical(other.ch, ch) || other.ch == ch)&&(identical(other.options, options) || other.options == options)&&(identical(other.position, position) || other.position == position)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,ch,options,position,textDocument);

@override
String toString() {
  return 'DocumentOnTypeFormattingParams(ch: $ch, options: $options, position: $position, textDocument: $textDocument)';
}


}

/// @nodoc
abstract mixin class _$DocumentOnTypeFormattingParamsCopyWith<$Res> implements $DocumentOnTypeFormattingParamsCopyWith<$Res> {
  factory _$DocumentOnTypeFormattingParamsCopyWith(_DocumentOnTypeFormattingParams value, $Res Function(_DocumentOnTypeFormattingParams) _then) = __$DocumentOnTypeFormattingParamsCopyWithImpl;
@override @useResult
$Res call({
 String ch, FormattingOptions options, Position position, TextDocumentIdentifier textDocument
});


@override $FormattingOptionsCopyWith<$Res> get options;@override $PositionCopyWith<$Res> get position;@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$DocumentOnTypeFormattingParamsCopyWithImpl<$Res>
    implements _$DocumentOnTypeFormattingParamsCopyWith<$Res> {
  __$DocumentOnTypeFormattingParamsCopyWithImpl(this._self, this._then);

  final _DocumentOnTypeFormattingParams _self;
  final $Res Function(_DocumentOnTypeFormattingParams) _then;

/// Create a copy of DocumentOnTypeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? ch = null,Object? options = null,Object? position = null,Object? textDocument = null,}) {
  return _then(_DocumentOnTypeFormattingParams(
ch: null == ch ? _self.ch : ch // ignore: cast_nullable_to_non_nullable
as String,options: null == options ? _self.options : options // ignore: cast_nullable_to_non_nullable
as FormattingOptions,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,
  ));
}

/// Create a copy of DocumentOnTypeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FormattingOptionsCopyWith<$Res> get options {
  
  return $FormattingOptionsCopyWith<$Res>(_self.options, (value) {
    return _then(_self.copyWith(options: value));
  });
}/// Create a copy of DocumentOnTypeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of DocumentOnTypeFormattingParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$DocumentOnTypeFormattingRegistrationOptions {

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
 Sealed14 get documentSelector;/// A character on which formatting should be triggered, like `{`.
 String get firstTriggerCharacter;/// More trigger characters.
 List<String>? get moreTriggerCharacter;
/// Create a copy of DocumentOnTypeFormattingRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentOnTypeFormattingRegistrationOptionsCopyWith<DocumentOnTypeFormattingRegistrationOptions> get copyWith => _$DocumentOnTypeFormattingRegistrationOptionsCopyWithImpl<DocumentOnTypeFormattingRegistrationOptions>(this as DocumentOnTypeFormattingRegistrationOptions, _$identity);

  /// Serializes this DocumentOnTypeFormattingRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentOnTypeFormattingRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.firstTriggerCharacter, firstTriggerCharacter) || other.firstTriggerCharacter == firstTriggerCharacter)&&const DeepCollectionEquality().equals(other.moreTriggerCharacter, moreTriggerCharacter));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,firstTriggerCharacter,const DeepCollectionEquality().hash(moreTriggerCharacter));

@override
String toString() {
  return 'DocumentOnTypeFormattingRegistrationOptions(documentSelector: $documentSelector, firstTriggerCharacter: $firstTriggerCharacter, moreTriggerCharacter: $moreTriggerCharacter)';
}


}

/// @nodoc
abstract mixin class $DocumentOnTypeFormattingRegistrationOptionsCopyWith<$Res>  {
  factory $DocumentOnTypeFormattingRegistrationOptionsCopyWith(DocumentOnTypeFormattingRegistrationOptions value, $Res Function(DocumentOnTypeFormattingRegistrationOptions) _then) = _$DocumentOnTypeFormattingRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 Sealed14 documentSelector, String firstTriggerCharacter, List<String>? moreTriggerCharacter
});




}
/// @nodoc
class _$DocumentOnTypeFormattingRegistrationOptionsCopyWithImpl<$Res>
    implements $DocumentOnTypeFormattingRegistrationOptionsCopyWith<$Res> {
  _$DocumentOnTypeFormattingRegistrationOptionsCopyWithImpl(this._self, this._then);

  final DocumentOnTypeFormattingRegistrationOptions _self;
  final $Res Function(DocumentOnTypeFormattingRegistrationOptions) _then;

/// Create a copy of DocumentOnTypeFormattingRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = null,Object? firstTriggerCharacter = null,Object? moreTriggerCharacter = freezed,}) {
  return _then(_self.copyWith(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,firstTriggerCharacter: null == firstTriggerCharacter ? _self.firstTriggerCharacter : firstTriggerCharacter // ignore: cast_nullable_to_non_nullable
as String,moreTriggerCharacter: freezed == moreTriggerCharacter ? _self.moreTriggerCharacter : moreTriggerCharacter // ignore: cast_nullable_to_non_nullable
as List<String>?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DocumentOnTypeFormattingRegistrationOptions implements DocumentOnTypeFormattingRegistrationOptions {
  const _DocumentOnTypeFormattingRegistrationOptions({required this.documentSelector, required this.firstTriggerCharacter, final  List<String>? moreTriggerCharacter}): _moreTriggerCharacter = moreTriggerCharacter;
  factory _DocumentOnTypeFormattingRegistrationOptions.fromJson(Map<String, dynamic> json) => _$DocumentOnTypeFormattingRegistrationOptionsFromJson(json);

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
@override final  Sealed14 documentSelector;
/// A character on which formatting should be triggered, like `{`.
@override final  String firstTriggerCharacter;
/// More trigger characters.
 final  List<String>? _moreTriggerCharacter;
/// More trigger characters.
@override List<String>? get moreTriggerCharacter {
  final value = _moreTriggerCharacter;
  if (value == null) return null;
  if (_moreTriggerCharacter is EqualUnmodifiableListView) return _moreTriggerCharacter;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}


/// Create a copy of DocumentOnTypeFormattingRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentOnTypeFormattingRegistrationOptionsCopyWith<_DocumentOnTypeFormattingRegistrationOptions> get copyWith => __$DocumentOnTypeFormattingRegistrationOptionsCopyWithImpl<_DocumentOnTypeFormattingRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentOnTypeFormattingRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentOnTypeFormattingRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.firstTriggerCharacter, firstTriggerCharacter) || other.firstTriggerCharacter == firstTriggerCharacter)&&const DeepCollectionEquality().equals(other._moreTriggerCharacter, _moreTriggerCharacter));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,firstTriggerCharacter,const DeepCollectionEquality().hash(_moreTriggerCharacter));

@override
String toString() {
  return 'DocumentOnTypeFormattingRegistrationOptions(documentSelector: $documentSelector, firstTriggerCharacter: $firstTriggerCharacter, moreTriggerCharacter: $moreTriggerCharacter)';
}


}

/// @nodoc
abstract mixin class _$DocumentOnTypeFormattingRegistrationOptionsCopyWith<$Res> implements $DocumentOnTypeFormattingRegistrationOptionsCopyWith<$Res> {
  factory _$DocumentOnTypeFormattingRegistrationOptionsCopyWith(_DocumentOnTypeFormattingRegistrationOptions value, $Res Function(_DocumentOnTypeFormattingRegistrationOptions) _then) = __$DocumentOnTypeFormattingRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 Sealed14 documentSelector, String firstTriggerCharacter, List<String>? moreTriggerCharacter
});




}
/// @nodoc
class __$DocumentOnTypeFormattingRegistrationOptionsCopyWithImpl<$Res>
    implements _$DocumentOnTypeFormattingRegistrationOptionsCopyWith<$Res> {
  __$DocumentOnTypeFormattingRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _DocumentOnTypeFormattingRegistrationOptions _self;
  final $Res Function(_DocumentOnTypeFormattingRegistrationOptions) _then;

/// Create a copy of DocumentOnTypeFormattingRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = null,Object? firstTriggerCharacter = null,Object? moreTriggerCharacter = freezed,}) {
  return _then(_DocumentOnTypeFormattingRegistrationOptions(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,firstTriggerCharacter: null == firstTriggerCharacter ? _self.firstTriggerCharacter : firstTriggerCharacter // ignore: cast_nullable_to_non_nullable
as String,moreTriggerCharacter: freezed == moreTriggerCharacter ? _self._moreTriggerCharacter : moreTriggerCharacter // ignore: cast_nullable_to_non_nullable
as List<String>?,
  ));
}


}


/// @nodoc
mixin _$RenameParams {

/// The new name of the symbol. If the given name is not valid the request
/// must return a {@link ResponseError} with an appropriate message set.
 String get newName;/// The position at which this request was sent.
 Position get position;/// The document to rename.
 TextDocumentIdentifier get textDocument;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of RenameParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RenameParamsCopyWith<RenameParams> get copyWith => _$RenameParamsCopyWithImpl<RenameParams>(this as RenameParams, _$identity);

  /// Serializes this RenameParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RenameParams&&(identical(other.newName, newName) || other.newName == newName)&&(identical(other.position, position) || other.position == position)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,newName,position,textDocument,workDoneToken);

@override
String toString() {
  return 'RenameParams(newName: $newName, position: $position, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $RenameParamsCopyWith<$Res>  {
  factory $RenameParamsCopyWith(RenameParams value, $Res Function(RenameParams) _then) = _$RenameParamsCopyWithImpl;
@useResult
$Res call({
 String newName, Position position, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


$PositionCopyWith<$Res> get position;$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$RenameParamsCopyWithImpl<$Res>
    implements $RenameParamsCopyWith<$Res> {
  _$RenameParamsCopyWithImpl(this._self, this._then);

  final RenameParams _self;
  final $Res Function(RenameParams) _then;

/// Create a copy of RenameParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? newName = null,Object? position = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
newName: null == newName ? _self.newName : newName // ignore: cast_nullable_to_non_nullable
as String,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of RenameParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of RenameParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _RenameParams implements RenameParams {
  const _RenameParams({required this.newName, required this.position, required this.textDocument, this.workDoneToken});
  factory _RenameParams.fromJson(Map<String, dynamic> json) => _$RenameParamsFromJson(json);

/// The new name of the symbol. If the given name is not valid the request
/// must return a {@link ResponseError} with an appropriate message set.
@override final  String newName;
/// The position at which this request was sent.
@override final  Position position;
/// The document to rename.
@override final  TextDocumentIdentifier textDocument;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of RenameParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RenameParamsCopyWith<_RenameParams> get copyWith => __$RenameParamsCopyWithImpl<_RenameParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$RenameParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _RenameParams&&(identical(other.newName, newName) || other.newName == newName)&&(identical(other.position, position) || other.position == position)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,newName,position,textDocument,workDoneToken);

@override
String toString() {
  return 'RenameParams(newName: $newName, position: $position, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$RenameParamsCopyWith<$Res> implements $RenameParamsCopyWith<$Res> {
  factory _$RenameParamsCopyWith(_RenameParams value, $Res Function(_RenameParams) _then) = __$RenameParamsCopyWithImpl;
@override @useResult
$Res call({
 String newName, Position position, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


@override $PositionCopyWith<$Res> get position;@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$RenameParamsCopyWithImpl<$Res>
    implements _$RenameParamsCopyWith<$Res> {
  __$RenameParamsCopyWithImpl(this._self, this._then);

  final _RenameParams _self;
  final $Res Function(_RenameParams) _then;

/// Create a copy of RenameParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? newName = null,Object? position = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_RenameParams(
newName: null == newName ? _self.newName : newName // ignore: cast_nullable_to_non_nullable
as String,position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of RenameParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of RenameParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$RenameRegistrationOptions {

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
 Sealed14 get documentSelector;/// Renames should be checked and tested before being executed.
/// @since version 3.12.0
 bool? get prepareProvider;
/// Create a copy of RenameRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RenameRegistrationOptionsCopyWith<RenameRegistrationOptions> get copyWith => _$RenameRegistrationOptionsCopyWithImpl<RenameRegistrationOptions>(this as RenameRegistrationOptions, _$identity);

  /// Serializes this RenameRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RenameRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.prepareProvider, prepareProvider) || other.prepareProvider == prepareProvider));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,prepareProvider);

@override
String toString() {
  return 'RenameRegistrationOptions(documentSelector: $documentSelector, prepareProvider: $prepareProvider)';
}


}

/// @nodoc
abstract mixin class $RenameRegistrationOptionsCopyWith<$Res>  {
  factory $RenameRegistrationOptionsCopyWith(RenameRegistrationOptions value, $Res Function(RenameRegistrationOptions) _then) = _$RenameRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 Sealed14 documentSelector, bool? prepareProvider
});




}
/// @nodoc
class _$RenameRegistrationOptionsCopyWithImpl<$Res>
    implements $RenameRegistrationOptionsCopyWith<$Res> {
  _$RenameRegistrationOptionsCopyWithImpl(this._self, this._then);

  final RenameRegistrationOptions _self;
  final $Res Function(RenameRegistrationOptions) _then;

/// Create a copy of RenameRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentSelector = null,Object? prepareProvider = freezed,}) {
  return _then(_self.copyWith(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,prepareProvider: freezed == prepareProvider ? _self.prepareProvider : prepareProvider // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _RenameRegistrationOptions implements RenameRegistrationOptions {
  const _RenameRegistrationOptions({required this.documentSelector, this.prepareProvider});
  factory _RenameRegistrationOptions.fromJson(Map<String, dynamic> json) => _$RenameRegistrationOptionsFromJson(json);

/// A document selector to identify the scope of the registration. If set
/// to null the document selector provided on the client side will be used.
@override final  Sealed14 documentSelector;
/// Renames should be checked and tested before being executed.
/// @since version 3.12.0
@override final  bool? prepareProvider;

/// Create a copy of RenameRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RenameRegistrationOptionsCopyWith<_RenameRegistrationOptions> get copyWith => __$RenameRegistrationOptionsCopyWithImpl<_RenameRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$RenameRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _RenameRegistrationOptions&&(identical(other.documentSelector, documentSelector) || other.documentSelector == documentSelector)&&(identical(other.prepareProvider, prepareProvider) || other.prepareProvider == prepareProvider));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentSelector,prepareProvider);

@override
String toString() {
  return 'RenameRegistrationOptions(documentSelector: $documentSelector, prepareProvider: $prepareProvider)';
}


}

/// @nodoc
abstract mixin class _$RenameRegistrationOptionsCopyWith<$Res> implements $RenameRegistrationOptionsCopyWith<$Res> {
  factory _$RenameRegistrationOptionsCopyWith(_RenameRegistrationOptions value, $Res Function(_RenameRegistrationOptions) _then) = __$RenameRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 Sealed14 documentSelector, bool? prepareProvider
});




}
/// @nodoc
class __$RenameRegistrationOptionsCopyWithImpl<$Res>
    implements _$RenameRegistrationOptionsCopyWith<$Res> {
  __$RenameRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _RenameRegistrationOptions _self;
  final $Res Function(_RenameRegistrationOptions) _then;

/// Create a copy of RenameRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentSelector = null,Object? prepareProvider = freezed,}) {
  return _then(_RenameRegistrationOptions(
documentSelector: null == documentSelector ? _self.documentSelector : documentSelector // ignore: cast_nullable_to_non_nullable
as Sealed14,prepareProvider: freezed == prepareProvider ? _self.prepareProvider : prepareProvider // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$PrepareRenameParams {

/// The position inside the text document.
 Position get position;/// The text document.
 TextDocumentIdentifier get textDocument;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of PrepareRenameParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$PrepareRenameParamsCopyWith<PrepareRenameParams> get copyWith => _$PrepareRenameParamsCopyWithImpl<PrepareRenameParams>(this as PrepareRenameParams, _$identity);

  /// Serializes this PrepareRenameParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is PrepareRenameParams&&(identical(other.position, position) || other.position == position)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,position,textDocument,workDoneToken);

@override
String toString() {
  return 'PrepareRenameParams(position: $position, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $PrepareRenameParamsCopyWith<$Res>  {
  factory $PrepareRenameParamsCopyWith(PrepareRenameParams value, $Res Function(PrepareRenameParams) _then) = _$PrepareRenameParamsCopyWithImpl;
@useResult
$Res call({
 Position position, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


$PositionCopyWith<$Res> get position;$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$PrepareRenameParamsCopyWithImpl<$Res>
    implements $PrepareRenameParamsCopyWith<$Res> {
  _$PrepareRenameParamsCopyWithImpl(this._self, this._then);

  final PrepareRenameParams _self;
  final $Res Function(PrepareRenameParams) _then;

/// Create a copy of PrepareRenameParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? position = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of PrepareRenameParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of PrepareRenameParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _PrepareRenameParams implements PrepareRenameParams {
  const _PrepareRenameParams({required this.position, required this.textDocument, this.workDoneToken});
  factory _PrepareRenameParams.fromJson(Map<String, dynamic> json) => _$PrepareRenameParamsFromJson(json);

/// The position inside the text document.
@override final  Position position;
/// The text document.
@override final  TextDocumentIdentifier textDocument;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of PrepareRenameParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$PrepareRenameParamsCopyWith<_PrepareRenameParams> get copyWith => __$PrepareRenameParamsCopyWithImpl<_PrepareRenameParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$PrepareRenameParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _PrepareRenameParams&&(identical(other.position, position) || other.position == position)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,position,textDocument,workDoneToken);

@override
String toString() {
  return 'PrepareRenameParams(position: $position, textDocument: $textDocument, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$PrepareRenameParamsCopyWith<$Res> implements $PrepareRenameParamsCopyWith<$Res> {
  factory _$PrepareRenameParamsCopyWith(_PrepareRenameParams value, $Res Function(_PrepareRenameParams) _then) = __$PrepareRenameParamsCopyWithImpl;
@override @useResult
$Res call({
 Position position, TextDocumentIdentifier textDocument, ProgressToken? workDoneToken
});


@override $PositionCopyWith<$Res> get position;@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$PrepareRenameParamsCopyWithImpl<$Res>
    implements _$PrepareRenameParamsCopyWith<$Res> {
  __$PrepareRenameParamsCopyWithImpl(this._self, this._then);

  final _PrepareRenameParams _self;
  final $Res Function(_PrepareRenameParams) _then;

/// Create a copy of PrepareRenameParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? position = null,Object? textDocument = null,Object? workDoneToken = freezed,}) {
  return _then(_PrepareRenameParams(
position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of PrepareRenameParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of PrepareRenameParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$ExecuteCommandParams {

/// Arguments that the command should be invoked with.
 List<LSPAny>? get arguments;/// The identifier of the actual command handler.
 String get command;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of ExecuteCommandParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ExecuteCommandParamsCopyWith<ExecuteCommandParams> get copyWith => _$ExecuteCommandParamsCopyWithImpl<ExecuteCommandParams>(this as ExecuteCommandParams, _$identity);

  /// Serializes this ExecuteCommandParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ExecuteCommandParams&&const DeepCollectionEquality().equals(other.arguments, arguments)&&(identical(other.command, command) || other.command == command)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(arguments),command,workDoneToken);

@override
String toString() {
  return 'ExecuteCommandParams(arguments: $arguments, command: $command, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $ExecuteCommandParamsCopyWith<$Res>  {
  factory $ExecuteCommandParamsCopyWith(ExecuteCommandParams value, $Res Function(ExecuteCommandParams) _then) = _$ExecuteCommandParamsCopyWithImpl;
@useResult
$Res call({
 List<LSPAny>? arguments, String command, ProgressToken? workDoneToken
});




}
/// @nodoc
class _$ExecuteCommandParamsCopyWithImpl<$Res>
    implements $ExecuteCommandParamsCopyWith<$Res> {
  _$ExecuteCommandParamsCopyWithImpl(this._self, this._then);

  final ExecuteCommandParams _self;
  final $Res Function(ExecuteCommandParams) _then;

/// Create a copy of ExecuteCommandParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? arguments = freezed,Object? command = null,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
arguments: freezed == arguments ? _self.arguments : arguments // ignore: cast_nullable_to_non_nullable
as List<LSPAny>?,command: null == command ? _self.command : command // ignore: cast_nullable_to_non_nullable
as String,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _ExecuteCommandParams implements ExecuteCommandParams {
  const _ExecuteCommandParams({final  List<LSPAny>? arguments, required this.command, this.workDoneToken}): _arguments = arguments;
  factory _ExecuteCommandParams.fromJson(Map<String, dynamic> json) => _$ExecuteCommandParamsFromJson(json);

/// Arguments that the command should be invoked with.
 final  List<LSPAny>? _arguments;
/// Arguments that the command should be invoked with.
@override List<LSPAny>? get arguments {
  final value = _arguments;
  if (value == null) return null;
  if (_arguments is EqualUnmodifiableListView) return _arguments;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

/// The identifier of the actual command handler.
@override final  String command;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of ExecuteCommandParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ExecuteCommandParamsCopyWith<_ExecuteCommandParams> get copyWith => __$ExecuteCommandParamsCopyWithImpl<_ExecuteCommandParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ExecuteCommandParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ExecuteCommandParams&&const DeepCollectionEquality().equals(other._arguments, _arguments)&&(identical(other.command, command) || other.command == command)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_arguments),command,workDoneToken);

@override
String toString() {
  return 'ExecuteCommandParams(arguments: $arguments, command: $command, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$ExecuteCommandParamsCopyWith<$Res> implements $ExecuteCommandParamsCopyWith<$Res> {
  factory _$ExecuteCommandParamsCopyWith(_ExecuteCommandParams value, $Res Function(_ExecuteCommandParams) _then) = __$ExecuteCommandParamsCopyWithImpl;
@override @useResult
$Res call({
 List<LSPAny>? arguments, String command, ProgressToken? workDoneToken
});




}
/// @nodoc
class __$ExecuteCommandParamsCopyWithImpl<$Res>
    implements _$ExecuteCommandParamsCopyWith<$Res> {
  __$ExecuteCommandParamsCopyWithImpl(this._self, this._then);

  final _ExecuteCommandParams _self;
  final $Res Function(_ExecuteCommandParams) _then;

/// Create a copy of ExecuteCommandParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? arguments = freezed,Object? command = null,Object? workDoneToken = freezed,}) {
  return _then(_ExecuteCommandParams(
arguments: freezed == arguments ? _self._arguments : arguments // ignore: cast_nullable_to_non_nullable
as List<LSPAny>?,command: null == command ? _self.command : command // ignore: cast_nullable_to_non_nullable
as String,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}


}


/// @nodoc
mixin _$ExecuteCommandRegistrationOptions {

/// The commands to be executed on the server
 List<String> get commands;
/// Create a copy of ExecuteCommandRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ExecuteCommandRegistrationOptionsCopyWith<ExecuteCommandRegistrationOptions> get copyWith => _$ExecuteCommandRegistrationOptionsCopyWithImpl<ExecuteCommandRegistrationOptions>(this as ExecuteCommandRegistrationOptions, _$identity);

  /// Serializes this ExecuteCommandRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ExecuteCommandRegistrationOptions&&const DeepCollectionEquality().equals(other.commands, commands));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(commands));

@override
String toString() {
  return 'ExecuteCommandRegistrationOptions(commands: $commands)';
}


}

/// @nodoc
abstract mixin class $ExecuteCommandRegistrationOptionsCopyWith<$Res>  {
  factory $ExecuteCommandRegistrationOptionsCopyWith(ExecuteCommandRegistrationOptions value, $Res Function(ExecuteCommandRegistrationOptions) _then) = _$ExecuteCommandRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 List<String> commands
});




}
/// @nodoc
class _$ExecuteCommandRegistrationOptionsCopyWithImpl<$Res>
    implements $ExecuteCommandRegistrationOptionsCopyWith<$Res> {
  _$ExecuteCommandRegistrationOptionsCopyWithImpl(this._self, this._then);

  final ExecuteCommandRegistrationOptions _self;
  final $Res Function(ExecuteCommandRegistrationOptions) _then;

/// Create a copy of ExecuteCommandRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? commands = null,}) {
  return _then(_self.copyWith(
commands: null == commands ? _self.commands : commands // ignore: cast_nullable_to_non_nullable
as List<String>,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _ExecuteCommandRegistrationOptions implements ExecuteCommandRegistrationOptions {
  const _ExecuteCommandRegistrationOptions({required final  List<String> commands}): _commands = commands;
  factory _ExecuteCommandRegistrationOptions.fromJson(Map<String, dynamic> json) => _$ExecuteCommandRegistrationOptionsFromJson(json);

/// The commands to be executed on the server
 final  List<String> _commands;
/// The commands to be executed on the server
@override List<String> get commands {
  if (_commands is EqualUnmodifiableListView) return _commands;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_commands);
}


/// Create a copy of ExecuteCommandRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ExecuteCommandRegistrationOptionsCopyWith<_ExecuteCommandRegistrationOptions> get copyWith => __$ExecuteCommandRegistrationOptionsCopyWithImpl<_ExecuteCommandRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ExecuteCommandRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ExecuteCommandRegistrationOptions&&const DeepCollectionEquality().equals(other._commands, _commands));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_commands));

@override
String toString() {
  return 'ExecuteCommandRegistrationOptions(commands: $commands)';
}


}

/// @nodoc
abstract mixin class _$ExecuteCommandRegistrationOptionsCopyWith<$Res> implements $ExecuteCommandRegistrationOptionsCopyWith<$Res> {
  factory _$ExecuteCommandRegistrationOptionsCopyWith(_ExecuteCommandRegistrationOptions value, $Res Function(_ExecuteCommandRegistrationOptions) _then) = __$ExecuteCommandRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 List<String> commands
});




}
/// @nodoc
class __$ExecuteCommandRegistrationOptionsCopyWithImpl<$Res>
    implements _$ExecuteCommandRegistrationOptionsCopyWith<$Res> {
  __$ExecuteCommandRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _ExecuteCommandRegistrationOptions _self;
  final $Res Function(_ExecuteCommandRegistrationOptions) _then;

/// Create a copy of ExecuteCommandRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? commands = null,}) {
  return _then(_ExecuteCommandRegistrationOptions(
commands: null == commands ? _self._commands : commands // ignore: cast_nullable_to_non_nullable
as List<String>,
  ));
}


}


/// @nodoc
mixin _$ApplyWorkspaceEditParams {

/// The edits to apply.
 WorkspaceEdit get edit;/// An optional label of the workspace edit. This label is presented in the
/// user interface for example on an undo stack to undo the workspace edit.
 String? get label;
/// Create a copy of ApplyWorkspaceEditParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ApplyWorkspaceEditParamsCopyWith<ApplyWorkspaceEditParams> get copyWith => _$ApplyWorkspaceEditParamsCopyWithImpl<ApplyWorkspaceEditParams>(this as ApplyWorkspaceEditParams, _$identity);

  /// Serializes this ApplyWorkspaceEditParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ApplyWorkspaceEditParams&&(identical(other.edit, edit) || other.edit == edit)&&(identical(other.label, label) || other.label == label));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,edit,label);

@override
String toString() {
  return 'ApplyWorkspaceEditParams(edit: $edit, label: $label)';
}


}

/// @nodoc
abstract mixin class $ApplyWorkspaceEditParamsCopyWith<$Res>  {
  factory $ApplyWorkspaceEditParamsCopyWith(ApplyWorkspaceEditParams value, $Res Function(ApplyWorkspaceEditParams) _then) = _$ApplyWorkspaceEditParamsCopyWithImpl;
@useResult
$Res call({
 WorkspaceEdit edit, String? label
});


$WorkspaceEditCopyWith<$Res> get edit;

}
/// @nodoc
class _$ApplyWorkspaceEditParamsCopyWithImpl<$Res>
    implements $ApplyWorkspaceEditParamsCopyWith<$Res> {
  _$ApplyWorkspaceEditParamsCopyWithImpl(this._self, this._then);

  final ApplyWorkspaceEditParams _self;
  final $Res Function(ApplyWorkspaceEditParams) _then;

/// Create a copy of ApplyWorkspaceEditParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? edit = null,Object? label = freezed,}) {
  return _then(_self.copyWith(
edit: null == edit ? _self.edit : edit // ignore: cast_nullable_to_non_nullable
as WorkspaceEdit,label: freezed == label ? _self.label : label // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}
/// Create a copy of ApplyWorkspaceEditParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$WorkspaceEditCopyWith<$Res> get edit {
  
  return $WorkspaceEditCopyWith<$Res>(_self.edit, (value) {
    return _then(_self.copyWith(edit: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _ApplyWorkspaceEditParams implements ApplyWorkspaceEditParams {
  const _ApplyWorkspaceEditParams({required this.edit, this.label});
  factory _ApplyWorkspaceEditParams.fromJson(Map<String, dynamic> json) => _$ApplyWorkspaceEditParamsFromJson(json);

/// The edits to apply.
@override final  WorkspaceEdit edit;
/// An optional label of the workspace edit. This label is presented in the
/// user interface for example on an undo stack to undo the workspace edit.
@override final  String? label;

/// Create a copy of ApplyWorkspaceEditParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ApplyWorkspaceEditParamsCopyWith<_ApplyWorkspaceEditParams> get copyWith => __$ApplyWorkspaceEditParamsCopyWithImpl<_ApplyWorkspaceEditParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ApplyWorkspaceEditParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ApplyWorkspaceEditParams&&(identical(other.edit, edit) || other.edit == edit)&&(identical(other.label, label) || other.label == label));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,edit,label);

@override
String toString() {
  return 'ApplyWorkspaceEditParams(edit: $edit, label: $label)';
}


}

/// @nodoc
abstract mixin class _$ApplyWorkspaceEditParamsCopyWith<$Res> implements $ApplyWorkspaceEditParamsCopyWith<$Res> {
  factory _$ApplyWorkspaceEditParamsCopyWith(_ApplyWorkspaceEditParams value, $Res Function(_ApplyWorkspaceEditParams) _then) = __$ApplyWorkspaceEditParamsCopyWithImpl;
@override @useResult
$Res call({
 WorkspaceEdit edit, String? label
});


@override $WorkspaceEditCopyWith<$Res> get edit;

}
/// @nodoc
class __$ApplyWorkspaceEditParamsCopyWithImpl<$Res>
    implements _$ApplyWorkspaceEditParamsCopyWith<$Res> {
  __$ApplyWorkspaceEditParamsCopyWithImpl(this._self, this._then);

  final _ApplyWorkspaceEditParams _self;
  final $Res Function(_ApplyWorkspaceEditParams) _then;

/// Create a copy of ApplyWorkspaceEditParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? edit = null,Object? label = freezed,}) {
  return _then(_ApplyWorkspaceEditParams(
edit: null == edit ? _self.edit : edit // ignore: cast_nullable_to_non_nullable
as WorkspaceEdit,label: freezed == label ? _self.label : label // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

/// Create a copy of ApplyWorkspaceEditParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$WorkspaceEditCopyWith<$Res> get edit {
  
  return $WorkspaceEditCopyWith<$Res>(_self.edit, (value) {
    return _then(_self.copyWith(edit: value));
  });
}
}


/// @nodoc
mixin _$ApplyWorkspaceEditResult {

/// Indicates whether the edit was applied or not.
 bool get applied;/// Depending on the client's failure handling strategy `failedChange`
/// might contain the index of the change that failed. This property is
/// only available if the client signals a `failureHandlingStrategy` in its
/// client capabilities.
 int? get failedChange;/// An optional textual description for why the edit was not applied. This
/// may be used by the server for diagnostic logging or to provide a
/// suitable error for a request that triggered the edit.
 String? get failureReason;
/// Create a copy of ApplyWorkspaceEditResult
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ApplyWorkspaceEditResultCopyWith<ApplyWorkspaceEditResult> get copyWith => _$ApplyWorkspaceEditResultCopyWithImpl<ApplyWorkspaceEditResult>(this as ApplyWorkspaceEditResult, _$identity);

  /// Serializes this ApplyWorkspaceEditResult to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ApplyWorkspaceEditResult&&(identical(other.applied, applied) || other.applied == applied)&&(identical(other.failedChange, failedChange) || other.failedChange == failedChange)&&(identical(other.failureReason, failureReason) || other.failureReason == failureReason));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,applied,failedChange,failureReason);

@override
String toString() {
  return 'ApplyWorkspaceEditResult(applied: $applied, failedChange: $failedChange, failureReason: $failureReason)';
}


}

/// @nodoc
abstract mixin class $ApplyWorkspaceEditResultCopyWith<$Res>  {
  factory $ApplyWorkspaceEditResultCopyWith(ApplyWorkspaceEditResult value, $Res Function(ApplyWorkspaceEditResult) _then) = _$ApplyWorkspaceEditResultCopyWithImpl;
@useResult
$Res call({
 bool applied, int? failedChange, String? failureReason
});




}
/// @nodoc
class _$ApplyWorkspaceEditResultCopyWithImpl<$Res>
    implements $ApplyWorkspaceEditResultCopyWith<$Res> {
  _$ApplyWorkspaceEditResultCopyWithImpl(this._self, this._then);

  final ApplyWorkspaceEditResult _self;
  final $Res Function(ApplyWorkspaceEditResult) _then;

/// Create a copy of ApplyWorkspaceEditResult
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? applied = null,Object? failedChange = freezed,Object? failureReason = freezed,}) {
  return _then(_self.copyWith(
applied: null == applied ? _self.applied : applied // ignore: cast_nullable_to_non_nullable
as bool,failedChange: freezed == failedChange ? _self.failedChange : failedChange // ignore: cast_nullable_to_non_nullable
as int?,failureReason: freezed == failureReason ? _self.failureReason : failureReason // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _ApplyWorkspaceEditResult implements ApplyWorkspaceEditResult {
  const _ApplyWorkspaceEditResult({required this.applied, this.failedChange, this.failureReason});
  factory _ApplyWorkspaceEditResult.fromJson(Map<String, dynamic> json) => _$ApplyWorkspaceEditResultFromJson(json);

/// Indicates whether the edit was applied or not.
@override final  bool applied;
/// Depending on the client's failure handling strategy `failedChange`
/// might contain the index of the change that failed. This property is
/// only available if the client signals a `failureHandlingStrategy` in its
/// client capabilities.
@override final  int? failedChange;
/// An optional textual description for why the edit was not applied. This
/// may be used by the server for diagnostic logging or to provide a
/// suitable error for a request that triggered the edit.
@override final  String? failureReason;

/// Create a copy of ApplyWorkspaceEditResult
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ApplyWorkspaceEditResultCopyWith<_ApplyWorkspaceEditResult> get copyWith => __$ApplyWorkspaceEditResultCopyWithImpl<_ApplyWorkspaceEditResult>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ApplyWorkspaceEditResultToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ApplyWorkspaceEditResult&&(identical(other.applied, applied) || other.applied == applied)&&(identical(other.failedChange, failedChange) || other.failedChange == failedChange)&&(identical(other.failureReason, failureReason) || other.failureReason == failureReason));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,applied,failedChange,failureReason);

@override
String toString() {
  return 'ApplyWorkspaceEditResult(applied: $applied, failedChange: $failedChange, failureReason: $failureReason)';
}


}

/// @nodoc
abstract mixin class _$ApplyWorkspaceEditResultCopyWith<$Res> implements $ApplyWorkspaceEditResultCopyWith<$Res> {
  factory _$ApplyWorkspaceEditResultCopyWith(_ApplyWorkspaceEditResult value, $Res Function(_ApplyWorkspaceEditResult) _then) = __$ApplyWorkspaceEditResultCopyWithImpl;
@override @useResult
$Res call({
 bool applied, int? failedChange, String? failureReason
});




}
/// @nodoc
class __$ApplyWorkspaceEditResultCopyWithImpl<$Res>
    implements _$ApplyWorkspaceEditResultCopyWith<$Res> {
  __$ApplyWorkspaceEditResultCopyWithImpl(this._self, this._then);

  final _ApplyWorkspaceEditResult _self;
  final $Res Function(_ApplyWorkspaceEditResult) _then;

/// Create a copy of ApplyWorkspaceEditResult
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? applied = null,Object? failedChange = freezed,Object? failureReason = freezed,}) {
  return _then(_ApplyWorkspaceEditResult(
applied: null == applied ? _self.applied : applied // ignore: cast_nullable_to_non_nullable
as bool,failedChange: freezed == failedChange ? _self.failedChange : failedChange // ignore: cast_nullable_to_non_nullable
as int?,failureReason: freezed == failureReason ? _self.failureReason : failureReason // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$WorkDoneProgressBegin {

/// Controls if a cancel button should show to allow the user to cancel the
/// long running operation. Clients that don't support cancellation are
/// allowed to ignore the setting.
 bool? get cancellable; StringLiteralRef get kind;/// Optional, more detailed associated progress message. Contains
/// complementary information to the `title`.
/// Examples: "3/25 files", "project/src/module2", "node_modules/some_dep".
/// If unset, the previous progress message (if any) is still valid.
 String? get message;/// Optional progress percentage to display (value 100 is considered 100%).
/// If not provided infinite progress is assumed and clients are allowed to
/// ignore the `percentage` value in subsequent report notifications.
/// The value should be steadily rising. Clients are free to ignore values
/// that are not following this rule. The value range is [0, 100].
 int? get percentage;/// Mandatory title of the progress operation. Used to briefly inform about
/// the kind of operation being performed.
/// Examples: "Indexing" or "Linking dependencies".
 String get title;
/// Create a copy of WorkDoneProgressBegin
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkDoneProgressBeginCopyWith<WorkDoneProgressBegin> get copyWith => _$WorkDoneProgressBeginCopyWithImpl<WorkDoneProgressBegin>(this as WorkDoneProgressBegin, _$identity);

  /// Serializes this WorkDoneProgressBegin to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkDoneProgressBegin&&(identical(other.cancellable, cancellable) || other.cancellable == cancellable)&&const DeepCollectionEquality().equals(other.kind, kind)&&(identical(other.message, message) || other.message == message)&&(identical(other.percentage, percentage) || other.percentage == percentage)&&(identical(other.title, title) || other.title == title));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,cancellable,const DeepCollectionEquality().hash(kind),message,percentage,title);

@override
String toString() {
  return 'WorkDoneProgressBegin(cancellable: $cancellable, kind: $kind, message: $message, percentage: $percentage, title: $title)';
}


}

/// @nodoc
abstract mixin class $WorkDoneProgressBeginCopyWith<$Res>  {
  factory $WorkDoneProgressBeginCopyWith(WorkDoneProgressBegin value, $Res Function(WorkDoneProgressBegin) _then) = _$WorkDoneProgressBeginCopyWithImpl;
@useResult
$Res call({
 bool? cancellable, StringLiteralRef kind, String? message, int? percentage, String title
});




}
/// @nodoc
class _$WorkDoneProgressBeginCopyWithImpl<$Res>
    implements $WorkDoneProgressBeginCopyWith<$Res> {
  _$WorkDoneProgressBeginCopyWithImpl(this._self, this._then);

  final WorkDoneProgressBegin _self;
  final $Res Function(WorkDoneProgressBegin) _then;

/// Create a copy of WorkDoneProgressBegin
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? cancellable = freezed,Object? kind = freezed,Object? message = freezed,Object? percentage = freezed,Object? title = null,}) {
  return _then(_self.copyWith(
cancellable: freezed == cancellable ? _self.cancellable : cancellable // ignore: cast_nullable_to_non_nullable
as bool?,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as StringLiteralRef,message: freezed == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String?,percentage: freezed == percentage ? _self.percentage : percentage // ignore: cast_nullable_to_non_nullable
as int?,title: null == title ? _self.title : title // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _WorkDoneProgressBegin implements WorkDoneProgressBegin {
  const _WorkDoneProgressBegin({this.cancellable, required this.kind, this.message, this.percentage, required this.title});
  factory _WorkDoneProgressBegin.fromJson(Map<String, dynamic> json) => _$WorkDoneProgressBeginFromJson(json);

/// Controls if a cancel button should show to allow the user to cancel the
/// long running operation. Clients that don't support cancellation are
/// allowed to ignore the setting.
@override final  bool? cancellable;
@override final  StringLiteralRef kind;
/// Optional, more detailed associated progress message. Contains
/// complementary information to the `title`.
/// Examples: "3/25 files", "project/src/module2", "node_modules/some_dep".
/// If unset, the previous progress message (if any) is still valid.
@override final  String? message;
/// Optional progress percentage to display (value 100 is considered 100%).
/// If not provided infinite progress is assumed and clients are allowed to
/// ignore the `percentage` value in subsequent report notifications.
/// The value should be steadily rising. Clients are free to ignore values
/// that are not following this rule. The value range is [0, 100].
@override final  int? percentage;
/// Mandatory title of the progress operation. Used to briefly inform about
/// the kind of operation being performed.
/// Examples: "Indexing" or "Linking dependencies".
@override final  String title;

/// Create a copy of WorkDoneProgressBegin
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkDoneProgressBeginCopyWith<_WorkDoneProgressBegin> get copyWith => __$WorkDoneProgressBeginCopyWithImpl<_WorkDoneProgressBegin>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkDoneProgressBeginToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkDoneProgressBegin&&(identical(other.cancellable, cancellable) || other.cancellable == cancellable)&&const DeepCollectionEquality().equals(other.kind, kind)&&(identical(other.message, message) || other.message == message)&&(identical(other.percentage, percentage) || other.percentage == percentage)&&(identical(other.title, title) || other.title == title));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,cancellable,const DeepCollectionEquality().hash(kind),message,percentage,title);

@override
String toString() {
  return 'WorkDoneProgressBegin(cancellable: $cancellable, kind: $kind, message: $message, percentage: $percentage, title: $title)';
}


}

/// @nodoc
abstract mixin class _$WorkDoneProgressBeginCopyWith<$Res> implements $WorkDoneProgressBeginCopyWith<$Res> {
  factory _$WorkDoneProgressBeginCopyWith(_WorkDoneProgressBegin value, $Res Function(_WorkDoneProgressBegin) _then) = __$WorkDoneProgressBeginCopyWithImpl;
@override @useResult
$Res call({
 bool? cancellable, StringLiteralRef kind, String? message, int? percentage, String title
});




}
/// @nodoc
class __$WorkDoneProgressBeginCopyWithImpl<$Res>
    implements _$WorkDoneProgressBeginCopyWith<$Res> {
  __$WorkDoneProgressBeginCopyWithImpl(this._self, this._then);

  final _WorkDoneProgressBegin _self;
  final $Res Function(_WorkDoneProgressBegin) _then;

/// Create a copy of WorkDoneProgressBegin
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? cancellable = freezed,Object? kind = freezed,Object? message = freezed,Object? percentage = freezed,Object? title = null,}) {
  return _then(_WorkDoneProgressBegin(
cancellable: freezed == cancellable ? _self.cancellable : cancellable // ignore: cast_nullable_to_non_nullable
as bool?,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as StringLiteralRef,message: freezed == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String?,percentage: freezed == percentage ? _self.percentage : percentage // ignore: cast_nullable_to_non_nullable
as int?,title: null == title ? _self.title : title // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}


/// @nodoc
mixin _$WorkDoneProgressReport {

/// Controls enablement state of a cancel button.
/// Clients that don't support cancellation or don't support controlling
/// the button's enablement state are allowed to ignore the property.
 bool? get cancellable; StringLiteralRef get kind;/// Optional, more detailed associated progress message. Contains
/// complementary information to the `title`.
/// Examples: "3/25 files", "project/src/module2", "node_modules/some_dep".
/// If unset, the previous progress message (if any) is still valid.
 String? get message;/// Optional progress percentage to display (value 100 is considered 100%).
/// If not provided infinite progress is assumed and clients are allowed to
/// ignore the `percentage` value in subsequent report notifications.
/// The value should be steadily rising. Clients are free to ignore values
/// that are not following this rule. The value range is [0, 100].
 int? get percentage;
/// Create a copy of WorkDoneProgressReport
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkDoneProgressReportCopyWith<WorkDoneProgressReport> get copyWith => _$WorkDoneProgressReportCopyWithImpl<WorkDoneProgressReport>(this as WorkDoneProgressReport, _$identity);

  /// Serializes this WorkDoneProgressReport to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkDoneProgressReport&&(identical(other.cancellable, cancellable) || other.cancellable == cancellable)&&const DeepCollectionEquality().equals(other.kind, kind)&&(identical(other.message, message) || other.message == message)&&(identical(other.percentage, percentage) || other.percentage == percentage));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,cancellable,const DeepCollectionEquality().hash(kind),message,percentage);

@override
String toString() {
  return 'WorkDoneProgressReport(cancellable: $cancellable, kind: $kind, message: $message, percentage: $percentage)';
}


}

/// @nodoc
abstract mixin class $WorkDoneProgressReportCopyWith<$Res>  {
  factory $WorkDoneProgressReportCopyWith(WorkDoneProgressReport value, $Res Function(WorkDoneProgressReport) _then) = _$WorkDoneProgressReportCopyWithImpl;
@useResult
$Res call({
 bool? cancellable, StringLiteralRef kind, String? message, int? percentage
});




}
/// @nodoc
class _$WorkDoneProgressReportCopyWithImpl<$Res>
    implements $WorkDoneProgressReportCopyWith<$Res> {
  _$WorkDoneProgressReportCopyWithImpl(this._self, this._then);

  final WorkDoneProgressReport _self;
  final $Res Function(WorkDoneProgressReport) _then;

/// Create a copy of WorkDoneProgressReport
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? cancellable = freezed,Object? kind = freezed,Object? message = freezed,Object? percentage = freezed,}) {
  return _then(_self.copyWith(
cancellable: freezed == cancellable ? _self.cancellable : cancellable // ignore: cast_nullable_to_non_nullable
as bool?,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as StringLiteralRef,message: freezed == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String?,percentage: freezed == percentage ? _self.percentage : percentage // ignore: cast_nullable_to_non_nullable
as int?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _WorkDoneProgressReport implements WorkDoneProgressReport {
  const _WorkDoneProgressReport({this.cancellable, required this.kind, this.message, this.percentage});
  factory _WorkDoneProgressReport.fromJson(Map<String, dynamic> json) => _$WorkDoneProgressReportFromJson(json);

/// Controls enablement state of a cancel button.
/// Clients that don't support cancellation or don't support controlling
/// the button's enablement state are allowed to ignore the property.
@override final  bool? cancellable;
@override final  StringLiteralRef kind;
/// Optional, more detailed associated progress message. Contains
/// complementary information to the `title`.
/// Examples: "3/25 files", "project/src/module2", "node_modules/some_dep".
/// If unset, the previous progress message (if any) is still valid.
@override final  String? message;
/// Optional progress percentage to display (value 100 is considered 100%).
/// If not provided infinite progress is assumed and clients are allowed to
/// ignore the `percentage` value in subsequent report notifications.
/// The value should be steadily rising. Clients are free to ignore values
/// that are not following this rule. The value range is [0, 100].
@override final  int? percentage;

/// Create a copy of WorkDoneProgressReport
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkDoneProgressReportCopyWith<_WorkDoneProgressReport> get copyWith => __$WorkDoneProgressReportCopyWithImpl<_WorkDoneProgressReport>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkDoneProgressReportToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkDoneProgressReport&&(identical(other.cancellable, cancellable) || other.cancellable == cancellable)&&const DeepCollectionEquality().equals(other.kind, kind)&&(identical(other.message, message) || other.message == message)&&(identical(other.percentage, percentage) || other.percentage == percentage));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,cancellable,const DeepCollectionEquality().hash(kind),message,percentage);

@override
String toString() {
  return 'WorkDoneProgressReport(cancellable: $cancellable, kind: $kind, message: $message, percentage: $percentage)';
}


}

/// @nodoc
abstract mixin class _$WorkDoneProgressReportCopyWith<$Res> implements $WorkDoneProgressReportCopyWith<$Res> {
  factory _$WorkDoneProgressReportCopyWith(_WorkDoneProgressReport value, $Res Function(_WorkDoneProgressReport) _then) = __$WorkDoneProgressReportCopyWithImpl;
@override @useResult
$Res call({
 bool? cancellable, StringLiteralRef kind, String? message, int? percentage
});




}
/// @nodoc
class __$WorkDoneProgressReportCopyWithImpl<$Res>
    implements _$WorkDoneProgressReportCopyWith<$Res> {
  __$WorkDoneProgressReportCopyWithImpl(this._self, this._then);

  final _WorkDoneProgressReport _self;
  final $Res Function(_WorkDoneProgressReport) _then;

/// Create a copy of WorkDoneProgressReport
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? cancellable = freezed,Object? kind = freezed,Object? message = freezed,Object? percentage = freezed,}) {
  return _then(_WorkDoneProgressReport(
cancellable: freezed == cancellable ? _self.cancellable : cancellable // ignore: cast_nullable_to_non_nullable
as bool?,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as StringLiteralRef,message: freezed == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String?,percentage: freezed == percentage ? _self.percentage : percentage // ignore: cast_nullable_to_non_nullable
as int?,
  ));
}


}


/// @nodoc
mixin _$WorkDoneProgressEnd {

 StringLiteralRef get kind;/// Optional, a final message indicating to for example indicate the
/// outcome of the operation.
 String? get message;
/// Create a copy of WorkDoneProgressEnd
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkDoneProgressEndCopyWith<WorkDoneProgressEnd> get copyWith => _$WorkDoneProgressEndCopyWithImpl<WorkDoneProgressEnd>(this as WorkDoneProgressEnd, _$identity);

  /// Serializes this WorkDoneProgressEnd to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkDoneProgressEnd&&const DeepCollectionEquality().equals(other.kind, kind)&&(identical(other.message, message) || other.message == message));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(kind),message);

@override
String toString() {
  return 'WorkDoneProgressEnd(kind: $kind, message: $message)';
}


}

/// @nodoc
abstract mixin class $WorkDoneProgressEndCopyWith<$Res>  {
  factory $WorkDoneProgressEndCopyWith(WorkDoneProgressEnd value, $Res Function(WorkDoneProgressEnd) _then) = _$WorkDoneProgressEndCopyWithImpl;
@useResult
$Res call({
 StringLiteralRef kind, String? message
});




}
/// @nodoc
class _$WorkDoneProgressEndCopyWithImpl<$Res>
    implements $WorkDoneProgressEndCopyWith<$Res> {
  _$WorkDoneProgressEndCopyWithImpl(this._self, this._then);

  final WorkDoneProgressEnd _self;
  final $Res Function(WorkDoneProgressEnd) _then;

/// Create a copy of WorkDoneProgressEnd
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? kind = freezed,Object? message = freezed,}) {
  return _then(_self.copyWith(
kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as StringLiteralRef,message: freezed == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _WorkDoneProgressEnd implements WorkDoneProgressEnd {
  const _WorkDoneProgressEnd({required this.kind, this.message});
  factory _WorkDoneProgressEnd.fromJson(Map<String, dynamic> json) => _$WorkDoneProgressEndFromJson(json);

@override final  StringLiteralRef kind;
/// Optional, a final message indicating to for example indicate the
/// outcome of the operation.
@override final  String? message;

/// Create a copy of WorkDoneProgressEnd
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkDoneProgressEndCopyWith<_WorkDoneProgressEnd> get copyWith => __$WorkDoneProgressEndCopyWithImpl<_WorkDoneProgressEnd>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkDoneProgressEndToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkDoneProgressEnd&&const DeepCollectionEquality().equals(other.kind, kind)&&(identical(other.message, message) || other.message == message));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(kind),message);

@override
String toString() {
  return 'WorkDoneProgressEnd(kind: $kind, message: $message)';
}


}

/// @nodoc
abstract mixin class _$WorkDoneProgressEndCopyWith<$Res> implements $WorkDoneProgressEndCopyWith<$Res> {
  factory _$WorkDoneProgressEndCopyWith(_WorkDoneProgressEnd value, $Res Function(_WorkDoneProgressEnd) _then) = __$WorkDoneProgressEndCopyWithImpl;
@override @useResult
$Res call({
 StringLiteralRef kind, String? message
});




}
/// @nodoc
class __$WorkDoneProgressEndCopyWithImpl<$Res>
    implements _$WorkDoneProgressEndCopyWith<$Res> {
  __$WorkDoneProgressEndCopyWithImpl(this._self, this._then);

  final _WorkDoneProgressEnd _self;
  final $Res Function(_WorkDoneProgressEnd) _then;

/// Create a copy of WorkDoneProgressEnd
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? kind = freezed,Object? message = freezed,}) {
  return _then(_WorkDoneProgressEnd(
kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as StringLiteralRef,message: freezed == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$SetTraceParams {

 TraceValues get value;
/// Create a copy of SetTraceParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SetTraceParamsCopyWith<SetTraceParams> get copyWith => _$SetTraceParamsCopyWithImpl<SetTraceParams>(this as SetTraceParams, _$identity);

  /// Serializes this SetTraceParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SetTraceParams&&(identical(other.value, value) || other.value == value));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,value);

@override
String toString() {
  return 'SetTraceParams(value: $value)';
}


}

/// @nodoc
abstract mixin class $SetTraceParamsCopyWith<$Res>  {
  factory $SetTraceParamsCopyWith(SetTraceParams value, $Res Function(SetTraceParams) _then) = _$SetTraceParamsCopyWithImpl;
@useResult
$Res call({
 TraceValues value
});




}
/// @nodoc
class _$SetTraceParamsCopyWithImpl<$Res>
    implements $SetTraceParamsCopyWith<$Res> {
  _$SetTraceParamsCopyWithImpl(this._self, this._then);

  final SetTraceParams _self;
  final $Res Function(SetTraceParams) _then;

/// Create a copy of SetTraceParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? value = null,}) {
  return _then(_self.copyWith(
value: null == value ? _self.value : value // ignore: cast_nullable_to_non_nullable
as TraceValues,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _SetTraceParams implements SetTraceParams {
  const _SetTraceParams({required this.value});
  factory _SetTraceParams.fromJson(Map<String, dynamic> json) => _$SetTraceParamsFromJson(json);

@override final  TraceValues value;

/// Create a copy of SetTraceParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SetTraceParamsCopyWith<_SetTraceParams> get copyWith => __$SetTraceParamsCopyWithImpl<_SetTraceParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SetTraceParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SetTraceParams&&(identical(other.value, value) || other.value == value));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,value);

@override
String toString() {
  return 'SetTraceParams(value: $value)';
}


}

/// @nodoc
abstract mixin class _$SetTraceParamsCopyWith<$Res> implements $SetTraceParamsCopyWith<$Res> {
  factory _$SetTraceParamsCopyWith(_SetTraceParams value, $Res Function(_SetTraceParams) _then) = __$SetTraceParamsCopyWithImpl;
@override @useResult
$Res call({
 TraceValues value
});




}
/// @nodoc
class __$SetTraceParamsCopyWithImpl<$Res>
    implements _$SetTraceParamsCopyWith<$Res> {
  __$SetTraceParamsCopyWithImpl(this._self, this._then);

  final _SetTraceParams _self;
  final $Res Function(_SetTraceParams) _then;

/// Create a copy of SetTraceParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? value = null,}) {
  return _then(_SetTraceParams(
value: null == value ? _self.value : value // ignore: cast_nullable_to_non_nullable
as TraceValues,
  ));
}


}


/// @nodoc
mixin _$LogTraceParams {

 String get message; String? get verbose;
/// Create a copy of LogTraceParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LogTraceParamsCopyWith<LogTraceParams> get copyWith => _$LogTraceParamsCopyWithImpl<LogTraceParams>(this as LogTraceParams, _$identity);

  /// Serializes this LogTraceParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LogTraceParams&&(identical(other.message, message) || other.message == message)&&(identical(other.verbose, verbose) || other.verbose == verbose));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,message,verbose);

@override
String toString() {
  return 'LogTraceParams(message: $message, verbose: $verbose)';
}


}

/// @nodoc
abstract mixin class $LogTraceParamsCopyWith<$Res>  {
  factory $LogTraceParamsCopyWith(LogTraceParams value, $Res Function(LogTraceParams) _then) = _$LogTraceParamsCopyWithImpl;
@useResult
$Res call({
 String message, String? verbose
});




}
/// @nodoc
class _$LogTraceParamsCopyWithImpl<$Res>
    implements $LogTraceParamsCopyWith<$Res> {
  _$LogTraceParamsCopyWithImpl(this._self, this._then);

  final LogTraceParams _self;
  final $Res Function(LogTraceParams) _then;

/// Create a copy of LogTraceParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? message = null,Object? verbose = freezed,}) {
  return _then(_self.copyWith(
message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,verbose: freezed == verbose ? _self.verbose : verbose // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _LogTraceParams implements LogTraceParams {
  const _LogTraceParams({required this.message, this.verbose});
  factory _LogTraceParams.fromJson(Map<String, dynamic> json) => _$LogTraceParamsFromJson(json);

@override final  String message;
@override final  String? verbose;

/// Create a copy of LogTraceParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$LogTraceParamsCopyWith<_LogTraceParams> get copyWith => __$LogTraceParamsCopyWithImpl<_LogTraceParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$LogTraceParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _LogTraceParams&&(identical(other.message, message) || other.message == message)&&(identical(other.verbose, verbose) || other.verbose == verbose));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,message,verbose);

@override
String toString() {
  return 'LogTraceParams(message: $message, verbose: $verbose)';
}


}

/// @nodoc
abstract mixin class _$LogTraceParamsCopyWith<$Res> implements $LogTraceParamsCopyWith<$Res> {
  factory _$LogTraceParamsCopyWith(_LogTraceParams value, $Res Function(_LogTraceParams) _then) = __$LogTraceParamsCopyWithImpl;
@override @useResult
$Res call({
 String message, String? verbose
});




}
/// @nodoc
class __$LogTraceParamsCopyWithImpl<$Res>
    implements _$LogTraceParamsCopyWith<$Res> {
  __$LogTraceParamsCopyWithImpl(this._self, this._then);

  final _LogTraceParams _self;
  final $Res Function(_LogTraceParams) _then;

/// Create a copy of LogTraceParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? message = null,Object? verbose = freezed,}) {
  return _then(_LogTraceParams(
message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,verbose: freezed == verbose ? _self.verbose : verbose // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$CancelParams {

/// The request id to cancel.
 Sealed6 get id;
/// Create a copy of CancelParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CancelParamsCopyWith<CancelParams> get copyWith => _$CancelParamsCopyWithImpl<CancelParams>(this as CancelParams, _$identity);

  /// Serializes this CancelParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CancelParams&&(identical(other.id, id) || other.id == id));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id);

@override
String toString() {
  return 'CancelParams(id: $id)';
}


}

/// @nodoc
abstract mixin class $CancelParamsCopyWith<$Res>  {
  factory $CancelParamsCopyWith(CancelParams value, $Res Function(CancelParams) _then) = _$CancelParamsCopyWithImpl;
@useResult
$Res call({
 Sealed6 id
});




}
/// @nodoc
class _$CancelParamsCopyWithImpl<$Res>
    implements $CancelParamsCopyWith<$Res> {
  _$CancelParamsCopyWithImpl(this._self, this._then);

  final CancelParams _self;
  final $Res Function(CancelParams) _then;

/// Create a copy of CancelParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = null,}) {
  return _then(_self.copyWith(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as Sealed6,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _CancelParams implements CancelParams {
  const _CancelParams({required this.id});
  factory _CancelParams.fromJson(Map<String, dynamic> json) => _$CancelParamsFromJson(json);

/// The request id to cancel.
@override final  Sealed6 id;

/// Create a copy of CancelParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CancelParamsCopyWith<_CancelParams> get copyWith => __$CancelParamsCopyWithImpl<_CancelParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CancelParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CancelParams&&(identical(other.id, id) || other.id == id));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id);

@override
String toString() {
  return 'CancelParams(id: $id)';
}


}

/// @nodoc
abstract mixin class _$CancelParamsCopyWith<$Res> implements $CancelParamsCopyWith<$Res> {
  factory _$CancelParamsCopyWith(_CancelParams value, $Res Function(_CancelParams) _then) = __$CancelParamsCopyWithImpl;
@override @useResult
$Res call({
 Sealed6 id
});




}
/// @nodoc
class __$CancelParamsCopyWithImpl<$Res>
    implements _$CancelParamsCopyWith<$Res> {
  __$CancelParamsCopyWithImpl(this._self, this._then);

  final _CancelParams _self;
  final $Res Function(_CancelParams) _then;

/// Create a copy of CancelParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = null,}) {
  return _then(_CancelParams(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as Sealed6,
  ));
}


}


/// @nodoc
mixin _$ProgressParams {

/// The progress token provided by the client or server.
 ProgressToken get token;/// The progress data.
 LSPAny get value;
/// Create a copy of ProgressParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ProgressParamsCopyWith<ProgressParams> get copyWith => _$ProgressParamsCopyWithImpl<ProgressParams>(this as ProgressParams, _$identity);

  /// Serializes this ProgressParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ProgressParams&&(identical(other.token, token) || other.token == token)&&(identical(other.value, value) || other.value == value));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,token,value);

@override
String toString() {
  return 'ProgressParams(token: $token, value: $value)';
}


}

/// @nodoc
abstract mixin class $ProgressParamsCopyWith<$Res>  {
  factory $ProgressParamsCopyWith(ProgressParams value, $Res Function(ProgressParams) _then) = _$ProgressParamsCopyWithImpl;
@useResult
$Res call({
 ProgressToken token, LSPAny value
});




}
/// @nodoc
class _$ProgressParamsCopyWithImpl<$Res>
    implements $ProgressParamsCopyWith<$Res> {
  _$ProgressParamsCopyWithImpl(this._self, this._then);

  final ProgressParams _self;
  final $Res Function(ProgressParams) _then;

/// Create a copy of ProgressParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? token = null,Object? value = null,}) {
  return _then(_self.copyWith(
token: null == token ? _self.token : token // ignore: cast_nullable_to_non_nullable
as ProgressToken,value: null == value ? _self.value : value // ignore: cast_nullable_to_non_nullable
as LSPAny,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _ProgressParams implements ProgressParams {
  const _ProgressParams({required this.token, required this.value});
  factory _ProgressParams.fromJson(Map<String, dynamic> json) => _$ProgressParamsFromJson(json);

/// The progress token provided by the client or server.
@override final  ProgressToken token;
/// The progress data.
@override final  LSPAny value;

/// Create a copy of ProgressParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ProgressParamsCopyWith<_ProgressParams> get copyWith => __$ProgressParamsCopyWithImpl<_ProgressParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ProgressParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ProgressParams&&(identical(other.token, token) || other.token == token)&&(identical(other.value, value) || other.value == value));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,token,value);

@override
String toString() {
  return 'ProgressParams(token: $token, value: $value)';
}


}

/// @nodoc
abstract mixin class _$ProgressParamsCopyWith<$Res> implements $ProgressParamsCopyWith<$Res> {
  factory _$ProgressParamsCopyWith(_ProgressParams value, $Res Function(_ProgressParams) _then) = __$ProgressParamsCopyWithImpl;
@override @useResult
$Res call({
 ProgressToken token, LSPAny value
});




}
/// @nodoc
class __$ProgressParamsCopyWithImpl<$Res>
    implements _$ProgressParamsCopyWith<$Res> {
  __$ProgressParamsCopyWithImpl(this._self, this._then);

  final _ProgressParams _self;
  final $Res Function(_ProgressParams) _then;

/// Create a copy of ProgressParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? token = null,Object? value = null,}) {
  return _then(_ProgressParams(
token: null == token ? _self.token : token // ignore: cast_nullable_to_non_nullable
as ProgressToken,value: null == value ? _self.value : value // ignore: cast_nullable_to_non_nullable
as LSPAny,
  ));
}


}


/// @nodoc
mixin _$TextDocumentPositionParams {

/// The position inside the text document.
 Position get position;/// The text document.
 TextDocumentIdentifier get textDocument;
/// Create a copy of TextDocumentPositionParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TextDocumentPositionParamsCopyWith<TextDocumentPositionParams> get copyWith => _$TextDocumentPositionParamsCopyWithImpl<TextDocumentPositionParams>(this as TextDocumentPositionParams, _$identity);

  /// Serializes this TextDocumentPositionParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TextDocumentPositionParams&&(identical(other.position, position) || other.position == position)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,position,textDocument);

@override
String toString() {
  return 'TextDocumentPositionParams(position: $position, textDocument: $textDocument)';
}


}

/// @nodoc
abstract mixin class $TextDocumentPositionParamsCopyWith<$Res>  {
  factory $TextDocumentPositionParamsCopyWith(TextDocumentPositionParams value, $Res Function(TextDocumentPositionParams) _then) = _$TextDocumentPositionParamsCopyWithImpl;
@useResult
$Res call({
 Position position, TextDocumentIdentifier textDocument
});


$PositionCopyWith<$Res> get position;$TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$TextDocumentPositionParamsCopyWithImpl<$Res>
    implements $TextDocumentPositionParamsCopyWith<$Res> {
  _$TextDocumentPositionParamsCopyWithImpl(this._self, this._then);

  final TextDocumentPositionParams _self;
  final $Res Function(TextDocumentPositionParams) _then;

/// Create a copy of TextDocumentPositionParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? position = null,Object? textDocument = null,}) {
  return _then(_self.copyWith(
position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,
  ));
}
/// Create a copy of TextDocumentPositionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of TextDocumentPositionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _TextDocumentPositionParams implements TextDocumentPositionParams {
  const _TextDocumentPositionParams({required this.position, required this.textDocument});
  factory _TextDocumentPositionParams.fromJson(Map<String, dynamic> json) => _$TextDocumentPositionParamsFromJson(json);

/// The position inside the text document.
@override final  Position position;
/// The text document.
@override final  TextDocumentIdentifier textDocument;

/// Create a copy of TextDocumentPositionParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TextDocumentPositionParamsCopyWith<_TextDocumentPositionParams> get copyWith => __$TextDocumentPositionParamsCopyWithImpl<_TextDocumentPositionParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TextDocumentPositionParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TextDocumentPositionParams&&(identical(other.position, position) || other.position == position)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,position,textDocument);

@override
String toString() {
  return 'TextDocumentPositionParams(position: $position, textDocument: $textDocument)';
}


}

/// @nodoc
abstract mixin class _$TextDocumentPositionParamsCopyWith<$Res> implements $TextDocumentPositionParamsCopyWith<$Res> {
  factory _$TextDocumentPositionParamsCopyWith(_TextDocumentPositionParams value, $Res Function(_TextDocumentPositionParams) _then) = __$TextDocumentPositionParamsCopyWithImpl;
@override @useResult
$Res call({
 Position position, TextDocumentIdentifier textDocument
});


@override $PositionCopyWith<$Res> get position;@override $TextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$TextDocumentPositionParamsCopyWithImpl<$Res>
    implements _$TextDocumentPositionParamsCopyWith<$Res> {
  __$TextDocumentPositionParamsCopyWithImpl(this._self, this._then);

  final _TextDocumentPositionParams _self;
  final $Res Function(_TextDocumentPositionParams) _then;

/// Create a copy of TextDocumentPositionParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? position = null,Object? textDocument = null,}) {
  return _then(_TextDocumentPositionParams(
position: null == position ? _self.position : position // ignore: cast_nullable_to_non_nullable
as Position,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentIdentifier,
  ));
}

/// Create a copy of TextDocumentPositionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get position {
  
  return $PositionCopyWith<$Res>(_self.position, (value) {
    return _then(_self.copyWith(position: value));
  });
}/// Create a copy of TextDocumentPositionParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $TextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$WorkDoneProgressParams {

/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of WorkDoneProgressParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkDoneProgressParamsCopyWith<WorkDoneProgressParams> get copyWith => _$WorkDoneProgressParamsCopyWithImpl<WorkDoneProgressParams>(this as WorkDoneProgressParams, _$identity);

  /// Serializes this WorkDoneProgressParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkDoneProgressParams&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneToken);

@override
String toString() {
  return 'WorkDoneProgressParams(workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $WorkDoneProgressParamsCopyWith<$Res>  {
  factory $WorkDoneProgressParamsCopyWith(WorkDoneProgressParams value, $Res Function(WorkDoneProgressParams) _then) = _$WorkDoneProgressParamsCopyWithImpl;
@useResult
$Res call({
 ProgressToken? workDoneToken
});




}
/// @nodoc
class _$WorkDoneProgressParamsCopyWithImpl<$Res>
    implements $WorkDoneProgressParamsCopyWith<$Res> {
  _$WorkDoneProgressParamsCopyWithImpl(this._self, this._then);

  final WorkDoneProgressParams _self;
  final $Res Function(WorkDoneProgressParams) _then;

/// Create a copy of WorkDoneProgressParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _WorkDoneProgressParams implements WorkDoneProgressParams {
  const _WorkDoneProgressParams({this.workDoneToken});
  factory _WorkDoneProgressParams.fromJson(Map<String, dynamic> json) => _$WorkDoneProgressParamsFromJson(json);

/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of WorkDoneProgressParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkDoneProgressParamsCopyWith<_WorkDoneProgressParams> get copyWith => __$WorkDoneProgressParamsCopyWithImpl<_WorkDoneProgressParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkDoneProgressParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkDoneProgressParams&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneToken);

@override
String toString() {
  return 'WorkDoneProgressParams(workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$WorkDoneProgressParamsCopyWith<$Res> implements $WorkDoneProgressParamsCopyWith<$Res> {
  factory _$WorkDoneProgressParamsCopyWith(_WorkDoneProgressParams value, $Res Function(_WorkDoneProgressParams) _then) = __$WorkDoneProgressParamsCopyWithImpl;
@override @useResult
$Res call({
 ProgressToken? workDoneToken
});




}
/// @nodoc
class __$WorkDoneProgressParamsCopyWithImpl<$Res>
    implements _$WorkDoneProgressParamsCopyWith<$Res> {
  __$WorkDoneProgressParamsCopyWithImpl(this._self, this._then);

  final _WorkDoneProgressParams _self;
  final $Res Function(_WorkDoneProgressParams) _then;

/// Create a copy of WorkDoneProgressParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workDoneToken = freezed,}) {
  return _then(_WorkDoneProgressParams(
workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}


}


/// @nodoc
mixin _$PartialResultParams {

/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
 ProgressToken? get partialResultToken;
/// Create a copy of PartialResultParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$PartialResultParamsCopyWith<PartialResultParams> get copyWith => _$PartialResultParamsCopyWithImpl<PartialResultParams>(this as PartialResultParams, _$identity);

  /// Serializes this PartialResultParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is PartialResultParams&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,partialResultToken);

@override
String toString() {
  return 'PartialResultParams(partialResultToken: $partialResultToken)';
}


}

/// @nodoc
abstract mixin class $PartialResultParamsCopyWith<$Res>  {
  factory $PartialResultParamsCopyWith(PartialResultParams value, $Res Function(PartialResultParams) _then) = _$PartialResultParamsCopyWithImpl;
@useResult
$Res call({
 ProgressToken? partialResultToken
});




}
/// @nodoc
class _$PartialResultParamsCopyWithImpl<$Res>
    implements $PartialResultParamsCopyWith<$Res> {
  _$PartialResultParamsCopyWithImpl(this._self, this._then);

  final PartialResultParams _self;
  final $Res Function(PartialResultParams) _then;

/// Create a copy of PartialResultParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? partialResultToken = freezed,}) {
  return _then(_self.copyWith(
partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _PartialResultParams implements PartialResultParams {
  const _PartialResultParams({this.partialResultToken});
  factory _PartialResultParams.fromJson(Map<String, dynamic> json) => _$PartialResultParamsFromJson(json);

/// An optional token that a server can use to report partial results (e.g.
/// streaming) to the client.
@override final  ProgressToken? partialResultToken;

/// Create a copy of PartialResultParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$PartialResultParamsCopyWith<_PartialResultParams> get copyWith => __$PartialResultParamsCopyWithImpl<_PartialResultParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$PartialResultParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _PartialResultParams&&(identical(other.partialResultToken, partialResultToken) || other.partialResultToken == partialResultToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,partialResultToken);

@override
String toString() {
  return 'PartialResultParams(partialResultToken: $partialResultToken)';
}


}

/// @nodoc
abstract mixin class _$PartialResultParamsCopyWith<$Res> implements $PartialResultParamsCopyWith<$Res> {
  factory _$PartialResultParamsCopyWith(_PartialResultParams value, $Res Function(_PartialResultParams) _then) = __$PartialResultParamsCopyWithImpl;
@override @useResult
$Res call({
 ProgressToken? partialResultToken
});




}
/// @nodoc
class __$PartialResultParamsCopyWithImpl<$Res>
    implements _$PartialResultParamsCopyWith<$Res> {
  __$PartialResultParamsCopyWithImpl(this._self, this._then);

  final _PartialResultParams _self;
  final $Res Function(_PartialResultParams) _then;

/// Create a copy of PartialResultParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? partialResultToken = freezed,}) {
  return _then(_PartialResultParams(
partialResultToken: freezed == partialResultToken ? _self.partialResultToken : partialResultToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}


}


/// @nodoc
mixin _$LocationLink {

/// Span of the origin of this link.
/// Used as the underlined span for mouse interaction. Defaults to the word
/// range at the definition position.
 Range? get originSelectionRange;/// The full target range of this link. If the target for example is a
/// symbol then target range is the range enclosing this symbol not
/// including leading/trailing whitespace but everything else like
/// comments. This information is typically used to highlight the range in
/// the editor.
 Range get targetRange;/// The range that should be selected and revealed when this link is being
/// followed, e.g the name of a function. Must be contained by the
/// `targetRange`. See also `DocumentSymbol#range`
 Range get targetSelectionRange;/// The target resource identifier of this link.
 String get targetUri;
/// Create a copy of LocationLink
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LocationLinkCopyWith<LocationLink> get copyWith => _$LocationLinkCopyWithImpl<LocationLink>(this as LocationLink, _$identity);

  /// Serializes this LocationLink to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LocationLink&&(identical(other.originSelectionRange, originSelectionRange) || other.originSelectionRange == originSelectionRange)&&(identical(other.targetRange, targetRange) || other.targetRange == targetRange)&&(identical(other.targetSelectionRange, targetSelectionRange) || other.targetSelectionRange == targetSelectionRange)&&(identical(other.targetUri, targetUri) || other.targetUri == targetUri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,originSelectionRange,targetRange,targetSelectionRange,targetUri);

@override
String toString() {
  return 'LocationLink(originSelectionRange: $originSelectionRange, targetRange: $targetRange, targetSelectionRange: $targetSelectionRange, targetUri: $targetUri)';
}


}

/// @nodoc
abstract mixin class $LocationLinkCopyWith<$Res>  {
  factory $LocationLinkCopyWith(LocationLink value, $Res Function(LocationLink) _then) = _$LocationLinkCopyWithImpl;
@useResult
$Res call({
 Range? originSelectionRange, Range targetRange, Range targetSelectionRange, String targetUri
});


$RangeCopyWith<$Res>? get originSelectionRange;$RangeCopyWith<$Res> get targetRange;$RangeCopyWith<$Res> get targetSelectionRange;

}
/// @nodoc
class _$LocationLinkCopyWithImpl<$Res>
    implements $LocationLinkCopyWith<$Res> {
  _$LocationLinkCopyWithImpl(this._self, this._then);

  final LocationLink _self;
  final $Res Function(LocationLink) _then;

/// Create a copy of LocationLink
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? originSelectionRange = freezed,Object? targetRange = null,Object? targetSelectionRange = null,Object? targetUri = null,}) {
  return _then(_self.copyWith(
originSelectionRange: freezed == originSelectionRange ? _self.originSelectionRange : originSelectionRange // ignore: cast_nullable_to_non_nullable
as Range?,targetRange: null == targetRange ? _self.targetRange : targetRange // ignore: cast_nullable_to_non_nullable
as Range,targetSelectionRange: null == targetSelectionRange ? _self.targetSelectionRange : targetSelectionRange // ignore: cast_nullable_to_non_nullable
as Range,targetUri: null == targetUri ? _self.targetUri : targetUri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}
/// Create a copy of LocationLink
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res>? get originSelectionRange {
    if (_self.originSelectionRange == null) {
    return null;
  }

  return $RangeCopyWith<$Res>(_self.originSelectionRange!, (value) {
    return _then(_self.copyWith(originSelectionRange: value));
  });
}/// Create a copy of LocationLink
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get targetRange {
  
  return $RangeCopyWith<$Res>(_self.targetRange, (value) {
    return _then(_self.copyWith(targetRange: value));
  });
}/// Create a copy of LocationLink
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get targetSelectionRange {
  
  return $RangeCopyWith<$Res>(_self.targetSelectionRange, (value) {
    return _then(_self.copyWith(targetSelectionRange: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _LocationLink implements LocationLink {
  const _LocationLink({this.originSelectionRange, required this.targetRange, required this.targetSelectionRange, required this.targetUri});
  factory _LocationLink.fromJson(Map<String, dynamic> json) => _$LocationLinkFromJson(json);

/// Span of the origin of this link.
/// Used as the underlined span for mouse interaction. Defaults to the word
/// range at the definition position.
@override final  Range? originSelectionRange;
/// The full target range of this link. If the target for example is a
/// symbol then target range is the range enclosing this symbol not
/// including leading/trailing whitespace but everything else like
/// comments. This information is typically used to highlight the range in
/// the editor.
@override final  Range targetRange;
/// The range that should be selected and revealed when this link is being
/// followed, e.g the name of a function. Must be contained by the
/// `targetRange`. See also `DocumentSymbol#range`
@override final  Range targetSelectionRange;
/// The target resource identifier of this link.
@override final  String targetUri;

/// Create a copy of LocationLink
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$LocationLinkCopyWith<_LocationLink> get copyWith => __$LocationLinkCopyWithImpl<_LocationLink>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$LocationLinkToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _LocationLink&&(identical(other.originSelectionRange, originSelectionRange) || other.originSelectionRange == originSelectionRange)&&(identical(other.targetRange, targetRange) || other.targetRange == targetRange)&&(identical(other.targetSelectionRange, targetSelectionRange) || other.targetSelectionRange == targetSelectionRange)&&(identical(other.targetUri, targetUri) || other.targetUri == targetUri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,originSelectionRange,targetRange,targetSelectionRange,targetUri);

@override
String toString() {
  return 'LocationLink(originSelectionRange: $originSelectionRange, targetRange: $targetRange, targetSelectionRange: $targetSelectionRange, targetUri: $targetUri)';
}


}

/// @nodoc
abstract mixin class _$LocationLinkCopyWith<$Res> implements $LocationLinkCopyWith<$Res> {
  factory _$LocationLinkCopyWith(_LocationLink value, $Res Function(_LocationLink) _then) = __$LocationLinkCopyWithImpl;
@override @useResult
$Res call({
 Range? originSelectionRange, Range targetRange, Range targetSelectionRange, String targetUri
});


@override $RangeCopyWith<$Res>? get originSelectionRange;@override $RangeCopyWith<$Res> get targetRange;@override $RangeCopyWith<$Res> get targetSelectionRange;

}
/// @nodoc
class __$LocationLinkCopyWithImpl<$Res>
    implements _$LocationLinkCopyWith<$Res> {
  __$LocationLinkCopyWithImpl(this._self, this._then);

  final _LocationLink _self;
  final $Res Function(_LocationLink) _then;

/// Create a copy of LocationLink
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? originSelectionRange = freezed,Object? targetRange = null,Object? targetSelectionRange = null,Object? targetUri = null,}) {
  return _then(_LocationLink(
originSelectionRange: freezed == originSelectionRange ? _self.originSelectionRange : originSelectionRange // ignore: cast_nullable_to_non_nullable
as Range?,targetRange: null == targetRange ? _self.targetRange : targetRange // ignore: cast_nullable_to_non_nullable
as Range,targetSelectionRange: null == targetSelectionRange ? _self.targetSelectionRange : targetSelectionRange // ignore: cast_nullable_to_non_nullable
as Range,targetUri: null == targetUri ? _self.targetUri : targetUri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

/// Create a copy of LocationLink
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res>? get originSelectionRange {
    if (_self.originSelectionRange == null) {
    return null;
  }

  return $RangeCopyWith<$Res>(_self.originSelectionRange!, (value) {
    return _then(_self.copyWith(originSelectionRange: value));
  });
}/// Create a copy of LocationLink
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get targetRange {
  
  return $RangeCopyWith<$Res>(_self.targetRange, (value) {
    return _then(_self.copyWith(targetRange: value));
  });
}/// Create a copy of LocationLink
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get targetSelectionRange {
  
  return $RangeCopyWith<$Res>(_self.targetSelectionRange, (value) {
    return _then(_self.copyWith(targetSelectionRange: value));
  });
}
}


/// @nodoc
mixin _$Range {

/// The range's end position.
 Position get end;/// The range's start position.
 Position get start;
/// Create a copy of Range
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RangeCopyWith<Range> get copyWith => _$RangeCopyWithImpl<Range>(this as Range, _$identity);

  /// Serializes this Range to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Range&&(identical(other.end, end) || other.end == end)&&(identical(other.start, start) || other.start == start));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,end,start);

@override
String toString() {
  return 'Range(end: $end, start: $start)';
}


}

/// @nodoc
abstract mixin class $RangeCopyWith<$Res>  {
  factory $RangeCopyWith(Range value, $Res Function(Range) _then) = _$RangeCopyWithImpl;
@useResult
$Res call({
 Position end, Position start
});


$PositionCopyWith<$Res> get end;$PositionCopyWith<$Res> get start;

}
/// @nodoc
class _$RangeCopyWithImpl<$Res>
    implements $RangeCopyWith<$Res> {
  _$RangeCopyWithImpl(this._self, this._then);

  final Range _self;
  final $Res Function(Range) _then;

/// Create a copy of Range
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? end = null,Object? start = null,}) {
  return _then(_self.copyWith(
end: null == end ? _self.end : end // ignore: cast_nullable_to_non_nullable
as Position,start: null == start ? _self.start : start // ignore: cast_nullable_to_non_nullable
as Position,
  ));
}
/// Create a copy of Range
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get end {
  
  return $PositionCopyWith<$Res>(_self.end, (value) {
    return _then(_self.copyWith(end: value));
  });
}/// Create a copy of Range
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get start {
  
  return $PositionCopyWith<$Res>(_self.start, (value) {
    return _then(_self.copyWith(start: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _Range implements Range {
  const _Range({required this.end, required this.start});
  factory _Range.fromJson(Map<String, dynamic> json) => _$RangeFromJson(json);

/// The range's end position.
@override final  Position end;
/// The range's start position.
@override final  Position start;

/// Create a copy of Range
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RangeCopyWith<_Range> get copyWith => __$RangeCopyWithImpl<_Range>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$RangeToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _Range&&(identical(other.end, end) || other.end == end)&&(identical(other.start, start) || other.start == start));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,end,start);

@override
String toString() {
  return 'Range(end: $end, start: $start)';
}


}

/// @nodoc
abstract mixin class _$RangeCopyWith<$Res> implements $RangeCopyWith<$Res> {
  factory _$RangeCopyWith(_Range value, $Res Function(_Range) _then) = __$RangeCopyWithImpl;
@override @useResult
$Res call({
 Position end, Position start
});


@override $PositionCopyWith<$Res> get end;@override $PositionCopyWith<$Res> get start;

}
/// @nodoc
class __$RangeCopyWithImpl<$Res>
    implements _$RangeCopyWith<$Res> {
  __$RangeCopyWithImpl(this._self, this._then);

  final _Range _self;
  final $Res Function(_Range) _then;

/// Create a copy of Range
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? end = null,Object? start = null,}) {
  return _then(_Range(
end: null == end ? _self.end : end // ignore: cast_nullable_to_non_nullable
as Position,start: null == start ? _self.start : start // ignore: cast_nullable_to_non_nullable
as Position,
  ));
}

/// Create a copy of Range
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get end {
  
  return $PositionCopyWith<$Res>(_self.end, (value) {
    return _then(_self.copyWith(end: value));
  });
}/// Create a copy of Range
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PositionCopyWith<$Res> get start {
  
  return $PositionCopyWith<$Res>(_self.start, (value) {
    return _then(_self.copyWith(start: value));
  });
}
}


/// @nodoc
mixin _$ImplementationOptions {

 bool? get workDoneProgress;
/// Create a copy of ImplementationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ImplementationOptionsCopyWith<ImplementationOptions> get copyWith => _$ImplementationOptionsCopyWithImpl<ImplementationOptions>(this as ImplementationOptions, _$identity);

  /// Serializes this ImplementationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ImplementationOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'ImplementationOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $ImplementationOptionsCopyWith<$Res>  {
  factory $ImplementationOptionsCopyWith(ImplementationOptions value, $Res Function(ImplementationOptions) _then) = _$ImplementationOptionsCopyWithImpl;
@useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class _$ImplementationOptionsCopyWithImpl<$Res>
    implements $ImplementationOptionsCopyWith<$Res> {
  _$ImplementationOptionsCopyWithImpl(this._self, this._then);

  final ImplementationOptions _self;
  final $Res Function(ImplementationOptions) _then;

/// Create a copy of ImplementationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _ImplementationOptions implements ImplementationOptions {
  const _ImplementationOptions({this.workDoneProgress});
  factory _ImplementationOptions.fromJson(Map<String, dynamic> json) => _$ImplementationOptionsFromJson(json);

@override final  bool? workDoneProgress;

/// Create a copy of ImplementationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ImplementationOptionsCopyWith<_ImplementationOptions> get copyWith => __$ImplementationOptionsCopyWithImpl<_ImplementationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ImplementationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ImplementationOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'ImplementationOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$ImplementationOptionsCopyWith<$Res> implements $ImplementationOptionsCopyWith<$Res> {
  factory _$ImplementationOptionsCopyWith(_ImplementationOptions value, $Res Function(_ImplementationOptions) _then) = __$ImplementationOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class __$ImplementationOptionsCopyWithImpl<$Res>
    implements _$ImplementationOptionsCopyWith<$Res> {
  __$ImplementationOptionsCopyWithImpl(this._self, this._then);

  final _ImplementationOptions _self;
  final $Res Function(_ImplementationOptions) _then;

/// Create a copy of ImplementationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_ImplementationOptions(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$StaticRegistrationOptions {

/// The id used to register the request. The id can be used to deregister
/// the request again. See also Registration#id.
 String? get id;
/// Create a copy of StaticRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$StaticRegistrationOptionsCopyWith<StaticRegistrationOptions> get copyWith => _$StaticRegistrationOptionsCopyWithImpl<StaticRegistrationOptions>(this as StaticRegistrationOptions, _$identity);

  /// Serializes this StaticRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is StaticRegistrationOptions&&(identical(other.id, id) || other.id == id));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id);

@override
String toString() {
  return 'StaticRegistrationOptions(id: $id)';
}


}

/// @nodoc
abstract mixin class $StaticRegistrationOptionsCopyWith<$Res>  {
  factory $StaticRegistrationOptionsCopyWith(StaticRegistrationOptions value, $Res Function(StaticRegistrationOptions) _then) = _$StaticRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 String? id
});




}
/// @nodoc
class _$StaticRegistrationOptionsCopyWithImpl<$Res>
    implements $StaticRegistrationOptionsCopyWith<$Res> {
  _$StaticRegistrationOptionsCopyWithImpl(this._self, this._then);

  final StaticRegistrationOptions _self;
  final $Res Function(StaticRegistrationOptions) _then;

/// Create a copy of StaticRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = freezed,}) {
  return _then(_self.copyWith(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _StaticRegistrationOptions implements StaticRegistrationOptions {
  const _StaticRegistrationOptions({this.id});
  factory _StaticRegistrationOptions.fromJson(Map<String, dynamic> json) => _$StaticRegistrationOptionsFromJson(json);

/// The id used to register the request. The id can be used to deregister
/// the request again. See also Registration#id.
@override final  String? id;

/// Create a copy of StaticRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$StaticRegistrationOptionsCopyWith<_StaticRegistrationOptions> get copyWith => __$StaticRegistrationOptionsCopyWithImpl<_StaticRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$StaticRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _StaticRegistrationOptions&&(identical(other.id, id) || other.id == id));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id);

@override
String toString() {
  return 'StaticRegistrationOptions(id: $id)';
}


}

/// @nodoc
abstract mixin class _$StaticRegistrationOptionsCopyWith<$Res> implements $StaticRegistrationOptionsCopyWith<$Res> {
  factory _$StaticRegistrationOptionsCopyWith(_StaticRegistrationOptions value, $Res Function(_StaticRegistrationOptions) _then) = __$StaticRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 String? id
});




}
/// @nodoc
class __$StaticRegistrationOptionsCopyWithImpl<$Res>
    implements _$StaticRegistrationOptionsCopyWith<$Res> {
  __$StaticRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _StaticRegistrationOptions _self;
  final $Res Function(_StaticRegistrationOptions) _then;

/// Create a copy of StaticRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = freezed,}) {
  return _then(_StaticRegistrationOptions(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$TypeDefinitionOptions {

 bool? get workDoneProgress;
/// Create a copy of TypeDefinitionOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TypeDefinitionOptionsCopyWith<TypeDefinitionOptions> get copyWith => _$TypeDefinitionOptionsCopyWithImpl<TypeDefinitionOptions>(this as TypeDefinitionOptions, _$identity);

  /// Serializes this TypeDefinitionOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TypeDefinitionOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'TypeDefinitionOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $TypeDefinitionOptionsCopyWith<$Res>  {
  factory $TypeDefinitionOptionsCopyWith(TypeDefinitionOptions value, $Res Function(TypeDefinitionOptions) _then) = _$TypeDefinitionOptionsCopyWithImpl;
@useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class _$TypeDefinitionOptionsCopyWithImpl<$Res>
    implements $TypeDefinitionOptionsCopyWith<$Res> {
  _$TypeDefinitionOptionsCopyWithImpl(this._self, this._then);

  final TypeDefinitionOptions _self;
  final $Res Function(TypeDefinitionOptions) _then;

/// Create a copy of TypeDefinitionOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _TypeDefinitionOptions implements TypeDefinitionOptions {
  const _TypeDefinitionOptions({this.workDoneProgress});
  factory _TypeDefinitionOptions.fromJson(Map<String, dynamic> json) => _$TypeDefinitionOptionsFromJson(json);

@override final  bool? workDoneProgress;

/// Create a copy of TypeDefinitionOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TypeDefinitionOptionsCopyWith<_TypeDefinitionOptions> get copyWith => __$TypeDefinitionOptionsCopyWithImpl<_TypeDefinitionOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TypeDefinitionOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TypeDefinitionOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'TypeDefinitionOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$TypeDefinitionOptionsCopyWith<$Res> implements $TypeDefinitionOptionsCopyWith<$Res> {
  factory _$TypeDefinitionOptionsCopyWith(_TypeDefinitionOptions value, $Res Function(_TypeDefinitionOptions) _then) = __$TypeDefinitionOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class __$TypeDefinitionOptionsCopyWithImpl<$Res>
    implements _$TypeDefinitionOptionsCopyWith<$Res> {
  __$TypeDefinitionOptionsCopyWithImpl(this._self, this._then);

  final _TypeDefinitionOptions _self;
  final $Res Function(_TypeDefinitionOptions) _then;

/// Create a copy of TypeDefinitionOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_TypeDefinitionOptions(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$WorkspaceFoldersChangeEvent {

/// The array of added workspace folders
 List<WorkspaceFolder> get added;/// The array of the removed workspace folders
 List<WorkspaceFolder> get removed;
/// Create a copy of WorkspaceFoldersChangeEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkspaceFoldersChangeEventCopyWith<WorkspaceFoldersChangeEvent> get copyWith => _$WorkspaceFoldersChangeEventCopyWithImpl<WorkspaceFoldersChangeEvent>(this as WorkspaceFoldersChangeEvent, _$identity);

  /// Serializes this WorkspaceFoldersChangeEvent to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkspaceFoldersChangeEvent&&const DeepCollectionEquality().equals(other.added, added)&&const DeepCollectionEquality().equals(other.removed, removed));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(added),const DeepCollectionEquality().hash(removed));

@override
String toString() {
  return 'WorkspaceFoldersChangeEvent(added: $added, removed: $removed)';
}


}

/// @nodoc
abstract mixin class $WorkspaceFoldersChangeEventCopyWith<$Res>  {
  factory $WorkspaceFoldersChangeEventCopyWith(WorkspaceFoldersChangeEvent value, $Res Function(WorkspaceFoldersChangeEvent) _then) = _$WorkspaceFoldersChangeEventCopyWithImpl;
@useResult
$Res call({
 List<WorkspaceFolder> added, List<WorkspaceFolder> removed
});




}
/// @nodoc
class _$WorkspaceFoldersChangeEventCopyWithImpl<$Res>
    implements $WorkspaceFoldersChangeEventCopyWith<$Res> {
  _$WorkspaceFoldersChangeEventCopyWithImpl(this._self, this._then);

  final WorkspaceFoldersChangeEvent _self;
  final $Res Function(WorkspaceFoldersChangeEvent) _then;

/// Create a copy of WorkspaceFoldersChangeEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? added = null,Object? removed = null,}) {
  return _then(_self.copyWith(
added: null == added ? _self.added : added // ignore: cast_nullable_to_non_nullable
as List<WorkspaceFolder>,removed: null == removed ? _self.removed : removed // ignore: cast_nullable_to_non_nullable
as List<WorkspaceFolder>,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _WorkspaceFoldersChangeEvent implements WorkspaceFoldersChangeEvent {
  const _WorkspaceFoldersChangeEvent({required final  List<WorkspaceFolder> added, required final  List<WorkspaceFolder> removed}): _added = added,_removed = removed;
  factory _WorkspaceFoldersChangeEvent.fromJson(Map<String, dynamic> json) => _$WorkspaceFoldersChangeEventFromJson(json);

/// The array of added workspace folders
 final  List<WorkspaceFolder> _added;
/// The array of added workspace folders
@override List<WorkspaceFolder> get added {
  if (_added is EqualUnmodifiableListView) return _added;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_added);
}

/// The array of the removed workspace folders
 final  List<WorkspaceFolder> _removed;
/// The array of the removed workspace folders
@override List<WorkspaceFolder> get removed {
  if (_removed is EqualUnmodifiableListView) return _removed;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_removed);
}


/// Create a copy of WorkspaceFoldersChangeEvent
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkspaceFoldersChangeEventCopyWith<_WorkspaceFoldersChangeEvent> get copyWith => __$WorkspaceFoldersChangeEventCopyWithImpl<_WorkspaceFoldersChangeEvent>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkspaceFoldersChangeEventToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkspaceFoldersChangeEvent&&const DeepCollectionEquality().equals(other._added, _added)&&const DeepCollectionEquality().equals(other._removed, _removed));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_added),const DeepCollectionEquality().hash(_removed));

@override
String toString() {
  return 'WorkspaceFoldersChangeEvent(added: $added, removed: $removed)';
}


}

/// @nodoc
abstract mixin class _$WorkspaceFoldersChangeEventCopyWith<$Res> implements $WorkspaceFoldersChangeEventCopyWith<$Res> {
  factory _$WorkspaceFoldersChangeEventCopyWith(_WorkspaceFoldersChangeEvent value, $Res Function(_WorkspaceFoldersChangeEvent) _then) = __$WorkspaceFoldersChangeEventCopyWithImpl;
@override @useResult
$Res call({
 List<WorkspaceFolder> added, List<WorkspaceFolder> removed
});




}
/// @nodoc
class __$WorkspaceFoldersChangeEventCopyWithImpl<$Res>
    implements _$WorkspaceFoldersChangeEventCopyWith<$Res> {
  __$WorkspaceFoldersChangeEventCopyWithImpl(this._self, this._then);

  final _WorkspaceFoldersChangeEvent _self;
  final $Res Function(_WorkspaceFoldersChangeEvent) _then;

/// Create a copy of WorkspaceFoldersChangeEvent
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? added = null,Object? removed = null,}) {
  return _then(_WorkspaceFoldersChangeEvent(
added: null == added ? _self._added : added // ignore: cast_nullable_to_non_nullable
as List<WorkspaceFolder>,removed: null == removed ? _self._removed : removed // ignore: cast_nullable_to_non_nullable
as List<WorkspaceFolder>,
  ));
}


}


/// @nodoc
mixin _$ConfigurationItem {

/// The scope to get the configuration section for.
 String? get scopeUri;/// The configuration section asked for.
 String? get section;
/// Create a copy of ConfigurationItem
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ConfigurationItemCopyWith<ConfigurationItem> get copyWith => _$ConfigurationItemCopyWithImpl<ConfigurationItem>(this as ConfigurationItem, _$identity);

  /// Serializes this ConfigurationItem to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ConfigurationItem&&(identical(other.scopeUri, scopeUri) || other.scopeUri == scopeUri)&&(identical(other.section, section) || other.section == section));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,scopeUri,section);

@override
String toString() {
  return 'ConfigurationItem(scopeUri: $scopeUri, section: $section)';
}


}

/// @nodoc
abstract mixin class $ConfigurationItemCopyWith<$Res>  {
  factory $ConfigurationItemCopyWith(ConfigurationItem value, $Res Function(ConfigurationItem) _then) = _$ConfigurationItemCopyWithImpl;
@useResult
$Res call({
 String? scopeUri, String? section
});




}
/// @nodoc
class _$ConfigurationItemCopyWithImpl<$Res>
    implements $ConfigurationItemCopyWith<$Res> {
  _$ConfigurationItemCopyWithImpl(this._self, this._then);

  final ConfigurationItem _self;
  final $Res Function(ConfigurationItem) _then;

/// Create a copy of ConfigurationItem
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? scopeUri = freezed,Object? section = freezed,}) {
  return _then(_self.copyWith(
scopeUri: freezed == scopeUri ? _self.scopeUri : scopeUri // ignore: cast_nullable_to_non_nullable
as String?,section: freezed == section ? _self.section : section // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _ConfigurationItem implements ConfigurationItem {
  const _ConfigurationItem({this.scopeUri, this.section});
  factory _ConfigurationItem.fromJson(Map<String, dynamic> json) => _$ConfigurationItemFromJson(json);

/// The scope to get the configuration section for.
@override final  String? scopeUri;
/// The configuration section asked for.
@override final  String? section;

/// Create a copy of ConfigurationItem
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ConfigurationItemCopyWith<_ConfigurationItem> get copyWith => __$ConfigurationItemCopyWithImpl<_ConfigurationItem>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ConfigurationItemToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ConfigurationItem&&(identical(other.scopeUri, scopeUri) || other.scopeUri == scopeUri)&&(identical(other.section, section) || other.section == section));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,scopeUri,section);

@override
String toString() {
  return 'ConfigurationItem(scopeUri: $scopeUri, section: $section)';
}


}

/// @nodoc
abstract mixin class _$ConfigurationItemCopyWith<$Res> implements $ConfigurationItemCopyWith<$Res> {
  factory _$ConfigurationItemCopyWith(_ConfigurationItem value, $Res Function(_ConfigurationItem) _then) = __$ConfigurationItemCopyWithImpl;
@override @useResult
$Res call({
 String? scopeUri, String? section
});




}
/// @nodoc
class __$ConfigurationItemCopyWithImpl<$Res>
    implements _$ConfigurationItemCopyWith<$Res> {
  __$ConfigurationItemCopyWithImpl(this._self, this._then);

  final _ConfigurationItem _self;
  final $Res Function(_ConfigurationItem) _then;

/// Create a copy of ConfigurationItem
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? scopeUri = freezed,Object? section = freezed,}) {
  return _then(_ConfigurationItem(
scopeUri: freezed == scopeUri ? _self.scopeUri : scopeUri // ignore: cast_nullable_to_non_nullable
as String?,section: freezed == section ? _self.section : section // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$TextDocumentIdentifier {

/// The text document's uri.
 String get uri;
/// Create a copy of TextDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TextDocumentIdentifierCopyWith<TextDocumentIdentifier> get copyWith => _$TextDocumentIdentifierCopyWithImpl<TextDocumentIdentifier>(this as TextDocumentIdentifier, _$identity);

  /// Serializes this TextDocumentIdentifier to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TextDocumentIdentifier&&(identical(other.uri, uri) || other.uri == uri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri);

@override
String toString() {
  return 'TextDocumentIdentifier(uri: $uri)';
}


}

/// @nodoc
abstract mixin class $TextDocumentIdentifierCopyWith<$Res>  {
  factory $TextDocumentIdentifierCopyWith(TextDocumentIdentifier value, $Res Function(TextDocumentIdentifier) _then) = _$TextDocumentIdentifierCopyWithImpl;
@useResult
$Res call({
 String uri
});




}
/// @nodoc
class _$TextDocumentIdentifierCopyWithImpl<$Res>
    implements $TextDocumentIdentifierCopyWith<$Res> {
  _$TextDocumentIdentifierCopyWithImpl(this._self, this._then);

  final TextDocumentIdentifier _self;
  final $Res Function(TextDocumentIdentifier) _then;

/// Create a copy of TextDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? uri = null,}) {
  return _then(_self.copyWith(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _TextDocumentIdentifier implements TextDocumentIdentifier {
  const _TextDocumentIdentifier({required this.uri});
  factory _TextDocumentIdentifier.fromJson(Map<String, dynamic> json) => _$TextDocumentIdentifierFromJson(json);

/// The text document's uri.
@override final  String uri;

/// Create a copy of TextDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TextDocumentIdentifierCopyWith<_TextDocumentIdentifier> get copyWith => __$TextDocumentIdentifierCopyWithImpl<_TextDocumentIdentifier>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TextDocumentIdentifierToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TextDocumentIdentifier&&(identical(other.uri, uri) || other.uri == uri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri);

@override
String toString() {
  return 'TextDocumentIdentifier(uri: $uri)';
}


}

/// @nodoc
abstract mixin class _$TextDocumentIdentifierCopyWith<$Res> implements $TextDocumentIdentifierCopyWith<$Res> {
  factory _$TextDocumentIdentifierCopyWith(_TextDocumentIdentifier value, $Res Function(_TextDocumentIdentifier) _then) = __$TextDocumentIdentifierCopyWithImpl;
@override @useResult
$Res call({
 String uri
});




}
/// @nodoc
class __$TextDocumentIdentifierCopyWithImpl<$Res>
    implements _$TextDocumentIdentifierCopyWith<$Res> {
  __$TextDocumentIdentifierCopyWithImpl(this._self, this._then);

  final _TextDocumentIdentifier _self;
  final $Res Function(_TextDocumentIdentifier) _then;

/// Create a copy of TextDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? uri = null,}) {
  return _then(_TextDocumentIdentifier(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}


/// @nodoc
mixin _$Color {

/// The alpha component of this color in the range [0-1].
 double get alpha;/// The blue component of this color in the range [0-1].
 double get blue;/// The green component of this color in the range [0-1].
 double get green;/// The red component of this color in the range [0-1].
 double get red;
/// Create a copy of Color
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ColorCopyWith<Color> get copyWith => _$ColorCopyWithImpl<Color>(this as Color, _$identity);

  /// Serializes this Color to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Color&&(identical(other.alpha, alpha) || other.alpha == alpha)&&(identical(other.blue, blue) || other.blue == blue)&&(identical(other.green, green) || other.green == green)&&(identical(other.red, red) || other.red == red));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,alpha,blue,green,red);

@override
String toString() {
  return 'Color(alpha: $alpha, blue: $blue, green: $green, red: $red)';
}


}

/// @nodoc
abstract mixin class $ColorCopyWith<$Res>  {
  factory $ColorCopyWith(Color value, $Res Function(Color) _then) = _$ColorCopyWithImpl;
@useResult
$Res call({
 double alpha, double blue, double green, double red
});




}
/// @nodoc
class _$ColorCopyWithImpl<$Res>
    implements $ColorCopyWith<$Res> {
  _$ColorCopyWithImpl(this._self, this._then);

  final Color _self;
  final $Res Function(Color) _then;

/// Create a copy of Color
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? alpha = null,Object? blue = null,Object? green = null,Object? red = null,}) {
  return _then(_self.copyWith(
alpha: null == alpha ? _self.alpha : alpha // ignore: cast_nullable_to_non_nullable
as double,blue: null == blue ? _self.blue : blue // ignore: cast_nullable_to_non_nullable
as double,green: null == green ? _self.green : green // ignore: cast_nullable_to_non_nullable
as double,red: null == red ? _self.red : red // ignore: cast_nullable_to_non_nullable
as double,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _Color implements Color {
  const _Color({required this.alpha, required this.blue, required this.green, required this.red});
  factory _Color.fromJson(Map<String, dynamic> json) => _$ColorFromJson(json);

/// The alpha component of this color in the range [0-1].
@override final  double alpha;
/// The blue component of this color in the range [0-1].
@override final  double blue;
/// The green component of this color in the range [0-1].
@override final  double green;
/// The red component of this color in the range [0-1].
@override final  double red;

/// Create a copy of Color
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ColorCopyWith<_Color> get copyWith => __$ColorCopyWithImpl<_Color>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ColorToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _Color&&(identical(other.alpha, alpha) || other.alpha == alpha)&&(identical(other.blue, blue) || other.blue == blue)&&(identical(other.green, green) || other.green == green)&&(identical(other.red, red) || other.red == red));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,alpha,blue,green,red);

@override
String toString() {
  return 'Color(alpha: $alpha, blue: $blue, green: $green, red: $red)';
}


}

/// @nodoc
abstract mixin class _$ColorCopyWith<$Res> implements $ColorCopyWith<$Res> {
  factory _$ColorCopyWith(_Color value, $Res Function(_Color) _then) = __$ColorCopyWithImpl;
@override @useResult
$Res call({
 double alpha, double blue, double green, double red
});




}
/// @nodoc
class __$ColorCopyWithImpl<$Res>
    implements _$ColorCopyWith<$Res> {
  __$ColorCopyWithImpl(this._self, this._then);

  final _Color _self;
  final $Res Function(_Color) _then;

/// Create a copy of Color
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? alpha = null,Object? blue = null,Object? green = null,Object? red = null,}) {
  return _then(_Color(
alpha: null == alpha ? _self.alpha : alpha // ignore: cast_nullable_to_non_nullable
as double,blue: null == blue ? _self.blue : blue // ignore: cast_nullable_to_non_nullable
as double,green: null == green ? _self.green : green // ignore: cast_nullable_to_non_nullable
as double,red: null == red ? _self.red : red // ignore: cast_nullable_to_non_nullable
as double,
  ));
}


}


/// @nodoc
mixin _$DocumentColorOptions {

 bool? get workDoneProgress;
/// Create a copy of DocumentColorOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentColorOptionsCopyWith<DocumentColorOptions> get copyWith => _$DocumentColorOptionsCopyWithImpl<DocumentColorOptions>(this as DocumentColorOptions, _$identity);

  /// Serializes this DocumentColorOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentColorOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'DocumentColorOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $DocumentColorOptionsCopyWith<$Res>  {
  factory $DocumentColorOptionsCopyWith(DocumentColorOptions value, $Res Function(DocumentColorOptions) _then) = _$DocumentColorOptionsCopyWithImpl;
@useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class _$DocumentColorOptionsCopyWithImpl<$Res>
    implements $DocumentColorOptionsCopyWith<$Res> {
  _$DocumentColorOptionsCopyWithImpl(this._self, this._then);

  final DocumentColorOptions _self;
  final $Res Function(DocumentColorOptions) _then;

/// Create a copy of DocumentColorOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DocumentColorOptions implements DocumentColorOptions {
  const _DocumentColorOptions({this.workDoneProgress});
  factory _DocumentColorOptions.fromJson(Map<String, dynamic> json) => _$DocumentColorOptionsFromJson(json);

@override final  bool? workDoneProgress;

/// Create a copy of DocumentColorOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentColorOptionsCopyWith<_DocumentColorOptions> get copyWith => __$DocumentColorOptionsCopyWithImpl<_DocumentColorOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentColorOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentColorOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'DocumentColorOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$DocumentColorOptionsCopyWith<$Res> implements $DocumentColorOptionsCopyWith<$Res> {
  factory _$DocumentColorOptionsCopyWith(_DocumentColorOptions value, $Res Function(_DocumentColorOptions) _then) = __$DocumentColorOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class __$DocumentColorOptionsCopyWithImpl<$Res>
    implements _$DocumentColorOptionsCopyWith<$Res> {
  __$DocumentColorOptionsCopyWithImpl(this._self, this._then);

  final _DocumentColorOptions _self;
  final $Res Function(_DocumentColorOptions) _then;

/// Create a copy of DocumentColorOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_DocumentColorOptions(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$FoldingRangeOptions {

 bool? get workDoneProgress;
/// Create a copy of FoldingRangeOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FoldingRangeOptionsCopyWith<FoldingRangeOptions> get copyWith => _$FoldingRangeOptionsCopyWithImpl<FoldingRangeOptions>(this as FoldingRangeOptions, _$identity);

  /// Serializes this FoldingRangeOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FoldingRangeOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'FoldingRangeOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $FoldingRangeOptionsCopyWith<$Res>  {
  factory $FoldingRangeOptionsCopyWith(FoldingRangeOptions value, $Res Function(FoldingRangeOptions) _then) = _$FoldingRangeOptionsCopyWithImpl;
@useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class _$FoldingRangeOptionsCopyWithImpl<$Res>
    implements $FoldingRangeOptionsCopyWith<$Res> {
  _$FoldingRangeOptionsCopyWithImpl(this._self, this._then);

  final FoldingRangeOptions _self;
  final $Res Function(FoldingRangeOptions) _then;

/// Create a copy of FoldingRangeOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _FoldingRangeOptions implements FoldingRangeOptions {
  const _FoldingRangeOptions({this.workDoneProgress});
  factory _FoldingRangeOptions.fromJson(Map<String, dynamic> json) => _$FoldingRangeOptionsFromJson(json);

@override final  bool? workDoneProgress;

/// Create a copy of FoldingRangeOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$FoldingRangeOptionsCopyWith<_FoldingRangeOptions> get copyWith => __$FoldingRangeOptionsCopyWithImpl<_FoldingRangeOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$FoldingRangeOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _FoldingRangeOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'FoldingRangeOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$FoldingRangeOptionsCopyWith<$Res> implements $FoldingRangeOptionsCopyWith<$Res> {
  factory _$FoldingRangeOptionsCopyWith(_FoldingRangeOptions value, $Res Function(_FoldingRangeOptions) _then) = __$FoldingRangeOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class __$FoldingRangeOptionsCopyWithImpl<$Res>
    implements _$FoldingRangeOptionsCopyWith<$Res> {
  __$FoldingRangeOptionsCopyWithImpl(this._self, this._then);

  final _FoldingRangeOptions _self;
  final $Res Function(_FoldingRangeOptions) _then;

/// Create a copy of FoldingRangeOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_FoldingRangeOptions(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DeclarationOptions {

 bool? get workDoneProgress;
/// Create a copy of DeclarationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DeclarationOptionsCopyWith<DeclarationOptions> get copyWith => _$DeclarationOptionsCopyWithImpl<DeclarationOptions>(this as DeclarationOptions, _$identity);

  /// Serializes this DeclarationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DeclarationOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'DeclarationOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $DeclarationOptionsCopyWith<$Res>  {
  factory $DeclarationOptionsCopyWith(DeclarationOptions value, $Res Function(DeclarationOptions) _then) = _$DeclarationOptionsCopyWithImpl;
@useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class _$DeclarationOptionsCopyWithImpl<$Res>
    implements $DeclarationOptionsCopyWith<$Res> {
  _$DeclarationOptionsCopyWithImpl(this._self, this._then);

  final DeclarationOptions _self;
  final $Res Function(DeclarationOptions) _then;

/// Create a copy of DeclarationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DeclarationOptions implements DeclarationOptions {
  const _DeclarationOptions({this.workDoneProgress});
  factory _DeclarationOptions.fromJson(Map<String, dynamic> json) => _$DeclarationOptionsFromJson(json);

@override final  bool? workDoneProgress;

/// Create a copy of DeclarationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DeclarationOptionsCopyWith<_DeclarationOptions> get copyWith => __$DeclarationOptionsCopyWithImpl<_DeclarationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DeclarationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DeclarationOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'DeclarationOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$DeclarationOptionsCopyWith<$Res> implements $DeclarationOptionsCopyWith<$Res> {
  factory _$DeclarationOptionsCopyWith(_DeclarationOptions value, $Res Function(_DeclarationOptions) _then) = __$DeclarationOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class __$DeclarationOptionsCopyWithImpl<$Res>
    implements _$DeclarationOptionsCopyWith<$Res> {
  __$DeclarationOptionsCopyWithImpl(this._self, this._then);

  final _DeclarationOptions _self;
  final $Res Function(_DeclarationOptions) _then;

/// Create a copy of DeclarationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_DeclarationOptions(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$Position {

/// Character offset on a line in a document (zero-based).
/// The meaning of this offset is determined by the negotiated
/// `PositionEncodingKind`.
/// If the character value is greater than the line length it defaults back
/// to the line length.
 int get character;/// Line position in a document (zero-based).
/// If a line number is greater than the number of lines in a document, it
/// defaults back to the number of lines in the document. If a line number
/// is negative, it defaults to 0.
 int get line;
/// Create a copy of Position
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$PositionCopyWith<Position> get copyWith => _$PositionCopyWithImpl<Position>(this as Position, _$identity);

  /// Serializes this Position to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Position&&(identical(other.character, character) || other.character == character)&&(identical(other.line, line) || other.line == line));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,character,line);

@override
String toString() {
  return 'Position(character: $character, line: $line)';
}


}

/// @nodoc
abstract mixin class $PositionCopyWith<$Res>  {
  factory $PositionCopyWith(Position value, $Res Function(Position) _then) = _$PositionCopyWithImpl;
@useResult
$Res call({
 int character, int line
});




}
/// @nodoc
class _$PositionCopyWithImpl<$Res>
    implements $PositionCopyWith<$Res> {
  _$PositionCopyWithImpl(this._self, this._then);

  final Position _self;
  final $Res Function(Position) _then;

/// Create a copy of Position
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? character = null,Object? line = null,}) {
  return _then(_self.copyWith(
character: null == character ? _self.character : character // ignore: cast_nullable_to_non_nullable
as int,line: null == line ? _self.line : line // ignore: cast_nullable_to_non_nullable
as int,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _Position implements Position {
  const _Position({required this.character, required this.line});
  factory _Position.fromJson(Map<String, dynamic> json) => _$PositionFromJson(json);

/// Character offset on a line in a document (zero-based).
/// The meaning of this offset is determined by the negotiated
/// `PositionEncodingKind`.
/// If the character value is greater than the line length it defaults back
/// to the line length.
@override final  int character;
/// Line position in a document (zero-based).
/// If a line number is greater than the number of lines in a document, it
/// defaults back to the number of lines in the document. If a line number
/// is negative, it defaults to 0.
@override final  int line;

/// Create a copy of Position
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$PositionCopyWith<_Position> get copyWith => __$PositionCopyWithImpl<_Position>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$PositionToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _Position&&(identical(other.character, character) || other.character == character)&&(identical(other.line, line) || other.line == line));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,character,line);

@override
String toString() {
  return 'Position(character: $character, line: $line)';
}


}

/// @nodoc
abstract mixin class _$PositionCopyWith<$Res> implements $PositionCopyWith<$Res> {
  factory _$PositionCopyWith(_Position value, $Res Function(_Position) _then) = __$PositionCopyWithImpl;
@override @useResult
$Res call({
 int character, int line
});




}
/// @nodoc
class __$PositionCopyWithImpl<$Res>
    implements _$PositionCopyWith<$Res> {
  __$PositionCopyWithImpl(this._self, this._then);

  final _Position _self;
  final $Res Function(_Position) _then;

/// Create a copy of Position
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? character = null,Object? line = null,}) {
  return _then(_Position(
character: null == character ? _self.character : character // ignore: cast_nullable_to_non_nullable
as int,line: null == line ? _self.line : line // ignore: cast_nullable_to_non_nullable
as int,
  ));
}


}


/// @nodoc
mixin _$SelectionRangeOptions {

 bool? get workDoneProgress;
/// Create a copy of SelectionRangeOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SelectionRangeOptionsCopyWith<SelectionRangeOptions> get copyWith => _$SelectionRangeOptionsCopyWithImpl<SelectionRangeOptions>(this as SelectionRangeOptions, _$identity);

  /// Serializes this SelectionRangeOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SelectionRangeOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'SelectionRangeOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $SelectionRangeOptionsCopyWith<$Res>  {
  factory $SelectionRangeOptionsCopyWith(SelectionRangeOptions value, $Res Function(SelectionRangeOptions) _then) = _$SelectionRangeOptionsCopyWithImpl;
@useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class _$SelectionRangeOptionsCopyWithImpl<$Res>
    implements $SelectionRangeOptionsCopyWith<$Res> {
  _$SelectionRangeOptionsCopyWithImpl(this._self, this._then);

  final SelectionRangeOptions _self;
  final $Res Function(SelectionRangeOptions) _then;

/// Create a copy of SelectionRangeOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _SelectionRangeOptions implements SelectionRangeOptions {
  const _SelectionRangeOptions({this.workDoneProgress});
  factory _SelectionRangeOptions.fromJson(Map<String, dynamic> json) => _$SelectionRangeOptionsFromJson(json);

@override final  bool? workDoneProgress;

/// Create a copy of SelectionRangeOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SelectionRangeOptionsCopyWith<_SelectionRangeOptions> get copyWith => __$SelectionRangeOptionsCopyWithImpl<_SelectionRangeOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SelectionRangeOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SelectionRangeOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'SelectionRangeOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$SelectionRangeOptionsCopyWith<$Res> implements $SelectionRangeOptionsCopyWith<$Res> {
  factory _$SelectionRangeOptionsCopyWith(_SelectionRangeOptions value, $Res Function(_SelectionRangeOptions) _then) = __$SelectionRangeOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class __$SelectionRangeOptionsCopyWithImpl<$Res>
    implements _$SelectionRangeOptionsCopyWith<$Res> {
  __$SelectionRangeOptionsCopyWithImpl(this._self, this._then);

  final _SelectionRangeOptions _self;
  final $Res Function(_SelectionRangeOptions) _then;

/// Create a copy of SelectionRangeOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_SelectionRangeOptions(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$CallHierarchyOptions {

 bool? get workDoneProgress;
/// Create a copy of CallHierarchyOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CallHierarchyOptionsCopyWith<CallHierarchyOptions> get copyWith => _$CallHierarchyOptionsCopyWithImpl<CallHierarchyOptions>(this as CallHierarchyOptions, _$identity);

  /// Serializes this CallHierarchyOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CallHierarchyOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'CallHierarchyOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $CallHierarchyOptionsCopyWith<$Res>  {
  factory $CallHierarchyOptionsCopyWith(CallHierarchyOptions value, $Res Function(CallHierarchyOptions) _then) = _$CallHierarchyOptionsCopyWithImpl;
@useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class _$CallHierarchyOptionsCopyWithImpl<$Res>
    implements $CallHierarchyOptionsCopyWith<$Res> {
  _$CallHierarchyOptionsCopyWithImpl(this._self, this._then);

  final CallHierarchyOptions _self;
  final $Res Function(CallHierarchyOptions) _then;

/// Create a copy of CallHierarchyOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _CallHierarchyOptions implements CallHierarchyOptions {
  const _CallHierarchyOptions({this.workDoneProgress});
  factory _CallHierarchyOptions.fromJson(Map<String, dynamic> json) => _$CallHierarchyOptionsFromJson(json);

@override final  bool? workDoneProgress;

/// Create a copy of CallHierarchyOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CallHierarchyOptionsCopyWith<_CallHierarchyOptions> get copyWith => __$CallHierarchyOptionsCopyWithImpl<_CallHierarchyOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CallHierarchyOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CallHierarchyOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'CallHierarchyOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$CallHierarchyOptionsCopyWith<$Res> implements $CallHierarchyOptionsCopyWith<$Res> {
  factory _$CallHierarchyOptionsCopyWith(_CallHierarchyOptions value, $Res Function(_CallHierarchyOptions) _then) = __$CallHierarchyOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class __$CallHierarchyOptionsCopyWithImpl<$Res>
    implements _$CallHierarchyOptionsCopyWith<$Res> {
  __$CallHierarchyOptionsCopyWithImpl(this._self, this._then);

  final _CallHierarchyOptions _self;
  final $Res Function(_CallHierarchyOptions) _then;

/// Create a copy of CallHierarchyOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_CallHierarchyOptions(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$SemanticTokensOptions {

/// Server supports providing semantic tokens for a full document.
 Sealed26? get full;/// The legend used by the server
 SemanticTokensLegend get legend;/// Server supports providing semantic tokens for a specific range of a
/// document.
 Sealed25? get range; bool? get workDoneProgress;
/// Create a copy of SemanticTokensOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SemanticTokensOptionsCopyWith<SemanticTokensOptions> get copyWith => _$SemanticTokensOptionsCopyWithImpl<SemanticTokensOptions>(this as SemanticTokensOptions, _$identity);

  /// Serializes this SemanticTokensOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SemanticTokensOptions&&(identical(other.full, full) || other.full == full)&&(identical(other.legend, legend) || other.legend == legend)&&(identical(other.range, range) || other.range == range)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,full,legend,range,workDoneProgress);

@override
String toString() {
  return 'SemanticTokensOptions(full: $full, legend: $legend, range: $range, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $SemanticTokensOptionsCopyWith<$Res>  {
  factory $SemanticTokensOptionsCopyWith(SemanticTokensOptions value, $Res Function(SemanticTokensOptions) _then) = _$SemanticTokensOptionsCopyWithImpl;
@useResult
$Res call({
 Sealed26? full, SemanticTokensLegend legend, Sealed25? range, bool? workDoneProgress
});


$SemanticTokensLegendCopyWith<$Res> get legend;

}
/// @nodoc
class _$SemanticTokensOptionsCopyWithImpl<$Res>
    implements $SemanticTokensOptionsCopyWith<$Res> {
  _$SemanticTokensOptionsCopyWithImpl(this._self, this._then);

  final SemanticTokensOptions _self;
  final $Res Function(SemanticTokensOptions) _then;

/// Create a copy of SemanticTokensOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? full = freezed,Object? legend = null,Object? range = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
full: freezed == full ? _self.full : full // ignore: cast_nullable_to_non_nullable
as Sealed26?,legend: null == legend ? _self.legend : legend // ignore: cast_nullable_to_non_nullable
as SemanticTokensLegend,range: freezed == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Sealed25?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}
/// Create a copy of SemanticTokensOptions
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SemanticTokensLegendCopyWith<$Res> get legend {
  
  return $SemanticTokensLegendCopyWith<$Res>(_self.legend, (value) {
    return _then(_self.copyWith(legend: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _SemanticTokensOptions implements SemanticTokensOptions {
  const _SemanticTokensOptions({this.full, required this.legend, this.range, this.workDoneProgress});
  factory _SemanticTokensOptions.fromJson(Map<String, dynamic> json) => _$SemanticTokensOptionsFromJson(json);

/// Server supports providing semantic tokens for a full document.
@override final  Sealed26? full;
/// The legend used by the server
@override final  SemanticTokensLegend legend;
/// Server supports providing semantic tokens for a specific range of a
/// document.
@override final  Sealed25? range;
@override final  bool? workDoneProgress;

/// Create a copy of SemanticTokensOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SemanticTokensOptionsCopyWith<_SemanticTokensOptions> get copyWith => __$SemanticTokensOptionsCopyWithImpl<_SemanticTokensOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SemanticTokensOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SemanticTokensOptions&&(identical(other.full, full) || other.full == full)&&(identical(other.legend, legend) || other.legend == legend)&&(identical(other.range, range) || other.range == range)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,full,legend,range,workDoneProgress);

@override
String toString() {
  return 'SemanticTokensOptions(full: $full, legend: $legend, range: $range, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$SemanticTokensOptionsCopyWith<$Res> implements $SemanticTokensOptionsCopyWith<$Res> {
  factory _$SemanticTokensOptionsCopyWith(_SemanticTokensOptions value, $Res Function(_SemanticTokensOptions) _then) = __$SemanticTokensOptionsCopyWithImpl;
@override @useResult
$Res call({
 Sealed26? full, SemanticTokensLegend legend, Sealed25? range, bool? workDoneProgress
});


@override $SemanticTokensLegendCopyWith<$Res> get legend;

}
/// @nodoc
class __$SemanticTokensOptionsCopyWithImpl<$Res>
    implements _$SemanticTokensOptionsCopyWith<$Res> {
  __$SemanticTokensOptionsCopyWithImpl(this._self, this._then);

  final _SemanticTokensOptions _self;
  final $Res Function(_SemanticTokensOptions) _then;

/// Create a copy of SemanticTokensOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? full = freezed,Object? legend = null,Object? range = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_SemanticTokensOptions(
full: freezed == full ? _self.full : full // ignore: cast_nullable_to_non_nullable
as Sealed26?,legend: null == legend ? _self.legend : legend // ignore: cast_nullable_to_non_nullable
as SemanticTokensLegend,range: freezed == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Sealed25?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

/// Create a copy of SemanticTokensOptions
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SemanticTokensLegendCopyWith<$Res> get legend {
  
  return $SemanticTokensLegendCopyWith<$Res>(_self.legend, (value) {
    return _then(_self.copyWith(legend: value));
  });
}
}


/// @nodoc
mixin _$SemanticTokensEdit {

/// The elements to insert.
 List<int>? get data;/// The count of elements to remove.
 int get deleteCount;/// The start offset of the edit.
 int get start;
/// Create a copy of SemanticTokensEdit
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SemanticTokensEditCopyWith<SemanticTokensEdit> get copyWith => _$SemanticTokensEditCopyWithImpl<SemanticTokensEdit>(this as SemanticTokensEdit, _$identity);

  /// Serializes this SemanticTokensEdit to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SemanticTokensEdit&&const DeepCollectionEquality().equals(other.data, data)&&(identical(other.deleteCount, deleteCount) || other.deleteCount == deleteCount)&&(identical(other.start, start) || other.start == start));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(data),deleteCount,start);

@override
String toString() {
  return 'SemanticTokensEdit(data: $data, deleteCount: $deleteCount, start: $start)';
}


}

/// @nodoc
abstract mixin class $SemanticTokensEditCopyWith<$Res>  {
  factory $SemanticTokensEditCopyWith(SemanticTokensEdit value, $Res Function(SemanticTokensEdit) _then) = _$SemanticTokensEditCopyWithImpl;
@useResult
$Res call({
 List<int>? data, int deleteCount, int start
});




}
/// @nodoc
class _$SemanticTokensEditCopyWithImpl<$Res>
    implements $SemanticTokensEditCopyWith<$Res> {
  _$SemanticTokensEditCopyWithImpl(this._self, this._then);

  final SemanticTokensEdit _self;
  final $Res Function(SemanticTokensEdit) _then;

/// Create a copy of SemanticTokensEdit
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? data = freezed,Object? deleteCount = null,Object? start = null,}) {
  return _then(_self.copyWith(
data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as List<int>?,deleteCount: null == deleteCount ? _self.deleteCount : deleteCount // ignore: cast_nullable_to_non_nullable
as int,start: null == start ? _self.start : start // ignore: cast_nullable_to_non_nullable
as int,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _SemanticTokensEdit implements SemanticTokensEdit {
  const _SemanticTokensEdit({final  List<int>? data, required this.deleteCount, required this.start}): _data = data;
  factory _SemanticTokensEdit.fromJson(Map<String, dynamic> json) => _$SemanticTokensEditFromJson(json);

/// The elements to insert.
 final  List<int>? _data;
/// The elements to insert.
@override List<int>? get data {
  final value = _data;
  if (value == null) return null;
  if (_data is EqualUnmodifiableListView) return _data;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

/// The count of elements to remove.
@override final  int deleteCount;
/// The start offset of the edit.
@override final  int start;

/// Create a copy of SemanticTokensEdit
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SemanticTokensEditCopyWith<_SemanticTokensEdit> get copyWith => __$SemanticTokensEditCopyWithImpl<_SemanticTokensEdit>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SemanticTokensEditToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SemanticTokensEdit&&const DeepCollectionEquality().equals(other._data, _data)&&(identical(other.deleteCount, deleteCount) || other.deleteCount == deleteCount)&&(identical(other.start, start) || other.start == start));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_data),deleteCount,start);

@override
String toString() {
  return 'SemanticTokensEdit(data: $data, deleteCount: $deleteCount, start: $start)';
}


}

/// @nodoc
abstract mixin class _$SemanticTokensEditCopyWith<$Res> implements $SemanticTokensEditCopyWith<$Res> {
  factory _$SemanticTokensEditCopyWith(_SemanticTokensEdit value, $Res Function(_SemanticTokensEdit) _then) = __$SemanticTokensEditCopyWithImpl;
@override @useResult
$Res call({
 List<int>? data, int deleteCount, int start
});




}
/// @nodoc
class __$SemanticTokensEditCopyWithImpl<$Res>
    implements _$SemanticTokensEditCopyWith<$Res> {
  __$SemanticTokensEditCopyWithImpl(this._self, this._then);

  final _SemanticTokensEdit _self;
  final $Res Function(_SemanticTokensEdit) _then;

/// Create a copy of SemanticTokensEdit
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? data = freezed,Object? deleteCount = null,Object? start = null,}) {
  return _then(_SemanticTokensEdit(
data: freezed == data ? _self._data : data // ignore: cast_nullable_to_non_nullable
as List<int>?,deleteCount: null == deleteCount ? _self.deleteCount : deleteCount // ignore: cast_nullable_to_non_nullable
as int,start: null == start ? _self.start : start // ignore: cast_nullable_to_non_nullable
as int,
  ));
}


}


/// @nodoc
mixin _$LinkedEditingRangeOptions {

 bool? get workDoneProgress;
/// Create a copy of LinkedEditingRangeOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LinkedEditingRangeOptionsCopyWith<LinkedEditingRangeOptions> get copyWith => _$LinkedEditingRangeOptionsCopyWithImpl<LinkedEditingRangeOptions>(this as LinkedEditingRangeOptions, _$identity);

  /// Serializes this LinkedEditingRangeOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LinkedEditingRangeOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'LinkedEditingRangeOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $LinkedEditingRangeOptionsCopyWith<$Res>  {
  factory $LinkedEditingRangeOptionsCopyWith(LinkedEditingRangeOptions value, $Res Function(LinkedEditingRangeOptions) _then) = _$LinkedEditingRangeOptionsCopyWithImpl;
@useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class _$LinkedEditingRangeOptionsCopyWithImpl<$Res>
    implements $LinkedEditingRangeOptionsCopyWith<$Res> {
  _$LinkedEditingRangeOptionsCopyWithImpl(this._self, this._then);

  final LinkedEditingRangeOptions _self;
  final $Res Function(LinkedEditingRangeOptions) _then;

/// Create a copy of LinkedEditingRangeOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _LinkedEditingRangeOptions implements LinkedEditingRangeOptions {
  const _LinkedEditingRangeOptions({this.workDoneProgress});
  factory _LinkedEditingRangeOptions.fromJson(Map<String, dynamic> json) => _$LinkedEditingRangeOptionsFromJson(json);

@override final  bool? workDoneProgress;

/// Create a copy of LinkedEditingRangeOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$LinkedEditingRangeOptionsCopyWith<_LinkedEditingRangeOptions> get copyWith => __$LinkedEditingRangeOptionsCopyWithImpl<_LinkedEditingRangeOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$LinkedEditingRangeOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _LinkedEditingRangeOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'LinkedEditingRangeOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$LinkedEditingRangeOptionsCopyWith<$Res> implements $LinkedEditingRangeOptionsCopyWith<$Res> {
  factory _$LinkedEditingRangeOptionsCopyWith(_LinkedEditingRangeOptions value, $Res Function(_LinkedEditingRangeOptions) _then) = __$LinkedEditingRangeOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class __$LinkedEditingRangeOptionsCopyWithImpl<$Res>
    implements _$LinkedEditingRangeOptionsCopyWith<$Res> {
  __$LinkedEditingRangeOptionsCopyWithImpl(this._self, this._then);

  final _LinkedEditingRangeOptions _self;
  final $Res Function(_LinkedEditingRangeOptions) _then;

/// Create a copy of LinkedEditingRangeOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_LinkedEditingRangeOptions(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$FileCreate {

/// A file:// URI for the location of the file/folder being created.
 String get uri;
/// Create a copy of FileCreate
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FileCreateCopyWith<FileCreate> get copyWith => _$FileCreateCopyWithImpl<FileCreate>(this as FileCreate, _$identity);

  /// Serializes this FileCreate to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FileCreate&&(identical(other.uri, uri) || other.uri == uri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri);

@override
String toString() {
  return 'FileCreate(uri: $uri)';
}


}

/// @nodoc
abstract mixin class $FileCreateCopyWith<$Res>  {
  factory $FileCreateCopyWith(FileCreate value, $Res Function(FileCreate) _then) = _$FileCreateCopyWithImpl;
@useResult
$Res call({
 String uri
});




}
/// @nodoc
class _$FileCreateCopyWithImpl<$Res>
    implements $FileCreateCopyWith<$Res> {
  _$FileCreateCopyWithImpl(this._self, this._then);

  final FileCreate _self;
  final $Res Function(FileCreate) _then;

/// Create a copy of FileCreate
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? uri = null,}) {
  return _then(_self.copyWith(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _FileCreate implements FileCreate {
  const _FileCreate({required this.uri});
  factory _FileCreate.fromJson(Map<String, dynamic> json) => _$FileCreateFromJson(json);

/// A file:// URI for the location of the file/folder being created.
@override final  String uri;

/// Create a copy of FileCreate
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$FileCreateCopyWith<_FileCreate> get copyWith => __$FileCreateCopyWithImpl<_FileCreate>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$FileCreateToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _FileCreate&&(identical(other.uri, uri) || other.uri == uri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri);

@override
String toString() {
  return 'FileCreate(uri: $uri)';
}


}

/// @nodoc
abstract mixin class _$FileCreateCopyWith<$Res> implements $FileCreateCopyWith<$Res> {
  factory _$FileCreateCopyWith(_FileCreate value, $Res Function(_FileCreate) _then) = __$FileCreateCopyWithImpl;
@override @useResult
$Res call({
 String uri
});




}
/// @nodoc
class __$FileCreateCopyWithImpl<$Res>
    implements _$FileCreateCopyWith<$Res> {
  __$FileCreateCopyWithImpl(this._self, this._then);

  final _FileCreate _self;
  final $Res Function(_FileCreate) _then;

/// Create a copy of FileCreate
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? uri = null,}) {
  return _then(_FileCreate(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}


/// @nodoc
mixin _$TextDocumentEdit {

/// The edits to be applied.
/// @since 3.16.0 - support for AnnotatedTextEdit. This is guarded using a
/// client capability.
 List<Sealed27> get edits;/// The text document to change.
 OptionalVersionedTextDocumentIdentifier get textDocument;
/// Create a copy of TextDocumentEdit
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TextDocumentEditCopyWith<TextDocumentEdit> get copyWith => _$TextDocumentEditCopyWithImpl<TextDocumentEdit>(this as TextDocumentEdit, _$identity);

  /// Serializes this TextDocumentEdit to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TextDocumentEdit&&const DeepCollectionEquality().equals(other.edits, edits)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(edits),textDocument);

@override
String toString() {
  return 'TextDocumentEdit(edits: $edits, textDocument: $textDocument)';
}


}

/// @nodoc
abstract mixin class $TextDocumentEditCopyWith<$Res>  {
  factory $TextDocumentEditCopyWith(TextDocumentEdit value, $Res Function(TextDocumentEdit) _then) = _$TextDocumentEditCopyWithImpl;
@useResult
$Res call({
 List<Sealed27> edits, OptionalVersionedTextDocumentIdentifier textDocument
});


$OptionalVersionedTextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class _$TextDocumentEditCopyWithImpl<$Res>
    implements $TextDocumentEditCopyWith<$Res> {
  _$TextDocumentEditCopyWithImpl(this._self, this._then);

  final TextDocumentEdit _self;
  final $Res Function(TextDocumentEdit) _then;

/// Create a copy of TextDocumentEdit
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? edits = null,Object? textDocument = null,}) {
  return _then(_self.copyWith(
edits: null == edits ? _self.edits : edits // ignore: cast_nullable_to_non_nullable
as List<Sealed27>,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as OptionalVersionedTextDocumentIdentifier,
  ));
}
/// Create a copy of TextDocumentEdit
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$OptionalVersionedTextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $OptionalVersionedTextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _TextDocumentEdit implements TextDocumentEdit {
  const _TextDocumentEdit({required final  List<Sealed27> edits, required this.textDocument}): _edits = edits;
  factory _TextDocumentEdit.fromJson(Map<String, dynamic> json) => _$TextDocumentEditFromJson(json);

/// The edits to be applied.
/// @since 3.16.0 - support for AnnotatedTextEdit. This is guarded using a
/// client capability.
 final  List<Sealed27> _edits;
/// The edits to be applied.
/// @since 3.16.0 - support for AnnotatedTextEdit. This is guarded using a
/// client capability.
@override List<Sealed27> get edits {
  if (_edits is EqualUnmodifiableListView) return _edits;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_edits);
}

/// The text document to change.
@override final  OptionalVersionedTextDocumentIdentifier textDocument;

/// Create a copy of TextDocumentEdit
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TextDocumentEditCopyWith<_TextDocumentEdit> get copyWith => __$TextDocumentEditCopyWithImpl<_TextDocumentEdit>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TextDocumentEditToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TextDocumentEdit&&const DeepCollectionEquality().equals(other._edits, _edits)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_edits),textDocument);

@override
String toString() {
  return 'TextDocumentEdit(edits: $edits, textDocument: $textDocument)';
}


}

/// @nodoc
abstract mixin class _$TextDocumentEditCopyWith<$Res> implements $TextDocumentEditCopyWith<$Res> {
  factory _$TextDocumentEditCopyWith(_TextDocumentEdit value, $Res Function(_TextDocumentEdit) _then) = __$TextDocumentEditCopyWithImpl;
@override @useResult
$Res call({
 List<Sealed27> edits, OptionalVersionedTextDocumentIdentifier textDocument
});


@override $OptionalVersionedTextDocumentIdentifierCopyWith<$Res> get textDocument;

}
/// @nodoc
class __$TextDocumentEditCopyWithImpl<$Res>
    implements _$TextDocumentEditCopyWith<$Res> {
  __$TextDocumentEditCopyWithImpl(this._self, this._then);

  final _TextDocumentEdit _self;
  final $Res Function(_TextDocumentEdit) _then;

/// Create a copy of TextDocumentEdit
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? edits = null,Object? textDocument = null,}) {
  return _then(_TextDocumentEdit(
edits: null == edits ? _self._edits : edits // ignore: cast_nullable_to_non_nullable
as List<Sealed27>,textDocument: null == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as OptionalVersionedTextDocumentIdentifier,
  ));
}

/// Create a copy of TextDocumentEdit
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$OptionalVersionedTextDocumentIdentifierCopyWith<$Res> get textDocument {
  
  return $OptionalVersionedTextDocumentIdentifierCopyWith<$Res>(_self.textDocument, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}
}


/// @nodoc
mixin _$CreateFile {

/// An optional annotation identifier describing the operation.
/// @since 3.16.0
 ChangeAnnotationIdentifier? get annotationId;/// A create
 StringLiteralRef get kind;/// Additional options
 CreateFileOptions? get options;/// The resource to create.
 String get uri;
/// Create a copy of CreateFile
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CreateFileCopyWith<CreateFile> get copyWith => _$CreateFileCopyWithImpl<CreateFile>(this as CreateFile, _$identity);

  /// Serializes this CreateFile to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CreateFile&&(identical(other.annotationId, annotationId) || other.annotationId == annotationId)&&const DeepCollectionEquality().equals(other.kind, kind)&&(identical(other.options, options) || other.options == options)&&(identical(other.uri, uri) || other.uri == uri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,annotationId,const DeepCollectionEquality().hash(kind),options,uri);

@override
String toString() {
  return 'CreateFile(annotationId: $annotationId, kind: $kind, options: $options, uri: $uri)';
}


}

/// @nodoc
abstract mixin class $CreateFileCopyWith<$Res>  {
  factory $CreateFileCopyWith(CreateFile value, $Res Function(CreateFile) _then) = _$CreateFileCopyWithImpl;
@useResult
$Res call({
 ChangeAnnotationIdentifier? annotationId, StringLiteralRef kind, CreateFileOptions? options, String uri
});


$CreateFileOptionsCopyWith<$Res>? get options;

}
/// @nodoc
class _$CreateFileCopyWithImpl<$Res>
    implements $CreateFileCopyWith<$Res> {
  _$CreateFileCopyWithImpl(this._self, this._then);

  final CreateFile _self;
  final $Res Function(CreateFile) _then;

/// Create a copy of CreateFile
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? annotationId = freezed,Object? kind = freezed,Object? options = freezed,Object? uri = null,}) {
  return _then(_self.copyWith(
annotationId: freezed == annotationId ? _self.annotationId : annotationId // ignore: cast_nullable_to_non_nullable
as ChangeAnnotationIdentifier?,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as StringLiteralRef,options: freezed == options ? _self.options : options // ignore: cast_nullable_to_non_nullable
as CreateFileOptions?,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}
/// Create a copy of CreateFile
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CreateFileOptionsCopyWith<$Res>? get options {
    if (_self.options == null) {
    return null;
  }

  return $CreateFileOptionsCopyWith<$Res>(_self.options!, (value) {
    return _then(_self.copyWith(options: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _CreateFile implements CreateFile {
  const _CreateFile({this.annotationId, required this.kind, this.options, required this.uri});
  factory _CreateFile.fromJson(Map<String, dynamic> json) => _$CreateFileFromJson(json);

/// An optional annotation identifier describing the operation.
/// @since 3.16.0
@override final  ChangeAnnotationIdentifier? annotationId;
/// A create
@override final  StringLiteralRef kind;
/// Additional options
@override final  CreateFileOptions? options;
/// The resource to create.
@override final  String uri;

/// Create a copy of CreateFile
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CreateFileCopyWith<_CreateFile> get copyWith => __$CreateFileCopyWithImpl<_CreateFile>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CreateFileToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CreateFile&&(identical(other.annotationId, annotationId) || other.annotationId == annotationId)&&const DeepCollectionEquality().equals(other.kind, kind)&&(identical(other.options, options) || other.options == options)&&(identical(other.uri, uri) || other.uri == uri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,annotationId,const DeepCollectionEquality().hash(kind),options,uri);

@override
String toString() {
  return 'CreateFile(annotationId: $annotationId, kind: $kind, options: $options, uri: $uri)';
}


}

/// @nodoc
abstract mixin class _$CreateFileCopyWith<$Res> implements $CreateFileCopyWith<$Res> {
  factory _$CreateFileCopyWith(_CreateFile value, $Res Function(_CreateFile) _then) = __$CreateFileCopyWithImpl;
@override @useResult
$Res call({
 ChangeAnnotationIdentifier? annotationId, StringLiteralRef kind, CreateFileOptions? options, String uri
});


@override $CreateFileOptionsCopyWith<$Res>? get options;

}
/// @nodoc
class __$CreateFileCopyWithImpl<$Res>
    implements _$CreateFileCopyWith<$Res> {
  __$CreateFileCopyWithImpl(this._self, this._then);

  final _CreateFile _self;
  final $Res Function(_CreateFile) _then;

/// Create a copy of CreateFile
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? annotationId = freezed,Object? kind = freezed,Object? options = freezed,Object? uri = null,}) {
  return _then(_CreateFile(
annotationId: freezed == annotationId ? _self.annotationId : annotationId // ignore: cast_nullable_to_non_nullable
as ChangeAnnotationIdentifier?,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as StringLiteralRef,options: freezed == options ? _self.options : options // ignore: cast_nullable_to_non_nullable
as CreateFileOptions?,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

/// Create a copy of CreateFile
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CreateFileOptionsCopyWith<$Res>? get options {
    if (_self.options == null) {
    return null;
  }

  return $CreateFileOptionsCopyWith<$Res>(_self.options!, (value) {
    return _then(_self.copyWith(options: value));
  });
}
}


/// @nodoc
mixin _$RenameFile {

/// An optional annotation identifier describing the operation.
/// @since 3.16.0
 ChangeAnnotationIdentifier? get annotationId;/// A rename
 StringLiteralRef get kind;/// The new location.
 String get newUri;/// The old (existing) location.
 String get oldUri;/// Rename options.
 RenameFileOptions? get options;
/// Create a copy of RenameFile
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RenameFileCopyWith<RenameFile> get copyWith => _$RenameFileCopyWithImpl<RenameFile>(this as RenameFile, _$identity);

  /// Serializes this RenameFile to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RenameFile&&(identical(other.annotationId, annotationId) || other.annotationId == annotationId)&&const DeepCollectionEquality().equals(other.kind, kind)&&(identical(other.newUri, newUri) || other.newUri == newUri)&&(identical(other.oldUri, oldUri) || other.oldUri == oldUri)&&(identical(other.options, options) || other.options == options));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,annotationId,const DeepCollectionEquality().hash(kind),newUri,oldUri,options);

@override
String toString() {
  return 'RenameFile(annotationId: $annotationId, kind: $kind, newUri: $newUri, oldUri: $oldUri, options: $options)';
}


}

/// @nodoc
abstract mixin class $RenameFileCopyWith<$Res>  {
  factory $RenameFileCopyWith(RenameFile value, $Res Function(RenameFile) _then) = _$RenameFileCopyWithImpl;
@useResult
$Res call({
 ChangeAnnotationIdentifier? annotationId, StringLiteralRef kind, String newUri, String oldUri, RenameFileOptions? options
});


$RenameFileOptionsCopyWith<$Res>? get options;

}
/// @nodoc
class _$RenameFileCopyWithImpl<$Res>
    implements $RenameFileCopyWith<$Res> {
  _$RenameFileCopyWithImpl(this._self, this._then);

  final RenameFile _self;
  final $Res Function(RenameFile) _then;

/// Create a copy of RenameFile
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? annotationId = freezed,Object? kind = freezed,Object? newUri = null,Object? oldUri = null,Object? options = freezed,}) {
  return _then(_self.copyWith(
annotationId: freezed == annotationId ? _self.annotationId : annotationId // ignore: cast_nullable_to_non_nullable
as ChangeAnnotationIdentifier?,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as StringLiteralRef,newUri: null == newUri ? _self.newUri : newUri // ignore: cast_nullable_to_non_nullable
as String,oldUri: null == oldUri ? _self.oldUri : oldUri // ignore: cast_nullable_to_non_nullable
as String,options: freezed == options ? _self.options : options // ignore: cast_nullable_to_non_nullable
as RenameFileOptions?,
  ));
}
/// Create a copy of RenameFile
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RenameFileOptionsCopyWith<$Res>? get options {
    if (_self.options == null) {
    return null;
  }

  return $RenameFileOptionsCopyWith<$Res>(_self.options!, (value) {
    return _then(_self.copyWith(options: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _RenameFile implements RenameFile {
  const _RenameFile({this.annotationId, required this.kind, required this.newUri, required this.oldUri, this.options});
  factory _RenameFile.fromJson(Map<String, dynamic> json) => _$RenameFileFromJson(json);

/// An optional annotation identifier describing the operation.
/// @since 3.16.0
@override final  ChangeAnnotationIdentifier? annotationId;
/// A rename
@override final  StringLiteralRef kind;
/// The new location.
@override final  String newUri;
/// The old (existing) location.
@override final  String oldUri;
/// Rename options.
@override final  RenameFileOptions? options;

/// Create a copy of RenameFile
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RenameFileCopyWith<_RenameFile> get copyWith => __$RenameFileCopyWithImpl<_RenameFile>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$RenameFileToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _RenameFile&&(identical(other.annotationId, annotationId) || other.annotationId == annotationId)&&const DeepCollectionEquality().equals(other.kind, kind)&&(identical(other.newUri, newUri) || other.newUri == newUri)&&(identical(other.oldUri, oldUri) || other.oldUri == oldUri)&&(identical(other.options, options) || other.options == options));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,annotationId,const DeepCollectionEquality().hash(kind),newUri,oldUri,options);

@override
String toString() {
  return 'RenameFile(annotationId: $annotationId, kind: $kind, newUri: $newUri, oldUri: $oldUri, options: $options)';
}


}

/// @nodoc
abstract mixin class _$RenameFileCopyWith<$Res> implements $RenameFileCopyWith<$Res> {
  factory _$RenameFileCopyWith(_RenameFile value, $Res Function(_RenameFile) _then) = __$RenameFileCopyWithImpl;
@override @useResult
$Res call({
 ChangeAnnotationIdentifier? annotationId, StringLiteralRef kind, String newUri, String oldUri, RenameFileOptions? options
});


@override $RenameFileOptionsCopyWith<$Res>? get options;

}
/// @nodoc
class __$RenameFileCopyWithImpl<$Res>
    implements _$RenameFileCopyWith<$Res> {
  __$RenameFileCopyWithImpl(this._self, this._then);

  final _RenameFile _self;
  final $Res Function(_RenameFile) _then;

/// Create a copy of RenameFile
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? annotationId = freezed,Object? kind = freezed,Object? newUri = null,Object? oldUri = null,Object? options = freezed,}) {
  return _then(_RenameFile(
annotationId: freezed == annotationId ? _self.annotationId : annotationId // ignore: cast_nullable_to_non_nullable
as ChangeAnnotationIdentifier?,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as StringLiteralRef,newUri: null == newUri ? _self.newUri : newUri // ignore: cast_nullable_to_non_nullable
as String,oldUri: null == oldUri ? _self.oldUri : oldUri // ignore: cast_nullable_to_non_nullable
as String,options: freezed == options ? _self.options : options // ignore: cast_nullable_to_non_nullable
as RenameFileOptions?,
  ));
}

/// Create a copy of RenameFile
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RenameFileOptionsCopyWith<$Res>? get options {
    if (_self.options == null) {
    return null;
  }

  return $RenameFileOptionsCopyWith<$Res>(_self.options!, (value) {
    return _then(_self.copyWith(options: value));
  });
}
}


/// @nodoc
mixin _$DeleteFile {

/// An optional annotation identifier describing the operation.
/// @since 3.16.0
 ChangeAnnotationIdentifier? get annotationId;/// A delete
 StringLiteralRef get kind;/// Delete options.
 DeleteFileOptions? get options;/// The file to delete.
 String get uri;
/// Create a copy of DeleteFile
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DeleteFileCopyWith<DeleteFile> get copyWith => _$DeleteFileCopyWithImpl<DeleteFile>(this as DeleteFile, _$identity);

  /// Serializes this DeleteFile to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DeleteFile&&(identical(other.annotationId, annotationId) || other.annotationId == annotationId)&&const DeepCollectionEquality().equals(other.kind, kind)&&(identical(other.options, options) || other.options == options)&&(identical(other.uri, uri) || other.uri == uri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,annotationId,const DeepCollectionEquality().hash(kind),options,uri);

@override
String toString() {
  return 'DeleteFile(annotationId: $annotationId, kind: $kind, options: $options, uri: $uri)';
}


}

/// @nodoc
abstract mixin class $DeleteFileCopyWith<$Res>  {
  factory $DeleteFileCopyWith(DeleteFile value, $Res Function(DeleteFile) _then) = _$DeleteFileCopyWithImpl;
@useResult
$Res call({
 ChangeAnnotationIdentifier? annotationId, StringLiteralRef kind, DeleteFileOptions? options, String uri
});


$DeleteFileOptionsCopyWith<$Res>? get options;

}
/// @nodoc
class _$DeleteFileCopyWithImpl<$Res>
    implements $DeleteFileCopyWith<$Res> {
  _$DeleteFileCopyWithImpl(this._self, this._then);

  final DeleteFile _self;
  final $Res Function(DeleteFile) _then;

/// Create a copy of DeleteFile
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? annotationId = freezed,Object? kind = freezed,Object? options = freezed,Object? uri = null,}) {
  return _then(_self.copyWith(
annotationId: freezed == annotationId ? _self.annotationId : annotationId // ignore: cast_nullable_to_non_nullable
as ChangeAnnotationIdentifier?,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as StringLiteralRef,options: freezed == options ? _self.options : options // ignore: cast_nullable_to_non_nullable
as DeleteFileOptions?,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}
/// Create a copy of DeleteFile
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DeleteFileOptionsCopyWith<$Res>? get options {
    if (_self.options == null) {
    return null;
  }

  return $DeleteFileOptionsCopyWith<$Res>(_self.options!, (value) {
    return _then(_self.copyWith(options: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _DeleteFile implements DeleteFile {
  const _DeleteFile({this.annotationId, required this.kind, this.options, required this.uri});
  factory _DeleteFile.fromJson(Map<String, dynamic> json) => _$DeleteFileFromJson(json);

/// An optional annotation identifier describing the operation.
/// @since 3.16.0
@override final  ChangeAnnotationIdentifier? annotationId;
/// A delete
@override final  StringLiteralRef kind;
/// Delete options.
@override final  DeleteFileOptions? options;
/// The file to delete.
@override final  String uri;

/// Create a copy of DeleteFile
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DeleteFileCopyWith<_DeleteFile> get copyWith => __$DeleteFileCopyWithImpl<_DeleteFile>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DeleteFileToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DeleteFile&&(identical(other.annotationId, annotationId) || other.annotationId == annotationId)&&const DeepCollectionEquality().equals(other.kind, kind)&&(identical(other.options, options) || other.options == options)&&(identical(other.uri, uri) || other.uri == uri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,annotationId,const DeepCollectionEquality().hash(kind),options,uri);

@override
String toString() {
  return 'DeleteFile(annotationId: $annotationId, kind: $kind, options: $options, uri: $uri)';
}


}

/// @nodoc
abstract mixin class _$DeleteFileCopyWith<$Res> implements $DeleteFileCopyWith<$Res> {
  factory _$DeleteFileCopyWith(_DeleteFile value, $Res Function(_DeleteFile) _then) = __$DeleteFileCopyWithImpl;
@override @useResult
$Res call({
 ChangeAnnotationIdentifier? annotationId, StringLiteralRef kind, DeleteFileOptions? options, String uri
});


@override $DeleteFileOptionsCopyWith<$Res>? get options;

}
/// @nodoc
class __$DeleteFileCopyWithImpl<$Res>
    implements _$DeleteFileCopyWith<$Res> {
  __$DeleteFileCopyWithImpl(this._self, this._then);

  final _DeleteFile _self;
  final $Res Function(_DeleteFile) _then;

/// Create a copy of DeleteFile
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? annotationId = freezed,Object? kind = freezed,Object? options = freezed,Object? uri = null,}) {
  return _then(_DeleteFile(
annotationId: freezed == annotationId ? _self.annotationId : annotationId // ignore: cast_nullable_to_non_nullable
as ChangeAnnotationIdentifier?,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as StringLiteralRef,options: freezed == options ? _self.options : options // ignore: cast_nullable_to_non_nullable
as DeleteFileOptions?,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

/// Create a copy of DeleteFile
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DeleteFileOptionsCopyWith<$Res>? get options {
    if (_self.options == null) {
    return null;
  }

  return $DeleteFileOptionsCopyWith<$Res>(_self.options!, (value) {
    return _then(_self.copyWith(options: value));
  });
}
}


/// @nodoc
mixin _$ChangeAnnotation {

/// A human-readable string which is rendered less prominent in the user
/// interface.
 String? get description;/// A human-readable string describing the actual change. The string is
/// rendered prominent in the user interface.
 String get label;/// A flag which indicates that user confirmation is needed before applying
/// the change.
 bool? get needsConfirmation;
/// Create a copy of ChangeAnnotation
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ChangeAnnotationCopyWith<ChangeAnnotation> get copyWith => _$ChangeAnnotationCopyWithImpl<ChangeAnnotation>(this as ChangeAnnotation, _$identity);

  /// Serializes this ChangeAnnotation to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ChangeAnnotation&&(identical(other.description, description) || other.description == description)&&(identical(other.label, label) || other.label == label)&&(identical(other.needsConfirmation, needsConfirmation) || other.needsConfirmation == needsConfirmation));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,description,label,needsConfirmation);

@override
String toString() {
  return 'ChangeAnnotation(description: $description, label: $label, needsConfirmation: $needsConfirmation)';
}


}

/// @nodoc
abstract mixin class $ChangeAnnotationCopyWith<$Res>  {
  factory $ChangeAnnotationCopyWith(ChangeAnnotation value, $Res Function(ChangeAnnotation) _then) = _$ChangeAnnotationCopyWithImpl;
@useResult
$Res call({
 String? description, String label, bool? needsConfirmation
});




}
/// @nodoc
class _$ChangeAnnotationCopyWithImpl<$Res>
    implements $ChangeAnnotationCopyWith<$Res> {
  _$ChangeAnnotationCopyWithImpl(this._self, this._then);

  final ChangeAnnotation _self;
  final $Res Function(ChangeAnnotation) _then;

/// Create a copy of ChangeAnnotation
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? description = freezed,Object? label = null,Object? needsConfirmation = freezed,}) {
  return _then(_self.copyWith(
description: freezed == description ? _self.description : description // ignore: cast_nullable_to_non_nullable
as String?,label: null == label ? _self.label : label // ignore: cast_nullable_to_non_nullable
as String,needsConfirmation: freezed == needsConfirmation ? _self.needsConfirmation : needsConfirmation // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _ChangeAnnotation implements ChangeAnnotation {
  const _ChangeAnnotation({this.description, required this.label, this.needsConfirmation});
  factory _ChangeAnnotation.fromJson(Map<String, dynamic> json) => _$ChangeAnnotationFromJson(json);

/// A human-readable string which is rendered less prominent in the user
/// interface.
@override final  String? description;
/// A human-readable string describing the actual change. The string is
/// rendered prominent in the user interface.
@override final  String label;
/// A flag which indicates that user confirmation is needed before applying
/// the change.
@override final  bool? needsConfirmation;

/// Create a copy of ChangeAnnotation
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ChangeAnnotationCopyWith<_ChangeAnnotation> get copyWith => __$ChangeAnnotationCopyWithImpl<_ChangeAnnotation>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ChangeAnnotationToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ChangeAnnotation&&(identical(other.description, description) || other.description == description)&&(identical(other.label, label) || other.label == label)&&(identical(other.needsConfirmation, needsConfirmation) || other.needsConfirmation == needsConfirmation));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,description,label,needsConfirmation);

@override
String toString() {
  return 'ChangeAnnotation(description: $description, label: $label, needsConfirmation: $needsConfirmation)';
}


}

/// @nodoc
abstract mixin class _$ChangeAnnotationCopyWith<$Res> implements $ChangeAnnotationCopyWith<$Res> {
  factory _$ChangeAnnotationCopyWith(_ChangeAnnotation value, $Res Function(_ChangeAnnotation) _then) = __$ChangeAnnotationCopyWithImpl;
@override @useResult
$Res call({
 String? description, String label, bool? needsConfirmation
});




}
/// @nodoc
class __$ChangeAnnotationCopyWithImpl<$Res>
    implements _$ChangeAnnotationCopyWith<$Res> {
  __$ChangeAnnotationCopyWithImpl(this._self, this._then);

  final _ChangeAnnotation _self;
  final $Res Function(_ChangeAnnotation) _then;

/// Create a copy of ChangeAnnotation
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? description = freezed,Object? label = null,Object? needsConfirmation = freezed,}) {
  return _then(_ChangeAnnotation(
description: freezed == description ? _self.description : description // ignore: cast_nullable_to_non_nullable
as String?,label: null == label ? _self.label : label // ignore: cast_nullable_to_non_nullable
as String,needsConfirmation: freezed == needsConfirmation ? _self.needsConfirmation : needsConfirmation // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$FileOperationFilter {

/// The actual file operation pattern.
 FileOperationPattern get pattern;/// A Uri scheme like `file` or `untitled`.
 String? get scheme;
/// Create a copy of FileOperationFilter
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FileOperationFilterCopyWith<FileOperationFilter> get copyWith => _$FileOperationFilterCopyWithImpl<FileOperationFilter>(this as FileOperationFilter, _$identity);

  /// Serializes this FileOperationFilter to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FileOperationFilter&&(identical(other.pattern, pattern) || other.pattern == pattern)&&(identical(other.scheme, scheme) || other.scheme == scheme));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,pattern,scheme);

@override
String toString() {
  return 'FileOperationFilter(pattern: $pattern, scheme: $scheme)';
}


}

/// @nodoc
abstract mixin class $FileOperationFilterCopyWith<$Res>  {
  factory $FileOperationFilterCopyWith(FileOperationFilter value, $Res Function(FileOperationFilter) _then) = _$FileOperationFilterCopyWithImpl;
@useResult
$Res call({
 FileOperationPattern pattern, String? scheme
});


$FileOperationPatternCopyWith<$Res> get pattern;

}
/// @nodoc
class _$FileOperationFilterCopyWithImpl<$Res>
    implements $FileOperationFilterCopyWith<$Res> {
  _$FileOperationFilterCopyWithImpl(this._self, this._then);

  final FileOperationFilter _self;
  final $Res Function(FileOperationFilter) _then;

/// Create a copy of FileOperationFilter
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? pattern = null,Object? scheme = freezed,}) {
  return _then(_self.copyWith(
pattern: null == pattern ? _self.pattern : pattern // ignore: cast_nullable_to_non_nullable
as FileOperationPattern,scheme: freezed == scheme ? _self.scheme : scheme // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}
/// Create a copy of FileOperationFilter
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FileOperationPatternCopyWith<$Res> get pattern {
  
  return $FileOperationPatternCopyWith<$Res>(_self.pattern, (value) {
    return _then(_self.copyWith(pattern: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _FileOperationFilter implements FileOperationFilter {
  const _FileOperationFilter({required this.pattern, this.scheme});
  factory _FileOperationFilter.fromJson(Map<String, dynamic> json) => _$FileOperationFilterFromJson(json);

/// The actual file operation pattern.
@override final  FileOperationPattern pattern;
/// A Uri scheme like `file` or `untitled`.
@override final  String? scheme;

/// Create a copy of FileOperationFilter
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$FileOperationFilterCopyWith<_FileOperationFilter> get copyWith => __$FileOperationFilterCopyWithImpl<_FileOperationFilter>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$FileOperationFilterToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _FileOperationFilter&&(identical(other.pattern, pattern) || other.pattern == pattern)&&(identical(other.scheme, scheme) || other.scheme == scheme));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,pattern,scheme);

@override
String toString() {
  return 'FileOperationFilter(pattern: $pattern, scheme: $scheme)';
}


}

/// @nodoc
abstract mixin class _$FileOperationFilterCopyWith<$Res> implements $FileOperationFilterCopyWith<$Res> {
  factory _$FileOperationFilterCopyWith(_FileOperationFilter value, $Res Function(_FileOperationFilter) _then) = __$FileOperationFilterCopyWithImpl;
@override @useResult
$Res call({
 FileOperationPattern pattern, String? scheme
});


@override $FileOperationPatternCopyWith<$Res> get pattern;

}
/// @nodoc
class __$FileOperationFilterCopyWithImpl<$Res>
    implements _$FileOperationFilterCopyWith<$Res> {
  __$FileOperationFilterCopyWithImpl(this._self, this._then);

  final _FileOperationFilter _self;
  final $Res Function(_FileOperationFilter) _then;

/// Create a copy of FileOperationFilter
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? pattern = null,Object? scheme = freezed,}) {
  return _then(_FileOperationFilter(
pattern: null == pattern ? _self.pattern : pattern // ignore: cast_nullable_to_non_nullable
as FileOperationPattern,scheme: freezed == scheme ? _self.scheme : scheme // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

/// Create a copy of FileOperationFilter
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FileOperationPatternCopyWith<$Res> get pattern {
  
  return $FileOperationPatternCopyWith<$Res>(_self.pattern, (value) {
    return _then(_self.copyWith(pattern: value));
  });
}
}


/// @nodoc
mixin _$FileRename {

/// A file:// URI for the new location of the file/folder being renamed.
 String get newUri;/// A file:// URI for the original location of the file/folder being
/// renamed.
 String get oldUri;
/// Create a copy of FileRename
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FileRenameCopyWith<FileRename> get copyWith => _$FileRenameCopyWithImpl<FileRename>(this as FileRename, _$identity);

  /// Serializes this FileRename to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FileRename&&(identical(other.newUri, newUri) || other.newUri == newUri)&&(identical(other.oldUri, oldUri) || other.oldUri == oldUri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,newUri,oldUri);

@override
String toString() {
  return 'FileRename(newUri: $newUri, oldUri: $oldUri)';
}


}

/// @nodoc
abstract mixin class $FileRenameCopyWith<$Res>  {
  factory $FileRenameCopyWith(FileRename value, $Res Function(FileRename) _then) = _$FileRenameCopyWithImpl;
@useResult
$Res call({
 String newUri, String oldUri
});




}
/// @nodoc
class _$FileRenameCopyWithImpl<$Res>
    implements $FileRenameCopyWith<$Res> {
  _$FileRenameCopyWithImpl(this._self, this._then);

  final FileRename _self;
  final $Res Function(FileRename) _then;

/// Create a copy of FileRename
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? newUri = null,Object? oldUri = null,}) {
  return _then(_self.copyWith(
newUri: null == newUri ? _self.newUri : newUri // ignore: cast_nullable_to_non_nullable
as String,oldUri: null == oldUri ? _self.oldUri : oldUri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _FileRename implements FileRename {
  const _FileRename({required this.newUri, required this.oldUri});
  factory _FileRename.fromJson(Map<String, dynamic> json) => _$FileRenameFromJson(json);

/// A file:// URI for the new location of the file/folder being renamed.
@override final  String newUri;
/// A file:// URI for the original location of the file/folder being
/// renamed.
@override final  String oldUri;

/// Create a copy of FileRename
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$FileRenameCopyWith<_FileRename> get copyWith => __$FileRenameCopyWithImpl<_FileRename>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$FileRenameToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _FileRename&&(identical(other.newUri, newUri) || other.newUri == newUri)&&(identical(other.oldUri, oldUri) || other.oldUri == oldUri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,newUri,oldUri);

@override
String toString() {
  return 'FileRename(newUri: $newUri, oldUri: $oldUri)';
}


}

/// @nodoc
abstract mixin class _$FileRenameCopyWith<$Res> implements $FileRenameCopyWith<$Res> {
  factory _$FileRenameCopyWith(_FileRename value, $Res Function(_FileRename) _then) = __$FileRenameCopyWithImpl;
@override @useResult
$Res call({
 String newUri, String oldUri
});




}
/// @nodoc
class __$FileRenameCopyWithImpl<$Res>
    implements _$FileRenameCopyWith<$Res> {
  __$FileRenameCopyWithImpl(this._self, this._then);

  final _FileRename _self;
  final $Res Function(_FileRename) _then;

/// Create a copy of FileRename
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? newUri = null,Object? oldUri = null,}) {
  return _then(_FileRename(
newUri: null == newUri ? _self.newUri : newUri // ignore: cast_nullable_to_non_nullable
as String,oldUri: null == oldUri ? _self.oldUri : oldUri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}


/// @nodoc
mixin _$FileDelete {

/// A file:// URI for the location of the file/folder being deleted.
 String get uri;
/// Create a copy of FileDelete
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FileDeleteCopyWith<FileDelete> get copyWith => _$FileDeleteCopyWithImpl<FileDelete>(this as FileDelete, _$identity);

  /// Serializes this FileDelete to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FileDelete&&(identical(other.uri, uri) || other.uri == uri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri);

@override
String toString() {
  return 'FileDelete(uri: $uri)';
}


}

/// @nodoc
abstract mixin class $FileDeleteCopyWith<$Res>  {
  factory $FileDeleteCopyWith(FileDelete value, $Res Function(FileDelete) _then) = _$FileDeleteCopyWithImpl;
@useResult
$Res call({
 String uri
});




}
/// @nodoc
class _$FileDeleteCopyWithImpl<$Res>
    implements $FileDeleteCopyWith<$Res> {
  _$FileDeleteCopyWithImpl(this._self, this._then);

  final FileDelete _self;
  final $Res Function(FileDelete) _then;

/// Create a copy of FileDelete
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? uri = null,}) {
  return _then(_self.copyWith(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _FileDelete implements FileDelete {
  const _FileDelete({required this.uri});
  factory _FileDelete.fromJson(Map<String, dynamic> json) => _$FileDeleteFromJson(json);

/// A file:// URI for the location of the file/folder being deleted.
@override final  String uri;

/// Create a copy of FileDelete
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$FileDeleteCopyWith<_FileDelete> get copyWith => __$FileDeleteCopyWithImpl<_FileDelete>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$FileDeleteToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _FileDelete&&(identical(other.uri, uri) || other.uri == uri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri);

@override
String toString() {
  return 'FileDelete(uri: $uri)';
}


}

/// @nodoc
abstract mixin class _$FileDeleteCopyWith<$Res> implements $FileDeleteCopyWith<$Res> {
  factory _$FileDeleteCopyWith(_FileDelete value, $Res Function(_FileDelete) _then) = __$FileDeleteCopyWithImpl;
@override @useResult
$Res call({
 String uri
});




}
/// @nodoc
class __$FileDeleteCopyWithImpl<$Res>
    implements _$FileDeleteCopyWith<$Res> {
  __$FileDeleteCopyWithImpl(this._self, this._then);

  final _FileDelete _self;
  final $Res Function(_FileDelete) _then;

/// Create a copy of FileDelete
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? uri = null,}) {
  return _then(_FileDelete(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}


/// @nodoc
mixin _$MonikerOptions {

 bool? get workDoneProgress;
/// Create a copy of MonikerOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$MonikerOptionsCopyWith<MonikerOptions> get copyWith => _$MonikerOptionsCopyWithImpl<MonikerOptions>(this as MonikerOptions, _$identity);

  /// Serializes this MonikerOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is MonikerOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'MonikerOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $MonikerOptionsCopyWith<$Res>  {
  factory $MonikerOptionsCopyWith(MonikerOptions value, $Res Function(MonikerOptions) _then) = _$MonikerOptionsCopyWithImpl;
@useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class _$MonikerOptionsCopyWithImpl<$Res>
    implements $MonikerOptionsCopyWith<$Res> {
  _$MonikerOptionsCopyWithImpl(this._self, this._then);

  final MonikerOptions _self;
  final $Res Function(MonikerOptions) _then;

/// Create a copy of MonikerOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _MonikerOptions implements MonikerOptions {
  const _MonikerOptions({this.workDoneProgress});
  factory _MonikerOptions.fromJson(Map<String, dynamic> json) => _$MonikerOptionsFromJson(json);

@override final  bool? workDoneProgress;

/// Create a copy of MonikerOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$MonikerOptionsCopyWith<_MonikerOptions> get copyWith => __$MonikerOptionsCopyWithImpl<_MonikerOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$MonikerOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _MonikerOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'MonikerOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$MonikerOptionsCopyWith<$Res> implements $MonikerOptionsCopyWith<$Res> {
  factory _$MonikerOptionsCopyWith(_MonikerOptions value, $Res Function(_MonikerOptions) _then) = __$MonikerOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class __$MonikerOptionsCopyWithImpl<$Res>
    implements _$MonikerOptionsCopyWith<$Res> {
  __$MonikerOptionsCopyWithImpl(this._self, this._then);

  final _MonikerOptions _self;
  final $Res Function(_MonikerOptions) _then;

/// Create a copy of MonikerOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_MonikerOptions(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$TypeHierarchyOptions {

 bool? get workDoneProgress;
/// Create a copy of TypeHierarchyOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TypeHierarchyOptionsCopyWith<TypeHierarchyOptions> get copyWith => _$TypeHierarchyOptionsCopyWithImpl<TypeHierarchyOptions>(this as TypeHierarchyOptions, _$identity);

  /// Serializes this TypeHierarchyOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TypeHierarchyOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'TypeHierarchyOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $TypeHierarchyOptionsCopyWith<$Res>  {
  factory $TypeHierarchyOptionsCopyWith(TypeHierarchyOptions value, $Res Function(TypeHierarchyOptions) _then) = _$TypeHierarchyOptionsCopyWithImpl;
@useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class _$TypeHierarchyOptionsCopyWithImpl<$Res>
    implements $TypeHierarchyOptionsCopyWith<$Res> {
  _$TypeHierarchyOptionsCopyWithImpl(this._self, this._then);

  final TypeHierarchyOptions _self;
  final $Res Function(TypeHierarchyOptions) _then;

/// Create a copy of TypeHierarchyOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _TypeHierarchyOptions implements TypeHierarchyOptions {
  const _TypeHierarchyOptions({this.workDoneProgress});
  factory _TypeHierarchyOptions.fromJson(Map<String, dynamic> json) => _$TypeHierarchyOptionsFromJson(json);

@override final  bool? workDoneProgress;

/// Create a copy of TypeHierarchyOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TypeHierarchyOptionsCopyWith<_TypeHierarchyOptions> get copyWith => __$TypeHierarchyOptionsCopyWithImpl<_TypeHierarchyOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TypeHierarchyOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TypeHierarchyOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'TypeHierarchyOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$TypeHierarchyOptionsCopyWith<$Res> implements $TypeHierarchyOptionsCopyWith<$Res> {
  factory _$TypeHierarchyOptionsCopyWith(_TypeHierarchyOptions value, $Res Function(_TypeHierarchyOptions) _then) = __$TypeHierarchyOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class __$TypeHierarchyOptionsCopyWithImpl<$Res>
    implements _$TypeHierarchyOptionsCopyWith<$Res> {
  __$TypeHierarchyOptionsCopyWithImpl(this._self, this._then);

  final _TypeHierarchyOptions _self;
  final $Res Function(_TypeHierarchyOptions) _then;

/// Create a copy of TypeHierarchyOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_TypeHierarchyOptions(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$InlineValueContext {

/// The stack frame (as a DAP Id) where the execution has stopped.
 int get frameId;/// The document range where execution has stopped. Typically the end
/// position of the range denotes the line where the inline values are
/// shown.
 Range get stoppedLocation;
/// Create a copy of InlineValueContext
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlineValueContextCopyWith<InlineValueContext> get copyWith => _$InlineValueContextCopyWithImpl<InlineValueContext>(this as InlineValueContext, _$identity);

  /// Serializes this InlineValueContext to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlineValueContext&&(identical(other.frameId, frameId) || other.frameId == frameId)&&(identical(other.stoppedLocation, stoppedLocation) || other.stoppedLocation == stoppedLocation));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,frameId,stoppedLocation);

@override
String toString() {
  return 'InlineValueContext(frameId: $frameId, stoppedLocation: $stoppedLocation)';
}


}

/// @nodoc
abstract mixin class $InlineValueContextCopyWith<$Res>  {
  factory $InlineValueContextCopyWith(InlineValueContext value, $Res Function(InlineValueContext) _then) = _$InlineValueContextCopyWithImpl;
@useResult
$Res call({
 int frameId, Range stoppedLocation
});


$RangeCopyWith<$Res> get stoppedLocation;

}
/// @nodoc
class _$InlineValueContextCopyWithImpl<$Res>
    implements $InlineValueContextCopyWith<$Res> {
  _$InlineValueContextCopyWithImpl(this._self, this._then);

  final InlineValueContext _self;
  final $Res Function(InlineValueContext) _then;

/// Create a copy of InlineValueContext
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? frameId = null,Object? stoppedLocation = null,}) {
  return _then(_self.copyWith(
frameId: null == frameId ? _self.frameId : frameId // ignore: cast_nullable_to_non_nullable
as int,stoppedLocation: null == stoppedLocation ? _self.stoppedLocation : stoppedLocation // ignore: cast_nullable_to_non_nullable
as Range,
  ));
}
/// Create a copy of InlineValueContext
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get stoppedLocation {
  
  return $RangeCopyWith<$Res>(_self.stoppedLocation, (value) {
    return _then(_self.copyWith(stoppedLocation: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _InlineValueContext implements InlineValueContext {
  const _InlineValueContext({required this.frameId, required this.stoppedLocation});
  factory _InlineValueContext.fromJson(Map<String, dynamic> json) => _$InlineValueContextFromJson(json);

/// The stack frame (as a DAP Id) where the execution has stopped.
@override final  int frameId;
/// The document range where execution has stopped. Typically the end
/// position of the range denotes the line where the inline values are
/// shown.
@override final  Range stoppedLocation;

/// Create a copy of InlineValueContext
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlineValueContextCopyWith<_InlineValueContext> get copyWith => __$InlineValueContextCopyWithImpl<_InlineValueContext>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlineValueContextToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlineValueContext&&(identical(other.frameId, frameId) || other.frameId == frameId)&&(identical(other.stoppedLocation, stoppedLocation) || other.stoppedLocation == stoppedLocation));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,frameId,stoppedLocation);

@override
String toString() {
  return 'InlineValueContext(frameId: $frameId, stoppedLocation: $stoppedLocation)';
}


}

/// @nodoc
abstract mixin class _$InlineValueContextCopyWith<$Res> implements $InlineValueContextCopyWith<$Res> {
  factory _$InlineValueContextCopyWith(_InlineValueContext value, $Res Function(_InlineValueContext) _then) = __$InlineValueContextCopyWithImpl;
@override @useResult
$Res call({
 int frameId, Range stoppedLocation
});


@override $RangeCopyWith<$Res> get stoppedLocation;

}
/// @nodoc
class __$InlineValueContextCopyWithImpl<$Res>
    implements _$InlineValueContextCopyWith<$Res> {
  __$InlineValueContextCopyWithImpl(this._self, this._then);

  final _InlineValueContext _self;
  final $Res Function(_InlineValueContext) _then;

/// Create a copy of InlineValueContext
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? frameId = null,Object? stoppedLocation = null,}) {
  return _then(_InlineValueContext(
frameId: null == frameId ? _self.frameId : frameId // ignore: cast_nullable_to_non_nullable
as int,stoppedLocation: null == stoppedLocation ? _self.stoppedLocation : stoppedLocation // ignore: cast_nullable_to_non_nullable
as Range,
  ));
}

/// Create a copy of InlineValueContext
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get stoppedLocation {
  
  return $RangeCopyWith<$Res>(_self.stoppedLocation, (value) {
    return _then(_self.copyWith(stoppedLocation: value));
  });
}
}


/// @nodoc
mixin _$InlineValueText {

/// The document range for which the inline value applies.
 Range get range;/// The text of the inline value.
 String get text;
/// Create a copy of InlineValueText
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlineValueTextCopyWith<InlineValueText> get copyWith => _$InlineValueTextCopyWithImpl<InlineValueText>(this as InlineValueText, _$identity);

  /// Serializes this InlineValueText to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlineValueText&&(identical(other.range, range) || other.range == range)&&(identical(other.text, text) || other.text == text));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,range,text);

@override
String toString() {
  return 'InlineValueText(range: $range, text: $text)';
}


}

/// @nodoc
abstract mixin class $InlineValueTextCopyWith<$Res>  {
  factory $InlineValueTextCopyWith(InlineValueText value, $Res Function(InlineValueText) _then) = _$InlineValueTextCopyWithImpl;
@useResult
$Res call({
 Range range, String text
});


$RangeCopyWith<$Res> get range;

}
/// @nodoc
class _$InlineValueTextCopyWithImpl<$Res>
    implements $InlineValueTextCopyWith<$Res> {
  _$InlineValueTextCopyWithImpl(this._self, this._then);

  final InlineValueText _self;
  final $Res Function(InlineValueText) _then;

/// Create a copy of InlineValueText
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? range = null,Object? text = null,}) {
  return _then(_self.copyWith(
range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,text: null == text ? _self.text : text // ignore: cast_nullable_to_non_nullable
as String,
  ));
}
/// Create a copy of InlineValueText
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _InlineValueText implements InlineValueText {
  const _InlineValueText({required this.range, required this.text});
  factory _InlineValueText.fromJson(Map<String, dynamic> json) => _$InlineValueTextFromJson(json);

/// The document range for which the inline value applies.
@override final  Range range;
/// The text of the inline value.
@override final  String text;

/// Create a copy of InlineValueText
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlineValueTextCopyWith<_InlineValueText> get copyWith => __$InlineValueTextCopyWithImpl<_InlineValueText>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlineValueTextToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlineValueText&&(identical(other.range, range) || other.range == range)&&(identical(other.text, text) || other.text == text));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,range,text);

@override
String toString() {
  return 'InlineValueText(range: $range, text: $text)';
}


}

/// @nodoc
abstract mixin class _$InlineValueTextCopyWith<$Res> implements $InlineValueTextCopyWith<$Res> {
  factory _$InlineValueTextCopyWith(_InlineValueText value, $Res Function(_InlineValueText) _then) = __$InlineValueTextCopyWithImpl;
@override @useResult
$Res call({
 Range range, String text
});


@override $RangeCopyWith<$Res> get range;

}
/// @nodoc
class __$InlineValueTextCopyWithImpl<$Res>
    implements _$InlineValueTextCopyWith<$Res> {
  __$InlineValueTextCopyWithImpl(this._self, this._then);

  final _InlineValueText _self;
  final $Res Function(_InlineValueText) _then;

/// Create a copy of InlineValueText
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? range = null,Object? text = null,}) {
  return _then(_InlineValueText(
range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,text: null == text ? _self.text : text // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

/// Create a copy of InlineValueText
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}


/// @nodoc
mixin _$InlineValueVariableLookup {

/// How to perform the lookup.
 bool get caseSensitiveLookup;/// The document range for which the inline value applies. The range is
/// used to extract the variable name from the underlying document.
 Range get range;/// If specified the name of the variable to look up.
 String? get variableName;
/// Create a copy of InlineValueVariableLookup
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlineValueVariableLookupCopyWith<InlineValueVariableLookup> get copyWith => _$InlineValueVariableLookupCopyWithImpl<InlineValueVariableLookup>(this as InlineValueVariableLookup, _$identity);

  /// Serializes this InlineValueVariableLookup to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlineValueVariableLookup&&(identical(other.caseSensitiveLookup, caseSensitiveLookup) || other.caseSensitiveLookup == caseSensitiveLookup)&&(identical(other.range, range) || other.range == range)&&(identical(other.variableName, variableName) || other.variableName == variableName));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,caseSensitiveLookup,range,variableName);

@override
String toString() {
  return 'InlineValueVariableLookup(caseSensitiveLookup: $caseSensitiveLookup, range: $range, variableName: $variableName)';
}


}

/// @nodoc
abstract mixin class $InlineValueVariableLookupCopyWith<$Res>  {
  factory $InlineValueVariableLookupCopyWith(InlineValueVariableLookup value, $Res Function(InlineValueVariableLookup) _then) = _$InlineValueVariableLookupCopyWithImpl;
@useResult
$Res call({
 bool caseSensitiveLookup, Range range, String? variableName
});


$RangeCopyWith<$Res> get range;

}
/// @nodoc
class _$InlineValueVariableLookupCopyWithImpl<$Res>
    implements $InlineValueVariableLookupCopyWith<$Res> {
  _$InlineValueVariableLookupCopyWithImpl(this._self, this._then);

  final InlineValueVariableLookup _self;
  final $Res Function(InlineValueVariableLookup) _then;

/// Create a copy of InlineValueVariableLookup
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? caseSensitiveLookup = null,Object? range = null,Object? variableName = freezed,}) {
  return _then(_self.copyWith(
caseSensitiveLookup: null == caseSensitiveLookup ? _self.caseSensitiveLookup : caseSensitiveLookup // ignore: cast_nullable_to_non_nullable
as bool,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,variableName: freezed == variableName ? _self.variableName : variableName // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}
/// Create a copy of InlineValueVariableLookup
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _InlineValueVariableLookup implements InlineValueVariableLookup {
  const _InlineValueVariableLookup({required this.caseSensitiveLookup, required this.range, this.variableName});
  factory _InlineValueVariableLookup.fromJson(Map<String, dynamic> json) => _$InlineValueVariableLookupFromJson(json);

/// How to perform the lookup.
@override final  bool caseSensitiveLookup;
/// The document range for which the inline value applies. The range is
/// used to extract the variable name from the underlying document.
@override final  Range range;
/// If specified the name of the variable to look up.
@override final  String? variableName;

/// Create a copy of InlineValueVariableLookup
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlineValueVariableLookupCopyWith<_InlineValueVariableLookup> get copyWith => __$InlineValueVariableLookupCopyWithImpl<_InlineValueVariableLookup>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlineValueVariableLookupToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlineValueVariableLookup&&(identical(other.caseSensitiveLookup, caseSensitiveLookup) || other.caseSensitiveLookup == caseSensitiveLookup)&&(identical(other.range, range) || other.range == range)&&(identical(other.variableName, variableName) || other.variableName == variableName));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,caseSensitiveLookup,range,variableName);

@override
String toString() {
  return 'InlineValueVariableLookup(caseSensitiveLookup: $caseSensitiveLookup, range: $range, variableName: $variableName)';
}


}

/// @nodoc
abstract mixin class _$InlineValueVariableLookupCopyWith<$Res> implements $InlineValueVariableLookupCopyWith<$Res> {
  factory _$InlineValueVariableLookupCopyWith(_InlineValueVariableLookup value, $Res Function(_InlineValueVariableLookup) _then) = __$InlineValueVariableLookupCopyWithImpl;
@override @useResult
$Res call({
 bool caseSensitiveLookup, Range range, String? variableName
});


@override $RangeCopyWith<$Res> get range;

}
/// @nodoc
class __$InlineValueVariableLookupCopyWithImpl<$Res>
    implements _$InlineValueVariableLookupCopyWith<$Res> {
  __$InlineValueVariableLookupCopyWithImpl(this._self, this._then);

  final _InlineValueVariableLookup _self;
  final $Res Function(_InlineValueVariableLookup) _then;

/// Create a copy of InlineValueVariableLookup
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? caseSensitiveLookup = null,Object? range = null,Object? variableName = freezed,}) {
  return _then(_InlineValueVariableLookup(
caseSensitiveLookup: null == caseSensitiveLookup ? _self.caseSensitiveLookup : caseSensitiveLookup // ignore: cast_nullable_to_non_nullable
as bool,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,variableName: freezed == variableName ? _self.variableName : variableName // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

/// Create a copy of InlineValueVariableLookup
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}


/// @nodoc
mixin _$InlineValueEvaluatableExpression {

/// If specified the expression overrides the extracted expression.
 String? get expression;/// The document range for which the inline value applies. The range is
/// used to extract the evaluatable expression from the underlying
/// document.
 Range get range;
/// Create a copy of InlineValueEvaluatableExpression
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlineValueEvaluatableExpressionCopyWith<InlineValueEvaluatableExpression> get copyWith => _$InlineValueEvaluatableExpressionCopyWithImpl<InlineValueEvaluatableExpression>(this as InlineValueEvaluatableExpression, _$identity);

  /// Serializes this InlineValueEvaluatableExpression to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlineValueEvaluatableExpression&&(identical(other.expression, expression) || other.expression == expression)&&(identical(other.range, range) || other.range == range));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,expression,range);

@override
String toString() {
  return 'InlineValueEvaluatableExpression(expression: $expression, range: $range)';
}


}

/// @nodoc
abstract mixin class $InlineValueEvaluatableExpressionCopyWith<$Res>  {
  factory $InlineValueEvaluatableExpressionCopyWith(InlineValueEvaluatableExpression value, $Res Function(InlineValueEvaluatableExpression) _then) = _$InlineValueEvaluatableExpressionCopyWithImpl;
@useResult
$Res call({
 String? expression, Range range
});


$RangeCopyWith<$Res> get range;

}
/// @nodoc
class _$InlineValueEvaluatableExpressionCopyWithImpl<$Res>
    implements $InlineValueEvaluatableExpressionCopyWith<$Res> {
  _$InlineValueEvaluatableExpressionCopyWithImpl(this._self, this._then);

  final InlineValueEvaluatableExpression _self;
  final $Res Function(InlineValueEvaluatableExpression) _then;

/// Create a copy of InlineValueEvaluatableExpression
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? expression = freezed,Object? range = null,}) {
  return _then(_self.copyWith(
expression: freezed == expression ? _self.expression : expression // ignore: cast_nullable_to_non_nullable
as String?,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,
  ));
}
/// Create a copy of InlineValueEvaluatableExpression
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _InlineValueEvaluatableExpression implements InlineValueEvaluatableExpression {
  const _InlineValueEvaluatableExpression({this.expression, required this.range});
  factory _InlineValueEvaluatableExpression.fromJson(Map<String, dynamic> json) => _$InlineValueEvaluatableExpressionFromJson(json);

/// If specified the expression overrides the extracted expression.
@override final  String? expression;
/// The document range for which the inline value applies. The range is
/// used to extract the evaluatable expression from the underlying
/// document.
@override final  Range range;

/// Create a copy of InlineValueEvaluatableExpression
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlineValueEvaluatableExpressionCopyWith<_InlineValueEvaluatableExpression> get copyWith => __$InlineValueEvaluatableExpressionCopyWithImpl<_InlineValueEvaluatableExpression>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlineValueEvaluatableExpressionToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlineValueEvaluatableExpression&&(identical(other.expression, expression) || other.expression == expression)&&(identical(other.range, range) || other.range == range));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,expression,range);

@override
String toString() {
  return 'InlineValueEvaluatableExpression(expression: $expression, range: $range)';
}


}

/// @nodoc
abstract mixin class _$InlineValueEvaluatableExpressionCopyWith<$Res> implements $InlineValueEvaluatableExpressionCopyWith<$Res> {
  factory _$InlineValueEvaluatableExpressionCopyWith(_InlineValueEvaluatableExpression value, $Res Function(_InlineValueEvaluatableExpression) _then) = __$InlineValueEvaluatableExpressionCopyWithImpl;
@override @useResult
$Res call({
 String? expression, Range range
});


@override $RangeCopyWith<$Res> get range;

}
/// @nodoc
class __$InlineValueEvaluatableExpressionCopyWithImpl<$Res>
    implements _$InlineValueEvaluatableExpressionCopyWith<$Res> {
  __$InlineValueEvaluatableExpressionCopyWithImpl(this._self, this._then);

  final _InlineValueEvaluatableExpression _self;
  final $Res Function(_InlineValueEvaluatableExpression) _then;

/// Create a copy of InlineValueEvaluatableExpression
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? expression = freezed,Object? range = null,}) {
  return _then(_InlineValueEvaluatableExpression(
expression: freezed == expression ? _self.expression : expression // ignore: cast_nullable_to_non_nullable
as String?,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,
  ));
}

/// Create a copy of InlineValueEvaluatableExpression
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}


/// @nodoc
mixin _$InlineValueOptions {

 bool? get workDoneProgress;
/// Create a copy of InlineValueOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlineValueOptionsCopyWith<InlineValueOptions> get copyWith => _$InlineValueOptionsCopyWithImpl<InlineValueOptions>(this as InlineValueOptions, _$identity);

  /// Serializes this InlineValueOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlineValueOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'InlineValueOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $InlineValueOptionsCopyWith<$Res>  {
  factory $InlineValueOptionsCopyWith(InlineValueOptions value, $Res Function(InlineValueOptions) _then) = _$InlineValueOptionsCopyWithImpl;
@useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class _$InlineValueOptionsCopyWithImpl<$Res>
    implements $InlineValueOptionsCopyWith<$Res> {
  _$InlineValueOptionsCopyWithImpl(this._self, this._then);

  final InlineValueOptions _self;
  final $Res Function(InlineValueOptions) _then;

/// Create a copy of InlineValueOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _InlineValueOptions implements InlineValueOptions {
  const _InlineValueOptions({this.workDoneProgress});
  factory _InlineValueOptions.fromJson(Map<String, dynamic> json) => _$InlineValueOptionsFromJson(json);

@override final  bool? workDoneProgress;

/// Create a copy of InlineValueOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlineValueOptionsCopyWith<_InlineValueOptions> get copyWith => __$InlineValueOptionsCopyWithImpl<_InlineValueOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlineValueOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlineValueOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'InlineValueOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$InlineValueOptionsCopyWith<$Res> implements $InlineValueOptionsCopyWith<$Res> {
  factory _$InlineValueOptionsCopyWith(_InlineValueOptions value, $Res Function(_InlineValueOptions) _then) = __$InlineValueOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class __$InlineValueOptionsCopyWithImpl<$Res>
    implements _$InlineValueOptionsCopyWith<$Res> {
  __$InlineValueOptionsCopyWithImpl(this._self, this._then);

  final _InlineValueOptions _self;
  final $Res Function(_InlineValueOptions) _then;

/// Create a copy of InlineValueOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_InlineValueOptions(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$InlayHintLabelPart {

/// An optional command for this label part.
/// Depending on the client capability `inlayHint.resolveSupport` clients
/// might resolve this property late using the resolve request.
 Command? get command;/// An optional source code location that represents this label part.
/// The editor will use this location for the hover and for code navigation
/// features: This part will become a clickable link that resolves to the
/// definition of the symbol at the given location (not necessarily the
/// location itself), it shows the hover that shows at the given location,
/// and it shows a context menu with further code navigation commands.
/// Depending on the client capability `inlayHint.resolveSupport` clients
/// might resolve this property late using the resolve request.
 Location? get location;/// The tooltip text when you hover over this label part. Depending on the
/// client capability `inlayHint.resolveSupport` clients might resolve this
/// property late using the resolve request.
 Sealed17? get tooltip;/// The value of this label part.
 String get value;
/// Create a copy of InlayHintLabelPart
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlayHintLabelPartCopyWith<InlayHintLabelPart> get copyWith => _$InlayHintLabelPartCopyWithImpl<InlayHintLabelPart>(this as InlayHintLabelPart, _$identity);

  /// Serializes this InlayHintLabelPart to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlayHintLabelPart&&(identical(other.command, command) || other.command == command)&&(identical(other.location, location) || other.location == location)&&(identical(other.tooltip, tooltip) || other.tooltip == tooltip)&&(identical(other.value, value) || other.value == value));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,command,location,tooltip,value);

@override
String toString() {
  return 'InlayHintLabelPart(command: $command, location: $location, tooltip: $tooltip, value: $value)';
}


}

/// @nodoc
abstract mixin class $InlayHintLabelPartCopyWith<$Res>  {
  factory $InlayHintLabelPartCopyWith(InlayHintLabelPart value, $Res Function(InlayHintLabelPart) _then) = _$InlayHintLabelPartCopyWithImpl;
@useResult
$Res call({
 Command? command, Location? location, Sealed17? tooltip, String value
});


$CommandCopyWith<$Res>? get command;$LocationCopyWith<$Res>? get location;

}
/// @nodoc
class _$InlayHintLabelPartCopyWithImpl<$Res>
    implements $InlayHintLabelPartCopyWith<$Res> {
  _$InlayHintLabelPartCopyWithImpl(this._self, this._then);

  final InlayHintLabelPart _self;
  final $Res Function(InlayHintLabelPart) _then;

/// Create a copy of InlayHintLabelPart
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? command = freezed,Object? location = freezed,Object? tooltip = freezed,Object? value = null,}) {
  return _then(_self.copyWith(
command: freezed == command ? _self.command : command // ignore: cast_nullable_to_non_nullable
as Command?,location: freezed == location ? _self.location : location // ignore: cast_nullable_to_non_nullable
as Location?,tooltip: freezed == tooltip ? _self.tooltip : tooltip // ignore: cast_nullable_to_non_nullable
as Sealed17?,value: null == value ? _self.value : value // ignore: cast_nullable_to_non_nullable
as String,
  ));
}
/// Create a copy of InlayHintLabelPart
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CommandCopyWith<$Res>? get command {
    if (_self.command == null) {
    return null;
  }

  return $CommandCopyWith<$Res>(_self.command!, (value) {
    return _then(_self.copyWith(command: value));
  });
}/// Create a copy of InlayHintLabelPart
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$LocationCopyWith<$Res>? get location {
    if (_self.location == null) {
    return null;
  }

  return $LocationCopyWith<$Res>(_self.location!, (value) {
    return _then(_self.copyWith(location: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _InlayHintLabelPart implements InlayHintLabelPart {
  const _InlayHintLabelPart({this.command, this.location, this.tooltip, required this.value});
  factory _InlayHintLabelPart.fromJson(Map<String, dynamic> json) => _$InlayHintLabelPartFromJson(json);

/// An optional command for this label part.
/// Depending on the client capability `inlayHint.resolveSupport` clients
/// might resolve this property late using the resolve request.
@override final  Command? command;
/// An optional source code location that represents this label part.
/// The editor will use this location for the hover and for code navigation
/// features: This part will become a clickable link that resolves to the
/// definition of the symbol at the given location (not necessarily the
/// location itself), it shows the hover that shows at the given location,
/// and it shows a context menu with further code navigation commands.
/// Depending on the client capability `inlayHint.resolveSupport` clients
/// might resolve this property late using the resolve request.
@override final  Location? location;
/// The tooltip text when you hover over this label part. Depending on the
/// client capability `inlayHint.resolveSupport` clients might resolve this
/// property late using the resolve request.
@override final  Sealed17? tooltip;
/// The value of this label part.
@override final  String value;

/// Create a copy of InlayHintLabelPart
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlayHintLabelPartCopyWith<_InlayHintLabelPart> get copyWith => __$InlayHintLabelPartCopyWithImpl<_InlayHintLabelPart>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlayHintLabelPartToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlayHintLabelPart&&(identical(other.command, command) || other.command == command)&&(identical(other.location, location) || other.location == location)&&(identical(other.tooltip, tooltip) || other.tooltip == tooltip)&&(identical(other.value, value) || other.value == value));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,command,location,tooltip,value);

@override
String toString() {
  return 'InlayHintLabelPart(command: $command, location: $location, tooltip: $tooltip, value: $value)';
}


}

/// @nodoc
abstract mixin class _$InlayHintLabelPartCopyWith<$Res> implements $InlayHintLabelPartCopyWith<$Res> {
  factory _$InlayHintLabelPartCopyWith(_InlayHintLabelPart value, $Res Function(_InlayHintLabelPart) _then) = __$InlayHintLabelPartCopyWithImpl;
@override @useResult
$Res call({
 Command? command, Location? location, Sealed17? tooltip, String value
});


@override $CommandCopyWith<$Res>? get command;@override $LocationCopyWith<$Res>? get location;

}
/// @nodoc
class __$InlayHintLabelPartCopyWithImpl<$Res>
    implements _$InlayHintLabelPartCopyWith<$Res> {
  __$InlayHintLabelPartCopyWithImpl(this._self, this._then);

  final _InlayHintLabelPart _self;
  final $Res Function(_InlayHintLabelPart) _then;

/// Create a copy of InlayHintLabelPart
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? command = freezed,Object? location = freezed,Object? tooltip = freezed,Object? value = null,}) {
  return _then(_InlayHintLabelPart(
command: freezed == command ? _self.command : command // ignore: cast_nullable_to_non_nullable
as Command?,location: freezed == location ? _self.location : location // ignore: cast_nullable_to_non_nullable
as Location?,tooltip: freezed == tooltip ? _self.tooltip : tooltip // ignore: cast_nullable_to_non_nullable
as Sealed17?,value: null == value ? _self.value : value // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

/// Create a copy of InlayHintLabelPart
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CommandCopyWith<$Res>? get command {
    if (_self.command == null) {
    return null;
  }

  return $CommandCopyWith<$Res>(_self.command!, (value) {
    return _then(_self.copyWith(command: value));
  });
}/// Create a copy of InlayHintLabelPart
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$LocationCopyWith<$Res>? get location {
    if (_self.location == null) {
    return null;
  }

  return $LocationCopyWith<$Res>(_self.location!, (value) {
    return _then(_self.copyWith(location: value));
  });
}
}


/// @nodoc
mixin _$MarkupContent {

/// The type of the Markup
 MarkupKind get kind;/// The content itself
 String get value;
/// Create a copy of MarkupContent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$MarkupContentCopyWith<MarkupContent> get copyWith => _$MarkupContentCopyWithImpl<MarkupContent>(this as MarkupContent, _$identity);

  /// Serializes this MarkupContent to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is MarkupContent&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.value, value) || other.value == value));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,kind,value);

@override
String toString() {
  return 'MarkupContent(kind: $kind, value: $value)';
}


}

/// @nodoc
abstract mixin class $MarkupContentCopyWith<$Res>  {
  factory $MarkupContentCopyWith(MarkupContent value, $Res Function(MarkupContent) _then) = _$MarkupContentCopyWithImpl;
@useResult
$Res call({
 MarkupKind kind, String value
});




}
/// @nodoc
class _$MarkupContentCopyWithImpl<$Res>
    implements $MarkupContentCopyWith<$Res> {
  _$MarkupContentCopyWithImpl(this._self, this._then);

  final MarkupContent _self;
  final $Res Function(MarkupContent) _then;

/// Create a copy of MarkupContent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? kind = null,Object? value = null,}) {
  return _then(_self.copyWith(
kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as MarkupKind,value: null == value ? _self.value : value // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _MarkupContent implements MarkupContent {
  const _MarkupContent({required this.kind, required this.value});
  factory _MarkupContent.fromJson(Map<String, dynamic> json) => _$MarkupContentFromJson(json);

/// The type of the Markup
@override final  MarkupKind kind;
/// The content itself
@override final  String value;

/// Create a copy of MarkupContent
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$MarkupContentCopyWith<_MarkupContent> get copyWith => __$MarkupContentCopyWithImpl<_MarkupContent>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$MarkupContentToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _MarkupContent&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.value, value) || other.value == value));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,kind,value);

@override
String toString() {
  return 'MarkupContent(kind: $kind, value: $value)';
}


}

/// @nodoc
abstract mixin class _$MarkupContentCopyWith<$Res> implements $MarkupContentCopyWith<$Res> {
  factory _$MarkupContentCopyWith(_MarkupContent value, $Res Function(_MarkupContent) _then) = __$MarkupContentCopyWithImpl;
@override @useResult
$Res call({
 MarkupKind kind, String value
});




}
/// @nodoc
class __$MarkupContentCopyWithImpl<$Res>
    implements _$MarkupContentCopyWith<$Res> {
  __$MarkupContentCopyWithImpl(this._self, this._then);

  final _MarkupContent _self;
  final $Res Function(_MarkupContent) _then;

/// Create a copy of MarkupContent
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? kind = null,Object? value = null,}) {
  return _then(_MarkupContent(
kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as MarkupKind,value: null == value ? _self.value : value // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}


/// @nodoc
mixin _$InlayHintOptions {

/// The server provides support to resolve additional information for an
/// inlay hint item.
 bool? get resolveProvider; bool? get workDoneProgress;
/// Create a copy of InlayHintOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlayHintOptionsCopyWith<InlayHintOptions> get copyWith => _$InlayHintOptionsCopyWithImpl<InlayHintOptions>(this as InlayHintOptions, _$identity);

  /// Serializes this InlayHintOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlayHintOptions&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,resolveProvider,workDoneProgress);

@override
String toString() {
  return 'InlayHintOptions(resolveProvider: $resolveProvider, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $InlayHintOptionsCopyWith<$Res>  {
  factory $InlayHintOptionsCopyWith(InlayHintOptions value, $Res Function(InlayHintOptions) _then) = _$InlayHintOptionsCopyWithImpl;
@useResult
$Res call({
 bool? resolveProvider, bool? workDoneProgress
});




}
/// @nodoc
class _$InlayHintOptionsCopyWithImpl<$Res>
    implements $InlayHintOptionsCopyWith<$Res> {
  _$InlayHintOptionsCopyWithImpl(this._self, this._then);

  final InlayHintOptions _self;
  final $Res Function(InlayHintOptions) _then;

/// Create a copy of InlayHintOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? resolveProvider = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _InlayHintOptions implements InlayHintOptions {
  const _InlayHintOptions({this.resolveProvider, this.workDoneProgress});
  factory _InlayHintOptions.fromJson(Map<String, dynamic> json) => _$InlayHintOptionsFromJson(json);

/// The server provides support to resolve additional information for an
/// inlay hint item.
@override final  bool? resolveProvider;
@override final  bool? workDoneProgress;

/// Create a copy of InlayHintOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlayHintOptionsCopyWith<_InlayHintOptions> get copyWith => __$InlayHintOptionsCopyWithImpl<_InlayHintOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlayHintOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlayHintOptions&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,resolveProvider,workDoneProgress);

@override
String toString() {
  return 'InlayHintOptions(resolveProvider: $resolveProvider, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$InlayHintOptionsCopyWith<$Res> implements $InlayHintOptionsCopyWith<$Res> {
  factory _$InlayHintOptionsCopyWith(_InlayHintOptions value, $Res Function(_InlayHintOptions) _then) = __$InlayHintOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? resolveProvider, bool? workDoneProgress
});




}
/// @nodoc
class __$InlayHintOptionsCopyWithImpl<$Res>
    implements _$InlayHintOptionsCopyWith<$Res> {
  __$InlayHintOptionsCopyWithImpl(this._self, this._then);

  final _InlayHintOptions _self;
  final $Res Function(_InlayHintOptions) _then;

/// Create a copy of InlayHintOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? resolveProvider = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_InlayHintOptions(
resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$RelatedFullDocumentDiagnosticReport {

/// The actual items.
 List<Diagnostic> get items;/// A full document diagnostic report.
 StringLiteralRef get kind;/// Diagnostics of related documents. This information is useful in
/// programming languages where code in a file A can generate diagnostics
/// in a file B which A depends on. An example of such a language is C/C++
/// where marco definitions in a file a.cpp and result in errors in a
/// header file b.hpp.
/// @since 3.17.0
 Map<String, Sealed18>? get relatedDocuments;/// An optional result id. If provided it will be sent on the next
/// diagnostic request for the same document.
 String? get resultId;
/// Create a copy of RelatedFullDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RelatedFullDocumentDiagnosticReportCopyWith<RelatedFullDocumentDiagnosticReport> get copyWith => _$RelatedFullDocumentDiagnosticReportCopyWithImpl<RelatedFullDocumentDiagnosticReport>(this as RelatedFullDocumentDiagnosticReport, _$identity);

  /// Serializes this RelatedFullDocumentDiagnosticReport to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RelatedFullDocumentDiagnosticReport&&const DeepCollectionEquality().equals(other.items, items)&&const DeepCollectionEquality().equals(other.kind, kind)&&const DeepCollectionEquality().equals(other.relatedDocuments, relatedDocuments)&&(identical(other.resultId, resultId) || other.resultId == resultId));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(items),const DeepCollectionEquality().hash(kind),const DeepCollectionEquality().hash(relatedDocuments),resultId);

@override
String toString() {
  return 'RelatedFullDocumentDiagnosticReport(items: $items, kind: $kind, relatedDocuments: $relatedDocuments, resultId: $resultId)';
}


}

/// @nodoc
abstract mixin class $RelatedFullDocumentDiagnosticReportCopyWith<$Res>  {
  factory $RelatedFullDocumentDiagnosticReportCopyWith(RelatedFullDocumentDiagnosticReport value, $Res Function(RelatedFullDocumentDiagnosticReport) _then) = _$RelatedFullDocumentDiagnosticReportCopyWithImpl;
@useResult
$Res call({
 List<Diagnostic> items, StringLiteralRef kind, Map<String, Sealed18>? relatedDocuments, String? resultId
});




}
/// @nodoc
class _$RelatedFullDocumentDiagnosticReportCopyWithImpl<$Res>
    implements $RelatedFullDocumentDiagnosticReportCopyWith<$Res> {
  _$RelatedFullDocumentDiagnosticReportCopyWithImpl(this._self, this._then);

  final RelatedFullDocumentDiagnosticReport _self;
  final $Res Function(RelatedFullDocumentDiagnosticReport) _then;

/// Create a copy of RelatedFullDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? items = null,Object? kind = freezed,Object? relatedDocuments = freezed,Object? resultId = freezed,}) {
  return _then(_self.copyWith(
items: null == items ? _self.items : items // ignore: cast_nullable_to_non_nullable
as List<Diagnostic>,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as StringLiteralRef,relatedDocuments: freezed == relatedDocuments ? _self.relatedDocuments : relatedDocuments // ignore: cast_nullable_to_non_nullable
as Map<String, Sealed18>?,resultId: freezed == resultId ? _self.resultId : resultId // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _RelatedFullDocumentDiagnosticReport implements RelatedFullDocumentDiagnosticReport {
  const _RelatedFullDocumentDiagnosticReport({required final  List<Diagnostic> items, required this.kind, final  Map<String, Sealed18>? relatedDocuments, this.resultId}): _items = items,_relatedDocuments = relatedDocuments;
  factory _RelatedFullDocumentDiagnosticReport.fromJson(Map<String, dynamic> json) => _$RelatedFullDocumentDiagnosticReportFromJson(json);

/// The actual items.
 final  List<Diagnostic> _items;
/// The actual items.
@override List<Diagnostic> get items {
  if (_items is EqualUnmodifiableListView) return _items;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_items);
}

/// A full document diagnostic report.
@override final  StringLiteralRef kind;
/// Diagnostics of related documents. This information is useful in
/// programming languages where code in a file A can generate diagnostics
/// in a file B which A depends on. An example of such a language is C/C++
/// where marco definitions in a file a.cpp and result in errors in a
/// header file b.hpp.
/// @since 3.17.0
 final  Map<String, Sealed18>? _relatedDocuments;
/// Diagnostics of related documents. This information is useful in
/// programming languages where code in a file A can generate diagnostics
/// in a file B which A depends on. An example of such a language is C/C++
/// where marco definitions in a file a.cpp and result in errors in a
/// header file b.hpp.
/// @since 3.17.0
@override Map<String, Sealed18>? get relatedDocuments {
  final value = _relatedDocuments;
  if (value == null) return null;
  if (_relatedDocuments is EqualUnmodifiableMapView) return _relatedDocuments;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(value);
}

/// An optional result id. If provided it will be sent on the next
/// diagnostic request for the same document.
@override final  String? resultId;

/// Create a copy of RelatedFullDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RelatedFullDocumentDiagnosticReportCopyWith<_RelatedFullDocumentDiagnosticReport> get copyWith => __$RelatedFullDocumentDiagnosticReportCopyWithImpl<_RelatedFullDocumentDiagnosticReport>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$RelatedFullDocumentDiagnosticReportToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _RelatedFullDocumentDiagnosticReport&&const DeepCollectionEquality().equals(other._items, _items)&&const DeepCollectionEquality().equals(other.kind, kind)&&const DeepCollectionEquality().equals(other._relatedDocuments, _relatedDocuments)&&(identical(other.resultId, resultId) || other.resultId == resultId));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_items),const DeepCollectionEquality().hash(kind),const DeepCollectionEquality().hash(_relatedDocuments),resultId);

@override
String toString() {
  return 'RelatedFullDocumentDiagnosticReport(items: $items, kind: $kind, relatedDocuments: $relatedDocuments, resultId: $resultId)';
}


}

/// @nodoc
abstract mixin class _$RelatedFullDocumentDiagnosticReportCopyWith<$Res> implements $RelatedFullDocumentDiagnosticReportCopyWith<$Res> {
  factory _$RelatedFullDocumentDiagnosticReportCopyWith(_RelatedFullDocumentDiagnosticReport value, $Res Function(_RelatedFullDocumentDiagnosticReport) _then) = __$RelatedFullDocumentDiagnosticReportCopyWithImpl;
@override @useResult
$Res call({
 List<Diagnostic> items, StringLiteralRef kind, Map<String, Sealed18>? relatedDocuments, String? resultId
});




}
/// @nodoc
class __$RelatedFullDocumentDiagnosticReportCopyWithImpl<$Res>
    implements _$RelatedFullDocumentDiagnosticReportCopyWith<$Res> {
  __$RelatedFullDocumentDiagnosticReportCopyWithImpl(this._self, this._then);

  final _RelatedFullDocumentDiagnosticReport _self;
  final $Res Function(_RelatedFullDocumentDiagnosticReport) _then;

/// Create a copy of RelatedFullDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? items = null,Object? kind = freezed,Object? relatedDocuments = freezed,Object? resultId = freezed,}) {
  return _then(_RelatedFullDocumentDiagnosticReport(
items: null == items ? _self._items : items // ignore: cast_nullable_to_non_nullable
as List<Diagnostic>,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as StringLiteralRef,relatedDocuments: freezed == relatedDocuments ? _self._relatedDocuments : relatedDocuments // ignore: cast_nullable_to_non_nullable
as Map<String, Sealed18>?,resultId: freezed == resultId ? _self.resultId : resultId // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$RelatedUnchangedDocumentDiagnosticReport {

/// A document diagnostic report indicating no changes to the last result.
/// A server can only return `unchanged` if result ids are provided.
 StringLiteralRef get kind;/// Diagnostics of related documents. This information is useful in
/// programming languages where code in a file A can generate diagnostics
/// in a file B which A depends on. An example of such a language is C/C++
/// where marco definitions in a file a.cpp and result in errors in a
/// header file b.hpp.
/// @since 3.17.0
 Map<String, Sealed18>? get relatedDocuments;/// A result id which will be sent on the next diagnostic request for the
/// same document.
 String get resultId;
/// Create a copy of RelatedUnchangedDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RelatedUnchangedDocumentDiagnosticReportCopyWith<RelatedUnchangedDocumentDiagnosticReport> get copyWith => _$RelatedUnchangedDocumentDiagnosticReportCopyWithImpl<RelatedUnchangedDocumentDiagnosticReport>(this as RelatedUnchangedDocumentDiagnosticReport, _$identity);

  /// Serializes this RelatedUnchangedDocumentDiagnosticReport to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RelatedUnchangedDocumentDiagnosticReport&&const DeepCollectionEquality().equals(other.kind, kind)&&const DeepCollectionEquality().equals(other.relatedDocuments, relatedDocuments)&&(identical(other.resultId, resultId) || other.resultId == resultId));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(kind),const DeepCollectionEquality().hash(relatedDocuments),resultId);

@override
String toString() {
  return 'RelatedUnchangedDocumentDiagnosticReport(kind: $kind, relatedDocuments: $relatedDocuments, resultId: $resultId)';
}


}

/// @nodoc
abstract mixin class $RelatedUnchangedDocumentDiagnosticReportCopyWith<$Res>  {
  factory $RelatedUnchangedDocumentDiagnosticReportCopyWith(RelatedUnchangedDocumentDiagnosticReport value, $Res Function(RelatedUnchangedDocumentDiagnosticReport) _then) = _$RelatedUnchangedDocumentDiagnosticReportCopyWithImpl;
@useResult
$Res call({
 StringLiteralRef kind, Map<String, Sealed18>? relatedDocuments, String resultId
});




}
/// @nodoc
class _$RelatedUnchangedDocumentDiagnosticReportCopyWithImpl<$Res>
    implements $RelatedUnchangedDocumentDiagnosticReportCopyWith<$Res> {
  _$RelatedUnchangedDocumentDiagnosticReportCopyWithImpl(this._self, this._then);

  final RelatedUnchangedDocumentDiagnosticReport _self;
  final $Res Function(RelatedUnchangedDocumentDiagnosticReport) _then;

/// Create a copy of RelatedUnchangedDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? kind = freezed,Object? relatedDocuments = freezed,Object? resultId = null,}) {
  return _then(_self.copyWith(
kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as StringLiteralRef,relatedDocuments: freezed == relatedDocuments ? _self.relatedDocuments : relatedDocuments // ignore: cast_nullable_to_non_nullable
as Map<String, Sealed18>?,resultId: null == resultId ? _self.resultId : resultId // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _RelatedUnchangedDocumentDiagnosticReport implements RelatedUnchangedDocumentDiagnosticReport {
  const _RelatedUnchangedDocumentDiagnosticReport({required this.kind, final  Map<String, Sealed18>? relatedDocuments, required this.resultId}): _relatedDocuments = relatedDocuments;
  factory _RelatedUnchangedDocumentDiagnosticReport.fromJson(Map<String, dynamic> json) => _$RelatedUnchangedDocumentDiagnosticReportFromJson(json);

/// A document diagnostic report indicating no changes to the last result.
/// A server can only return `unchanged` if result ids are provided.
@override final  StringLiteralRef kind;
/// Diagnostics of related documents. This information is useful in
/// programming languages where code in a file A can generate diagnostics
/// in a file B which A depends on. An example of such a language is C/C++
/// where marco definitions in a file a.cpp and result in errors in a
/// header file b.hpp.
/// @since 3.17.0
 final  Map<String, Sealed18>? _relatedDocuments;
/// Diagnostics of related documents. This information is useful in
/// programming languages where code in a file A can generate diagnostics
/// in a file B which A depends on. An example of such a language is C/C++
/// where marco definitions in a file a.cpp and result in errors in a
/// header file b.hpp.
/// @since 3.17.0
@override Map<String, Sealed18>? get relatedDocuments {
  final value = _relatedDocuments;
  if (value == null) return null;
  if (_relatedDocuments is EqualUnmodifiableMapView) return _relatedDocuments;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(value);
}

/// A result id which will be sent on the next diagnostic request for the
/// same document.
@override final  String resultId;

/// Create a copy of RelatedUnchangedDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RelatedUnchangedDocumentDiagnosticReportCopyWith<_RelatedUnchangedDocumentDiagnosticReport> get copyWith => __$RelatedUnchangedDocumentDiagnosticReportCopyWithImpl<_RelatedUnchangedDocumentDiagnosticReport>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$RelatedUnchangedDocumentDiagnosticReportToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _RelatedUnchangedDocumentDiagnosticReport&&const DeepCollectionEquality().equals(other.kind, kind)&&const DeepCollectionEquality().equals(other._relatedDocuments, _relatedDocuments)&&(identical(other.resultId, resultId) || other.resultId == resultId));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(kind),const DeepCollectionEquality().hash(_relatedDocuments),resultId);

@override
String toString() {
  return 'RelatedUnchangedDocumentDiagnosticReport(kind: $kind, relatedDocuments: $relatedDocuments, resultId: $resultId)';
}


}

/// @nodoc
abstract mixin class _$RelatedUnchangedDocumentDiagnosticReportCopyWith<$Res> implements $RelatedUnchangedDocumentDiagnosticReportCopyWith<$Res> {
  factory _$RelatedUnchangedDocumentDiagnosticReportCopyWith(_RelatedUnchangedDocumentDiagnosticReport value, $Res Function(_RelatedUnchangedDocumentDiagnosticReport) _then) = __$RelatedUnchangedDocumentDiagnosticReportCopyWithImpl;
@override @useResult
$Res call({
 StringLiteralRef kind, Map<String, Sealed18>? relatedDocuments, String resultId
});




}
/// @nodoc
class __$RelatedUnchangedDocumentDiagnosticReportCopyWithImpl<$Res>
    implements _$RelatedUnchangedDocumentDiagnosticReportCopyWith<$Res> {
  __$RelatedUnchangedDocumentDiagnosticReportCopyWithImpl(this._self, this._then);

  final _RelatedUnchangedDocumentDiagnosticReport _self;
  final $Res Function(_RelatedUnchangedDocumentDiagnosticReport) _then;

/// Create a copy of RelatedUnchangedDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? kind = freezed,Object? relatedDocuments = freezed,Object? resultId = null,}) {
  return _then(_RelatedUnchangedDocumentDiagnosticReport(
kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as StringLiteralRef,relatedDocuments: freezed == relatedDocuments ? _self._relatedDocuments : relatedDocuments // ignore: cast_nullable_to_non_nullable
as Map<String, Sealed18>?,resultId: null == resultId ? _self.resultId : resultId // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}


/// @nodoc
mixin _$FullDocumentDiagnosticReport {

/// The actual items.
 List<Diagnostic> get items;/// A full document diagnostic report.
 StringLiteralRef get kind;/// An optional result id. If provided it will be sent on the next
/// diagnostic request for the same document.
 String? get resultId;
/// Create a copy of FullDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FullDocumentDiagnosticReportCopyWith<FullDocumentDiagnosticReport> get copyWith => _$FullDocumentDiagnosticReportCopyWithImpl<FullDocumentDiagnosticReport>(this as FullDocumentDiagnosticReport, _$identity);

  /// Serializes this FullDocumentDiagnosticReport to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FullDocumentDiagnosticReport&&const DeepCollectionEquality().equals(other.items, items)&&const DeepCollectionEquality().equals(other.kind, kind)&&(identical(other.resultId, resultId) || other.resultId == resultId));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(items),const DeepCollectionEquality().hash(kind),resultId);

@override
String toString() {
  return 'FullDocumentDiagnosticReport(items: $items, kind: $kind, resultId: $resultId)';
}


}

/// @nodoc
abstract mixin class $FullDocumentDiagnosticReportCopyWith<$Res>  {
  factory $FullDocumentDiagnosticReportCopyWith(FullDocumentDiagnosticReport value, $Res Function(FullDocumentDiagnosticReport) _then) = _$FullDocumentDiagnosticReportCopyWithImpl;
@useResult
$Res call({
 List<Diagnostic> items, StringLiteralRef kind, String? resultId
});




}
/// @nodoc
class _$FullDocumentDiagnosticReportCopyWithImpl<$Res>
    implements $FullDocumentDiagnosticReportCopyWith<$Res> {
  _$FullDocumentDiagnosticReportCopyWithImpl(this._self, this._then);

  final FullDocumentDiagnosticReport _self;
  final $Res Function(FullDocumentDiagnosticReport) _then;

/// Create a copy of FullDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? items = null,Object? kind = freezed,Object? resultId = freezed,}) {
  return _then(_self.copyWith(
items: null == items ? _self.items : items // ignore: cast_nullable_to_non_nullable
as List<Diagnostic>,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as StringLiteralRef,resultId: freezed == resultId ? _self.resultId : resultId // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _FullDocumentDiagnosticReport implements FullDocumentDiagnosticReport {
  const _FullDocumentDiagnosticReport({required final  List<Diagnostic> items, required this.kind, this.resultId}): _items = items;
  factory _FullDocumentDiagnosticReport.fromJson(Map<String, dynamic> json) => _$FullDocumentDiagnosticReportFromJson(json);

/// The actual items.
 final  List<Diagnostic> _items;
/// The actual items.
@override List<Diagnostic> get items {
  if (_items is EqualUnmodifiableListView) return _items;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_items);
}

/// A full document diagnostic report.
@override final  StringLiteralRef kind;
/// An optional result id. If provided it will be sent on the next
/// diagnostic request for the same document.
@override final  String? resultId;

/// Create a copy of FullDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$FullDocumentDiagnosticReportCopyWith<_FullDocumentDiagnosticReport> get copyWith => __$FullDocumentDiagnosticReportCopyWithImpl<_FullDocumentDiagnosticReport>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$FullDocumentDiagnosticReportToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _FullDocumentDiagnosticReport&&const DeepCollectionEquality().equals(other._items, _items)&&const DeepCollectionEquality().equals(other.kind, kind)&&(identical(other.resultId, resultId) || other.resultId == resultId));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_items),const DeepCollectionEquality().hash(kind),resultId);

@override
String toString() {
  return 'FullDocumentDiagnosticReport(items: $items, kind: $kind, resultId: $resultId)';
}


}

/// @nodoc
abstract mixin class _$FullDocumentDiagnosticReportCopyWith<$Res> implements $FullDocumentDiagnosticReportCopyWith<$Res> {
  factory _$FullDocumentDiagnosticReportCopyWith(_FullDocumentDiagnosticReport value, $Res Function(_FullDocumentDiagnosticReport) _then) = __$FullDocumentDiagnosticReportCopyWithImpl;
@override @useResult
$Res call({
 List<Diagnostic> items, StringLiteralRef kind, String? resultId
});




}
/// @nodoc
class __$FullDocumentDiagnosticReportCopyWithImpl<$Res>
    implements _$FullDocumentDiagnosticReportCopyWith<$Res> {
  __$FullDocumentDiagnosticReportCopyWithImpl(this._self, this._then);

  final _FullDocumentDiagnosticReport _self;
  final $Res Function(_FullDocumentDiagnosticReport) _then;

/// Create a copy of FullDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? items = null,Object? kind = freezed,Object? resultId = freezed,}) {
  return _then(_FullDocumentDiagnosticReport(
items: null == items ? _self._items : items // ignore: cast_nullable_to_non_nullable
as List<Diagnostic>,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as StringLiteralRef,resultId: freezed == resultId ? _self.resultId : resultId // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$UnchangedDocumentDiagnosticReport {

/// A document diagnostic report indicating no changes to the last result.
/// A server can only return `unchanged` if result ids are provided.
 StringLiteralRef get kind;/// A result id which will be sent on the next diagnostic request for the
/// same document.
 String get resultId;
/// Create a copy of UnchangedDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UnchangedDocumentDiagnosticReportCopyWith<UnchangedDocumentDiagnosticReport> get copyWith => _$UnchangedDocumentDiagnosticReportCopyWithImpl<UnchangedDocumentDiagnosticReport>(this as UnchangedDocumentDiagnosticReport, _$identity);

  /// Serializes this UnchangedDocumentDiagnosticReport to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is UnchangedDocumentDiagnosticReport&&const DeepCollectionEquality().equals(other.kind, kind)&&(identical(other.resultId, resultId) || other.resultId == resultId));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(kind),resultId);

@override
String toString() {
  return 'UnchangedDocumentDiagnosticReport(kind: $kind, resultId: $resultId)';
}


}

/// @nodoc
abstract mixin class $UnchangedDocumentDiagnosticReportCopyWith<$Res>  {
  factory $UnchangedDocumentDiagnosticReportCopyWith(UnchangedDocumentDiagnosticReport value, $Res Function(UnchangedDocumentDiagnosticReport) _then) = _$UnchangedDocumentDiagnosticReportCopyWithImpl;
@useResult
$Res call({
 StringLiteralRef kind, String resultId
});




}
/// @nodoc
class _$UnchangedDocumentDiagnosticReportCopyWithImpl<$Res>
    implements $UnchangedDocumentDiagnosticReportCopyWith<$Res> {
  _$UnchangedDocumentDiagnosticReportCopyWithImpl(this._self, this._then);

  final UnchangedDocumentDiagnosticReport _self;
  final $Res Function(UnchangedDocumentDiagnosticReport) _then;

/// Create a copy of UnchangedDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? kind = freezed,Object? resultId = null,}) {
  return _then(_self.copyWith(
kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as StringLiteralRef,resultId: null == resultId ? _self.resultId : resultId // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _UnchangedDocumentDiagnosticReport implements UnchangedDocumentDiagnosticReport {
  const _UnchangedDocumentDiagnosticReport({required this.kind, required this.resultId});
  factory _UnchangedDocumentDiagnosticReport.fromJson(Map<String, dynamic> json) => _$UnchangedDocumentDiagnosticReportFromJson(json);

/// A document diagnostic report indicating no changes to the last result.
/// A server can only return `unchanged` if result ids are provided.
@override final  StringLiteralRef kind;
/// A result id which will be sent on the next diagnostic request for the
/// same document.
@override final  String resultId;

/// Create a copy of UnchangedDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$UnchangedDocumentDiagnosticReportCopyWith<_UnchangedDocumentDiagnosticReport> get copyWith => __$UnchangedDocumentDiagnosticReportCopyWithImpl<_UnchangedDocumentDiagnosticReport>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$UnchangedDocumentDiagnosticReportToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _UnchangedDocumentDiagnosticReport&&const DeepCollectionEquality().equals(other.kind, kind)&&(identical(other.resultId, resultId) || other.resultId == resultId));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(kind),resultId);

@override
String toString() {
  return 'UnchangedDocumentDiagnosticReport(kind: $kind, resultId: $resultId)';
}


}

/// @nodoc
abstract mixin class _$UnchangedDocumentDiagnosticReportCopyWith<$Res> implements $UnchangedDocumentDiagnosticReportCopyWith<$Res> {
  factory _$UnchangedDocumentDiagnosticReportCopyWith(_UnchangedDocumentDiagnosticReport value, $Res Function(_UnchangedDocumentDiagnosticReport) _then) = __$UnchangedDocumentDiagnosticReportCopyWithImpl;
@override @useResult
$Res call({
 StringLiteralRef kind, String resultId
});




}
/// @nodoc
class __$UnchangedDocumentDiagnosticReportCopyWithImpl<$Res>
    implements _$UnchangedDocumentDiagnosticReportCopyWith<$Res> {
  __$UnchangedDocumentDiagnosticReportCopyWithImpl(this._self, this._then);

  final _UnchangedDocumentDiagnosticReport _self;
  final $Res Function(_UnchangedDocumentDiagnosticReport) _then;

/// Create a copy of UnchangedDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? kind = freezed,Object? resultId = null,}) {
  return _then(_UnchangedDocumentDiagnosticReport(
kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as StringLiteralRef,resultId: null == resultId ? _self.resultId : resultId // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}


/// @nodoc
mixin _$DiagnosticOptions {

/// An optional identifier under which the diagnostics are managed by the
/// client.
 String? get identifier;/// Whether the language has inter file dependencies meaning that editing
/// code in one file can result in a different diagnostic set in another
/// file. Inter file dependencies are common for most programming languages
/// and typically uncommon for linters.
 bool get interFileDependencies; bool? get workDoneProgress;/// The server provides support for workspace diagnostics as well.
 bool get workspaceDiagnostics;
/// Create a copy of DiagnosticOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DiagnosticOptionsCopyWith<DiagnosticOptions> get copyWith => _$DiagnosticOptionsCopyWithImpl<DiagnosticOptions>(this as DiagnosticOptions, _$identity);

  /// Serializes this DiagnosticOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DiagnosticOptions&&(identical(other.identifier, identifier) || other.identifier == identifier)&&(identical(other.interFileDependencies, interFileDependencies) || other.interFileDependencies == interFileDependencies)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress)&&(identical(other.workspaceDiagnostics, workspaceDiagnostics) || other.workspaceDiagnostics == workspaceDiagnostics));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,identifier,interFileDependencies,workDoneProgress,workspaceDiagnostics);

@override
String toString() {
  return 'DiagnosticOptions(identifier: $identifier, interFileDependencies: $interFileDependencies, workDoneProgress: $workDoneProgress, workspaceDiagnostics: $workspaceDiagnostics)';
}


}

/// @nodoc
abstract mixin class $DiagnosticOptionsCopyWith<$Res>  {
  factory $DiagnosticOptionsCopyWith(DiagnosticOptions value, $Res Function(DiagnosticOptions) _then) = _$DiagnosticOptionsCopyWithImpl;
@useResult
$Res call({
 String? identifier, bool interFileDependencies, bool? workDoneProgress, bool workspaceDiagnostics
});




}
/// @nodoc
class _$DiagnosticOptionsCopyWithImpl<$Res>
    implements $DiagnosticOptionsCopyWith<$Res> {
  _$DiagnosticOptionsCopyWithImpl(this._self, this._then);

  final DiagnosticOptions _self;
  final $Res Function(DiagnosticOptions) _then;

/// Create a copy of DiagnosticOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? identifier = freezed,Object? interFileDependencies = null,Object? workDoneProgress = freezed,Object? workspaceDiagnostics = null,}) {
  return _then(_self.copyWith(
identifier: freezed == identifier ? _self.identifier : identifier // ignore: cast_nullable_to_non_nullable
as String?,interFileDependencies: null == interFileDependencies ? _self.interFileDependencies : interFileDependencies // ignore: cast_nullable_to_non_nullable
as bool,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,workspaceDiagnostics: null == workspaceDiagnostics ? _self.workspaceDiagnostics : workspaceDiagnostics // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DiagnosticOptions implements DiagnosticOptions {
  const _DiagnosticOptions({this.identifier, required this.interFileDependencies, this.workDoneProgress, required this.workspaceDiagnostics});
  factory _DiagnosticOptions.fromJson(Map<String, dynamic> json) => _$DiagnosticOptionsFromJson(json);

/// An optional identifier under which the diagnostics are managed by the
/// client.
@override final  String? identifier;
/// Whether the language has inter file dependencies meaning that editing
/// code in one file can result in a different diagnostic set in another
/// file. Inter file dependencies are common for most programming languages
/// and typically uncommon for linters.
@override final  bool interFileDependencies;
@override final  bool? workDoneProgress;
/// The server provides support for workspace diagnostics as well.
@override final  bool workspaceDiagnostics;

/// Create a copy of DiagnosticOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DiagnosticOptionsCopyWith<_DiagnosticOptions> get copyWith => __$DiagnosticOptionsCopyWithImpl<_DiagnosticOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DiagnosticOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DiagnosticOptions&&(identical(other.identifier, identifier) || other.identifier == identifier)&&(identical(other.interFileDependencies, interFileDependencies) || other.interFileDependencies == interFileDependencies)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress)&&(identical(other.workspaceDiagnostics, workspaceDiagnostics) || other.workspaceDiagnostics == workspaceDiagnostics));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,identifier,interFileDependencies,workDoneProgress,workspaceDiagnostics);

@override
String toString() {
  return 'DiagnosticOptions(identifier: $identifier, interFileDependencies: $interFileDependencies, workDoneProgress: $workDoneProgress, workspaceDiagnostics: $workspaceDiagnostics)';
}


}

/// @nodoc
abstract mixin class _$DiagnosticOptionsCopyWith<$Res> implements $DiagnosticOptionsCopyWith<$Res> {
  factory _$DiagnosticOptionsCopyWith(_DiagnosticOptions value, $Res Function(_DiagnosticOptions) _then) = __$DiagnosticOptionsCopyWithImpl;
@override @useResult
$Res call({
 String? identifier, bool interFileDependencies, bool? workDoneProgress, bool workspaceDiagnostics
});




}
/// @nodoc
class __$DiagnosticOptionsCopyWithImpl<$Res>
    implements _$DiagnosticOptionsCopyWith<$Res> {
  __$DiagnosticOptionsCopyWithImpl(this._self, this._then);

  final _DiagnosticOptions _self;
  final $Res Function(_DiagnosticOptions) _then;

/// Create a copy of DiagnosticOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? identifier = freezed,Object? interFileDependencies = null,Object? workDoneProgress = freezed,Object? workspaceDiagnostics = null,}) {
  return _then(_DiagnosticOptions(
identifier: freezed == identifier ? _self.identifier : identifier // ignore: cast_nullable_to_non_nullable
as String?,interFileDependencies: null == interFileDependencies ? _self.interFileDependencies : interFileDependencies // ignore: cast_nullable_to_non_nullable
as bool,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,workspaceDiagnostics: null == workspaceDiagnostics ? _self.workspaceDiagnostics : workspaceDiagnostics // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}


}


/// @nodoc
mixin _$PreviousResultId {

/// The URI for which the client knowns a result id.
 String get uri;/// The value of the previous result id.
 String get value;
/// Create a copy of PreviousResultId
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$PreviousResultIdCopyWith<PreviousResultId> get copyWith => _$PreviousResultIdCopyWithImpl<PreviousResultId>(this as PreviousResultId, _$identity);

  /// Serializes this PreviousResultId to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is PreviousResultId&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.value, value) || other.value == value));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri,value);

@override
String toString() {
  return 'PreviousResultId(uri: $uri, value: $value)';
}


}

/// @nodoc
abstract mixin class $PreviousResultIdCopyWith<$Res>  {
  factory $PreviousResultIdCopyWith(PreviousResultId value, $Res Function(PreviousResultId) _then) = _$PreviousResultIdCopyWithImpl;
@useResult
$Res call({
 String uri, String value
});




}
/// @nodoc
class _$PreviousResultIdCopyWithImpl<$Res>
    implements $PreviousResultIdCopyWith<$Res> {
  _$PreviousResultIdCopyWithImpl(this._self, this._then);

  final PreviousResultId _self;
  final $Res Function(PreviousResultId) _then;

/// Create a copy of PreviousResultId
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? uri = null,Object? value = null,}) {
  return _then(_self.copyWith(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,value: null == value ? _self.value : value // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _PreviousResultId implements PreviousResultId {
  const _PreviousResultId({required this.uri, required this.value});
  factory _PreviousResultId.fromJson(Map<String, dynamic> json) => _$PreviousResultIdFromJson(json);

/// The URI for which the client knowns a result id.
@override final  String uri;
/// The value of the previous result id.
@override final  String value;

/// Create a copy of PreviousResultId
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$PreviousResultIdCopyWith<_PreviousResultId> get copyWith => __$PreviousResultIdCopyWithImpl<_PreviousResultId>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$PreviousResultIdToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _PreviousResultId&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.value, value) || other.value == value));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri,value);

@override
String toString() {
  return 'PreviousResultId(uri: $uri, value: $value)';
}


}

/// @nodoc
abstract mixin class _$PreviousResultIdCopyWith<$Res> implements $PreviousResultIdCopyWith<$Res> {
  factory _$PreviousResultIdCopyWith(_PreviousResultId value, $Res Function(_PreviousResultId) _then) = __$PreviousResultIdCopyWithImpl;
@override @useResult
$Res call({
 String uri, String value
});




}
/// @nodoc
class __$PreviousResultIdCopyWithImpl<$Res>
    implements _$PreviousResultIdCopyWith<$Res> {
  __$PreviousResultIdCopyWithImpl(this._self, this._then);

  final _PreviousResultId _self;
  final $Res Function(_PreviousResultId) _then;

/// Create a copy of PreviousResultId
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? uri = null,Object? value = null,}) {
  return _then(_PreviousResultId(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,value: null == value ? _self.value : value // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}


/// @nodoc
mixin _$NotebookDocument {

/// The cells of a notebook.
 List<NotebookCell> get cells;/// Additional metadata stored with the notebook document.
/// Note: should always be an object literal (e.g. LSPObject)
 LSPObject? get metadata;/// The type of the notebook.
 String get notebookType;/// The notebook document's uri.
 String get uri;/// The version number of this document (it will increase after each
/// change, including undo/redo).
 int get version;
/// Create a copy of NotebookDocument
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$NotebookDocumentCopyWith<NotebookDocument> get copyWith => _$NotebookDocumentCopyWithImpl<NotebookDocument>(this as NotebookDocument, _$identity);

  /// Serializes this NotebookDocument to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is NotebookDocument&&const DeepCollectionEquality().equals(other.cells, cells)&&const DeepCollectionEquality().equals(other.metadata, metadata)&&(identical(other.notebookType, notebookType) || other.notebookType == notebookType)&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.version, version) || other.version == version));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(cells),const DeepCollectionEquality().hash(metadata),notebookType,uri,version);

@override
String toString() {
  return 'NotebookDocument(cells: $cells, metadata: $metadata, notebookType: $notebookType, uri: $uri, version: $version)';
}


}

/// @nodoc
abstract mixin class $NotebookDocumentCopyWith<$Res>  {
  factory $NotebookDocumentCopyWith(NotebookDocument value, $Res Function(NotebookDocument) _then) = _$NotebookDocumentCopyWithImpl;
@useResult
$Res call({
 List<NotebookCell> cells, LSPObject? metadata, String notebookType, String uri, int version
});




}
/// @nodoc
class _$NotebookDocumentCopyWithImpl<$Res>
    implements $NotebookDocumentCopyWith<$Res> {
  _$NotebookDocumentCopyWithImpl(this._self, this._then);

  final NotebookDocument _self;
  final $Res Function(NotebookDocument) _then;

/// Create a copy of NotebookDocument
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? cells = null,Object? metadata = freezed,Object? notebookType = null,Object? uri = null,Object? version = null,}) {
  return _then(_self.copyWith(
cells: null == cells ? _self.cells : cells // ignore: cast_nullable_to_non_nullable
as List<NotebookCell>,metadata: freezed == metadata ? _self.metadata : metadata // ignore: cast_nullable_to_non_nullable
as LSPObject?,notebookType: null == notebookType ? _self.notebookType : notebookType // ignore: cast_nullable_to_non_nullable
as String,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,version: null == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as int,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _NotebookDocument implements NotebookDocument {
  const _NotebookDocument({required final  List<NotebookCell> cells, final  LSPObject? metadata, required this.notebookType, required this.uri, required this.version}): _cells = cells,_metadata = metadata;
  factory _NotebookDocument.fromJson(Map<String, dynamic> json) => _$NotebookDocumentFromJson(json);

/// The cells of a notebook.
 final  List<NotebookCell> _cells;
/// The cells of a notebook.
@override List<NotebookCell> get cells {
  if (_cells is EqualUnmodifiableListView) return _cells;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_cells);
}

/// Additional metadata stored with the notebook document.
/// Note: should always be an object literal (e.g. LSPObject)
 final  LSPObject? _metadata;
/// Additional metadata stored with the notebook document.
/// Note: should always be an object literal (e.g. LSPObject)
@override LSPObject? get metadata {
  final value = _metadata;
  if (value == null) return null;
  if (_metadata is EqualUnmodifiableMapView) return _metadata;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(value);
}

/// The type of the notebook.
@override final  String notebookType;
/// The notebook document's uri.
@override final  String uri;
/// The version number of this document (it will increase after each
/// change, including undo/redo).
@override final  int version;

/// Create a copy of NotebookDocument
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$NotebookDocumentCopyWith<_NotebookDocument> get copyWith => __$NotebookDocumentCopyWithImpl<_NotebookDocument>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$NotebookDocumentToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _NotebookDocument&&const DeepCollectionEquality().equals(other._cells, _cells)&&const DeepCollectionEquality().equals(other._metadata, _metadata)&&(identical(other.notebookType, notebookType) || other.notebookType == notebookType)&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.version, version) || other.version == version));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_cells),const DeepCollectionEquality().hash(_metadata),notebookType,uri,version);

@override
String toString() {
  return 'NotebookDocument(cells: $cells, metadata: $metadata, notebookType: $notebookType, uri: $uri, version: $version)';
}


}

/// @nodoc
abstract mixin class _$NotebookDocumentCopyWith<$Res> implements $NotebookDocumentCopyWith<$Res> {
  factory _$NotebookDocumentCopyWith(_NotebookDocument value, $Res Function(_NotebookDocument) _then) = __$NotebookDocumentCopyWithImpl;
@override @useResult
$Res call({
 List<NotebookCell> cells, LSPObject? metadata, String notebookType, String uri, int version
});




}
/// @nodoc
class __$NotebookDocumentCopyWithImpl<$Res>
    implements _$NotebookDocumentCopyWith<$Res> {
  __$NotebookDocumentCopyWithImpl(this._self, this._then);

  final _NotebookDocument _self;
  final $Res Function(_NotebookDocument) _then;

/// Create a copy of NotebookDocument
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? cells = null,Object? metadata = freezed,Object? notebookType = null,Object? uri = null,Object? version = null,}) {
  return _then(_NotebookDocument(
cells: null == cells ? _self._cells : cells // ignore: cast_nullable_to_non_nullable
as List<NotebookCell>,metadata: freezed == metadata ? _self._metadata : metadata // ignore: cast_nullable_to_non_nullable
as LSPObject?,notebookType: null == notebookType ? _self.notebookType : notebookType // ignore: cast_nullable_to_non_nullable
as String,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,version: null == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as int,
  ));
}


}


/// @nodoc
mixin _$TextDocumentItem {

/// The text document's language identifier.
 String get languageId;/// The content of the opened text document.
 String get text;/// The text document's uri.
 String get uri;/// The version number of this document (it will increase after each
/// change, including undo/redo).
 int get version;
/// Create a copy of TextDocumentItem
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TextDocumentItemCopyWith<TextDocumentItem> get copyWith => _$TextDocumentItemCopyWithImpl<TextDocumentItem>(this as TextDocumentItem, _$identity);

  /// Serializes this TextDocumentItem to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TextDocumentItem&&(identical(other.languageId, languageId) || other.languageId == languageId)&&(identical(other.text, text) || other.text == text)&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.version, version) || other.version == version));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,languageId,text,uri,version);

@override
String toString() {
  return 'TextDocumentItem(languageId: $languageId, text: $text, uri: $uri, version: $version)';
}


}

/// @nodoc
abstract mixin class $TextDocumentItemCopyWith<$Res>  {
  factory $TextDocumentItemCopyWith(TextDocumentItem value, $Res Function(TextDocumentItem) _then) = _$TextDocumentItemCopyWithImpl;
@useResult
$Res call({
 String languageId, String text, String uri, int version
});




}
/// @nodoc
class _$TextDocumentItemCopyWithImpl<$Res>
    implements $TextDocumentItemCopyWith<$Res> {
  _$TextDocumentItemCopyWithImpl(this._self, this._then);

  final TextDocumentItem _self;
  final $Res Function(TextDocumentItem) _then;

/// Create a copy of TextDocumentItem
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? languageId = null,Object? text = null,Object? uri = null,Object? version = null,}) {
  return _then(_self.copyWith(
languageId: null == languageId ? _self.languageId : languageId // ignore: cast_nullable_to_non_nullable
as String,text: null == text ? _self.text : text // ignore: cast_nullable_to_non_nullable
as String,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,version: null == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as int,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _TextDocumentItem implements TextDocumentItem {
  const _TextDocumentItem({required this.languageId, required this.text, required this.uri, required this.version});
  factory _TextDocumentItem.fromJson(Map<String, dynamic> json) => _$TextDocumentItemFromJson(json);

/// The text document's language identifier.
@override final  String languageId;
/// The content of the opened text document.
@override final  String text;
/// The text document's uri.
@override final  String uri;
/// The version number of this document (it will increase after each
/// change, including undo/redo).
@override final  int version;

/// Create a copy of TextDocumentItem
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TextDocumentItemCopyWith<_TextDocumentItem> get copyWith => __$TextDocumentItemCopyWithImpl<_TextDocumentItem>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TextDocumentItemToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TextDocumentItem&&(identical(other.languageId, languageId) || other.languageId == languageId)&&(identical(other.text, text) || other.text == text)&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.version, version) || other.version == version));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,languageId,text,uri,version);

@override
String toString() {
  return 'TextDocumentItem(languageId: $languageId, text: $text, uri: $uri, version: $version)';
}


}

/// @nodoc
abstract mixin class _$TextDocumentItemCopyWith<$Res> implements $TextDocumentItemCopyWith<$Res> {
  factory _$TextDocumentItemCopyWith(_TextDocumentItem value, $Res Function(_TextDocumentItem) _then) = __$TextDocumentItemCopyWithImpl;
@override @useResult
$Res call({
 String languageId, String text, String uri, int version
});




}
/// @nodoc
class __$TextDocumentItemCopyWithImpl<$Res>
    implements _$TextDocumentItemCopyWith<$Res> {
  __$TextDocumentItemCopyWithImpl(this._self, this._then);

  final _TextDocumentItem _self;
  final $Res Function(_TextDocumentItem) _then;

/// Create a copy of TextDocumentItem
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? languageId = null,Object? text = null,Object? uri = null,Object? version = null,}) {
  return _then(_TextDocumentItem(
languageId: null == languageId ? _self.languageId : languageId // ignore: cast_nullable_to_non_nullable
as String,text: null == text ? _self.text : text // ignore: cast_nullable_to_non_nullable
as String,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,version: null == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as int,
  ));
}


}


/// @nodoc
mixin _$VersionedNotebookDocumentIdentifier {

/// The notebook document's uri.
 String get uri;/// The version number of this notebook document.
 int get version;
/// Create a copy of VersionedNotebookDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$VersionedNotebookDocumentIdentifierCopyWith<VersionedNotebookDocumentIdentifier> get copyWith => _$VersionedNotebookDocumentIdentifierCopyWithImpl<VersionedNotebookDocumentIdentifier>(this as VersionedNotebookDocumentIdentifier, _$identity);

  /// Serializes this VersionedNotebookDocumentIdentifier to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is VersionedNotebookDocumentIdentifier&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.version, version) || other.version == version));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri,version);

@override
String toString() {
  return 'VersionedNotebookDocumentIdentifier(uri: $uri, version: $version)';
}


}

/// @nodoc
abstract mixin class $VersionedNotebookDocumentIdentifierCopyWith<$Res>  {
  factory $VersionedNotebookDocumentIdentifierCopyWith(VersionedNotebookDocumentIdentifier value, $Res Function(VersionedNotebookDocumentIdentifier) _then) = _$VersionedNotebookDocumentIdentifierCopyWithImpl;
@useResult
$Res call({
 String uri, int version
});




}
/// @nodoc
class _$VersionedNotebookDocumentIdentifierCopyWithImpl<$Res>
    implements $VersionedNotebookDocumentIdentifierCopyWith<$Res> {
  _$VersionedNotebookDocumentIdentifierCopyWithImpl(this._self, this._then);

  final VersionedNotebookDocumentIdentifier _self;
  final $Res Function(VersionedNotebookDocumentIdentifier) _then;

/// Create a copy of VersionedNotebookDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? uri = null,Object? version = null,}) {
  return _then(_self.copyWith(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,version: null == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as int,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _VersionedNotebookDocumentIdentifier implements VersionedNotebookDocumentIdentifier {
  const _VersionedNotebookDocumentIdentifier({required this.uri, required this.version});
  factory _VersionedNotebookDocumentIdentifier.fromJson(Map<String, dynamic> json) => _$VersionedNotebookDocumentIdentifierFromJson(json);

/// The notebook document's uri.
@override final  String uri;
/// The version number of this notebook document.
@override final  int version;

/// Create a copy of VersionedNotebookDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$VersionedNotebookDocumentIdentifierCopyWith<_VersionedNotebookDocumentIdentifier> get copyWith => __$VersionedNotebookDocumentIdentifierCopyWithImpl<_VersionedNotebookDocumentIdentifier>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$VersionedNotebookDocumentIdentifierToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _VersionedNotebookDocumentIdentifier&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.version, version) || other.version == version));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri,version);

@override
String toString() {
  return 'VersionedNotebookDocumentIdentifier(uri: $uri, version: $version)';
}


}

/// @nodoc
abstract mixin class _$VersionedNotebookDocumentIdentifierCopyWith<$Res> implements $VersionedNotebookDocumentIdentifierCopyWith<$Res> {
  factory _$VersionedNotebookDocumentIdentifierCopyWith(_VersionedNotebookDocumentIdentifier value, $Res Function(_VersionedNotebookDocumentIdentifier) _then) = __$VersionedNotebookDocumentIdentifierCopyWithImpl;
@override @useResult
$Res call({
 String uri, int version
});




}
/// @nodoc
class __$VersionedNotebookDocumentIdentifierCopyWithImpl<$Res>
    implements _$VersionedNotebookDocumentIdentifierCopyWith<$Res> {
  __$VersionedNotebookDocumentIdentifierCopyWithImpl(this._self, this._then);

  final _VersionedNotebookDocumentIdentifier _self;
  final $Res Function(_VersionedNotebookDocumentIdentifier) _then;

/// Create a copy of VersionedNotebookDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? uri = null,Object? version = null,}) {
  return _then(_VersionedNotebookDocumentIdentifier(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,version: null == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as int,
  ));
}


}


/// @nodoc
mixin _$NotebookDocumentChangeEvent {

/// Changes to cells
 NotebookCellArrayChangeArrayTextDocumentIdentifiersDidCloseTextDocumentItemsDidOpenStructureNotebookCellsDataTextDocumentContentChangeEventsChangesVersionedTextDocumentIdentifierDocumentsTextContent? get cells;/// The changed meta data if any.
/// Note: should always be an object literal (e.g. LSPObject)
 LSPObject? get metadata;
/// Create a copy of NotebookDocumentChangeEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$NotebookDocumentChangeEventCopyWith<NotebookDocumentChangeEvent> get copyWith => _$NotebookDocumentChangeEventCopyWithImpl<NotebookDocumentChangeEvent>(this as NotebookDocumentChangeEvent, _$identity);

  /// Serializes this NotebookDocumentChangeEvent to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is NotebookDocumentChangeEvent&&const DeepCollectionEquality().equals(other.cells, cells)&&const DeepCollectionEquality().equals(other.metadata, metadata));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(cells),const DeepCollectionEquality().hash(metadata));

@override
String toString() {
  return 'NotebookDocumentChangeEvent(cells: $cells, metadata: $metadata)';
}


}

/// @nodoc
abstract mixin class $NotebookDocumentChangeEventCopyWith<$Res>  {
  factory $NotebookDocumentChangeEventCopyWith(NotebookDocumentChangeEvent value, $Res Function(NotebookDocumentChangeEvent) _then) = _$NotebookDocumentChangeEventCopyWithImpl;
@useResult
$Res call({
 NotebookCellArrayChangeArrayTextDocumentIdentifiersDidCloseTextDocumentItemsDidOpenStructureNotebookCellsDataTextDocumentContentChangeEventsChangesVersionedTextDocumentIdentifierDocumentsTextContent? cells, LSPObject? metadata
});




}
/// @nodoc
class _$NotebookDocumentChangeEventCopyWithImpl<$Res>
    implements $NotebookDocumentChangeEventCopyWith<$Res> {
  _$NotebookDocumentChangeEventCopyWithImpl(this._self, this._then);

  final NotebookDocumentChangeEvent _self;
  final $Res Function(NotebookDocumentChangeEvent) _then;

/// Create a copy of NotebookDocumentChangeEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? cells = freezed,Object? metadata = freezed,}) {
  return _then(_self.copyWith(
cells: freezed == cells ? _self.cells : cells // ignore: cast_nullable_to_non_nullable
as NotebookCellArrayChangeArrayTextDocumentIdentifiersDidCloseTextDocumentItemsDidOpenStructureNotebookCellsDataTextDocumentContentChangeEventsChangesVersionedTextDocumentIdentifierDocumentsTextContent?,metadata: freezed == metadata ? _self.metadata : metadata // ignore: cast_nullable_to_non_nullable
as LSPObject?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _NotebookDocumentChangeEvent implements NotebookDocumentChangeEvent {
  const _NotebookDocumentChangeEvent({this.cells, final  LSPObject? metadata}): _metadata = metadata;
  factory _NotebookDocumentChangeEvent.fromJson(Map<String, dynamic> json) => _$NotebookDocumentChangeEventFromJson(json);

/// Changes to cells
@override final  NotebookCellArrayChangeArrayTextDocumentIdentifiersDidCloseTextDocumentItemsDidOpenStructureNotebookCellsDataTextDocumentContentChangeEventsChangesVersionedTextDocumentIdentifierDocumentsTextContent? cells;
/// The changed meta data if any.
/// Note: should always be an object literal (e.g. LSPObject)
 final  LSPObject? _metadata;
/// The changed meta data if any.
/// Note: should always be an object literal (e.g. LSPObject)
@override LSPObject? get metadata {
  final value = _metadata;
  if (value == null) return null;
  if (_metadata is EqualUnmodifiableMapView) return _metadata;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(value);
}


/// Create a copy of NotebookDocumentChangeEvent
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$NotebookDocumentChangeEventCopyWith<_NotebookDocumentChangeEvent> get copyWith => __$NotebookDocumentChangeEventCopyWithImpl<_NotebookDocumentChangeEvent>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$NotebookDocumentChangeEventToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _NotebookDocumentChangeEvent&&const DeepCollectionEquality().equals(other.cells, cells)&&const DeepCollectionEquality().equals(other._metadata, _metadata));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(cells),const DeepCollectionEquality().hash(_metadata));

@override
String toString() {
  return 'NotebookDocumentChangeEvent(cells: $cells, metadata: $metadata)';
}


}

/// @nodoc
abstract mixin class _$NotebookDocumentChangeEventCopyWith<$Res> implements $NotebookDocumentChangeEventCopyWith<$Res> {
  factory _$NotebookDocumentChangeEventCopyWith(_NotebookDocumentChangeEvent value, $Res Function(_NotebookDocumentChangeEvent) _then) = __$NotebookDocumentChangeEventCopyWithImpl;
@override @useResult
$Res call({
 NotebookCellArrayChangeArrayTextDocumentIdentifiersDidCloseTextDocumentItemsDidOpenStructureNotebookCellsDataTextDocumentContentChangeEventsChangesVersionedTextDocumentIdentifierDocumentsTextContent? cells, LSPObject? metadata
});




}
/// @nodoc
class __$NotebookDocumentChangeEventCopyWithImpl<$Res>
    implements _$NotebookDocumentChangeEventCopyWith<$Res> {
  __$NotebookDocumentChangeEventCopyWithImpl(this._self, this._then);

  final _NotebookDocumentChangeEvent _self;
  final $Res Function(_NotebookDocumentChangeEvent) _then;

/// Create a copy of NotebookDocumentChangeEvent
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? cells = freezed,Object? metadata = freezed,}) {
  return _then(_NotebookDocumentChangeEvent(
cells: freezed == cells ? _self.cells : cells // ignore: cast_nullable_to_non_nullable
as NotebookCellArrayChangeArrayTextDocumentIdentifiersDidCloseTextDocumentItemsDidOpenStructureNotebookCellsDataTextDocumentContentChangeEventsChangesVersionedTextDocumentIdentifierDocumentsTextContent?,metadata: freezed == metadata ? _self._metadata : metadata // ignore: cast_nullable_to_non_nullable
as LSPObject?,
  ));
}


}


/// @nodoc
mixin _$NotebookDocumentIdentifier {

/// The notebook document's uri.
 String get uri;
/// Create a copy of NotebookDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$NotebookDocumentIdentifierCopyWith<NotebookDocumentIdentifier> get copyWith => _$NotebookDocumentIdentifierCopyWithImpl<NotebookDocumentIdentifier>(this as NotebookDocumentIdentifier, _$identity);

  /// Serializes this NotebookDocumentIdentifier to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is NotebookDocumentIdentifier&&(identical(other.uri, uri) || other.uri == uri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri);

@override
String toString() {
  return 'NotebookDocumentIdentifier(uri: $uri)';
}


}

/// @nodoc
abstract mixin class $NotebookDocumentIdentifierCopyWith<$Res>  {
  factory $NotebookDocumentIdentifierCopyWith(NotebookDocumentIdentifier value, $Res Function(NotebookDocumentIdentifier) _then) = _$NotebookDocumentIdentifierCopyWithImpl;
@useResult
$Res call({
 String uri
});




}
/// @nodoc
class _$NotebookDocumentIdentifierCopyWithImpl<$Res>
    implements $NotebookDocumentIdentifierCopyWith<$Res> {
  _$NotebookDocumentIdentifierCopyWithImpl(this._self, this._then);

  final NotebookDocumentIdentifier _self;
  final $Res Function(NotebookDocumentIdentifier) _then;

/// Create a copy of NotebookDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? uri = null,}) {
  return _then(_self.copyWith(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _NotebookDocumentIdentifier implements NotebookDocumentIdentifier {
  const _NotebookDocumentIdentifier({required this.uri});
  factory _NotebookDocumentIdentifier.fromJson(Map<String, dynamic> json) => _$NotebookDocumentIdentifierFromJson(json);

/// The notebook document's uri.
@override final  String uri;

/// Create a copy of NotebookDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$NotebookDocumentIdentifierCopyWith<_NotebookDocumentIdentifier> get copyWith => __$NotebookDocumentIdentifierCopyWithImpl<_NotebookDocumentIdentifier>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$NotebookDocumentIdentifierToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _NotebookDocumentIdentifier&&(identical(other.uri, uri) || other.uri == uri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri);

@override
String toString() {
  return 'NotebookDocumentIdentifier(uri: $uri)';
}


}

/// @nodoc
abstract mixin class _$NotebookDocumentIdentifierCopyWith<$Res> implements $NotebookDocumentIdentifierCopyWith<$Res> {
  factory _$NotebookDocumentIdentifierCopyWith(_NotebookDocumentIdentifier value, $Res Function(_NotebookDocumentIdentifier) _then) = __$NotebookDocumentIdentifierCopyWithImpl;
@override @useResult
$Res call({
 String uri
});




}
/// @nodoc
class __$NotebookDocumentIdentifierCopyWithImpl<$Res>
    implements _$NotebookDocumentIdentifierCopyWith<$Res> {
  __$NotebookDocumentIdentifierCopyWithImpl(this._self, this._then);

  final _NotebookDocumentIdentifier _self;
  final $Res Function(_NotebookDocumentIdentifier) _then;

/// Create a copy of NotebookDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? uri = null,}) {
  return _then(_NotebookDocumentIdentifier(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}


/// @nodoc
mixin _$InlineCompletionContext {

/// Provides information about the currently selected item in the
/// autocomplete widget if it is visible.
 SelectedCompletionInfo? get selectedCompletionInfo;/// Describes how the inline completion was triggered.
 InlineCompletionTriggerKind get triggerKind;
/// Create a copy of InlineCompletionContext
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlineCompletionContextCopyWith<InlineCompletionContext> get copyWith => _$InlineCompletionContextCopyWithImpl<InlineCompletionContext>(this as InlineCompletionContext, _$identity);

  /// Serializes this InlineCompletionContext to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlineCompletionContext&&(identical(other.selectedCompletionInfo, selectedCompletionInfo) || other.selectedCompletionInfo == selectedCompletionInfo)&&(identical(other.triggerKind, triggerKind) || other.triggerKind == triggerKind));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,selectedCompletionInfo,triggerKind);

@override
String toString() {
  return 'InlineCompletionContext(selectedCompletionInfo: $selectedCompletionInfo, triggerKind: $triggerKind)';
}


}

/// @nodoc
abstract mixin class $InlineCompletionContextCopyWith<$Res>  {
  factory $InlineCompletionContextCopyWith(InlineCompletionContext value, $Res Function(InlineCompletionContext) _then) = _$InlineCompletionContextCopyWithImpl;
@useResult
$Res call({
 SelectedCompletionInfo? selectedCompletionInfo, InlineCompletionTriggerKind triggerKind
});


$SelectedCompletionInfoCopyWith<$Res>? get selectedCompletionInfo;

}
/// @nodoc
class _$InlineCompletionContextCopyWithImpl<$Res>
    implements $InlineCompletionContextCopyWith<$Res> {
  _$InlineCompletionContextCopyWithImpl(this._self, this._then);

  final InlineCompletionContext _self;
  final $Res Function(InlineCompletionContext) _then;

/// Create a copy of InlineCompletionContext
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? selectedCompletionInfo = freezed,Object? triggerKind = null,}) {
  return _then(_self.copyWith(
selectedCompletionInfo: freezed == selectedCompletionInfo ? _self.selectedCompletionInfo : selectedCompletionInfo // ignore: cast_nullable_to_non_nullable
as SelectedCompletionInfo?,triggerKind: null == triggerKind ? _self.triggerKind : triggerKind // ignore: cast_nullable_to_non_nullable
as InlineCompletionTriggerKind,
  ));
}
/// Create a copy of InlineCompletionContext
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SelectedCompletionInfoCopyWith<$Res>? get selectedCompletionInfo {
    if (_self.selectedCompletionInfo == null) {
    return null;
  }

  return $SelectedCompletionInfoCopyWith<$Res>(_self.selectedCompletionInfo!, (value) {
    return _then(_self.copyWith(selectedCompletionInfo: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _InlineCompletionContext implements InlineCompletionContext {
  const _InlineCompletionContext({this.selectedCompletionInfo, required this.triggerKind});
  factory _InlineCompletionContext.fromJson(Map<String, dynamic> json) => _$InlineCompletionContextFromJson(json);

/// Provides information about the currently selected item in the
/// autocomplete widget if it is visible.
@override final  SelectedCompletionInfo? selectedCompletionInfo;
/// Describes how the inline completion was triggered.
@override final  InlineCompletionTriggerKind triggerKind;

/// Create a copy of InlineCompletionContext
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlineCompletionContextCopyWith<_InlineCompletionContext> get copyWith => __$InlineCompletionContextCopyWithImpl<_InlineCompletionContext>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlineCompletionContextToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlineCompletionContext&&(identical(other.selectedCompletionInfo, selectedCompletionInfo) || other.selectedCompletionInfo == selectedCompletionInfo)&&(identical(other.triggerKind, triggerKind) || other.triggerKind == triggerKind));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,selectedCompletionInfo,triggerKind);

@override
String toString() {
  return 'InlineCompletionContext(selectedCompletionInfo: $selectedCompletionInfo, triggerKind: $triggerKind)';
}


}

/// @nodoc
abstract mixin class _$InlineCompletionContextCopyWith<$Res> implements $InlineCompletionContextCopyWith<$Res> {
  factory _$InlineCompletionContextCopyWith(_InlineCompletionContext value, $Res Function(_InlineCompletionContext) _then) = __$InlineCompletionContextCopyWithImpl;
@override @useResult
$Res call({
 SelectedCompletionInfo? selectedCompletionInfo, InlineCompletionTriggerKind triggerKind
});


@override $SelectedCompletionInfoCopyWith<$Res>? get selectedCompletionInfo;

}
/// @nodoc
class __$InlineCompletionContextCopyWithImpl<$Res>
    implements _$InlineCompletionContextCopyWith<$Res> {
  __$InlineCompletionContextCopyWithImpl(this._self, this._then);

  final _InlineCompletionContext _self;
  final $Res Function(_InlineCompletionContext) _then;

/// Create a copy of InlineCompletionContext
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? selectedCompletionInfo = freezed,Object? triggerKind = null,}) {
  return _then(_InlineCompletionContext(
selectedCompletionInfo: freezed == selectedCompletionInfo ? _self.selectedCompletionInfo : selectedCompletionInfo // ignore: cast_nullable_to_non_nullable
as SelectedCompletionInfo?,triggerKind: null == triggerKind ? _self.triggerKind : triggerKind // ignore: cast_nullable_to_non_nullable
as InlineCompletionTriggerKind,
  ));
}

/// Create a copy of InlineCompletionContext
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SelectedCompletionInfoCopyWith<$Res>? get selectedCompletionInfo {
    if (_self.selectedCompletionInfo == null) {
    return null;
  }

  return $SelectedCompletionInfoCopyWith<$Res>(_self.selectedCompletionInfo!, (value) {
    return _then(_self.copyWith(selectedCompletionInfo: value));
  });
}
}


/// @nodoc
mixin _$StringValue {

/// The kind of string value.
 StringLiteralRef get kind;/// The snippet string.
 String get value;
/// Create a copy of StringValue
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$StringValueCopyWith<StringValue> get copyWith => _$StringValueCopyWithImpl<StringValue>(this as StringValue, _$identity);

  /// Serializes this StringValue to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is StringValue&&const DeepCollectionEquality().equals(other.kind, kind)&&(identical(other.value, value) || other.value == value));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(kind),value);

@override
String toString() {
  return 'StringValue(kind: $kind, value: $value)';
}


}

/// @nodoc
abstract mixin class $StringValueCopyWith<$Res>  {
  factory $StringValueCopyWith(StringValue value, $Res Function(StringValue) _then) = _$StringValueCopyWithImpl;
@useResult
$Res call({
 StringLiteralRef kind, String value
});




}
/// @nodoc
class _$StringValueCopyWithImpl<$Res>
    implements $StringValueCopyWith<$Res> {
  _$StringValueCopyWithImpl(this._self, this._then);

  final StringValue _self;
  final $Res Function(StringValue) _then;

/// Create a copy of StringValue
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? kind = freezed,Object? value = null,}) {
  return _then(_self.copyWith(
kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as StringLiteralRef,value: null == value ? _self.value : value // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _StringValue implements StringValue {
  const _StringValue({required this.kind, required this.value});
  factory _StringValue.fromJson(Map<String, dynamic> json) => _$StringValueFromJson(json);

/// The kind of string value.
@override final  StringLiteralRef kind;
/// The snippet string.
@override final  String value;

/// Create a copy of StringValue
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$StringValueCopyWith<_StringValue> get copyWith => __$StringValueCopyWithImpl<_StringValue>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$StringValueToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _StringValue&&const DeepCollectionEquality().equals(other.kind, kind)&&(identical(other.value, value) || other.value == value));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(kind),value);

@override
String toString() {
  return 'StringValue(kind: $kind, value: $value)';
}


}

/// @nodoc
abstract mixin class _$StringValueCopyWith<$Res> implements $StringValueCopyWith<$Res> {
  factory _$StringValueCopyWith(_StringValue value, $Res Function(_StringValue) _then) = __$StringValueCopyWithImpl;
@override @useResult
$Res call({
 StringLiteralRef kind, String value
});




}
/// @nodoc
class __$StringValueCopyWithImpl<$Res>
    implements _$StringValueCopyWith<$Res> {
  __$StringValueCopyWithImpl(this._self, this._then);

  final _StringValue _self;
  final $Res Function(_StringValue) _then;

/// Create a copy of StringValue
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? kind = freezed,Object? value = null,}) {
  return _then(_StringValue(
kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as StringLiteralRef,value: null == value ? _self.value : value // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}


/// @nodoc
mixin _$InlineCompletionOptions {

 bool? get workDoneProgress;
/// Create a copy of InlineCompletionOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlineCompletionOptionsCopyWith<InlineCompletionOptions> get copyWith => _$InlineCompletionOptionsCopyWithImpl<InlineCompletionOptions>(this as InlineCompletionOptions, _$identity);

  /// Serializes this InlineCompletionOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlineCompletionOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'InlineCompletionOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $InlineCompletionOptionsCopyWith<$Res>  {
  factory $InlineCompletionOptionsCopyWith(InlineCompletionOptions value, $Res Function(InlineCompletionOptions) _then) = _$InlineCompletionOptionsCopyWithImpl;
@useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class _$InlineCompletionOptionsCopyWithImpl<$Res>
    implements $InlineCompletionOptionsCopyWith<$Res> {
  _$InlineCompletionOptionsCopyWithImpl(this._self, this._then);

  final InlineCompletionOptions _self;
  final $Res Function(InlineCompletionOptions) _then;

/// Create a copy of InlineCompletionOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _InlineCompletionOptions implements InlineCompletionOptions {
  const _InlineCompletionOptions({this.workDoneProgress});
  factory _InlineCompletionOptions.fromJson(Map<String, dynamic> json) => _$InlineCompletionOptionsFromJson(json);

@override final  bool? workDoneProgress;

/// Create a copy of InlineCompletionOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlineCompletionOptionsCopyWith<_InlineCompletionOptions> get copyWith => __$InlineCompletionOptionsCopyWithImpl<_InlineCompletionOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlineCompletionOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlineCompletionOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'InlineCompletionOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$InlineCompletionOptionsCopyWith<$Res> implements $InlineCompletionOptionsCopyWith<$Res> {
  factory _$InlineCompletionOptionsCopyWith(_InlineCompletionOptions value, $Res Function(_InlineCompletionOptions) _then) = __$InlineCompletionOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class __$InlineCompletionOptionsCopyWithImpl<$Res>
    implements _$InlineCompletionOptionsCopyWith<$Res> {
  __$InlineCompletionOptionsCopyWithImpl(this._self, this._then);

  final _InlineCompletionOptions _self;
  final $Res Function(_InlineCompletionOptions) _then;

/// Create a copy of InlineCompletionOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_InlineCompletionOptions(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$Registration {

/// The id used to register the request. The id can be used to deregister
/// the request again.
 String get id;/// The method / capability to register for.
 String get method;/// Options necessary for the registration.
 LSPAny? get registerOptions;
/// Create a copy of Registration
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RegistrationCopyWith<Registration> get copyWith => _$RegistrationCopyWithImpl<Registration>(this as Registration, _$identity);

  /// Serializes this Registration to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Registration&&(identical(other.id, id) || other.id == id)&&(identical(other.method, method) || other.method == method)&&(identical(other.registerOptions, registerOptions) || other.registerOptions == registerOptions));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,method,registerOptions);

@override
String toString() {
  return 'Registration(id: $id, method: $method, registerOptions: $registerOptions)';
}


}

/// @nodoc
abstract mixin class $RegistrationCopyWith<$Res>  {
  factory $RegistrationCopyWith(Registration value, $Res Function(Registration) _then) = _$RegistrationCopyWithImpl;
@useResult
$Res call({
 String id, String method, LSPAny? registerOptions
});




}
/// @nodoc
class _$RegistrationCopyWithImpl<$Res>
    implements $RegistrationCopyWith<$Res> {
  _$RegistrationCopyWithImpl(this._self, this._then);

  final Registration _self;
  final $Res Function(Registration) _then;

/// Create a copy of Registration
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = null,Object? method = null,Object? registerOptions = freezed,}) {
  return _then(_self.copyWith(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,method: null == method ? _self.method : method // ignore: cast_nullable_to_non_nullable
as String,registerOptions: freezed == registerOptions ? _self.registerOptions : registerOptions // ignore: cast_nullable_to_non_nullable
as LSPAny?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _Registration implements Registration {
  const _Registration({required this.id, required this.method, this.registerOptions});
  factory _Registration.fromJson(Map<String, dynamic> json) => _$RegistrationFromJson(json);

/// The id used to register the request. The id can be used to deregister
/// the request again.
@override final  String id;
/// The method / capability to register for.
@override final  String method;
/// Options necessary for the registration.
@override final  LSPAny? registerOptions;

/// Create a copy of Registration
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RegistrationCopyWith<_Registration> get copyWith => __$RegistrationCopyWithImpl<_Registration>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$RegistrationToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _Registration&&(identical(other.id, id) || other.id == id)&&(identical(other.method, method) || other.method == method)&&(identical(other.registerOptions, registerOptions) || other.registerOptions == registerOptions));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,method,registerOptions);

@override
String toString() {
  return 'Registration(id: $id, method: $method, registerOptions: $registerOptions)';
}


}

/// @nodoc
abstract mixin class _$RegistrationCopyWith<$Res> implements $RegistrationCopyWith<$Res> {
  factory _$RegistrationCopyWith(_Registration value, $Res Function(_Registration) _then) = __$RegistrationCopyWithImpl;
@override @useResult
$Res call({
 String id, String method, LSPAny? registerOptions
});




}
/// @nodoc
class __$RegistrationCopyWithImpl<$Res>
    implements _$RegistrationCopyWith<$Res> {
  __$RegistrationCopyWithImpl(this._self, this._then);

  final _Registration _self;
  final $Res Function(_Registration) _then;

/// Create a copy of Registration
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = null,Object? method = null,Object? registerOptions = freezed,}) {
  return _then(_Registration(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,method: null == method ? _self.method : method // ignore: cast_nullable_to_non_nullable
as String,registerOptions: freezed == registerOptions ? _self.registerOptions : registerOptions // ignore: cast_nullable_to_non_nullable
as LSPAny?,
  ));
}


}


/// @nodoc
mixin _$Unregistration {

/// The id used to unregister the request or notification. Usually an id
/// provided during the register request.
 String get id;/// The method to unregister for.
 String get method;
/// Create a copy of Unregistration
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$UnregistrationCopyWith<Unregistration> get copyWith => _$UnregistrationCopyWithImpl<Unregistration>(this as Unregistration, _$identity);

  /// Serializes this Unregistration to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Unregistration&&(identical(other.id, id) || other.id == id)&&(identical(other.method, method) || other.method == method));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,method);

@override
String toString() {
  return 'Unregistration(id: $id, method: $method)';
}


}

/// @nodoc
abstract mixin class $UnregistrationCopyWith<$Res>  {
  factory $UnregistrationCopyWith(Unregistration value, $Res Function(Unregistration) _then) = _$UnregistrationCopyWithImpl;
@useResult
$Res call({
 String id, String method
});




}
/// @nodoc
class _$UnregistrationCopyWithImpl<$Res>
    implements $UnregistrationCopyWith<$Res> {
  _$UnregistrationCopyWithImpl(this._self, this._then);

  final Unregistration _self;
  final $Res Function(Unregistration) _then;

/// Create a copy of Unregistration
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = null,Object? method = null,}) {
  return _then(_self.copyWith(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,method: null == method ? _self.method : method // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _Unregistration implements Unregistration {
  const _Unregistration({required this.id, required this.method});
  factory _Unregistration.fromJson(Map<String, dynamic> json) => _$UnregistrationFromJson(json);

/// The id used to unregister the request or notification. Usually an id
/// provided during the register request.
@override final  String id;
/// The method to unregister for.
@override final  String method;

/// Create a copy of Unregistration
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$UnregistrationCopyWith<_Unregistration> get copyWith => __$UnregistrationCopyWithImpl<_Unregistration>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$UnregistrationToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _Unregistration&&(identical(other.id, id) || other.id == id)&&(identical(other.method, method) || other.method == method));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,method);

@override
String toString() {
  return 'Unregistration(id: $id, method: $method)';
}


}

/// @nodoc
abstract mixin class _$UnregistrationCopyWith<$Res> implements $UnregistrationCopyWith<$Res> {
  factory _$UnregistrationCopyWith(_Unregistration value, $Res Function(_Unregistration) _then) = __$UnregistrationCopyWithImpl;
@override @useResult
$Res call({
 String id, String method
});




}
/// @nodoc
class __$UnregistrationCopyWithImpl<$Res>
    implements _$UnregistrationCopyWith<$Res> {
  __$UnregistrationCopyWithImpl(this._self, this._then);

  final _Unregistration _self;
  final $Res Function(_Unregistration) _then;

/// Create a copy of Unregistration
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = null,Object? method = null,}) {
  return _then(_Unregistration(
id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String,method: null == method ? _self.method : method // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}


/// @nodoc
mixin _$TInitializeParams {

/// The capabilities provided by the client (editor or tool)
 ClientCapabilities get capabilities;/// Information about the client
/// @since 3.15.0
 StringNameStringVersion? get clientInfo;/// User provided initialization options.
 LSPAny? get initializationOptions;/// The locale the client is currently showing the user interface in. This
/// must not necessarily be the locale of the operating system.
/// Uses IETF language tags as the value's syntax (See
/// https://en.wikipedia.org/wiki/IETF_language_tag)
/// @since 3.16.0
 String? get locale;/// The process Id of the parent process that started the server.
/// Is `null` if the process has not been started by another process. If
/// the parent process is not alive then the server should exit.
 Sealed28 get processId;/// The rootPath of the workspace. Is null if no folder is open.
/// @deprecated in favour of rootUri.
 Sealed29? get rootPath;/// The rootUri of the workspace. Is null if no folder is open. If both
/// `rootPath` and `rootUri` are set `rootUri` wins.
/// @deprecated in favour of workspaceFolders.
 Sealed29 get rootUri;/// The initial trace setting. If omitted trace is disabled ('off').
 TraceValues? get trace;/// An optional token that a server can use to report work done progress.
 ProgressToken? get workDoneToken;
/// Create a copy of TInitializeParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TInitializeParamsCopyWith<TInitializeParams> get copyWith => _$TInitializeParamsCopyWithImpl<TInitializeParams>(this as TInitializeParams, _$identity);

  /// Serializes this TInitializeParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TInitializeParams&&(identical(other.capabilities, capabilities) || other.capabilities == capabilities)&&const DeepCollectionEquality().equals(other.clientInfo, clientInfo)&&(identical(other.initializationOptions, initializationOptions) || other.initializationOptions == initializationOptions)&&(identical(other.locale, locale) || other.locale == locale)&&(identical(other.processId, processId) || other.processId == processId)&&(identical(other.rootPath, rootPath) || other.rootPath == rootPath)&&(identical(other.rootUri, rootUri) || other.rootUri == rootUri)&&(identical(other.trace, trace) || other.trace == trace)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,capabilities,const DeepCollectionEquality().hash(clientInfo),initializationOptions,locale,processId,rootPath,rootUri,trace,workDoneToken);

@override
String toString() {
  return 'TInitializeParams(capabilities: $capabilities, clientInfo: $clientInfo, initializationOptions: $initializationOptions, locale: $locale, processId: $processId, rootPath: $rootPath, rootUri: $rootUri, trace: $trace, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class $TInitializeParamsCopyWith<$Res>  {
  factory $TInitializeParamsCopyWith(TInitializeParams value, $Res Function(TInitializeParams) _then) = _$TInitializeParamsCopyWithImpl;
@useResult
$Res call({
 ClientCapabilities capabilities, StringNameStringVersion? clientInfo, LSPAny? initializationOptions, String? locale, Sealed28 processId, Sealed29? rootPath, Sealed29 rootUri, TraceValues? trace, ProgressToken? workDoneToken
});


$ClientCapabilitiesCopyWith<$Res> get capabilities;

}
/// @nodoc
class _$TInitializeParamsCopyWithImpl<$Res>
    implements $TInitializeParamsCopyWith<$Res> {
  _$TInitializeParamsCopyWithImpl(this._self, this._then);

  final TInitializeParams _self;
  final $Res Function(TInitializeParams) _then;

/// Create a copy of TInitializeParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? capabilities = null,Object? clientInfo = freezed,Object? initializationOptions = freezed,Object? locale = freezed,Object? processId = null,Object? rootPath = freezed,Object? rootUri = null,Object? trace = freezed,Object? workDoneToken = freezed,}) {
  return _then(_self.copyWith(
capabilities: null == capabilities ? _self.capabilities : capabilities // ignore: cast_nullable_to_non_nullable
as ClientCapabilities,clientInfo: freezed == clientInfo ? _self.clientInfo : clientInfo // ignore: cast_nullable_to_non_nullable
as StringNameStringVersion?,initializationOptions: freezed == initializationOptions ? _self.initializationOptions : initializationOptions // ignore: cast_nullable_to_non_nullable
as LSPAny?,locale: freezed == locale ? _self.locale : locale // ignore: cast_nullable_to_non_nullable
as String?,processId: null == processId ? _self.processId : processId // ignore: cast_nullable_to_non_nullable
as Sealed28,rootPath: freezed == rootPath ? _self.rootPath : rootPath // ignore: cast_nullable_to_non_nullable
as Sealed29?,rootUri: null == rootUri ? _self.rootUri : rootUri // ignore: cast_nullable_to_non_nullable
as Sealed29,trace: freezed == trace ? _self.trace : trace // ignore: cast_nullable_to_non_nullable
as TraceValues?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}
/// Create a copy of TInitializeParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ClientCapabilitiesCopyWith<$Res> get capabilities {
  
  return $ClientCapabilitiesCopyWith<$Res>(_self.capabilities, (value) {
    return _then(_self.copyWith(capabilities: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _TInitializeParams implements TInitializeParams {
  const _TInitializeParams({required this.capabilities, this.clientInfo, this.initializationOptions, this.locale, required this.processId, this.rootPath, required this.rootUri, this.trace, this.workDoneToken});
  factory _TInitializeParams.fromJson(Map<String, dynamic> json) => _$TInitializeParamsFromJson(json);

/// The capabilities provided by the client (editor or tool)
@override final  ClientCapabilities capabilities;
/// Information about the client
/// @since 3.15.0
@override final  StringNameStringVersion? clientInfo;
/// User provided initialization options.
@override final  LSPAny? initializationOptions;
/// The locale the client is currently showing the user interface in. This
/// must not necessarily be the locale of the operating system.
/// Uses IETF language tags as the value's syntax (See
/// https://en.wikipedia.org/wiki/IETF_language_tag)
/// @since 3.16.0
@override final  String? locale;
/// The process Id of the parent process that started the server.
/// Is `null` if the process has not been started by another process. If
/// the parent process is not alive then the server should exit.
@override final  Sealed28 processId;
/// The rootPath of the workspace. Is null if no folder is open.
/// @deprecated in favour of rootUri.
@override final  Sealed29? rootPath;
/// The rootUri of the workspace. Is null if no folder is open. If both
/// `rootPath` and `rootUri` are set `rootUri` wins.
/// @deprecated in favour of workspaceFolders.
@override final  Sealed29 rootUri;
/// The initial trace setting. If omitted trace is disabled ('off').
@override final  TraceValues? trace;
/// An optional token that a server can use to report work done progress.
@override final  ProgressToken? workDoneToken;

/// Create a copy of TInitializeParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TInitializeParamsCopyWith<_TInitializeParams> get copyWith => __$TInitializeParamsCopyWithImpl<_TInitializeParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TInitializeParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TInitializeParams&&(identical(other.capabilities, capabilities) || other.capabilities == capabilities)&&const DeepCollectionEquality().equals(other.clientInfo, clientInfo)&&(identical(other.initializationOptions, initializationOptions) || other.initializationOptions == initializationOptions)&&(identical(other.locale, locale) || other.locale == locale)&&(identical(other.processId, processId) || other.processId == processId)&&(identical(other.rootPath, rootPath) || other.rootPath == rootPath)&&(identical(other.rootUri, rootUri) || other.rootUri == rootUri)&&(identical(other.trace, trace) || other.trace == trace)&&(identical(other.workDoneToken, workDoneToken) || other.workDoneToken == workDoneToken));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,capabilities,const DeepCollectionEquality().hash(clientInfo),initializationOptions,locale,processId,rootPath,rootUri,trace,workDoneToken);

@override
String toString() {
  return 'TInitializeParams(capabilities: $capabilities, clientInfo: $clientInfo, initializationOptions: $initializationOptions, locale: $locale, processId: $processId, rootPath: $rootPath, rootUri: $rootUri, trace: $trace, workDoneToken: $workDoneToken)';
}


}

/// @nodoc
abstract mixin class _$TInitializeParamsCopyWith<$Res> implements $TInitializeParamsCopyWith<$Res> {
  factory _$TInitializeParamsCopyWith(_TInitializeParams value, $Res Function(_TInitializeParams) _then) = __$TInitializeParamsCopyWithImpl;
@override @useResult
$Res call({
 ClientCapabilities capabilities, StringNameStringVersion? clientInfo, LSPAny? initializationOptions, String? locale, Sealed28 processId, Sealed29? rootPath, Sealed29 rootUri, TraceValues? trace, ProgressToken? workDoneToken
});


@override $ClientCapabilitiesCopyWith<$Res> get capabilities;

}
/// @nodoc
class __$TInitializeParamsCopyWithImpl<$Res>
    implements _$TInitializeParamsCopyWith<$Res> {
  __$TInitializeParamsCopyWithImpl(this._self, this._then);

  final _TInitializeParams _self;
  final $Res Function(_TInitializeParams) _then;

/// Create a copy of TInitializeParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? capabilities = null,Object? clientInfo = freezed,Object? initializationOptions = freezed,Object? locale = freezed,Object? processId = null,Object? rootPath = freezed,Object? rootUri = null,Object? trace = freezed,Object? workDoneToken = freezed,}) {
  return _then(_TInitializeParams(
capabilities: null == capabilities ? _self.capabilities : capabilities // ignore: cast_nullable_to_non_nullable
as ClientCapabilities,clientInfo: freezed == clientInfo ? _self.clientInfo : clientInfo // ignore: cast_nullable_to_non_nullable
as StringNameStringVersion?,initializationOptions: freezed == initializationOptions ? _self.initializationOptions : initializationOptions // ignore: cast_nullable_to_non_nullable
as LSPAny?,locale: freezed == locale ? _self.locale : locale // ignore: cast_nullable_to_non_nullable
as String?,processId: null == processId ? _self.processId : processId // ignore: cast_nullable_to_non_nullable
as Sealed28,rootPath: freezed == rootPath ? _self.rootPath : rootPath // ignore: cast_nullable_to_non_nullable
as Sealed29?,rootUri: null == rootUri ? _self.rootUri : rootUri // ignore: cast_nullable_to_non_nullable
as Sealed29,trace: freezed == trace ? _self.trace : trace // ignore: cast_nullable_to_non_nullable
as TraceValues?,workDoneToken: freezed == workDoneToken ? _self.workDoneToken : workDoneToken // ignore: cast_nullable_to_non_nullable
as ProgressToken?,
  ));
}

/// Create a copy of TInitializeParams
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ClientCapabilitiesCopyWith<$Res> get capabilities {
  
  return $ClientCapabilitiesCopyWith<$Res>(_self.capabilities, (value) {
    return _then(_self.copyWith(capabilities: value));
  });
}
}


/// @nodoc
mixin _$WorkspaceFoldersInitializeParams {

/// The workspace folders configured in the client when the server starts.
/// This property is only available if the client supports workspace
/// folders. It can be `null` if the client supports workspace folders but
/// none are configured.
/// @since 3.6.0
 Sealed30? get workspaceFolders;
/// Create a copy of WorkspaceFoldersInitializeParams
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkspaceFoldersInitializeParamsCopyWith<WorkspaceFoldersInitializeParams> get copyWith => _$WorkspaceFoldersInitializeParamsCopyWithImpl<WorkspaceFoldersInitializeParams>(this as WorkspaceFoldersInitializeParams, _$identity);

  /// Serializes this WorkspaceFoldersInitializeParams to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkspaceFoldersInitializeParams&&(identical(other.workspaceFolders, workspaceFolders) || other.workspaceFolders == workspaceFolders));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workspaceFolders);

@override
String toString() {
  return 'WorkspaceFoldersInitializeParams(workspaceFolders: $workspaceFolders)';
}


}

/// @nodoc
abstract mixin class $WorkspaceFoldersInitializeParamsCopyWith<$Res>  {
  factory $WorkspaceFoldersInitializeParamsCopyWith(WorkspaceFoldersInitializeParams value, $Res Function(WorkspaceFoldersInitializeParams) _then) = _$WorkspaceFoldersInitializeParamsCopyWithImpl;
@useResult
$Res call({
 Sealed30? workspaceFolders
});




}
/// @nodoc
class _$WorkspaceFoldersInitializeParamsCopyWithImpl<$Res>
    implements $WorkspaceFoldersInitializeParamsCopyWith<$Res> {
  _$WorkspaceFoldersInitializeParamsCopyWithImpl(this._self, this._then);

  final WorkspaceFoldersInitializeParams _self;
  final $Res Function(WorkspaceFoldersInitializeParams) _then;

/// Create a copy of WorkspaceFoldersInitializeParams
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workspaceFolders = freezed,}) {
  return _then(_self.copyWith(
workspaceFolders: freezed == workspaceFolders ? _self.workspaceFolders : workspaceFolders // ignore: cast_nullable_to_non_nullable
as Sealed30?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _WorkspaceFoldersInitializeParams implements WorkspaceFoldersInitializeParams {
  const _WorkspaceFoldersInitializeParams({this.workspaceFolders});
  factory _WorkspaceFoldersInitializeParams.fromJson(Map<String, dynamic> json) => _$WorkspaceFoldersInitializeParamsFromJson(json);

/// The workspace folders configured in the client when the server starts.
/// This property is only available if the client supports workspace
/// folders. It can be `null` if the client supports workspace folders but
/// none are configured.
/// @since 3.6.0
@override final  Sealed30? workspaceFolders;

/// Create a copy of WorkspaceFoldersInitializeParams
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkspaceFoldersInitializeParamsCopyWith<_WorkspaceFoldersInitializeParams> get copyWith => __$WorkspaceFoldersInitializeParamsCopyWithImpl<_WorkspaceFoldersInitializeParams>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkspaceFoldersInitializeParamsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkspaceFoldersInitializeParams&&(identical(other.workspaceFolders, workspaceFolders) || other.workspaceFolders == workspaceFolders));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workspaceFolders);

@override
String toString() {
  return 'WorkspaceFoldersInitializeParams(workspaceFolders: $workspaceFolders)';
}


}

/// @nodoc
abstract mixin class _$WorkspaceFoldersInitializeParamsCopyWith<$Res> implements $WorkspaceFoldersInitializeParamsCopyWith<$Res> {
  factory _$WorkspaceFoldersInitializeParamsCopyWith(_WorkspaceFoldersInitializeParams value, $Res Function(_WorkspaceFoldersInitializeParams) _then) = __$WorkspaceFoldersInitializeParamsCopyWithImpl;
@override @useResult
$Res call({
 Sealed30? workspaceFolders
});




}
/// @nodoc
class __$WorkspaceFoldersInitializeParamsCopyWithImpl<$Res>
    implements _$WorkspaceFoldersInitializeParamsCopyWith<$Res> {
  __$WorkspaceFoldersInitializeParamsCopyWithImpl(this._self, this._then);

  final _WorkspaceFoldersInitializeParams _self;
  final $Res Function(_WorkspaceFoldersInitializeParams) _then;

/// Create a copy of WorkspaceFoldersInitializeParams
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workspaceFolders = freezed,}) {
  return _then(_WorkspaceFoldersInitializeParams(
workspaceFolders: freezed == workspaceFolders ? _self.workspaceFolders : workspaceFolders // ignore: cast_nullable_to_non_nullable
as Sealed30?,
  ));
}


}


/// @nodoc
mixin _$ServerCapabilities {

/// The server provides call hierarchy support.
/// @since 3.16.0
 Sealed49? get callHierarchyProvider;/// The server provides code actions. CodeActionOptions may only be
/// specified if the client states that it supports
/// `codeActionLiteralSupport` in its initial `initialize` request.
 Sealed41? get codeActionProvider;/// The server provides code lens.
 CodeLensOptions? get codeLensProvider;/// The server provides color provider support.
 Sealed42? get colorProvider;/// The server provides completion support.
 CompletionOptions? get completionProvider;/// The server provides Goto Declaration support.
 Sealed34? get declarationProvider;/// The server provides goto definition support.
 Sealed35? get definitionProvider;/// The server has support for pull model diagnostics.
/// @since 3.17.0
 Sealed56? get diagnosticProvider;/// The server provides document formatting.
 Sealed44? get documentFormattingProvider;/// The server provides document highlight support.
 Sealed39? get documentHighlightProvider;/// The server provides document link support.
 DocumentLinkOptions? get documentLinkProvider;/// The server provides document formatting on typing.
 DocumentOnTypeFormattingOptions? get documentOnTypeFormattingProvider;/// The server provides document range formatting.
 Sealed45? get documentRangeFormattingProvider;/// The server provides document symbol support.
 Sealed40? get documentSymbolProvider;/// The server provides execute command support.
 ExecuteCommandOptions? get executeCommandProvider;/// Experimental server capabilities.
 LSPAny? get experimental;/// The server provides folding provider support.
 Sealed47? get foldingRangeProvider;/// The server provides hover support.
 Sealed33? get hoverProvider;/// The server provides Goto Implementation support.
 Sealed37? get implementationProvider;/// The server provides inlay hints.
/// @since 3.17.0
 Sealed55? get inlayHintProvider;/// Inline completion options used during static registration.
/// @since 3.18.0 @proposed
 Sealed57? get inlineCompletionProvider;/// The server provides inline values.
/// @since 3.17.0
 Sealed54? get inlineValueProvider;/// The server provides linked editing range support.
/// @since 3.16.0
 Sealed50? get linkedEditingRangeProvider;/// The server provides moniker support.
/// @since 3.16.0
 Sealed52? get monikerProvider;/// Defines how notebook documents are synced.
/// @since 3.17.0
 Sealed32? get notebookDocumentSync;/// The position encoding the server picked from the encodings offered by
/// the client via the client capability `general.positionEncodings`.
/// If the client didn't provide any position encodings the only valid
/// value that a server can return is 'utf-16'.
/// If omitted it defaults to 'utf-16'.
/// @since 3.17.0
 PositionEncodingKind? get positionEncoding;/// The server provides find references support.
 Sealed38? get referencesProvider;/// The server provides rename support. RenameOptions may only be specified
/// if the client states that it supports `prepareSupport` in its initial
/// `initialize` request.
 Sealed46? get renameProvider;/// The server provides selection range support.
 Sealed48? get selectionRangeProvider;/// The server provides semantic tokens support.
/// @since 3.16.0
 Sealed51? get semanticTokensProvider;/// The server provides signature help support.
 SignatureHelpOptions? get signatureHelpProvider;/// Defines how text documents are synced. Is either a detailed structure
/// defining each notification or for backwards compatibility the
/// TextDocumentSyncKind number.
 Sealed31? get textDocumentSync;/// The server provides Goto Type Definition support.
 Sealed36? get typeDefinitionProvider;/// The server provides type hierarchy support.
/// @since 3.17.0
 Sealed53? get typeHierarchyProvider;/// Workspace specific server capabilities.
 FileOperationOptionsFileOperationsWorkspaceFoldersServerCapabilitiesWorkspaceFolders? get workspace;/// The server provides workspace symbol support.
 Sealed43? get workspaceSymbolProvider;
/// Create a copy of ServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ServerCapabilitiesCopyWith<ServerCapabilities> get copyWith => _$ServerCapabilitiesCopyWithImpl<ServerCapabilities>(this as ServerCapabilities, _$identity);

  /// Serializes this ServerCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ServerCapabilities&&(identical(other.callHierarchyProvider, callHierarchyProvider) || other.callHierarchyProvider == callHierarchyProvider)&&(identical(other.codeActionProvider, codeActionProvider) || other.codeActionProvider == codeActionProvider)&&(identical(other.codeLensProvider, codeLensProvider) || other.codeLensProvider == codeLensProvider)&&(identical(other.colorProvider, colorProvider) || other.colorProvider == colorProvider)&&(identical(other.completionProvider, completionProvider) || other.completionProvider == completionProvider)&&(identical(other.declarationProvider, declarationProvider) || other.declarationProvider == declarationProvider)&&(identical(other.definitionProvider, definitionProvider) || other.definitionProvider == definitionProvider)&&(identical(other.diagnosticProvider, diagnosticProvider) || other.diagnosticProvider == diagnosticProvider)&&(identical(other.documentFormattingProvider, documentFormattingProvider) || other.documentFormattingProvider == documentFormattingProvider)&&(identical(other.documentHighlightProvider, documentHighlightProvider) || other.documentHighlightProvider == documentHighlightProvider)&&(identical(other.documentLinkProvider, documentLinkProvider) || other.documentLinkProvider == documentLinkProvider)&&(identical(other.documentOnTypeFormattingProvider, documentOnTypeFormattingProvider) || other.documentOnTypeFormattingProvider == documentOnTypeFormattingProvider)&&(identical(other.documentRangeFormattingProvider, documentRangeFormattingProvider) || other.documentRangeFormattingProvider == documentRangeFormattingProvider)&&(identical(other.documentSymbolProvider, documentSymbolProvider) || other.documentSymbolProvider == documentSymbolProvider)&&(identical(other.executeCommandProvider, executeCommandProvider) || other.executeCommandProvider == executeCommandProvider)&&(identical(other.experimental, experimental) || other.experimental == experimental)&&(identical(other.foldingRangeProvider, foldingRangeProvider) || other.foldingRangeProvider == foldingRangeProvider)&&(identical(other.hoverProvider, hoverProvider) || other.hoverProvider == hoverProvider)&&(identical(other.implementationProvider, implementationProvider) || other.implementationProvider == implementationProvider)&&(identical(other.inlayHintProvider, inlayHintProvider) || other.inlayHintProvider == inlayHintProvider)&&(identical(other.inlineCompletionProvider, inlineCompletionProvider) || other.inlineCompletionProvider == inlineCompletionProvider)&&(identical(other.inlineValueProvider, inlineValueProvider) || other.inlineValueProvider == inlineValueProvider)&&(identical(other.linkedEditingRangeProvider, linkedEditingRangeProvider) || other.linkedEditingRangeProvider == linkedEditingRangeProvider)&&(identical(other.monikerProvider, monikerProvider) || other.monikerProvider == monikerProvider)&&(identical(other.notebookDocumentSync, notebookDocumentSync) || other.notebookDocumentSync == notebookDocumentSync)&&(identical(other.positionEncoding, positionEncoding) || other.positionEncoding == positionEncoding)&&(identical(other.referencesProvider, referencesProvider) || other.referencesProvider == referencesProvider)&&(identical(other.renameProvider, renameProvider) || other.renameProvider == renameProvider)&&(identical(other.selectionRangeProvider, selectionRangeProvider) || other.selectionRangeProvider == selectionRangeProvider)&&(identical(other.semanticTokensProvider, semanticTokensProvider) || other.semanticTokensProvider == semanticTokensProvider)&&(identical(other.signatureHelpProvider, signatureHelpProvider) || other.signatureHelpProvider == signatureHelpProvider)&&(identical(other.textDocumentSync, textDocumentSync) || other.textDocumentSync == textDocumentSync)&&(identical(other.typeDefinitionProvider, typeDefinitionProvider) || other.typeDefinitionProvider == typeDefinitionProvider)&&(identical(other.typeHierarchyProvider, typeHierarchyProvider) || other.typeHierarchyProvider == typeHierarchyProvider)&&const DeepCollectionEquality().equals(other.workspace, workspace)&&(identical(other.workspaceSymbolProvider, workspaceSymbolProvider) || other.workspaceSymbolProvider == workspaceSymbolProvider));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hashAll([runtimeType,callHierarchyProvider,codeActionProvider,codeLensProvider,colorProvider,completionProvider,declarationProvider,definitionProvider,diagnosticProvider,documentFormattingProvider,documentHighlightProvider,documentLinkProvider,documentOnTypeFormattingProvider,documentRangeFormattingProvider,documentSymbolProvider,executeCommandProvider,experimental,foldingRangeProvider,hoverProvider,implementationProvider,inlayHintProvider,inlineCompletionProvider,inlineValueProvider,linkedEditingRangeProvider,monikerProvider,notebookDocumentSync,positionEncoding,referencesProvider,renameProvider,selectionRangeProvider,semanticTokensProvider,signatureHelpProvider,textDocumentSync,typeDefinitionProvider,typeHierarchyProvider,const DeepCollectionEquality().hash(workspace),workspaceSymbolProvider]);

@override
String toString() {
  return 'ServerCapabilities(callHierarchyProvider: $callHierarchyProvider, codeActionProvider: $codeActionProvider, codeLensProvider: $codeLensProvider, colorProvider: $colorProvider, completionProvider: $completionProvider, declarationProvider: $declarationProvider, definitionProvider: $definitionProvider, diagnosticProvider: $diagnosticProvider, documentFormattingProvider: $documentFormattingProvider, documentHighlightProvider: $documentHighlightProvider, documentLinkProvider: $documentLinkProvider, documentOnTypeFormattingProvider: $documentOnTypeFormattingProvider, documentRangeFormattingProvider: $documentRangeFormattingProvider, documentSymbolProvider: $documentSymbolProvider, executeCommandProvider: $executeCommandProvider, experimental: $experimental, foldingRangeProvider: $foldingRangeProvider, hoverProvider: $hoverProvider, implementationProvider: $implementationProvider, inlayHintProvider: $inlayHintProvider, inlineCompletionProvider: $inlineCompletionProvider, inlineValueProvider: $inlineValueProvider, linkedEditingRangeProvider: $linkedEditingRangeProvider, monikerProvider: $monikerProvider, notebookDocumentSync: $notebookDocumentSync, positionEncoding: $positionEncoding, referencesProvider: $referencesProvider, renameProvider: $renameProvider, selectionRangeProvider: $selectionRangeProvider, semanticTokensProvider: $semanticTokensProvider, signatureHelpProvider: $signatureHelpProvider, textDocumentSync: $textDocumentSync, typeDefinitionProvider: $typeDefinitionProvider, typeHierarchyProvider: $typeHierarchyProvider, workspace: $workspace, workspaceSymbolProvider: $workspaceSymbolProvider)';
}


}

/// @nodoc
abstract mixin class $ServerCapabilitiesCopyWith<$Res>  {
  factory $ServerCapabilitiesCopyWith(ServerCapabilities value, $Res Function(ServerCapabilities) _then) = _$ServerCapabilitiesCopyWithImpl;
@useResult
$Res call({
 Sealed49? callHierarchyProvider, Sealed41? codeActionProvider, CodeLensOptions? codeLensProvider, Sealed42? colorProvider, CompletionOptions? completionProvider, Sealed34? declarationProvider, Sealed35? definitionProvider, Sealed56? diagnosticProvider, Sealed44? documentFormattingProvider, Sealed39? documentHighlightProvider, DocumentLinkOptions? documentLinkProvider, DocumentOnTypeFormattingOptions? documentOnTypeFormattingProvider, Sealed45? documentRangeFormattingProvider, Sealed40? documentSymbolProvider, ExecuteCommandOptions? executeCommandProvider, LSPAny? experimental, Sealed47? foldingRangeProvider, Sealed33? hoverProvider, Sealed37? implementationProvider, Sealed55? inlayHintProvider, Sealed57? inlineCompletionProvider, Sealed54? inlineValueProvider, Sealed50? linkedEditingRangeProvider, Sealed52? monikerProvider, Sealed32? notebookDocumentSync, PositionEncodingKind? positionEncoding, Sealed38? referencesProvider, Sealed46? renameProvider, Sealed48? selectionRangeProvider, Sealed51? semanticTokensProvider, SignatureHelpOptions? signatureHelpProvider, Sealed31? textDocumentSync, Sealed36? typeDefinitionProvider, Sealed53? typeHierarchyProvider, FileOperationOptionsFileOperationsWorkspaceFoldersServerCapabilitiesWorkspaceFolders? workspace, Sealed43? workspaceSymbolProvider
});


$CodeLensOptionsCopyWith<$Res>? get codeLensProvider;$CompletionOptionsCopyWith<$Res>? get completionProvider;$DocumentLinkOptionsCopyWith<$Res>? get documentLinkProvider;$DocumentOnTypeFormattingOptionsCopyWith<$Res>? get documentOnTypeFormattingProvider;$ExecuteCommandOptionsCopyWith<$Res>? get executeCommandProvider;$SignatureHelpOptionsCopyWith<$Res>? get signatureHelpProvider;

}
/// @nodoc
class _$ServerCapabilitiesCopyWithImpl<$Res>
    implements $ServerCapabilitiesCopyWith<$Res> {
  _$ServerCapabilitiesCopyWithImpl(this._self, this._then);

  final ServerCapabilities _self;
  final $Res Function(ServerCapabilities) _then;

/// Create a copy of ServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? callHierarchyProvider = freezed,Object? codeActionProvider = freezed,Object? codeLensProvider = freezed,Object? colorProvider = freezed,Object? completionProvider = freezed,Object? declarationProvider = freezed,Object? definitionProvider = freezed,Object? diagnosticProvider = freezed,Object? documentFormattingProvider = freezed,Object? documentHighlightProvider = freezed,Object? documentLinkProvider = freezed,Object? documentOnTypeFormattingProvider = freezed,Object? documentRangeFormattingProvider = freezed,Object? documentSymbolProvider = freezed,Object? executeCommandProvider = freezed,Object? experimental = freezed,Object? foldingRangeProvider = freezed,Object? hoverProvider = freezed,Object? implementationProvider = freezed,Object? inlayHintProvider = freezed,Object? inlineCompletionProvider = freezed,Object? inlineValueProvider = freezed,Object? linkedEditingRangeProvider = freezed,Object? monikerProvider = freezed,Object? notebookDocumentSync = freezed,Object? positionEncoding = freezed,Object? referencesProvider = freezed,Object? renameProvider = freezed,Object? selectionRangeProvider = freezed,Object? semanticTokensProvider = freezed,Object? signatureHelpProvider = freezed,Object? textDocumentSync = freezed,Object? typeDefinitionProvider = freezed,Object? typeHierarchyProvider = freezed,Object? workspace = freezed,Object? workspaceSymbolProvider = freezed,}) {
  return _then(_self.copyWith(
callHierarchyProvider: freezed == callHierarchyProvider ? _self.callHierarchyProvider : callHierarchyProvider // ignore: cast_nullable_to_non_nullable
as Sealed49?,codeActionProvider: freezed == codeActionProvider ? _self.codeActionProvider : codeActionProvider // ignore: cast_nullable_to_non_nullable
as Sealed41?,codeLensProvider: freezed == codeLensProvider ? _self.codeLensProvider : codeLensProvider // ignore: cast_nullable_to_non_nullable
as CodeLensOptions?,colorProvider: freezed == colorProvider ? _self.colorProvider : colorProvider // ignore: cast_nullable_to_non_nullable
as Sealed42?,completionProvider: freezed == completionProvider ? _self.completionProvider : completionProvider // ignore: cast_nullable_to_non_nullable
as CompletionOptions?,declarationProvider: freezed == declarationProvider ? _self.declarationProvider : declarationProvider // ignore: cast_nullable_to_non_nullable
as Sealed34?,definitionProvider: freezed == definitionProvider ? _self.definitionProvider : definitionProvider // ignore: cast_nullable_to_non_nullable
as Sealed35?,diagnosticProvider: freezed == diagnosticProvider ? _self.diagnosticProvider : diagnosticProvider // ignore: cast_nullable_to_non_nullable
as Sealed56?,documentFormattingProvider: freezed == documentFormattingProvider ? _self.documentFormattingProvider : documentFormattingProvider // ignore: cast_nullable_to_non_nullable
as Sealed44?,documentHighlightProvider: freezed == documentHighlightProvider ? _self.documentHighlightProvider : documentHighlightProvider // ignore: cast_nullable_to_non_nullable
as Sealed39?,documentLinkProvider: freezed == documentLinkProvider ? _self.documentLinkProvider : documentLinkProvider // ignore: cast_nullable_to_non_nullable
as DocumentLinkOptions?,documentOnTypeFormattingProvider: freezed == documentOnTypeFormattingProvider ? _self.documentOnTypeFormattingProvider : documentOnTypeFormattingProvider // ignore: cast_nullable_to_non_nullable
as DocumentOnTypeFormattingOptions?,documentRangeFormattingProvider: freezed == documentRangeFormattingProvider ? _self.documentRangeFormattingProvider : documentRangeFormattingProvider // ignore: cast_nullable_to_non_nullable
as Sealed45?,documentSymbolProvider: freezed == documentSymbolProvider ? _self.documentSymbolProvider : documentSymbolProvider // ignore: cast_nullable_to_non_nullable
as Sealed40?,executeCommandProvider: freezed == executeCommandProvider ? _self.executeCommandProvider : executeCommandProvider // ignore: cast_nullable_to_non_nullable
as ExecuteCommandOptions?,experimental: freezed == experimental ? _self.experimental : experimental // ignore: cast_nullable_to_non_nullable
as LSPAny?,foldingRangeProvider: freezed == foldingRangeProvider ? _self.foldingRangeProvider : foldingRangeProvider // ignore: cast_nullable_to_non_nullable
as Sealed47?,hoverProvider: freezed == hoverProvider ? _self.hoverProvider : hoverProvider // ignore: cast_nullable_to_non_nullable
as Sealed33?,implementationProvider: freezed == implementationProvider ? _self.implementationProvider : implementationProvider // ignore: cast_nullable_to_non_nullable
as Sealed37?,inlayHintProvider: freezed == inlayHintProvider ? _self.inlayHintProvider : inlayHintProvider // ignore: cast_nullable_to_non_nullable
as Sealed55?,inlineCompletionProvider: freezed == inlineCompletionProvider ? _self.inlineCompletionProvider : inlineCompletionProvider // ignore: cast_nullable_to_non_nullable
as Sealed57?,inlineValueProvider: freezed == inlineValueProvider ? _self.inlineValueProvider : inlineValueProvider // ignore: cast_nullable_to_non_nullable
as Sealed54?,linkedEditingRangeProvider: freezed == linkedEditingRangeProvider ? _self.linkedEditingRangeProvider : linkedEditingRangeProvider // ignore: cast_nullable_to_non_nullable
as Sealed50?,monikerProvider: freezed == monikerProvider ? _self.monikerProvider : monikerProvider // ignore: cast_nullable_to_non_nullable
as Sealed52?,notebookDocumentSync: freezed == notebookDocumentSync ? _self.notebookDocumentSync : notebookDocumentSync // ignore: cast_nullable_to_non_nullable
as Sealed32?,positionEncoding: freezed == positionEncoding ? _self.positionEncoding : positionEncoding // ignore: cast_nullable_to_non_nullable
as PositionEncodingKind?,referencesProvider: freezed == referencesProvider ? _self.referencesProvider : referencesProvider // ignore: cast_nullable_to_non_nullable
as Sealed38?,renameProvider: freezed == renameProvider ? _self.renameProvider : renameProvider // ignore: cast_nullable_to_non_nullable
as Sealed46?,selectionRangeProvider: freezed == selectionRangeProvider ? _self.selectionRangeProvider : selectionRangeProvider // ignore: cast_nullable_to_non_nullable
as Sealed48?,semanticTokensProvider: freezed == semanticTokensProvider ? _self.semanticTokensProvider : semanticTokensProvider // ignore: cast_nullable_to_non_nullable
as Sealed51?,signatureHelpProvider: freezed == signatureHelpProvider ? _self.signatureHelpProvider : signatureHelpProvider // ignore: cast_nullable_to_non_nullable
as SignatureHelpOptions?,textDocumentSync: freezed == textDocumentSync ? _self.textDocumentSync : textDocumentSync // ignore: cast_nullable_to_non_nullable
as Sealed31?,typeDefinitionProvider: freezed == typeDefinitionProvider ? _self.typeDefinitionProvider : typeDefinitionProvider // ignore: cast_nullable_to_non_nullable
as Sealed36?,typeHierarchyProvider: freezed == typeHierarchyProvider ? _self.typeHierarchyProvider : typeHierarchyProvider // ignore: cast_nullable_to_non_nullable
as Sealed53?,workspace: freezed == workspace ? _self.workspace : workspace // ignore: cast_nullable_to_non_nullable
as FileOperationOptionsFileOperationsWorkspaceFoldersServerCapabilitiesWorkspaceFolders?,workspaceSymbolProvider: freezed == workspaceSymbolProvider ? _self.workspaceSymbolProvider : workspaceSymbolProvider // ignore: cast_nullable_to_non_nullable
as Sealed43?,
  ));
}
/// Create a copy of ServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CodeLensOptionsCopyWith<$Res>? get codeLensProvider {
    if (_self.codeLensProvider == null) {
    return null;
  }

  return $CodeLensOptionsCopyWith<$Res>(_self.codeLensProvider!, (value) {
    return _then(_self.copyWith(codeLensProvider: value));
  });
}/// Create a copy of ServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CompletionOptionsCopyWith<$Res>? get completionProvider {
    if (_self.completionProvider == null) {
    return null;
  }

  return $CompletionOptionsCopyWith<$Res>(_self.completionProvider!, (value) {
    return _then(_self.copyWith(completionProvider: value));
  });
}/// Create a copy of ServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DocumentLinkOptionsCopyWith<$Res>? get documentLinkProvider {
    if (_self.documentLinkProvider == null) {
    return null;
  }

  return $DocumentLinkOptionsCopyWith<$Res>(_self.documentLinkProvider!, (value) {
    return _then(_self.copyWith(documentLinkProvider: value));
  });
}/// Create a copy of ServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DocumentOnTypeFormattingOptionsCopyWith<$Res>? get documentOnTypeFormattingProvider {
    if (_self.documentOnTypeFormattingProvider == null) {
    return null;
  }

  return $DocumentOnTypeFormattingOptionsCopyWith<$Res>(_self.documentOnTypeFormattingProvider!, (value) {
    return _then(_self.copyWith(documentOnTypeFormattingProvider: value));
  });
}/// Create a copy of ServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ExecuteCommandOptionsCopyWith<$Res>? get executeCommandProvider {
    if (_self.executeCommandProvider == null) {
    return null;
  }

  return $ExecuteCommandOptionsCopyWith<$Res>(_self.executeCommandProvider!, (value) {
    return _then(_self.copyWith(executeCommandProvider: value));
  });
}/// Create a copy of ServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SignatureHelpOptionsCopyWith<$Res>? get signatureHelpProvider {
    if (_self.signatureHelpProvider == null) {
    return null;
  }

  return $SignatureHelpOptionsCopyWith<$Res>(_self.signatureHelpProvider!, (value) {
    return _then(_self.copyWith(signatureHelpProvider: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _ServerCapabilities implements ServerCapabilities {
  const _ServerCapabilities({this.callHierarchyProvider, this.codeActionProvider, this.codeLensProvider, this.colorProvider, this.completionProvider, this.declarationProvider, this.definitionProvider, this.diagnosticProvider, this.documentFormattingProvider, this.documentHighlightProvider, this.documentLinkProvider, this.documentOnTypeFormattingProvider, this.documentRangeFormattingProvider, this.documentSymbolProvider, this.executeCommandProvider, this.experimental, this.foldingRangeProvider, this.hoverProvider, this.implementationProvider, this.inlayHintProvider, this.inlineCompletionProvider, this.inlineValueProvider, this.linkedEditingRangeProvider, this.monikerProvider, this.notebookDocumentSync, this.positionEncoding, this.referencesProvider, this.renameProvider, this.selectionRangeProvider, this.semanticTokensProvider, this.signatureHelpProvider, this.textDocumentSync, this.typeDefinitionProvider, this.typeHierarchyProvider, this.workspace, this.workspaceSymbolProvider});
  factory _ServerCapabilities.fromJson(Map<String, dynamic> json) => _$ServerCapabilitiesFromJson(json);

/// The server provides call hierarchy support.
/// @since 3.16.0
@override final  Sealed49? callHierarchyProvider;
/// The server provides code actions. CodeActionOptions may only be
/// specified if the client states that it supports
/// `codeActionLiteralSupport` in its initial `initialize` request.
@override final  Sealed41? codeActionProvider;
/// The server provides code lens.
@override final  CodeLensOptions? codeLensProvider;
/// The server provides color provider support.
@override final  Sealed42? colorProvider;
/// The server provides completion support.
@override final  CompletionOptions? completionProvider;
/// The server provides Goto Declaration support.
@override final  Sealed34? declarationProvider;
/// The server provides goto definition support.
@override final  Sealed35? definitionProvider;
/// The server has support for pull model diagnostics.
/// @since 3.17.0
@override final  Sealed56? diagnosticProvider;
/// The server provides document formatting.
@override final  Sealed44? documentFormattingProvider;
/// The server provides document highlight support.
@override final  Sealed39? documentHighlightProvider;
/// The server provides document link support.
@override final  DocumentLinkOptions? documentLinkProvider;
/// The server provides document formatting on typing.
@override final  DocumentOnTypeFormattingOptions? documentOnTypeFormattingProvider;
/// The server provides document range formatting.
@override final  Sealed45? documentRangeFormattingProvider;
/// The server provides document symbol support.
@override final  Sealed40? documentSymbolProvider;
/// The server provides execute command support.
@override final  ExecuteCommandOptions? executeCommandProvider;
/// Experimental server capabilities.
@override final  LSPAny? experimental;
/// The server provides folding provider support.
@override final  Sealed47? foldingRangeProvider;
/// The server provides hover support.
@override final  Sealed33? hoverProvider;
/// The server provides Goto Implementation support.
@override final  Sealed37? implementationProvider;
/// The server provides inlay hints.
/// @since 3.17.0
@override final  Sealed55? inlayHintProvider;
/// Inline completion options used during static registration.
/// @since 3.18.0 @proposed
@override final  Sealed57? inlineCompletionProvider;
/// The server provides inline values.
/// @since 3.17.0
@override final  Sealed54? inlineValueProvider;
/// The server provides linked editing range support.
/// @since 3.16.0
@override final  Sealed50? linkedEditingRangeProvider;
/// The server provides moniker support.
/// @since 3.16.0
@override final  Sealed52? monikerProvider;
/// Defines how notebook documents are synced.
/// @since 3.17.0
@override final  Sealed32? notebookDocumentSync;
/// The position encoding the server picked from the encodings offered by
/// the client via the client capability `general.positionEncodings`.
/// If the client didn't provide any position encodings the only valid
/// value that a server can return is 'utf-16'.
/// If omitted it defaults to 'utf-16'.
/// @since 3.17.0
@override final  PositionEncodingKind? positionEncoding;
/// The server provides find references support.
@override final  Sealed38? referencesProvider;
/// The server provides rename support. RenameOptions may only be specified
/// if the client states that it supports `prepareSupport` in its initial
/// `initialize` request.
@override final  Sealed46? renameProvider;
/// The server provides selection range support.
@override final  Sealed48? selectionRangeProvider;
/// The server provides semantic tokens support.
/// @since 3.16.0
@override final  Sealed51? semanticTokensProvider;
/// The server provides signature help support.
@override final  SignatureHelpOptions? signatureHelpProvider;
/// Defines how text documents are synced. Is either a detailed structure
/// defining each notification or for backwards compatibility the
/// TextDocumentSyncKind number.
@override final  Sealed31? textDocumentSync;
/// The server provides Goto Type Definition support.
@override final  Sealed36? typeDefinitionProvider;
/// The server provides type hierarchy support.
/// @since 3.17.0
@override final  Sealed53? typeHierarchyProvider;
/// Workspace specific server capabilities.
@override final  FileOperationOptionsFileOperationsWorkspaceFoldersServerCapabilitiesWorkspaceFolders? workspace;
/// The server provides workspace symbol support.
@override final  Sealed43? workspaceSymbolProvider;

/// Create a copy of ServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ServerCapabilitiesCopyWith<_ServerCapabilities> get copyWith => __$ServerCapabilitiesCopyWithImpl<_ServerCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ServerCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ServerCapabilities&&(identical(other.callHierarchyProvider, callHierarchyProvider) || other.callHierarchyProvider == callHierarchyProvider)&&(identical(other.codeActionProvider, codeActionProvider) || other.codeActionProvider == codeActionProvider)&&(identical(other.codeLensProvider, codeLensProvider) || other.codeLensProvider == codeLensProvider)&&(identical(other.colorProvider, colorProvider) || other.colorProvider == colorProvider)&&(identical(other.completionProvider, completionProvider) || other.completionProvider == completionProvider)&&(identical(other.declarationProvider, declarationProvider) || other.declarationProvider == declarationProvider)&&(identical(other.definitionProvider, definitionProvider) || other.definitionProvider == definitionProvider)&&(identical(other.diagnosticProvider, diagnosticProvider) || other.diagnosticProvider == diagnosticProvider)&&(identical(other.documentFormattingProvider, documentFormattingProvider) || other.documentFormattingProvider == documentFormattingProvider)&&(identical(other.documentHighlightProvider, documentHighlightProvider) || other.documentHighlightProvider == documentHighlightProvider)&&(identical(other.documentLinkProvider, documentLinkProvider) || other.documentLinkProvider == documentLinkProvider)&&(identical(other.documentOnTypeFormattingProvider, documentOnTypeFormattingProvider) || other.documentOnTypeFormattingProvider == documentOnTypeFormattingProvider)&&(identical(other.documentRangeFormattingProvider, documentRangeFormattingProvider) || other.documentRangeFormattingProvider == documentRangeFormattingProvider)&&(identical(other.documentSymbolProvider, documentSymbolProvider) || other.documentSymbolProvider == documentSymbolProvider)&&(identical(other.executeCommandProvider, executeCommandProvider) || other.executeCommandProvider == executeCommandProvider)&&(identical(other.experimental, experimental) || other.experimental == experimental)&&(identical(other.foldingRangeProvider, foldingRangeProvider) || other.foldingRangeProvider == foldingRangeProvider)&&(identical(other.hoverProvider, hoverProvider) || other.hoverProvider == hoverProvider)&&(identical(other.implementationProvider, implementationProvider) || other.implementationProvider == implementationProvider)&&(identical(other.inlayHintProvider, inlayHintProvider) || other.inlayHintProvider == inlayHintProvider)&&(identical(other.inlineCompletionProvider, inlineCompletionProvider) || other.inlineCompletionProvider == inlineCompletionProvider)&&(identical(other.inlineValueProvider, inlineValueProvider) || other.inlineValueProvider == inlineValueProvider)&&(identical(other.linkedEditingRangeProvider, linkedEditingRangeProvider) || other.linkedEditingRangeProvider == linkedEditingRangeProvider)&&(identical(other.monikerProvider, monikerProvider) || other.monikerProvider == monikerProvider)&&(identical(other.notebookDocumentSync, notebookDocumentSync) || other.notebookDocumentSync == notebookDocumentSync)&&(identical(other.positionEncoding, positionEncoding) || other.positionEncoding == positionEncoding)&&(identical(other.referencesProvider, referencesProvider) || other.referencesProvider == referencesProvider)&&(identical(other.renameProvider, renameProvider) || other.renameProvider == renameProvider)&&(identical(other.selectionRangeProvider, selectionRangeProvider) || other.selectionRangeProvider == selectionRangeProvider)&&(identical(other.semanticTokensProvider, semanticTokensProvider) || other.semanticTokensProvider == semanticTokensProvider)&&(identical(other.signatureHelpProvider, signatureHelpProvider) || other.signatureHelpProvider == signatureHelpProvider)&&(identical(other.textDocumentSync, textDocumentSync) || other.textDocumentSync == textDocumentSync)&&(identical(other.typeDefinitionProvider, typeDefinitionProvider) || other.typeDefinitionProvider == typeDefinitionProvider)&&(identical(other.typeHierarchyProvider, typeHierarchyProvider) || other.typeHierarchyProvider == typeHierarchyProvider)&&const DeepCollectionEquality().equals(other.workspace, workspace)&&(identical(other.workspaceSymbolProvider, workspaceSymbolProvider) || other.workspaceSymbolProvider == workspaceSymbolProvider));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hashAll([runtimeType,callHierarchyProvider,codeActionProvider,codeLensProvider,colorProvider,completionProvider,declarationProvider,definitionProvider,diagnosticProvider,documentFormattingProvider,documentHighlightProvider,documentLinkProvider,documentOnTypeFormattingProvider,documentRangeFormattingProvider,documentSymbolProvider,executeCommandProvider,experimental,foldingRangeProvider,hoverProvider,implementationProvider,inlayHintProvider,inlineCompletionProvider,inlineValueProvider,linkedEditingRangeProvider,monikerProvider,notebookDocumentSync,positionEncoding,referencesProvider,renameProvider,selectionRangeProvider,semanticTokensProvider,signatureHelpProvider,textDocumentSync,typeDefinitionProvider,typeHierarchyProvider,const DeepCollectionEquality().hash(workspace),workspaceSymbolProvider]);

@override
String toString() {
  return 'ServerCapabilities(callHierarchyProvider: $callHierarchyProvider, codeActionProvider: $codeActionProvider, codeLensProvider: $codeLensProvider, colorProvider: $colorProvider, completionProvider: $completionProvider, declarationProvider: $declarationProvider, definitionProvider: $definitionProvider, diagnosticProvider: $diagnosticProvider, documentFormattingProvider: $documentFormattingProvider, documentHighlightProvider: $documentHighlightProvider, documentLinkProvider: $documentLinkProvider, documentOnTypeFormattingProvider: $documentOnTypeFormattingProvider, documentRangeFormattingProvider: $documentRangeFormattingProvider, documentSymbolProvider: $documentSymbolProvider, executeCommandProvider: $executeCommandProvider, experimental: $experimental, foldingRangeProvider: $foldingRangeProvider, hoverProvider: $hoverProvider, implementationProvider: $implementationProvider, inlayHintProvider: $inlayHintProvider, inlineCompletionProvider: $inlineCompletionProvider, inlineValueProvider: $inlineValueProvider, linkedEditingRangeProvider: $linkedEditingRangeProvider, monikerProvider: $monikerProvider, notebookDocumentSync: $notebookDocumentSync, positionEncoding: $positionEncoding, referencesProvider: $referencesProvider, renameProvider: $renameProvider, selectionRangeProvider: $selectionRangeProvider, semanticTokensProvider: $semanticTokensProvider, signatureHelpProvider: $signatureHelpProvider, textDocumentSync: $textDocumentSync, typeDefinitionProvider: $typeDefinitionProvider, typeHierarchyProvider: $typeHierarchyProvider, workspace: $workspace, workspaceSymbolProvider: $workspaceSymbolProvider)';
}


}

/// @nodoc
abstract mixin class _$ServerCapabilitiesCopyWith<$Res> implements $ServerCapabilitiesCopyWith<$Res> {
  factory _$ServerCapabilitiesCopyWith(_ServerCapabilities value, $Res Function(_ServerCapabilities) _then) = __$ServerCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 Sealed49? callHierarchyProvider, Sealed41? codeActionProvider, CodeLensOptions? codeLensProvider, Sealed42? colorProvider, CompletionOptions? completionProvider, Sealed34? declarationProvider, Sealed35? definitionProvider, Sealed56? diagnosticProvider, Sealed44? documentFormattingProvider, Sealed39? documentHighlightProvider, DocumentLinkOptions? documentLinkProvider, DocumentOnTypeFormattingOptions? documentOnTypeFormattingProvider, Sealed45? documentRangeFormattingProvider, Sealed40? documentSymbolProvider, ExecuteCommandOptions? executeCommandProvider, LSPAny? experimental, Sealed47? foldingRangeProvider, Sealed33? hoverProvider, Sealed37? implementationProvider, Sealed55? inlayHintProvider, Sealed57? inlineCompletionProvider, Sealed54? inlineValueProvider, Sealed50? linkedEditingRangeProvider, Sealed52? monikerProvider, Sealed32? notebookDocumentSync, PositionEncodingKind? positionEncoding, Sealed38? referencesProvider, Sealed46? renameProvider, Sealed48? selectionRangeProvider, Sealed51? semanticTokensProvider, SignatureHelpOptions? signatureHelpProvider, Sealed31? textDocumentSync, Sealed36? typeDefinitionProvider, Sealed53? typeHierarchyProvider, FileOperationOptionsFileOperationsWorkspaceFoldersServerCapabilitiesWorkspaceFolders? workspace, Sealed43? workspaceSymbolProvider
});


@override $CodeLensOptionsCopyWith<$Res>? get codeLensProvider;@override $CompletionOptionsCopyWith<$Res>? get completionProvider;@override $DocumentLinkOptionsCopyWith<$Res>? get documentLinkProvider;@override $DocumentOnTypeFormattingOptionsCopyWith<$Res>? get documentOnTypeFormattingProvider;@override $ExecuteCommandOptionsCopyWith<$Res>? get executeCommandProvider;@override $SignatureHelpOptionsCopyWith<$Res>? get signatureHelpProvider;

}
/// @nodoc
class __$ServerCapabilitiesCopyWithImpl<$Res>
    implements _$ServerCapabilitiesCopyWith<$Res> {
  __$ServerCapabilitiesCopyWithImpl(this._self, this._then);

  final _ServerCapabilities _self;
  final $Res Function(_ServerCapabilities) _then;

/// Create a copy of ServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? callHierarchyProvider = freezed,Object? codeActionProvider = freezed,Object? codeLensProvider = freezed,Object? colorProvider = freezed,Object? completionProvider = freezed,Object? declarationProvider = freezed,Object? definitionProvider = freezed,Object? diagnosticProvider = freezed,Object? documentFormattingProvider = freezed,Object? documentHighlightProvider = freezed,Object? documentLinkProvider = freezed,Object? documentOnTypeFormattingProvider = freezed,Object? documentRangeFormattingProvider = freezed,Object? documentSymbolProvider = freezed,Object? executeCommandProvider = freezed,Object? experimental = freezed,Object? foldingRangeProvider = freezed,Object? hoverProvider = freezed,Object? implementationProvider = freezed,Object? inlayHintProvider = freezed,Object? inlineCompletionProvider = freezed,Object? inlineValueProvider = freezed,Object? linkedEditingRangeProvider = freezed,Object? monikerProvider = freezed,Object? notebookDocumentSync = freezed,Object? positionEncoding = freezed,Object? referencesProvider = freezed,Object? renameProvider = freezed,Object? selectionRangeProvider = freezed,Object? semanticTokensProvider = freezed,Object? signatureHelpProvider = freezed,Object? textDocumentSync = freezed,Object? typeDefinitionProvider = freezed,Object? typeHierarchyProvider = freezed,Object? workspace = freezed,Object? workspaceSymbolProvider = freezed,}) {
  return _then(_ServerCapabilities(
callHierarchyProvider: freezed == callHierarchyProvider ? _self.callHierarchyProvider : callHierarchyProvider // ignore: cast_nullable_to_non_nullable
as Sealed49?,codeActionProvider: freezed == codeActionProvider ? _self.codeActionProvider : codeActionProvider // ignore: cast_nullable_to_non_nullable
as Sealed41?,codeLensProvider: freezed == codeLensProvider ? _self.codeLensProvider : codeLensProvider // ignore: cast_nullable_to_non_nullable
as CodeLensOptions?,colorProvider: freezed == colorProvider ? _self.colorProvider : colorProvider // ignore: cast_nullable_to_non_nullable
as Sealed42?,completionProvider: freezed == completionProvider ? _self.completionProvider : completionProvider // ignore: cast_nullable_to_non_nullable
as CompletionOptions?,declarationProvider: freezed == declarationProvider ? _self.declarationProvider : declarationProvider // ignore: cast_nullable_to_non_nullable
as Sealed34?,definitionProvider: freezed == definitionProvider ? _self.definitionProvider : definitionProvider // ignore: cast_nullable_to_non_nullable
as Sealed35?,diagnosticProvider: freezed == diagnosticProvider ? _self.diagnosticProvider : diagnosticProvider // ignore: cast_nullable_to_non_nullable
as Sealed56?,documentFormattingProvider: freezed == documentFormattingProvider ? _self.documentFormattingProvider : documentFormattingProvider // ignore: cast_nullable_to_non_nullable
as Sealed44?,documentHighlightProvider: freezed == documentHighlightProvider ? _self.documentHighlightProvider : documentHighlightProvider // ignore: cast_nullable_to_non_nullable
as Sealed39?,documentLinkProvider: freezed == documentLinkProvider ? _self.documentLinkProvider : documentLinkProvider // ignore: cast_nullable_to_non_nullable
as DocumentLinkOptions?,documentOnTypeFormattingProvider: freezed == documentOnTypeFormattingProvider ? _self.documentOnTypeFormattingProvider : documentOnTypeFormattingProvider // ignore: cast_nullable_to_non_nullable
as DocumentOnTypeFormattingOptions?,documentRangeFormattingProvider: freezed == documentRangeFormattingProvider ? _self.documentRangeFormattingProvider : documentRangeFormattingProvider // ignore: cast_nullable_to_non_nullable
as Sealed45?,documentSymbolProvider: freezed == documentSymbolProvider ? _self.documentSymbolProvider : documentSymbolProvider // ignore: cast_nullable_to_non_nullable
as Sealed40?,executeCommandProvider: freezed == executeCommandProvider ? _self.executeCommandProvider : executeCommandProvider // ignore: cast_nullable_to_non_nullable
as ExecuteCommandOptions?,experimental: freezed == experimental ? _self.experimental : experimental // ignore: cast_nullable_to_non_nullable
as LSPAny?,foldingRangeProvider: freezed == foldingRangeProvider ? _self.foldingRangeProvider : foldingRangeProvider // ignore: cast_nullable_to_non_nullable
as Sealed47?,hoverProvider: freezed == hoverProvider ? _self.hoverProvider : hoverProvider // ignore: cast_nullable_to_non_nullable
as Sealed33?,implementationProvider: freezed == implementationProvider ? _self.implementationProvider : implementationProvider // ignore: cast_nullable_to_non_nullable
as Sealed37?,inlayHintProvider: freezed == inlayHintProvider ? _self.inlayHintProvider : inlayHintProvider // ignore: cast_nullable_to_non_nullable
as Sealed55?,inlineCompletionProvider: freezed == inlineCompletionProvider ? _self.inlineCompletionProvider : inlineCompletionProvider // ignore: cast_nullable_to_non_nullable
as Sealed57?,inlineValueProvider: freezed == inlineValueProvider ? _self.inlineValueProvider : inlineValueProvider // ignore: cast_nullable_to_non_nullable
as Sealed54?,linkedEditingRangeProvider: freezed == linkedEditingRangeProvider ? _self.linkedEditingRangeProvider : linkedEditingRangeProvider // ignore: cast_nullable_to_non_nullable
as Sealed50?,monikerProvider: freezed == monikerProvider ? _self.monikerProvider : monikerProvider // ignore: cast_nullable_to_non_nullable
as Sealed52?,notebookDocumentSync: freezed == notebookDocumentSync ? _self.notebookDocumentSync : notebookDocumentSync // ignore: cast_nullable_to_non_nullable
as Sealed32?,positionEncoding: freezed == positionEncoding ? _self.positionEncoding : positionEncoding // ignore: cast_nullable_to_non_nullable
as PositionEncodingKind?,referencesProvider: freezed == referencesProvider ? _self.referencesProvider : referencesProvider // ignore: cast_nullable_to_non_nullable
as Sealed38?,renameProvider: freezed == renameProvider ? _self.renameProvider : renameProvider // ignore: cast_nullable_to_non_nullable
as Sealed46?,selectionRangeProvider: freezed == selectionRangeProvider ? _self.selectionRangeProvider : selectionRangeProvider // ignore: cast_nullable_to_non_nullable
as Sealed48?,semanticTokensProvider: freezed == semanticTokensProvider ? _self.semanticTokensProvider : semanticTokensProvider // ignore: cast_nullable_to_non_nullable
as Sealed51?,signatureHelpProvider: freezed == signatureHelpProvider ? _self.signatureHelpProvider : signatureHelpProvider // ignore: cast_nullable_to_non_nullable
as SignatureHelpOptions?,textDocumentSync: freezed == textDocumentSync ? _self.textDocumentSync : textDocumentSync // ignore: cast_nullable_to_non_nullable
as Sealed31?,typeDefinitionProvider: freezed == typeDefinitionProvider ? _self.typeDefinitionProvider : typeDefinitionProvider // ignore: cast_nullable_to_non_nullable
as Sealed36?,typeHierarchyProvider: freezed == typeHierarchyProvider ? _self.typeHierarchyProvider : typeHierarchyProvider // ignore: cast_nullable_to_non_nullable
as Sealed53?,workspace: freezed == workspace ? _self.workspace : workspace // ignore: cast_nullable_to_non_nullable
as FileOperationOptionsFileOperationsWorkspaceFoldersServerCapabilitiesWorkspaceFolders?,workspaceSymbolProvider: freezed == workspaceSymbolProvider ? _self.workspaceSymbolProvider : workspaceSymbolProvider // ignore: cast_nullable_to_non_nullable
as Sealed43?,
  ));
}

/// Create a copy of ServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CodeLensOptionsCopyWith<$Res>? get codeLensProvider {
    if (_self.codeLensProvider == null) {
    return null;
  }

  return $CodeLensOptionsCopyWith<$Res>(_self.codeLensProvider!, (value) {
    return _then(_self.copyWith(codeLensProvider: value));
  });
}/// Create a copy of ServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CompletionOptionsCopyWith<$Res>? get completionProvider {
    if (_self.completionProvider == null) {
    return null;
  }

  return $CompletionOptionsCopyWith<$Res>(_self.completionProvider!, (value) {
    return _then(_self.copyWith(completionProvider: value));
  });
}/// Create a copy of ServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DocumentLinkOptionsCopyWith<$Res>? get documentLinkProvider {
    if (_self.documentLinkProvider == null) {
    return null;
  }

  return $DocumentLinkOptionsCopyWith<$Res>(_self.documentLinkProvider!, (value) {
    return _then(_self.copyWith(documentLinkProvider: value));
  });
}/// Create a copy of ServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DocumentOnTypeFormattingOptionsCopyWith<$Res>? get documentOnTypeFormattingProvider {
    if (_self.documentOnTypeFormattingProvider == null) {
    return null;
  }

  return $DocumentOnTypeFormattingOptionsCopyWith<$Res>(_self.documentOnTypeFormattingProvider!, (value) {
    return _then(_self.copyWith(documentOnTypeFormattingProvider: value));
  });
}/// Create a copy of ServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ExecuteCommandOptionsCopyWith<$Res>? get executeCommandProvider {
    if (_self.executeCommandProvider == null) {
    return null;
  }

  return $ExecuteCommandOptionsCopyWith<$Res>(_self.executeCommandProvider!, (value) {
    return _then(_self.copyWith(executeCommandProvider: value));
  });
}/// Create a copy of ServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SignatureHelpOptionsCopyWith<$Res>? get signatureHelpProvider {
    if (_self.signatureHelpProvider == null) {
    return null;
  }

  return $SignatureHelpOptionsCopyWith<$Res>(_self.signatureHelpProvider!, (value) {
    return _then(_self.copyWith(signatureHelpProvider: value));
  });
}
}


/// @nodoc
mixin _$VersionedTextDocumentIdentifier {

/// The text document's uri.
 String get uri;/// The version number of this document.
 int get version;
/// Create a copy of VersionedTextDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$VersionedTextDocumentIdentifierCopyWith<VersionedTextDocumentIdentifier> get copyWith => _$VersionedTextDocumentIdentifierCopyWithImpl<VersionedTextDocumentIdentifier>(this as VersionedTextDocumentIdentifier, _$identity);

  /// Serializes this VersionedTextDocumentIdentifier to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is VersionedTextDocumentIdentifier&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.version, version) || other.version == version));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri,version);

@override
String toString() {
  return 'VersionedTextDocumentIdentifier(uri: $uri, version: $version)';
}


}

/// @nodoc
abstract mixin class $VersionedTextDocumentIdentifierCopyWith<$Res>  {
  factory $VersionedTextDocumentIdentifierCopyWith(VersionedTextDocumentIdentifier value, $Res Function(VersionedTextDocumentIdentifier) _then) = _$VersionedTextDocumentIdentifierCopyWithImpl;
@useResult
$Res call({
 String uri, int version
});




}
/// @nodoc
class _$VersionedTextDocumentIdentifierCopyWithImpl<$Res>
    implements $VersionedTextDocumentIdentifierCopyWith<$Res> {
  _$VersionedTextDocumentIdentifierCopyWithImpl(this._self, this._then);

  final VersionedTextDocumentIdentifier _self;
  final $Res Function(VersionedTextDocumentIdentifier) _then;

/// Create a copy of VersionedTextDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? uri = null,Object? version = null,}) {
  return _then(_self.copyWith(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,version: null == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as int,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _VersionedTextDocumentIdentifier implements VersionedTextDocumentIdentifier {
  const _VersionedTextDocumentIdentifier({required this.uri, required this.version});
  factory _VersionedTextDocumentIdentifier.fromJson(Map<String, dynamic> json) => _$VersionedTextDocumentIdentifierFromJson(json);

/// The text document's uri.
@override final  String uri;
/// The version number of this document.
@override final  int version;

/// Create a copy of VersionedTextDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$VersionedTextDocumentIdentifierCopyWith<_VersionedTextDocumentIdentifier> get copyWith => __$VersionedTextDocumentIdentifierCopyWithImpl<_VersionedTextDocumentIdentifier>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$VersionedTextDocumentIdentifierToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _VersionedTextDocumentIdentifier&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.version, version) || other.version == version));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri,version);

@override
String toString() {
  return 'VersionedTextDocumentIdentifier(uri: $uri, version: $version)';
}


}

/// @nodoc
abstract mixin class _$VersionedTextDocumentIdentifierCopyWith<$Res> implements $VersionedTextDocumentIdentifierCopyWith<$Res> {
  factory _$VersionedTextDocumentIdentifierCopyWith(_VersionedTextDocumentIdentifier value, $Res Function(_VersionedTextDocumentIdentifier) _then) = __$VersionedTextDocumentIdentifierCopyWithImpl;
@override @useResult
$Res call({
 String uri, int version
});




}
/// @nodoc
class __$VersionedTextDocumentIdentifierCopyWithImpl<$Res>
    implements _$VersionedTextDocumentIdentifierCopyWith<$Res> {
  __$VersionedTextDocumentIdentifierCopyWithImpl(this._self, this._then);

  final _VersionedTextDocumentIdentifier _self;
  final $Res Function(_VersionedTextDocumentIdentifier) _then;

/// Create a copy of VersionedTextDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? uri = null,Object? version = null,}) {
  return _then(_VersionedTextDocumentIdentifier(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,version: null == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as int,
  ));
}


}


/// @nodoc
mixin _$SaveOptions {

/// The client is supposed to include the content on save.
 bool? get includeText;
/// Create a copy of SaveOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SaveOptionsCopyWith<SaveOptions> get copyWith => _$SaveOptionsCopyWithImpl<SaveOptions>(this as SaveOptions, _$identity);

  /// Serializes this SaveOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SaveOptions&&(identical(other.includeText, includeText) || other.includeText == includeText));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,includeText);

@override
String toString() {
  return 'SaveOptions(includeText: $includeText)';
}


}

/// @nodoc
abstract mixin class $SaveOptionsCopyWith<$Res>  {
  factory $SaveOptionsCopyWith(SaveOptions value, $Res Function(SaveOptions) _then) = _$SaveOptionsCopyWithImpl;
@useResult
$Res call({
 bool? includeText
});




}
/// @nodoc
class _$SaveOptionsCopyWithImpl<$Res>
    implements $SaveOptionsCopyWith<$Res> {
  _$SaveOptionsCopyWithImpl(this._self, this._then);

  final SaveOptions _self;
  final $Res Function(SaveOptions) _then;

/// Create a copy of SaveOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? includeText = freezed,}) {
  return _then(_self.copyWith(
includeText: freezed == includeText ? _self.includeText : includeText // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _SaveOptions implements SaveOptions {
  const _SaveOptions({this.includeText});
  factory _SaveOptions.fromJson(Map<String, dynamic> json) => _$SaveOptionsFromJson(json);

/// The client is supposed to include the content on save.
@override final  bool? includeText;

/// Create a copy of SaveOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SaveOptionsCopyWith<_SaveOptions> get copyWith => __$SaveOptionsCopyWithImpl<_SaveOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SaveOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SaveOptions&&(identical(other.includeText, includeText) || other.includeText == includeText));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,includeText);

@override
String toString() {
  return 'SaveOptions(includeText: $includeText)';
}


}

/// @nodoc
abstract mixin class _$SaveOptionsCopyWith<$Res> implements $SaveOptionsCopyWith<$Res> {
  factory _$SaveOptionsCopyWith(_SaveOptions value, $Res Function(_SaveOptions) _then) = __$SaveOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? includeText
});




}
/// @nodoc
class __$SaveOptionsCopyWithImpl<$Res>
    implements _$SaveOptionsCopyWith<$Res> {
  __$SaveOptionsCopyWithImpl(this._self, this._then);

  final _SaveOptions _self;
  final $Res Function(_SaveOptions) _then;

/// Create a copy of SaveOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? includeText = freezed,}) {
  return _then(_SaveOptions(
includeText: freezed == includeText ? _self.includeText : includeText // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$FileEvent {

/// The change type.
 FileChangeType get type;/// The file's uri.
 String get uri;
/// Create a copy of FileEvent
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FileEventCopyWith<FileEvent> get copyWith => _$FileEventCopyWithImpl<FileEvent>(this as FileEvent, _$identity);

  /// Serializes this FileEvent to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FileEvent&&(identical(other.type, type) || other.type == type)&&(identical(other.uri, uri) || other.uri == uri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,type,uri);

@override
String toString() {
  return 'FileEvent(type: $type, uri: $uri)';
}


}

/// @nodoc
abstract mixin class $FileEventCopyWith<$Res>  {
  factory $FileEventCopyWith(FileEvent value, $Res Function(FileEvent) _then) = _$FileEventCopyWithImpl;
@useResult
$Res call({
 FileChangeType type, String uri
});




}
/// @nodoc
class _$FileEventCopyWithImpl<$Res>
    implements $FileEventCopyWith<$Res> {
  _$FileEventCopyWithImpl(this._self, this._then);

  final FileEvent _self;
  final $Res Function(FileEvent) _then;

/// Create a copy of FileEvent
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? type = null,Object? uri = null,}) {
  return _then(_self.copyWith(
type: null == type ? _self.type : type // ignore: cast_nullable_to_non_nullable
as FileChangeType,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _FileEvent implements FileEvent {
  const _FileEvent({required this.type, required this.uri});
  factory _FileEvent.fromJson(Map<String, dynamic> json) => _$FileEventFromJson(json);

/// The change type.
@override final  FileChangeType type;
/// The file's uri.
@override final  String uri;

/// Create a copy of FileEvent
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$FileEventCopyWith<_FileEvent> get copyWith => __$FileEventCopyWithImpl<_FileEvent>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$FileEventToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _FileEvent&&(identical(other.type, type) || other.type == type)&&(identical(other.uri, uri) || other.uri == uri));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,type,uri);

@override
String toString() {
  return 'FileEvent(type: $type, uri: $uri)';
}


}

/// @nodoc
abstract mixin class _$FileEventCopyWith<$Res> implements $FileEventCopyWith<$Res> {
  factory _$FileEventCopyWith(_FileEvent value, $Res Function(_FileEvent) _then) = __$FileEventCopyWithImpl;
@override @useResult
$Res call({
 FileChangeType type, String uri
});




}
/// @nodoc
class __$FileEventCopyWithImpl<$Res>
    implements _$FileEventCopyWith<$Res> {
  __$FileEventCopyWithImpl(this._self, this._then);

  final _FileEvent _self;
  final $Res Function(_FileEvent) _then;

/// Create a copy of FileEvent
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? type = null,Object? uri = null,}) {
  return _then(_FileEvent(
type: null == type ? _self.type : type // ignore: cast_nullable_to_non_nullable
as FileChangeType,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}


/// @nodoc
mixin _$FileSystemWatcher {

/// The glob pattern to watch. See {@link GlobPattern glob pattern} for
/// more detail.
/// @since 3.17.0 support for relative patterns.
 GlobPattern get globPattern;/// The kind of events of interest. If omitted it defaults to
/// WatchKind.Create | WatchKind.Change | WatchKind.Delete which is 7.
 WatchKind? get kind;
/// Create a copy of FileSystemWatcher
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FileSystemWatcherCopyWith<FileSystemWatcher> get copyWith => _$FileSystemWatcherCopyWithImpl<FileSystemWatcher>(this as FileSystemWatcher, _$identity);

  /// Serializes this FileSystemWatcher to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FileSystemWatcher&&(identical(other.globPattern, globPattern) || other.globPattern == globPattern)&&(identical(other.kind, kind) || other.kind == kind));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,globPattern,kind);

@override
String toString() {
  return 'FileSystemWatcher(globPattern: $globPattern, kind: $kind)';
}


}

/// @nodoc
abstract mixin class $FileSystemWatcherCopyWith<$Res>  {
  factory $FileSystemWatcherCopyWith(FileSystemWatcher value, $Res Function(FileSystemWatcher) _then) = _$FileSystemWatcherCopyWithImpl;
@useResult
$Res call({
 GlobPattern globPattern, WatchKind? kind
});




}
/// @nodoc
class _$FileSystemWatcherCopyWithImpl<$Res>
    implements $FileSystemWatcherCopyWith<$Res> {
  _$FileSystemWatcherCopyWithImpl(this._self, this._then);

  final FileSystemWatcher _self;
  final $Res Function(FileSystemWatcher) _then;

/// Create a copy of FileSystemWatcher
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? globPattern = null,Object? kind = freezed,}) {
  return _then(_self.copyWith(
globPattern: null == globPattern ? _self.globPattern : globPattern // ignore: cast_nullable_to_non_nullable
as GlobPattern,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as WatchKind?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _FileSystemWatcher implements FileSystemWatcher {
  const _FileSystemWatcher({required this.globPattern, this.kind});
  factory _FileSystemWatcher.fromJson(Map<String, dynamic> json) => _$FileSystemWatcherFromJson(json);

/// The glob pattern to watch. See {@link GlobPattern glob pattern} for
/// more detail.
/// @since 3.17.0 support for relative patterns.
@override final  GlobPattern globPattern;
/// The kind of events of interest. If omitted it defaults to
/// WatchKind.Create | WatchKind.Change | WatchKind.Delete which is 7.
@override final  WatchKind? kind;

/// Create a copy of FileSystemWatcher
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$FileSystemWatcherCopyWith<_FileSystemWatcher> get copyWith => __$FileSystemWatcherCopyWithImpl<_FileSystemWatcher>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$FileSystemWatcherToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _FileSystemWatcher&&(identical(other.globPattern, globPattern) || other.globPattern == globPattern)&&(identical(other.kind, kind) || other.kind == kind));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,globPattern,kind);

@override
String toString() {
  return 'FileSystemWatcher(globPattern: $globPattern, kind: $kind)';
}


}

/// @nodoc
abstract mixin class _$FileSystemWatcherCopyWith<$Res> implements $FileSystemWatcherCopyWith<$Res> {
  factory _$FileSystemWatcherCopyWith(_FileSystemWatcher value, $Res Function(_FileSystemWatcher) _then) = __$FileSystemWatcherCopyWithImpl;
@override @useResult
$Res call({
 GlobPattern globPattern, WatchKind? kind
});




}
/// @nodoc
class __$FileSystemWatcherCopyWithImpl<$Res>
    implements _$FileSystemWatcherCopyWith<$Res> {
  __$FileSystemWatcherCopyWithImpl(this._self, this._then);

  final _FileSystemWatcher _self;
  final $Res Function(_FileSystemWatcher) _then;

/// Create a copy of FileSystemWatcher
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? globPattern = null,Object? kind = freezed,}) {
  return _then(_FileSystemWatcher(
globPattern: null == globPattern ? _self.globPattern : globPattern // ignore: cast_nullable_to_non_nullable
as GlobPattern,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as WatchKind?,
  ));
}


}


/// @nodoc
mixin _$Diagnostic {

/// The diagnostic's code, which usually appear in the user interface.
 Sealed6? get code;/// An optional property to describe the error code. Requires the code
/// field (above) to be present/not null.
/// @since 3.16.0
 CodeDescription? get codeDescription;/// A data entry field that is preserved between a
/// `textDocument/publishDiagnostics` notification and
/// `textDocument/codeAction` request.
/// @since 3.16.0
 LSPAny? get data;/// The diagnostic's message. It usually appears in the user interface
 String get message;/// The range at which the message applies
 Range get range;/// An array of related diagnostic information, e.g. when symbol-names
/// within a scope collide all definitions can be marked via this property.
 List<DiagnosticRelatedInformation>? get relatedInformation;/// The diagnostic's severity. Can be omitted. If omitted it is up to the
/// client to interpret diagnostics as error, warning, info or hint.
 DiagnosticSeverity? get severity;/// A human-readable string describing the source of this diagnostic, e.g.
/// 'typescript' or 'super lint'. It usually appears in the user interface.
 String? get source;/// Additional metadata about the diagnostic.
/// @since 3.15.0
 List<DiagnosticTag>? get tags;
/// Create a copy of Diagnostic
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DiagnosticCopyWith<Diagnostic> get copyWith => _$DiagnosticCopyWithImpl<Diagnostic>(this as Diagnostic, _$identity);

  /// Serializes this Diagnostic to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is Diagnostic&&(identical(other.code, code) || other.code == code)&&(identical(other.codeDescription, codeDescription) || other.codeDescription == codeDescription)&&(identical(other.data, data) || other.data == data)&&(identical(other.message, message) || other.message == message)&&(identical(other.range, range) || other.range == range)&&const DeepCollectionEquality().equals(other.relatedInformation, relatedInformation)&&(identical(other.severity, severity) || other.severity == severity)&&(identical(other.source, source) || other.source == source)&&const DeepCollectionEquality().equals(other.tags, tags));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,code,codeDescription,data,message,range,const DeepCollectionEquality().hash(relatedInformation),severity,source,const DeepCollectionEquality().hash(tags));

@override
String toString() {
  return 'Diagnostic(code: $code, codeDescription: $codeDescription, data: $data, message: $message, range: $range, relatedInformation: $relatedInformation, severity: $severity, source: $source, tags: $tags)';
}


}

/// @nodoc
abstract mixin class $DiagnosticCopyWith<$Res>  {
  factory $DiagnosticCopyWith(Diagnostic value, $Res Function(Diagnostic) _then) = _$DiagnosticCopyWithImpl;
@useResult
$Res call({
 Sealed6? code, CodeDescription? codeDescription, LSPAny? data, String message, Range range, List<DiagnosticRelatedInformation>? relatedInformation, DiagnosticSeverity? severity, String? source, List<DiagnosticTag>? tags
});


$CodeDescriptionCopyWith<$Res>? get codeDescription;$RangeCopyWith<$Res> get range;

}
/// @nodoc
class _$DiagnosticCopyWithImpl<$Res>
    implements $DiagnosticCopyWith<$Res> {
  _$DiagnosticCopyWithImpl(this._self, this._then);

  final Diagnostic _self;
  final $Res Function(Diagnostic) _then;

/// Create a copy of Diagnostic
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? code = freezed,Object? codeDescription = freezed,Object? data = freezed,Object? message = null,Object? range = null,Object? relatedInformation = freezed,Object? severity = freezed,Object? source = freezed,Object? tags = freezed,}) {
  return _then(_self.copyWith(
code: freezed == code ? _self.code : code // ignore: cast_nullable_to_non_nullable
as Sealed6?,codeDescription: freezed == codeDescription ? _self.codeDescription : codeDescription // ignore: cast_nullable_to_non_nullable
as CodeDescription?,data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LSPAny?,message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,relatedInformation: freezed == relatedInformation ? _self.relatedInformation : relatedInformation // ignore: cast_nullable_to_non_nullable
as List<DiagnosticRelatedInformation>?,severity: freezed == severity ? _self.severity : severity // ignore: cast_nullable_to_non_nullable
as DiagnosticSeverity?,source: freezed == source ? _self.source : source // ignore: cast_nullable_to_non_nullable
as String?,tags: freezed == tags ? _self.tags : tags // ignore: cast_nullable_to_non_nullable
as List<DiagnosticTag>?,
  ));
}
/// Create a copy of Diagnostic
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CodeDescriptionCopyWith<$Res>? get codeDescription {
    if (_self.codeDescription == null) {
    return null;
  }

  return $CodeDescriptionCopyWith<$Res>(_self.codeDescription!, (value) {
    return _then(_self.copyWith(codeDescription: value));
  });
}/// Create a copy of Diagnostic
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _Diagnostic implements Diagnostic {
  const _Diagnostic({this.code, this.codeDescription, this.data, required this.message, required this.range, final  List<DiagnosticRelatedInformation>? relatedInformation, this.severity, this.source, final  List<DiagnosticTag>? tags}): _relatedInformation = relatedInformation,_tags = tags;
  factory _Diagnostic.fromJson(Map<String, dynamic> json) => _$DiagnosticFromJson(json);

/// The diagnostic's code, which usually appear in the user interface.
@override final  Sealed6? code;
/// An optional property to describe the error code. Requires the code
/// field (above) to be present/not null.
/// @since 3.16.0
@override final  CodeDescription? codeDescription;
/// A data entry field that is preserved between a
/// `textDocument/publishDiagnostics` notification and
/// `textDocument/codeAction` request.
/// @since 3.16.0
@override final  LSPAny? data;
/// The diagnostic's message. It usually appears in the user interface
@override final  String message;
/// The range at which the message applies
@override final  Range range;
/// An array of related diagnostic information, e.g. when symbol-names
/// within a scope collide all definitions can be marked via this property.
 final  List<DiagnosticRelatedInformation>? _relatedInformation;
/// An array of related diagnostic information, e.g. when symbol-names
/// within a scope collide all definitions can be marked via this property.
@override List<DiagnosticRelatedInformation>? get relatedInformation {
  final value = _relatedInformation;
  if (value == null) return null;
  if (_relatedInformation is EqualUnmodifiableListView) return _relatedInformation;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

/// The diagnostic's severity. Can be omitted. If omitted it is up to the
/// client to interpret diagnostics as error, warning, info or hint.
@override final  DiagnosticSeverity? severity;
/// A human-readable string describing the source of this diagnostic, e.g.
/// 'typescript' or 'super lint'. It usually appears in the user interface.
@override final  String? source;
/// Additional metadata about the diagnostic.
/// @since 3.15.0
 final  List<DiagnosticTag>? _tags;
/// Additional metadata about the diagnostic.
/// @since 3.15.0
@override List<DiagnosticTag>? get tags {
  final value = _tags;
  if (value == null) return null;
  if (_tags is EqualUnmodifiableListView) return _tags;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}


/// Create a copy of Diagnostic
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DiagnosticCopyWith<_Diagnostic> get copyWith => __$DiagnosticCopyWithImpl<_Diagnostic>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DiagnosticToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _Diagnostic&&(identical(other.code, code) || other.code == code)&&(identical(other.codeDescription, codeDescription) || other.codeDescription == codeDescription)&&(identical(other.data, data) || other.data == data)&&(identical(other.message, message) || other.message == message)&&(identical(other.range, range) || other.range == range)&&const DeepCollectionEquality().equals(other._relatedInformation, _relatedInformation)&&(identical(other.severity, severity) || other.severity == severity)&&(identical(other.source, source) || other.source == source)&&const DeepCollectionEquality().equals(other._tags, _tags));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,code,codeDescription,data,message,range,const DeepCollectionEquality().hash(_relatedInformation),severity,source,const DeepCollectionEquality().hash(_tags));

@override
String toString() {
  return 'Diagnostic(code: $code, codeDescription: $codeDescription, data: $data, message: $message, range: $range, relatedInformation: $relatedInformation, severity: $severity, source: $source, tags: $tags)';
}


}

/// @nodoc
abstract mixin class _$DiagnosticCopyWith<$Res> implements $DiagnosticCopyWith<$Res> {
  factory _$DiagnosticCopyWith(_Diagnostic value, $Res Function(_Diagnostic) _then) = __$DiagnosticCopyWithImpl;
@override @useResult
$Res call({
 Sealed6? code, CodeDescription? codeDescription, LSPAny? data, String message, Range range, List<DiagnosticRelatedInformation>? relatedInformation, DiagnosticSeverity? severity, String? source, List<DiagnosticTag>? tags
});


@override $CodeDescriptionCopyWith<$Res>? get codeDescription;@override $RangeCopyWith<$Res> get range;

}
/// @nodoc
class __$DiagnosticCopyWithImpl<$Res>
    implements _$DiagnosticCopyWith<$Res> {
  __$DiagnosticCopyWithImpl(this._self, this._then);

  final _Diagnostic _self;
  final $Res Function(_Diagnostic) _then;

/// Create a copy of Diagnostic
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? code = freezed,Object? codeDescription = freezed,Object? data = freezed,Object? message = null,Object? range = null,Object? relatedInformation = freezed,Object? severity = freezed,Object? source = freezed,Object? tags = freezed,}) {
  return _then(_Diagnostic(
code: freezed == code ? _self.code : code // ignore: cast_nullable_to_non_nullable
as Sealed6?,codeDescription: freezed == codeDescription ? _self.codeDescription : codeDescription // ignore: cast_nullable_to_non_nullable
as CodeDescription?,data: freezed == data ? _self.data : data // ignore: cast_nullable_to_non_nullable
as LSPAny?,message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,relatedInformation: freezed == relatedInformation ? _self._relatedInformation : relatedInformation // ignore: cast_nullable_to_non_nullable
as List<DiagnosticRelatedInformation>?,severity: freezed == severity ? _self.severity : severity // ignore: cast_nullable_to_non_nullable
as DiagnosticSeverity?,source: freezed == source ? _self.source : source // ignore: cast_nullable_to_non_nullable
as String?,tags: freezed == tags ? _self._tags : tags // ignore: cast_nullable_to_non_nullable
as List<DiagnosticTag>?,
  ));
}

/// Create a copy of Diagnostic
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CodeDescriptionCopyWith<$Res>? get codeDescription {
    if (_self.codeDescription == null) {
    return null;
  }

  return $CodeDescriptionCopyWith<$Res>(_self.codeDescription!, (value) {
    return _then(_self.copyWith(codeDescription: value));
  });
}/// Create a copy of Diagnostic
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}


/// @nodoc
mixin _$CompletionContext {

/// The trigger character (a single character) that has trigger code
/// complete. Is undefined if `triggerKind !==
/// CompletionTriggerKind.TriggerCharacter`
 String? get triggerCharacter;/// How the completion was triggered.
 CompletionTriggerKind get triggerKind;
/// Create a copy of CompletionContext
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CompletionContextCopyWith<CompletionContext> get copyWith => _$CompletionContextCopyWithImpl<CompletionContext>(this as CompletionContext, _$identity);

  /// Serializes this CompletionContext to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CompletionContext&&(identical(other.triggerCharacter, triggerCharacter) || other.triggerCharacter == triggerCharacter)&&(identical(other.triggerKind, triggerKind) || other.triggerKind == triggerKind));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,triggerCharacter,triggerKind);

@override
String toString() {
  return 'CompletionContext(triggerCharacter: $triggerCharacter, triggerKind: $triggerKind)';
}


}

/// @nodoc
abstract mixin class $CompletionContextCopyWith<$Res>  {
  factory $CompletionContextCopyWith(CompletionContext value, $Res Function(CompletionContext) _then) = _$CompletionContextCopyWithImpl;
@useResult
$Res call({
 String? triggerCharacter, CompletionTriggerKind triggerKind
});




}
/// @nodoc
class _$CompletionContextCopyWithImpl<$Res>
    implements $CompletionContextCopyWith<$Res> {
  _$CompletionContextCopyWithImpl(this._self, this._then);

  final CompletionContext _self;
  final $Res Function(CompletionContext) _then;

/// Create a copy of CompletionContext
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? triggerCharacter = freezed,Object? triggerKind = null,}) {
  return _then(_self.copyWith(
triggerCharacter: freezed == triggerCharacter ? _self.triggerCharacter : triggerCharacter // ignore: cast_nullable_to_non_nullable
as String?,triggerKind: null == triggerKind ? _self.triggerKind : triggerKind // ignore: cast_nullable_to_non_nullable
as CompletionTriggerKind,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _CompletionContext implements CompletionContext {
  const _CompletionContext({this.triggerCharacter, required this.triggerKind});
  factory _CompletionContext.fromJson(Map<String, dynamic> json) => _$CompletionContextFromJson(json);

/// The trigger character (a single character) that has trigger code
/// complete. Is undefined if `triggerKind !==
/// CompletionTriggerKind.TriggerCharacter`
@override final  String? triggerCharacter;
/// How the completion was triggered.
@override final  CompletionTriggerKind triggerKind;

/// Create a copy of CompletionContext
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CompletionContextCopyWith<_CompletionContext> get copyWith => __$CompletionContextCopyWithImpl<_CompletionContext>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CompletionContextToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CompletionContext&&(identical(other.triggerCharacter, triggerCharacter) || other.triggerCharacter == triggerCharacter)&&(identical(other.triggerKind, triggerKind) || other.triggerKind == triggerKind));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,triggerCharacter,triggerKind);

@override
String toString() {
  return 'CompletionContext(triggerCharacter: $triggerCharacter, triggerKind: $triggerKind)';
}


}

/// @nodoc
abstract mixin class _$CompletionContextCopyWith<$Res> implements $CompletionContextCopyWith<$Res> {
  factory _$CompletionContextCopyWith(_CompletionContext value, $Res Function(_CompletionContext) _then) = __$CompletionContextCopyWithImpl;
@override @useResult
$Res call({
 String? triggerCharacter, CompletionTriggerKind triggerKind
});




}
/// @nodoc
class __$CompletionContextCopyWithImpl<$Res>
    implements _$CompletionContextCopyWith<$Res> {
  __$CompletionContextCopyWithImpl(this._self, this._then);

  final _CompletionContext _self;
  final $Res Function(_CompletionContext) _then;

/// Create a copy of CompletionContext
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? triggerCharacter = freezed,Object? triggerKind = null,}) {
  return _then(_CompletionContext(
triggerCharacter: freezed == triggerCharacter ? _self.triggerCharacter : triggerCharacter // ignore: cast_nullable_to_non_nullable
as String?,triggerKind: null == triggerKind ? _self.triggerKind : triggerKind // ignore: cast_nullable_to_non_nullable
as CompletionTriggerKind,
  ));
}


}


/// @nodoc
mixin _$CompletionItemLabelDetails {

/// An optional string which is rendered less prominently after {@link
/// CompletionItem.detail}. Should be used for fully qualified names and
/// file paths.
 String? get description;/// An optional string which is rendered less prominently directly after
/// {@link CompletionItem.label label}, without any spacing. Should be used
/// for function signatures and type annotations.
 String? get detail;
/// Create a copy of CompletionItemLabelDetails
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CompletionItemLabelDetailsCopyWith<CompletionItemLabelDetails> get copyWith => _$CompletionItemLabelDetailsCopyWithImpl<CompletionItemLabelDetails>(this as CompletionItemLabelDetails, _$identity);

  /// Serializes this CompletionItemLabelDetails to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CompletionItemLabelDetails&&(identical(other.description, description) || other.description == description)&&(identical(other.detail, detail) || other.detail == detail));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,description,detail);

@override
String toString() {
  return 'CompletionItemLabelDetails(description: $description, detail: $detail)';
}


}

/// @nodoc
abstract mixin class $CompletionItemLabelDetailsCopyWith<$Res>  {
  factory $CompletionItemLabelDetailsCopyWith(CompletionItemLabelDetails value, $Res Function(CompletionItemLabelDetails) _then) = _$CompletionItemLabelDetailsCopyWithImpl;
@useResult
$Res call({
 String? description, String? detail
});




}
/// @nodoc
class _$CompletionItemLabelDetailsCopyWithImpl<$Res>
    implements $CompletionItemLabelDetailsCopyWith<$Res> {
  _$CompletionItemLabelDetailsCopyWithImpl(this._self, this._then);

  final CompletionItemLabelDetails _self;
  final $Res Function(CompletionItemLabelDetails) _then;

/// Create a copy of CompletionItemLabelDetails
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? description = freezed,Object? detail = freezed,}) {
  return _then(_self.copyWith(
description: freezed == description ? _self.description : description // ignore: cast_nullable_to_non_nullable
as String?,detail: freezed == detail ? _self.detail : detail // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _CompletionItemLabelDetails implements CompletionItemLabelDetails {
  const _CompletionItemLabelDetails({this.description, this.detail});
  factory _CompletionItemLabelDetails.fromJson(Map<String, dynamic> json) => _$CompletionItemLabelDetailsFromJson(json);

/// An optional string which is rendered less prominently after {@link
/// CompletionItem.detail}. Should be used for fully qualified names and
/// file paths.
@override final  String? description;
/// An optional string which is rendered less prominently directly after
/// {@link CompletionItem.label label}, without any spacing. Should be used
/// for function signatures and type annotations.
@override final  String? detail;

/// Create a copy of CompletionItemLabelDetails
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CompletionItemLabelDetailsCopyWith<_CompletionItemLabelDetails> get copyWith => __$CompletionItemLabelDetailsCopyWithImpl<_CompletionItemLabelDetails>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CompletionItemLabelDetailsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CompletionItemLabelDetails&&(identical(other.description, description) || other.description == description)&&(identical(other.detail, detail) || other.detail == detail));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,description,detail);

@override
String toString() {
  return 'CompletionItemLabelDetails(description: $description, detail: $detail)';
}


}

/// @nodoc
abstract mixin class _$CompletionItemLabelDetailsCopyWith<$Res> implements $CompletionItemLabelDetailsCopyWith<$Res> {
  factory _$CompletionItemLabelDetailsCopyWith(_CompletionItemLabelDetails value, $Res Function(_CompletionItemLabelDetails) _then) = __$CompletionItemLabelDetailsCopyWithImpl;
@override @useResult
$Res call({
 String? description, String? detail
});




}
/// @nodoc
class __$CompletionItemLabelDetailsCopyWithImpl<$Res>
    implements _$CompletionItemLabelDetailsCopyWith<$Res> {
  __$CompletionItemLabelDetailsCopyWithImpl(this._self, this._then);

  final _CompletionItemLabelDetails _self;
  final $Res Function(_CompletionItemLabelDetails) _then;

/// Create a copy of CompletionItemLabelDetails
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? description = freezed,Object? detail = freezed,}) {
  return _then(_CompletionItemLabelDetails(
description: freezed == description ? _self.description : description // ignore: cast_nullable_to_non_nullable
as String?,detail: freezed == detail ? _self.detail : detail // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$InsertReplaceEdit {

/// The range if the insert is requested
 Range get insert;/// The string to be inserted.
 String get newText;/// The range if the replace is requested.
 Range get replace;
/// Create a copy of InsertReplaceEdit
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InsertReplaceEditCopyWith<InsertReplaceEdit> get copyWith => _$InsertReplaceEditCopyWithImpl<InsertReplaceEdit>(this as InsertReplaceEdit, _$identity);

  /// Serializes this InsertReplaceEdit to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InsertReplaceEdit&&(identical(other.insert, insert) || other.insert == insert)&&(identical(other.newText, newText) || other.newText == newText)&&(identical(other.replace, replace) || other.replace == replace));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,insert,newText,replace);

@override
String toString() {
  return 'InsertReplaceEdit(insert: $insert, newText: $newText, replace: $replace)';
}


}

/// @nodoc
abstract mixin class $InsertReplaceEditCopyWith<$Res>  {
  factory $InsertReplaceEditCopyWith(InsertReplaceEdit value, $Res Function(InsertReplaceEdit) _then) = _$InsertReplaceEditCopyWithImpl;
@useResult
$Res call({
 Range insert, String newText, Range replace
});


$RangeCopyWith<$Res> get insert;$RangeCopyWith<$Res> get replace;

}
/// @nodoc
class _$InsertReplaceEditCopyWithImpl<$Res>
    implements $InsertReplaceEditCopyWith<$Res> {
  _$InsertReplaceEditCopyWithImpl(this._self, this._then);

  final InsertReplaceEdit _self;
  final $Res Function(InsertReplaceEdit) _then;

/// Create a copy of InsertReplaceEdit
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? insert = null,Object? newText = null,Object? replace = null,}) {
  return _then(_self.copyWith(
insert: null == insert ? _self.insert : insert // ignore: cast_nullable_to_non_nullable
as Range,newText: null == newText ? _self.newText : newText // ignore: cast_nullable_to_non_nullable
as String,replace: null == replace ? _self.replace : replace // ignore: cast_nullable_to_non_nullable
as Range,
  ));
}
/// Create a copy of InsertReplaceEdit
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get insert {
  
  return $RangeCopyWith<$Res>(_self.insert, (value) {
    return _then(_self.copyWith(insert: value));
  });
}/// Create a copy of InsertReplaceEdit
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get replace {
  
  return $RangeCopyWith<$Res>(_self.replace, (value) {
    return _then(_self.copyWith(replace: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _InsertReplaceEdit implements InsertReplaceEdit {
  const _InsertReplaceEdit({required this.insert, required this.newText, required this.replace});
  factory _InsertReplaceEdit.fromJson(Map<String, dynamic> json) => _$InsertReplaceEditFromJson(json);

/// The range if the insert is requested
@override final  Range insert;
/// The string to be inserted.
@override final  String newText;
/// The range if the replace is requested.
@override final  Range replace;

/// Create a copy of InsertReplaceEdit
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InsertReplaceEditCopyWith<_InsertReplaceEdit> get copyWith => __$InsertReplaceEditCopyWithImpl<_InsertReplaceEdit>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InsertReplaceEditToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InsertReplaceEdit&&(identical(other.insert, insert) || other.insert == insert)&&(identical(other.newText, newText) || other.newText == newText)&&(identical(other.replace, replace) || other.replace == replace));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,insert,newText,replace);

@override
String toString() {
  return 'InsertReplaceEdit(insert: $insert, newText: $newText, replace: $replace)';
}


}

/// @nodoc
abstract mixin class _$InsertReplaceEditCopyWith<$Res> implements $InsertReplaceEditCopyWith<$Res> {
  factory _$InsertReplaceEditCopyWith(_InsertReplaceEdit value, $Res Function(_InsertReplaceEdit) _then) = __$InsertReplaceEditCopyWithImpl;
@override @useResult
$Res call({
 Range insert, String newText, Range replace
});


@override $RangeCopyWith<$Res> get insert;@override $RangeCopyWith<$Res> get replace;

}
/// @nodoc
class __$InsertReplaceEditCopyWithImpl<$Res>
    implements _$InsertReplaceEditCopyWith<$Res> {
  __$InsertReplaceEditCopyWithImpl(this._self, this._then);

  final _InsertReplaceEdit _self;
  final $Res Function(_InsertReplaceEdit) _then;

/// Create a copy of InsertReplaceEdit
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? insert = null,Object? newText = null,Object? replace = null,}) {
  return _then(_InsertReplaceEdit(
insert: null == insert ? _self.insert : insert // ignore: cast_nullable_to_non_nullable
as Range,newText: null == newText ? _self.newText : newText // ignore: cast_nullable_to_non_nullable
as String,replace: null == replace ? _self.replace : replace // ignore: cast_nullable_to_non_nullable
as Range,
  ));
}

/// Create a copy of InsertReplaceEdit
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get insert {
  
  return $RangeCopyWith<$Res>(_self.insert, (value) {
    return _then(_self.copyWith(insert: value));
  });
}/// Create a copy of InsertReplaceEdit
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get replace {
  
  return $RangeCopyWith<$Res>(_self.replace, (value) {
    return _then(_self.copyWith(replace: value));
  });
}
}


/// @nodoc
mixin _$CompletionOptions {

/// The list of all possible characters that commit a completion. This
/// field can be used if clients don't support individual commit characters
/// per completion item. See
/// `ClientCapabilities.textDocument.completion.completionItem.commitCharactersSupport`
/// If a server provides both `allCommitCharacters` and commit characters
/// on an individual completion item the ones on the completion item win.
/// @since 3.2.0
 List<String>? get allCommitCharacters;/// The server supports the following `CompletionItem` specific
/// capabilities.
/// @since 3.17.0
 BoolLabelDetailsSupport? get completionItem;/// The server provides support to resolve additional information for a
/// completion item.
 bool? get resolveProvider;/// Most tools trigger completion request automatically without explicitly
/// requesting it using a keyboard shortcut (e.g. Ctrl+Space). Typically
/// they do so when the user starts to type an identifier. For example if
/// the user types `c` in a JavaScript file code complete will
/// automatically pop up present `console` besides others as a completion
/// item. Characters that make up identifiers don't need to be listed here.
/// If code complete should automatically be trigger on characters not
/// being valid inside an identifier (for example `.` in JavaScript) list
/// them in `triggerCharacters`.
 List<String>? get triggerCharacters; bool? get workDoneProgress;
/// Create a copy of CompletionOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CompletionOptionsCopyWith<CompletionOptions> get copyWith => _$CompletionOptionsCopyWithImpl<CompletionOptions>(this as CompletionOptions, _$identity);

  /// Serializes this CompletionOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CompletionOptions&&const DeepCollectionEquality().equals(other.allCommitCharacters, allCommitCharacters)&&const DeepCollectionEquality().equals(other.completionItem, completionItem)&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider)&&const DeepCollectionEquality().equals(other.triggerCharacters, triggerCharacters)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(allCommitCharacters),const DeepCollectionEquality().hash(completionItem),resolveProvider,const DeepCollectionEquality().hash(triggerCharacters),workDoneProgress);

@override
String toString() {
  return 'CompletionOptions(allCommitCharacters: $allCommitCharacters, completionItem: $completionItem, resolveProvider: $resolveProvider, triggerCharacters: $triggerCharacters, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $CompletionOptionsCopyWith<$Res>  {
  factory $CompletionOptionsCopyWith(CompletionOptions value, $Res Function(CompletionOptions) _then) = _$CompletionOptionsCopyWithImpl;
@useResult
$Res call({
 List<String>? allCommitCharacters, BoolLabelDetailsSupport? completionItem, bool? resolveProvider, List<String>? triggerCharacters, bool? workDoneProgress
});




}
/// @nodoc
class _$CompletionOptionsCopyWithImpl<$Res>
    implements $CompletionOptionsCopyWith<$Res> {
  _$CompletionOptionsCopyWithImpl(this._self, this._then);

  final CompletionOptions _self;
  final $Res Function(CompletionOptions) _then;

/// Create a copy of CompletionOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? allCommitCharacters = freezed,Object? completionItem = freezed,Object? resolveProvider = freezed,Object? triggerCharacters = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
allCommitCharacters: freezed == allCommitCharacters ? _self.allCommitCharacters : allCommitCharacters // ignore: cast_nullable_to_non_nullable
as List<String>?,completionItem: freezed == completionItem ? _self.completionItem : completionItem // ignore: cast_nullable_to_non_nullable
as BoolLabelDetailsSupport?,resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,triggerCharacters: freezed == triggerCharacters ? _self.triggerCharacters : triggerCharacters // ignore: cast_nullable_to_non_nullable
as List<String>?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _CompletionOptions implements CompletionOptions {
  const _CompletionOptions({final  List<String>? allCommitCharacters, this.completionItem, this.resolveProvider, final  List<String>? triggerCharacters, this.workDoneProgress}): _allCommitCharacters = allCommitCharacters,_triggerCharacters = triggerCharacters;
  factory _CompletionOptions.fromJson(Map<String, dynamic> json) => _$CompletionOptionsFromJson(json);

/// The list of all possible characters that commit a completion. This
/// field can be used if clients don't support individual commit characters
/// per completion item. See
/// `ClientCapabilities.textDocument.completion.completionItem.commitCharactersSupport`
/// If a server provides both `allCommitCharacters` and commit characters
/// on an individual completion item the ones on the completion item win.
/// @since 3.2.0
 final  List<String>? _allCommitCharacters;
/// The list of all possible characters that commit a completion. This
/// field can be used if clients don't support individual commit characters
/// per completion item. See
/// `ClientCapabilities.textDocument.completion.completionItem.commitCharactersSupport`
/// If a server provides both `allCommitCharacters` and commit characters
/// on an individual completion item the ones on the completion item win.
/// @since 3.2.0
@override List<String>? get allCommitCharacters {
  final value = _allCommitCharacters;
  if (value == null) return null;
  if (_allCommitCharacters is EqualUnmodifiableListView) return _allCommitCharacters;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

/// The server supports the following `CompletionItem` specific
/// capabilities.
/// @since 3.17.0
@override final  BoolLabelDetailsSupport? completionItem;
/// The server provides support to resolve additional information for a
/// completion item.
@override final  bool? resolveProvider;
/// Most tools trigger completion request automatically without explicitly
/// requesting it using a keyboard shortcut (e.g. Ctrl+Space). Typically
/// they do so when the user starts to type an identifier. For example if
/// the user types `c` in a JavaScript file code complete will
/// automatically pop up present `console` besides others as a completion
/// item. Characters that make up identifiers don't need to be listed here.
/// If code complete should automatically be trigger on characters not
/// being valid inside an identifier (for example `.` in JavaScript) list
/// them in `triggerCharacters`.
 final  List<String>? _triggerCharacters;
/// Most tools trigger completion request automatically without explicitly
/// requesting it using a keyboard shortcut (e.g. Ctrl+Space). Typically
/// they do so when the user starts to type an identifier. For example if
/// the user types `c` in a JavaScript file code complete will
/// automatically pop up present `console` besides others as a completion
/// item. Characters that make up identifiers don't need to be listed here.
/// If code complete should automatically be trigger on characters not
/// being valid inside an identifier (for example `.` in JavaScript) list
/// them in `triggerCharacters`.
@override List<String>? get triggerCharacters {
  final value = _triggerCharacters;
  if (value == null) return null;
  if (_triggerCharacters is EqualUnmodifiableListView) return _triggerCharacters;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

@override final  bool? workDoneProgress;

/// Create a copy of CompletionOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CompletionOptionsCopyWith<_CompletionOptions> get copyWith => __$CompletionOptionsCopyWithImpl<_CompletionOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CompletionOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CompletionOptions&&const DeepCollectionEquality().equals(other._allCommitCharacters, _allCommitCharacters)&&const DeepCollectionEquality().equals(other.completionItem, completionItem)&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider)&&const DeepCollectionEquality().equals(other._triggerCharacters, _triggerCharacters)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_allCommitCharacters),const DeepCollectionEquality().hash(completionItem),resolveProvider,const DeepCollectionEquality().hash(_triggerCharacters),workDoneProgress);

@override
String toString() {
  return 'CompletionOptions(allCommitCharacters: $allCommitCharacters, completionItem: $completionItem, resolveProvider: $resolveProvider, triggerCharacters: $triggerCharacters, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$CompletionOptionsCopyWith<$Res> implements $CompletionOptionsCopyWith<$Res> {
  factory _$CompletionOptionsCopyWith(_CompletionOptions value, $Res Function(_CompletionOptions) _then) = __$CompletionOptionsCopyWithImpl;
@override @useResult
$Res call({
 List<String>? allCommitCharacters, BoolLabelDetailsSupport? completionItem, bool? resolveProvider, List<String>? triggerCharacters, bool? workDoneProgress
});




}
/// @nodoc
class __$CompletionOptionsCopyWithImpl<$Res>
    implements _$CompletionOptionsCopyWith<$Res> {
  __$CompletionOptionsCopyWithImpl(this._self, this._then);

  final _CompletionOptions _self;
  final $Res Function(_CompletionOptions) _then;

/// Create a copy of CompletionOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? allCommitCharacters = freezed,Object? completionItem = freezed,Object? resolveProvider = freezed,Object? triggerCharacters = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_CompletionOptions(
allCommitCharacters: freezed == allCommitCharacters ? _self._allCommitCharacters : allCommitCharacters // ignore: cast_nullable_to_non_nullable
as List<String>?,completionItem: freezed == completionItem ? _self.completionItem : completionItem // ignore: cast_nullable_to_non_nullable
as BoolLabelDetailsSupport?,resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,triggerCharacters: freezed == triggerCharacters ? _self._triggerCharacters : triggerCharacters // ignore: cast_nullable_to_non_nullable
as List<String>?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$HoverOptions {

 bool? get workDoneProgress;
/// Create a copy of HoverOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$HoverOptionsCopyWith<HoverOptions> get copyWith => _$HoverOptionsCopyWithImpl<HoverOptions>(this as HoverOptions, _$identity);

  /// Serializes this HoverOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is HoverOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'HoverOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $HoverOptionsCopyWith<$Res>  {
  factory $HoverOptionsCopyWith(HoverOptions value, $Res Function(HoverOptions) _then) = _$HoverOptionsCopyWithImpl;
@useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class _$HoverOptionsCopyWithImpl<$Res>
    implements $HoverOptionsCopyWith<$Res> {
  _$HoverOptionsCopyWithImpl(this._self, this._then);

  final HoverOptions _self;
  final $Res Function(HoverOptions) _then;

/// Create a copy of HoverOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _HoverOptions implements HoverOptions {
  const _HoverOptions({this.workDoneProgress});
  factory _HoverOptions.fromJson(Map<String, dynamic> json) => _$HoverOptionsFromJson(json);

@override final  bool? workDoneProgress;

/// Create a copy of HoverOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$HoverOptionsCopyWith<_HoverOptions> get copyWith => __$HoverOptionsCopyWithImpl<_HoverOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$HoverOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _HoverOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'HoverOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$HoverOptionsCopyWith<$Res> implements $HoverOptionsCopyWith<$Res> {
  factory _$HoverOptionsCopyWith(_HoverOptions value, $Res Function(_HoverOptions) _then) = __$HoverOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class __$HoverOptionsCopyWithImpl<$Res>
    implements _$HoverOptionsCopyWith<$Res> {
  __$HoverOptionsCopyWithImpl(this._self, this._then);

  final _HoverOptions _self;
  final $Res Function(_HoverOptions) _then;

/// Create a copy of HoverOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_HoverOptions(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$SignatureHelpContext {

/// The currently active `SignatureHelp`.
/// The `activeSignatureHelp` has its `SignatureHelp.activeSignature` field
/// updated based on the user navigating through available signatures.
 SignatureHelp? get activeSignatureHelp;/// `true` if signature help was already showing when it was triggered.
/// Retriggers occurs when the signature help is already active and can be
/// caused by actions such as typing a trigger character, a cursor move, or
/// document content changes.
 bool get isRetrigger;/// Character that caused signature help to be triggered.
/// This is undefined when `triggerKind !==
/// SignatureHelpTriggerKind.TriggerCharacter`
 String? get triggerCharacter;/// Action that caused signature help to be triggered.
 SignatureHelpTriggerKind get triggerKind;
/// Create a copy of SignatureHelpContext
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SignatureHelpContextCopyWith<SignatureHelpContext> get copyWith => _$SignatureHelpContextCopyWithImpl<SignatureHelpContext>(this as SignatureHelpContext, _$identity);

  /// Serializes this SignatureHelpContext to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SignatureHelpContext&&(identical(other.activeSignatureHelp, activeSignatureHelp) || other.activeSignatureHelp == activeSignatureHelp)&&(identical(other.isRetrigger, isRetrigger) || other.isRetrigger == isRetrigger)&&(identical(other.triggerCharacter, triggerCharacter) || other.triggerCharacter == triggerCharacter)&&(identical(other.triggerKind, triggerKind) || other.triggerKind == triggerKind));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,activeSignatureHelp,isRetrigger,triggerCharacter,triggerKind);

@override
String toString() {
  return 'SignatureHelpContext(activeSignatureHelp: $activeSignatureHelp, isRetrigger: $isRetrigger, triggerCharacter: $triggerCharacter, triggerKind: $triggerKind)';
}


}

/// @nodoc
abstract mixin class $SignatureHelpContextCopyWith<$Res>  {
  factory $SignatureHelpContextCopyWith(SignatureHelpContext value, $Res Function(SignatureHelpContext) _then) = _$SignatureHelpContextCopyWithImpl;
@useResult
$Res call({
 SignatureHelp? activeSignatureHelp, bool isRetrigger, String? triggerCharacter, SignatureHelpTriggerKind triggerKind
});


$SignatureHelpCopyWith<$Res>? get activeSignatureHelp;

}
/// @nodoc
class _$SignatureHelpContextCopyWithImpl<$Res>
    implements $SignatureHelpContextCopyWith<$Res> {
  _$SignatureHelpContextCopyWithImpl(this._self, this._then);

  final SignatureHelpContext _self;
  final $Res Function(SignatureHelpContext) _then;

/// Create a copy of SignatureHelpContext
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? activeSignatureHelp = freezed,Object? isRetrigger = null,Object? triggerCharacter = freezed,Object? triggerKind = null,}) {
  return _then(_self.copyWith(
activeSignatureHelp: freezed == activeSignatureHelp ? _self.activeSignatureHelp : activeSignatureHelp // ignore: cast_nullable_to_non_nullable
as SignatureHelp?,isRetrigger: null == isRetrigger ? _self.isRetrigger : isRetrigger // ignore: cast_nullable_to_non_nullable
as bool,triggerCharacter: freezed == triggerCharacter ? _self.triggerCharacter : triggerCharacter // ignore: cast_nullable_to_non_nullable
as String?,triggerKind: null == triggerKind ? _self.triggerKind : triggerKind // ignore: cast_nullable_to_non_nullable
as SignatureHelpTriggerKind,
  ));
}
/// Create a copy of SignatureHelpContext
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SignatureHelpCopyWith<$Res>? get activeSignatureHelp {
    if (_self.activeSignatureHelp == null) {
    return null;
  }

  return $SignatureHelpCopyWith<$Res>(_self.activeSignatureHelp!, (value) {
    return _then(_self.copyWith(activeSignatureHelp: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _SignatureHelpContext implements SignatureHelpContext {
  const _SignatureHelpContext({this.activeSignatureHelp, required this.isRetrigger, this.triggerCharacter, required this.triggerKind});
  factory _SignatureHelpContext.fromJson(Map<String, dynamic> json) => _$SignatureHelpContextFromJson(json);

/// The currently active `SignatureHelp`.
/// The `activeSignatureHelp` has its `SignatureHelp.activeSignature` field
/// updated based on the user navigating through available signatures.
@override final  SignatureHelp? activeSignatureHelp;
/// `true` if signature help was already showing when it was triggered.
/// Retriggers occurs when the signature help is already active and can be
/// caused by actions such as typing a trigger character, a cursor move, or
/// document content changes.
@override final  bool isRetrigger;
/// Character that caused signature help to be triggered.
/// This is undefined when `triggerKind !==
/// SignatureHelpTriggerKind.TriggerCharacter`
@override final  String? triggerCharacter;
/// Action that caused signature help to be triggered.
@override final  SignatureHelpTriggerKind triggerKind;

/// Create a copy of SignatureHelpContext
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SignatureHelpContextCopyWith<_SignatureHelpContext> get copyWith => __$SignatureHelpContextCopyWithImpl<_SignatureHelpContext>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SignatureHelpContextToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SignatureHelpContext&&(identical(other.activeSignatureHelp, activeSignatureHelp) || other.activeSignatureHelp == activeSignatureHelp)&&(identical(other.isRetrigger, isRetrigger) || other.isRetrigger == isRetrigger)&&(identical(other.triggerCharacter, triggerCharacter) || other.triggerCharacter == triggerCharacter)&&(identical(other.triggerKind, triggerKind) || other.triggerKind == triggerKind));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,activeSignatureHelp,isRetrigger,triggerCharacter,triggerKind);

@override
String toString() {
  return 'SignatureHelpContext(activeSignatureHelp: $activeSignatureHelp, isRetrigger: $isRetrigger, triggerCharacter: $triggerCharacter, triggerKind: $triggerKind)';
}


}

/// @nodoc
abstract mixin class _$SignatureHelpContextCopyWith<$Res> implements $SignatureHelpContextCopyWith<$Res> {
  factory _$SignatureHelpContextCopyWith(_SignatureHelpContext value, $Res Function(_SignatureHelpContext) _then) = __$SignatureHelpContextCopyWithImpl;
@override @useResult
$Res call({
 SignatureHelp? activeSignatureHelp, bool isRetrigger, String? triggerCharacter, SignatureHelpTriggerKind triggerKind
});


@override $SignatureHelpCopyWith<$Res>? get activeSignatureHelp;

}
/// @nodoc
class __$SignatureHelpContextCopyWithImpl<$Res>
    implements _$SignatureHelpContextCopyWith<$Res> {
  __$SignatureHelpContextCopyWithImpl(this._self, this._then);

  final _SignatureHelpContext _self;
  final $Res Function(_SignatureHelpContext) _then;

/// Create a copy of SignatureHelpContext
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? activeSignatureHelp = freezed,Object? isRetrigger = null,Object? triggerCharacter = freezed,Object? triggerKind = null,}) {
  return _then(_SignatureHelpContext(
activeSignatureHelp: freezed == activeSignatureHelp ? _self.activeSignatureHelp : activeSignatureHelp // ignore: cast_nullable_to_non_nullable
as SignatureHelp?,isRetrigger: null == isRetrigger ? _self.isRetrigger : isRetrigger // ignore: cast_nullable_to_non_nullable
as bool,triggerCharacter: freezed == triggerCharacter ? _self.triggerCharacter : triggerCharacter // ignore: cast_nullable_to_non_nullable
as String?,triggerKind: null == triggerKind ? _self.triggerKind : triggerKind // ignore: cast_nullable_to_non_nullable
as SignatureHelpTriggerKind,
  ));
}

/// Create a copy of SignatureHelpContext
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SignatureHelpCopyWith<$Res>? get activeSignatureHelp {
    if (_self.activeSignatureHelp == null) {
    return null;
  }

  return $SignatureHelpCopyWith<$Res>(_self.activeSignatureHelp!, (value) {
    return _then(_self.copyWith(activeSignatureHelp: value));
  });
}
}


/// @nodoc
mixin _$SignatureInformation {

/// The index of the active parameter.
/// If provided, this is used in place of `SignatureHelp.activeParameter`.
/// @since 3.16.0
 int? get activeParameter;/// The human-readable doc-comment of this signature. Will be shown in the
/// UI but can be omitted.
 Sealed17? get documentation;/// The label of this signature. Will be shown in the UI.
 String get label;/// The parameters of this signature.
 List<ParameterInformation>? get parameters;
/// Create a copy of SignatureInformation
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SignatureInformationCopyWith<SignatureInformation> get copyWith => _$SignatureInformationCopyWithImpl<SignatureInformation>(this as SignatureInformation, _$identity);

  /// Serializes this SignatureInformation to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SignatureInformation&&(identical(other.activeParameter, activeParameter) || other.activeParameter == activeParameter)&&(identical(other.documentation, documentation) || other.documentation == documentation)&&(identical(other.label, label) || other.label == label)&&const DeepCollectionEquality().equals(other.parameters, parameters));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,activeParameter,documentation,label,const DeepCollectionEquality().hash(parameters));

@override
String toString() {
  return 'SignatureInformation(activeParameter: $activeParameter, documentation: $documentation, label: $label, parameters: $parameters)';
}


}

/// @nodoc
abstract mixin class $SignatureInformationCopyWith<$Res>  {
  factory $SignatureInformationCopyWith(SignatureInformation value, $Res Function(SignatureInformation) _then) = _$SignatureInformationCopyWithImpl;
@useResult
$Res call({
 int? activeParameter, Sealed17? documentation, String label, List<ParameterInformation>? parameters
});




}
/// @nodoc
class _$SignatureInformationCopyWithImpl<$Res>
    implements $SignatureInformationCopyWith<$Res> {
  _$SignatureInformationCopyWithImpl(this._self, this._then);

  final SignatureInformation _self;
  final $Res Function(SignatureInformation) _then;

/// Create a copy of SignatureInformation
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? activeParameter = freezed,Object? documentation = freezed,Object? label = null,Object? parameters = freezed,}) {
  return _then(_self.copyWith(
activeParameter: freezed == activeParameter ? _self.activeParameter : activeParameter // ignore: cast_nullable_to_non_nullable
as int?,documentation: freezed == documentation ? _self.documentation : documentation // ignore: cast_nullable_to_non_nullable
as Sealed17?,label: null == label ? _self.label : label // ignore: cast_nullable_to_non_nullable
as String,parameters: freezed == parameters ? _self.parameters : parameters // ignore: cast_nullable_to_non_nullable
as List<ParameterInformation>?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _SignatureInformation implements SignatureInformation {
  const _SignatureInformation({this.activeParameter, this.documentation, required this.label, final  List<ParameterInformation>? parameters}): _parameters = parameters;
  factory _SignatureInformation.fromJson(Map<String, dynamic> json) => _$SignatureInformationFromJson(json);

/// The index of the active parameter.
/// If provided, this is used in place of `SignatureHelp.activeParameter`.
/// @since 3.16.0
@override final  int? activeParameter;
/// The human-readable doc-comment of this signature. Will be shown in the
/// UI but can be omitted.
@override final  Sealed17? documentation;
/// The label of this signature. Will be shown in the UI.
@override final  String label;
/// The parameters of this signature.
 final  List<ParameterInformation>? _parameters;
/// The parameters of this signature.
@override List<ParameterInformation>? get parameters {
  final value = _parameters;
  if (value == null) return null;
  if (_parameters is EqualUnmodifiableListView) return _parameters;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}


/// Create a copy of SignatureInformation
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SignatureInformationCopyWith<_SignatureInformation> get copyWith => __$SignatureInformationCopyWithImpl<_SignatureInformation>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SignatureInformationToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SignatureInformation&&(identical(other.activeParameter, activeParameter) || other.activeParameter == activeParameter)&&(identical(other.documentation, documentation) || other.documentation == documentation)&&(identical(other.label, label) || other.label == label)&&const DeepCollectionEquality().equals(other._parameters, _parameters));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,activeParameter,documentation,label,const DeepCollectionEquality().hash(_parameters));

@override
String toString() {
  return 'SignatureInformation(activeParameter: $activeParameter, documentation: $documentation, label: $label, parameters: $parameters)';
}


}

/// @nodoc
abstract mixin class _$SignatureInformationCopyWith<$Res> implements $SignatureInformationCopyWith<$Res> {
  factory _$SignatureInformationCopyWith(_SignatureInformation value, $Res Function(_SignatureInformation) _then) = __$SignatureInformationCopyWithImpl;
@override @useResult
$Res call({
 int? activeParameter, Sealed17? documentation, String label, List<ParameterInformation>? parameters
});




}
/// @nodoc
class __$SignatureInformationCopyWithImpl<$Res>
    implements _$SignatureInformationCopyWith<$Res> {
  __$SignatureInformationCopyWithImpl(this._self, this._then);

  final _SignatureInformation _self;
  final $Res Function(_SignatureInformation) _then;

/// Create a copy of SignatureInformation
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? activeParameter = freezed,Object? documentation = freezed,Object? label = null,Object? parameters = freezed,}) {
  return _then(_SignatureInformation(
activeParameter: freezed == activeParameter ? _self.activeParameter : activeParameter // ignore: cast_nullable_to_non_nullable
as int?,documentation: freezed == documentation ? _self.documentation : documentation // ignore: cast_nullable_to_non_nullable
as Sealed17?,label: null == label ? _self.label : label // ignore: cast_nullable_to_non_nullable
as String,parameters: freezed == parameters ? _self._parameters : parameters // ignore: cast_nullable_to_non_nullable
as List<ParameterInformation>?,
  ));
}


}


/// @nodoc
mixin _$SignatureHelpOptions {

/// List of characters that re-trigger signature help.
/// These trigger characters are only active when signature help is already
/// showing. All trigger characters are also counted as re-trigger
/// characters.
/// @since 3.15.0
 List<String>? get retriggerCharacters;/// List of characters that trigger signature help automatically.
 List<String>? get triggerCharacters; bool? get workDoneProgress;
/// Create a copy of SignatureHelpOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SignatureHelpOptionsCopyWith<SignatureHelpOptions> get copyWith => _$SignatureHelpOptionsCopyWithImpl<SignatureHelpOptions>(this as SignatureHelpOptions, _$identity);

  /// Serializes this SignatureHelpOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SignatureHelpOptions&&const DeepCollectionEquality().equals(other.retriggerCharacters, retriggerCharacters)&&const DeepCollectionEquality().equals(other.triggerCharacters, triggerCharacters)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(retriggerCharacters),const DeepCollectionEquality().hash(triggerCharacters),workDoneProgress);

@override
String toString() {
  return 'SignatureHelpOptions(retriggerCharacters: $retriggerCharacters, triggerCharacters: $triggerCharacters, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $SignatureHelpOptionsCopyWith<$Res>  {
  factory $SignatureHelpOptionsCopyWith(SignatureHelpOptions value, $Res Function(SignatureHelpOptions) _then) = _$SignatureHelpOptionsCopyWithImpl;
@useResult
$Res call({
 List<String>? retriggerCharacters, List<String>? triggerCharacters, bool? workDoneProgress
});




}
/// @nodoc
class _$SignatureHelpOptionsCopyWithImpl<$Res>
    implements $SignatureHelpOptionsCopyWith<$Res> {
  _$SignatureHelpOptionsCopyWithImpl(this._self, this._then);

  final SignatureHelpOptions _self;
  final $Res Function(SignatureHelpOptions) _then;

/// Create a copy of SignatureHelpOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? retriggerCharacters = freezed,Object? triggerCharacters = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
retriggerCharacters: freezed == retriggerCharacters ? _self.retriggerCharacters : retriggerCharacters // ignore: cast_nullable_to_non_nullable
as List<String>?,triggerCharacters: freezed == triggerCharacters ? _self.triggerCharacters : triggerCharacters // ignore: cast_nullable_to_non_nullable
as List<String>?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _SignatureHelpOptions implements SignatureHelpOptions {
  const _SignatureHelpOptions({final  List<String>? retriggerCharacters, final  List<String>? triggerCharacters, this.workDoneProgress}): _retriggerCharacters = retriggerCharacters,_triggerCharacters = triggerCharacters;
  factory _SignatureHelpOptions.fromJson(Map<String, dynamic> json) => _$SignatureHelpOptionsFromJson(json);

/// List of characters that re-trigger signature help.
/// These trigger characters are only active when signature help is already
/// showing. All trigger characters are also counted as re-trigger
/// characters.
/// @since 3.15.0
 final  List<String>? _retriggerCharacters;
/// List of characters that re-trigger signature help.
/// These trigger characters are only active when signature help is already
/// showing. All trigger characters are also counted as re-trigger
/// characters.
/// @since 3.15.0
@override List<String>? get retriggerCharacters {
  final value = _retriggerCharacters;
  if (value == null) return null;
  if (_retriggerCharacters is EqualUnmodifiableListView) return _retriggerCharacters;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

/// List of characters that trigger signature help automatically.
 final  List<String>? _triggerCharacters;
/// List of characters that trigger signature help automatically.
@override List<String>? get triggerCharacters {
  final value = _triggerCharacters;
  if (value == null) return null;
  if (_triggerCharacters is EqualUnmodifiableListView) return _triggerCharacters;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

@override final  bool? workDoneProgress;

/// Create a copy of SignatureHelpOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SignatureHelpOptionsCopyWith<_SignatureHelpOptions> get copyWith => __$SignatureHelpOptionsCopyWithImpl<_SignatureHelpOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SignatureHelpOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SignatureHelpOptions&&const DeepCollectionEquality().equals(other._retriggerCharacters, _retriggerCharacters)&&const DeepCollectionEquality().equals(other._triggerCharacters, _triggerCharacters)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_retriggerCharacters),const DeepCollectionEquality().hash(_triggerCharacters),workDoneProgress);

@override
String toString() {
  return 'SignatureHelpOptions(retriggerCharacters: $retriggerCharacters, triggerCharacters: $triggerCharacters, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$SignatureHelpOptionsCopyWith<$Res> implements $SignatureHelpOptionsCopyWith<$Res> {
  factory _$SignatureHelpOptionsCopyWith(_SignatureHelpOptions value, $Res Function(_SignatureHelpOptions) _then) = __$SignatureHelpOptionsCopyWithImpl;
@override @useResult
$Res call({
 List<String>? retriggerCharacters, List<String>? triggerCharacters, bool? workDoneProgress
});




}
/// @nodoc
class __$SignatureHelpOptionsCopyWithImpl<$Res>
    implements _$SignatureHelpOptionsCopyWith<$Res> {
  __$SignatureHelpOptionsCopyWithImpl(this._self, this._then);

  final _SignatureHelpOptions _self;
  final $Res Function(_SignatureHelpOptions) _then;

/// Create a copy of SignatureHelpOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? retriggerCharacters = freezed,Object? triggerCharacters = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_SignatureHelpOptions(
retriggerCharacters: freezed == retriggerCharacters ? _self._retriggerCharacters : retriggerCharacters // ignore: cast_nullable_to_non_nullable
as List<String>?,triggerCharacters: freezed == triggerCharacters ? _self._triggerCharacters : triggerCharacters // ignore: cast_nullable_to_non_nullable
as List<String>?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DefinitionOptions {

 bool? get workDoneProgress;
/// Create a copy of DefinitionOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DefinitionOptionsCopyWith<DefinitionOptions> get copyWith => _$DefinitionOptionsCopyWithImpl<DefinitionOptions>(this as DefinitionOptions, _$identity);

  /// Serializes this DefinitionOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DefinitionOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'DefinitionOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $DefinitionOptionsCopyWith<$Res>  {
  factory $DefinitionOptionsCopyWith(DefinitionOptions value, $Res Function(DefinitionOptions) _then) = _$DefinitionOptionsCopyWithImpl;
@useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class _$DefinitionOptionsCopyWithImpl<$Res>
    implements $DefinitionOptionsCopyWith<$Res> {
  _$DefinitionOptionsCopyWithImpl(this._self, this._then);

  final DefinitionOptions _self;
  final $Res Function(DefinitionOptions) _then;

/// Create a copy of DefinitionOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DefinitionOptions implements DefinitionOptions {
  const _DefinitionOptions({this.workDoneProgress});
  factory _DefinitionOptions.fromJson(Map<String, dynamic> json) => _$DefinitionOptionsFromJson(json);

@override final  bool? workDoneProgress;

/// Create a copy of DefinitionOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DefinitionOptionsCopyWith<_DefinitionOptions> get copyWith => __$DefinitionOptionsCopyWithImpl<_DefinitionOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DefinitionOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DefinitionOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'DefinitionOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$DefinitionOptionsCopyWith<$Res> implements $DefinitionOptionsCopyWith<$Res> {
  factory _$DefinitionOptionsCopyWith(_DefinitionOptions value, $Res Function(_DefinitionOptions) _then) = __$DefinitionOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class __$DefinitionOptionsCopyWithImpl<$Res>
    implements _$DefinitionOptionsCopyWith<$Res> {
  __$DefinitionOptionsCopyWithImpl(this._self, this._then);

  final _DefinitionOptions _self;
  final $Res Function(_DefinitionOptions) _then;

/// Create a copy of DefinitionOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_DefinitionOptions(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$ReferenceContext {

/// Include the declaration of the current symbol.
 bool get includeDeclaration;
/// Create a copy of ReferenceContext
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ReferenceContextCopyWith<ReferenceContext> get copyWith => _$ReferenceContextCopyWithImpl<ReferenceContext>(this as ReferenceContext, _$identity);

  /// Serializes this ReferenceContext to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ReferenceContext&&(identical(other.includeDeclaration, includeDeclaration) || other.includeDeclaration == includeDeclaration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,includeDeclaration);

@override
String toString() {
  return 'ReferenceContext(includeDeclaration: $includeDeclaration)';
}


}

/// @nodoc
abstract mixin class $ReferenceContextCopyWith<$Res>  {
  factory $ReferenceContextCopyWith(ReferenceContext value, $Res Function(ReferenceContext) _then) = _$ReferenceContextCopyWithImpl;
@useResult
$Res call({
 bool includeDeclaration
});




}
/// @nodoc
class _$ReferenceContextCopyWithImpl<$Res>
    implements $ReferenceContextCopyWith<$Res> {
  _$ReferenceContextCopyWithImpl(this._self, this._then);

  final ReferenceContext _self;
  final $Res Function(ReferenceContext) _then;

/// Create a copy of ReferenceContext
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? includeDeclaration = null,}) {
  return _then(_self.copyWith(
includeDeclaration: null == includeDeclaration ? _self.includeDeclaration : includeDeclaration // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _ReferenceContext implements ReferenceContext {
  const _ReferenceContext({required this.includeDeclaration});
  factory _ReferenceContext.fromJson(Map<String, dynamic> json) => _$ReferenceContextFromJson(json);

/// Include the declaration of the current symbol.
@override final  bool includeDeclaration;

/// Create a copy of ReferenceContext
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ReferenceContextCopyWith<_ReferenceContext> get copyWith => __$ReferenceContextCopyWithImpl<_ReferenceContext>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ReferenceContextToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ReferenceContext&&(identical(other.includeDeclaration, includeDeclaration) || other.includeDeclaration == includeDeclaration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,includeDeclaration);

@override
String toString() {
  return 'ReferenceContext(includeDeclaration: $includeDeclaration)';
}


}

/// @nodoc
abstract mixin class _$ReferenceContextCopyWith<$Res> implements $ReferenceContextCopyWith<$Res> {
  factory _$ReferenceContextCopyWith(_ReferenceContext value, $Res Function(_ReferenceContext) _then) = __$ReferenceContextCopyWithImpl;
@override @useResult
$Res call({
 bool includeDeclaration
});




}
/// @nodoc
class __$ReferenceContextCopyWithImpl<$Res>
    implements _$ReferenceContextCopyWith<$Res> {
  __$ReferenceContextCopyWithImpl(this._self, this._then);

  final _ReferenceContext _self;
  final $Res Function(_ReferenceContext) _then;

/// Create a copy of ReferenceContext
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? includeDeclaration = null,}) {
  return _then(_ReferenceContext(
includeDeclaration: null == includeDeclaration ? _self.includeDeclaration : includeDeclaration // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}


}


/// @nodoc
mixin _$ReferenceOptions {

 bool? get workDoneProgress;
/// Create a copy of ReferenceOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ReferenceOptionsCopyWith<ReferenceOptions> get copyWith => _$ReferenceOptionsCopyWithImpl<ReferenceOptions>(this as ReferenceOptions, _$identity);

  /// Serializes this ReferenceOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ReferenceOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'ReferenceOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $ReferenceOptionsCopyWith<$Res>  {
  factory $ReferenceOptionsCopyWith(ReferenceOptions value, $Res Function(ReferenceOptions) _then) = _$ReferenceOptionsCopyWithImpl;
@useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class _$ReferenceOptionsCopyWithImpl<$Res>
    implements $ReferenceOptionsCopyWith<$Res> {
  _$ReferenceOptionsCopyWithImpl(this._self, this._then);

  final ReferenceOptions _self;
  final $Res Function(ReferenceOptions) _then;

/// Create a copy of ReferenceOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _ReferenceOptions implements ReferenceOptions {
  const _ReferenceOptions({this.workDoneProgress});
  factory _ReferenceOptions.fromJson(Map<String, dynamic> json) => _$ReferenceOptionsFromJson(json);

@override final  bool? workDoneProgress;

/// Create a copy of ReferenceOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ReferenceOptionsCopyWith<_ReferenceOptions> get copyWith => __$ReferenceOptionsCopyWithImpl<_ReferenceOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ReferenceOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ReferenceOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'ReferenceOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$ReferenceOptionsCopyWith<$Res> implements $ReferenceOptionsCopyWith<$Res> {
  factory _$ReferenceOptionsCopyWith(_ReferenceOptions value, $Res Function(_ReferenceOptions) _then) = __$ReferenceOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class __$ReferenceOptionsCopyWithImpl<$Res>
    implements _$ReferenceOptionsCopyWith<$Res> {
  __$ReferenceOptionsCopyWithImpl(this._self, this._then);

  final _ReferenceOptions _self;
  final $Res Function(_ReferenceOptions) _then;

/// Create a copy of ReferenceOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_ReferenceOptions(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DocumentHighlightOptions {

 bool? get workDoneProgress;
/// Create a copy of DocumentHighlightOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentHighlightOptionsCopyWith<DocumentHighlightOptions> get copyWith => _$DocumentHighlightOptionsCopyWithImpl<DocumentHighlightOptions>(this as DocumentHighlightOptions, _$identity);

  /// Serializes this DocumentHighlightOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentHighlightOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'DocumentHighlightOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $DocumentHighlightOptionsCopyWith<$Res>  {
  factory $DocumentHighlightOptionsCopyWith(DocumentHighlightOptions value, $Res Function(DocumentHighlightOptions) _then) = _$DocumentHighlightOptionsCopyWithImpl;
@useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class _$DocumentHighlightOptionsCopyWithImpl<$Res>
    implements $DocumentHighlightOptionsCopyWith<$Res> {
  _$DocumentHighlightOptionsCopyWithImpl(this._self, this._then);

  final DocumentHighlightOptions _self;
  final $Res Function(DocumentHighlightOptions) _then;

/// Create a copy of DocumentHighlightOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DocumentHighlightOptions implements DocumentHighlightOptions {
  const _DocumentHighlightOptions({this.workDoneProgress});
  factory _DocumentHighlightOptions.fromJson(Map<String, dynamic> json) => _$DocumentHighlightOptionsFromJson(json);

@override final  bool? workDoneProgress;

/// Create a copy of DocumentHighlightOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentHighlightOptionsCopyWith<_DocumentHighlightOptions> get copyWith => __$DocumentHighlightOptionsCopyWithImpl<_DocumentHighlightOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentHighlightOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentHighlightOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'DocumentHighlightOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$DocumentHighlightOptionsCopyWith<$Res> implements $DocumentHighlightOptionsCopyWith<$Res> {
  factory _$DocumentHighlightOptionsCopyWith(_DocumentHighlightOptions value, $Res Function(_DocumentHighlightOptions) _then) = __$DocumentHighlightOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class __$DocumentHighlightOptionsCopyWithImpl<$Res>
    implements _$DocumentHighlightOptionsCopyWith<$Res> {
  __$DocumentHighlightOptionsCopyWithImpl(this._self, this._then);

  final _DocumentHighlightOptions _self;
  final $Res Function(_DocumentHighlightOptions) _then;

/// Create a copy of DocumentHighlightOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_DocumentHighlightOptions(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$BaseSymbolInformation {

/// The name of the symbol containing this symbol. This information is for
/// user interface purposes (e.g. to render a qualifier in the user
/// interface if necessary). It can't be used to re-infer a hierarchy for
/// the document symbols.
 String? get containerName;/// The kind of this symbol.
 SymbolKind get kind;/// The name of this symbol.
 String get name;/// Tags for this symbol.
/// @since 3.16.0
 List<SymbolTag>? get tags;
/// Create a copy of BaseSymbolInformation
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$BaseSymbolInformationCopyWith<BaseSymbolInformation> get copyWith => _$BaseSymbolInformationCopyWithImpl<BaseSymbolInformation>(this as BaseSymbolInformation, _$identity);

  /// Serializes this BaseSymbolInformation to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is BaseSymbolInformation&&(identical(other.containerName, containerName) || other.containerName == containerName)&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.name, name) || other.name == name)&&const DeepCollectionEquality().equals(other.tags, tags));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,containerName,kind,name,const DeepCollectionEquality().hash(tags));

@override
String toString() {
  return 'BaseSymbolInformation(containerName: $containerName, kind: $kind, name: $name, tags: $tags)';
}


}

/// @nodoc
abstract mixin class $BaseSymbolInformationCopyWith<$Res>  {
  factory $BaseSymbolInformationCopyWith(BaseSymbolInformation value, $Res Function(BaseSymbolInformation) _then) = _$BaseSymbolInformationCopyWithImpl;
@useResult
$Res call({
 String? containerName, SymbolKind kind, String name, List<SymbolTag>? tags
});




}
/// @nodoc
class _$BaseSymbolInformationCopyWithImpl<$Res>
    implements $BaseSymbolInformationCopyWith<$Res> {
  _$BaseSymbolInformationCopyWithImpl(this._self, this._then);

  final BaseSymbolInformation _self;
  final $Res Function(BaseSymbolInformation) _then;

/// Create a copy of BaseSymbolInformation
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? containerName = freezed,Object? kind = null,Object? name = null,Object? tags = freezed,}) {
  return _then(_self.copyWith(
containerName: freezed == containerName ? _self.containerName : containerName // ignore: cast_nullable_to_non_nullable
as String?,kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as SymbolKind,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,tags: freezed == tags ? _self.tags : tags // ignore: cast_nullable_to_non_nullable
as List<SymbolTag>?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _BaseSymbolInformation implements BaseSymbolInformation {
  const _BaseSymbolInformation({this.containerName, required this.kind, required this.name, final  List<SymbolTag>? tags}): _tags = tags;
  factory _BaseSymbolInformation.fromJson(Map<String, dynamic> json) => _$BaseSymbolInformationFromJson(json);

/// The name of the symbol containing this symbol. This information is for
/// user interface purposes (e.g. to render a qualifier in the user
/// interface if necessary). It can't be used to re-infer a hierarchy for
/// the document symbols.
@override final  String? containerName;
/// The kind of this symbol.
@override final  SymbolKind kind;
/// The name of this symbol.
@override final  String name;
/// Tags for this symbol.
/// @since 3.16.0
 final  List<SymbolTag>? _tags;
/// Tags for this symbol.
/// @since 3.16.0
@override List<SymbolTag>? get tags {
  final value = _tags;
  if (value == null) return null;
  if (_tags is EqualUnmodifiableListView) return _tags;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}


/// Create a copy of BaseSymbolInformation
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$BaseSymbolInformationCopyWith<_BaseSymbolInformation> get copyWith => __$BaseSymbolInformationCopyWithImpl<_BaseSymbolInformation>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$BaseSymbolInformationToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _BaseSymbolInformation&&(identical(other.containerName, containerName) || other.containerName == containerName)&&(identical(other.kind, kind) || other.kind == kind)&&(identical(other.name, name) || other.name == name)&&const DeepCollectionEquality().equals(other._tags, _tags));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,containerName,kind,name,const DeepCollectionEquality().hash(_tags));

@override
String toString() {
  return 'BaseSymbolInformation(containerName: $containerName, kind: $kind, name: $name, tags: $tags)';
}


}

/// @nodoc
abstract mixin class _$BaseSymbolInformationCopyWith<$Res> implements $BaseSymbolInformationCopyWith<$Res> {
  factory _$BaseSymbolInformationCopyWith(_BaseSymbolInformation value, $Res Function(_BaseSymbolInformation) _then) = __$BaseSymbolInformationCopyWithImpl;
@override @useResult
$Res call({
 String? containerName, SymbolKind kind, String name, List<SymbolTag>? tags
});




}
/// @nodoc
class __$BaseSymbolInformationCopyWithImpl<$Res>
    implements _$BaseSymbolInformationCopyWith<$Res> {
  __$BaseSymbolInformationCopyWithImpl(this._self, this._then);

  final _BaseSymbolInformation _self;
  final $Res Function(_BaseSymbolInformation) _then;

/// Create a copy of BaseSymbolInformation
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? containerName = freezed,Object? kind = null,Object? name = null,Object? tags = freezed,}) {
  return _then(_BaseSymbolInformation(
containerName: freezed == containerName ? _self.containerName : containerName // ignore: cast_nullable_to_non_nullable
as String?,kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as SymbolKind,name: null == name ? _self.name : name // ignore: cast_nullable_to_non_nullable
as String,tags: freezed == tags ? _self._tags : tags // ignore: cast_nullable_to_non_nullable
as List<SymbolTag>?,
  ));
}


}


/// @nodoc
mixin _$DocumentSymbolOptions {

/// A human-readable string that is shown when multiple outlines trees are
/// shown for the same document.
/// @since 3.16.0
 String? get label; bool? get workDoneProgress;
/// Create a copy of DocumentSymbolOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentSymbolOptionsCopyWith<DocumentSymbolOptions> get copyWith => _$DocumentSymbolOptionsCopyWithImpl<DocumentSymbolOptions>(this as DocumentSymbolOptions, _$identity);

  /// Serializes this DocumentSymbolOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentSymbolOptions&&(identical(other.label, label) || other.label == label)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,label,workDoneProgress);

@override
String toString() {
  return 'DocumentSymbolOptions(label: $label, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $DocumentSymbolOptionsCopyWith<$Res>  {
  factory $DocumentSymbolOptionsCopyWith(DocumentSymbolOptions value, $Res Function(DocumentSymbolOptions) _then) = _$DocumentSymbolOptionsCopyWithImpl;
@useResult
$Res call({
 String? label, bool? workDoneProgress
});




}
/// @nodoc
class _$DocumentSymbolOptionsCopyWithImpl<$Res>
    implements $DocumentSymbolOptionsCopyWith<$Res> {
  _$DocumentSymbolOptionsCopyWithImpl(this._self, this._then);

  final DocumentSymbolOptions _self;
  final $Res Function(DocumentSymbolOptions) _then;

/// Create a copy of DocumentSymbolOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? label = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
label: freezed == label ? _self.label : label // ignore: cast_nullable_to_non_nullable
as String?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DocumentSymbolOptions implements DocumentSymbolOptions {
  const _DocumentSymbolOptions({this.label, this.workDoneProgress});
  factory _DocumentSymbolOptions.fromJson(Map<String, dynamic> json) => _$DocumentSymbolOptionsFromJson(json);

/// A human-readable string that is shown when multiple outlines trees are
/// shown for the same document.
/// @since 3.16.0
@override final  String? label;
@override final  bool? workDoneProgress;

/// Create a copy of DocumentSymbolOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentSymbolOptionsCopyWith<_DocumentSymbolOptions> get copyWith => __$DocumentSymbolOptionsCopyWithImpl<_DocumentSymbolOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentSymbolOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentSymbolOptions&&(identical(other.label, label) || other.label == label)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,label,workDoneProgress);

@override
String toString() {
  return 'DocumentSymbolOptions(label: $label, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$DocumentSymbolOptionsCopyWith<$Res> implements $DocumentSymbolOptionsCopyWith<$Res> {
  factory _$DocumentSymbolOptionsCopyWith(_DocumentSymbolOptions value, $Res Function(_DocumentSymbolOptions) _then) = __$DocumentSymbolOptionsCopyWithImpl;
@override @useResult
$Res call({
 String? label, bool? workDoneProgress
});




}
/// @nodoc
class __$DocumentSymbolOptionsCopyWithImpl<$Res>
    implements _$DocumentSymbolOptionsCopyWith<$Res> {
  __$DocumentSymbolOptionsCopyWithImpl(this._self, this._then);

  final _DocumentSymbolOptions _self;
  final $Res Function(_DocumentSymbolOptions) _then;

/// Create a copy of DocumentSymbolOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? label = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_DocumentSymbolOptions(
label: freezed == label ? _self.label : label // ignore: cast_nullable_to_non_nullable
as String?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$CodeActionContext {

/// An array of diagnostics known on the client side overlapping the range
/// provided to the `textDocument/codeAction` request. They are provided so
/// that the server knows which errors are currently presented to the user
/// for the given range. There is no guarantee that these accurately
/// reflect the error state of the resource. The primary parameter to
/// compute code actions is the provided range.
 List<Diagnostic> get diagnostics;/// Requested kind of actions to return.
/// Actions not of this kind are filtered out by the client before being
/// shown. So servers can omit computing them.
 List<CodeActionKind>? get only;/// The reason why code actions were requested.
/// @since 3.17.0
 CodeActionTriggerKind? get triggerKind;
/// Create a copy of CodeActionContext
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CodeActionContextCopyWith<CodeActionContext> get copyWith => _$CodeActionContextCopyWithImpl<CodeActionContext>(this as CodeActionContext, _$identity);

  /// Serializes this CodeActionContext to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CodeActionContext&&const DeepCollectionEquality().equals(other.diagnostics, diagnostics)&&const DeepCollectionEquality().equals(other.only, only)&&(identical(other.triggerKind, triggerKind) || other.triggerKind == triggerKind));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(diagnostics),const DeepCollectionEquality().hash(only),triggerKind);

@override
String toString() {
  return 'CodeActionContext(diagnostics: $diagnostics, only: $only, triggerKind: $triggerKind)';
}


}

/// @nodoc
abstract mixin class $CodeActionContextCopyWith<$Res>  {
  factory $CodeActionContextCopyWith(CodeActionContext value, $Res Function(CodeActionContext) _then) = _$CodeActionContextCopyWithImpl;
@useResult
$Res call({
 List<Diagnostic> diagnostics, List<CodeActionKind>? only, CodeActionTriggerKind? triggerKind
});




}
/// @nodoc
class _$CodeActionContextCopyWithImpl<$Res>
    implements $CodeActionContextCopyWith<$Res> {
  _$CodeActionContextCopyWithImpl(this._self, this._then);

  final CodeActionContext _self;
  final $Res Function(CodeActionContext) _then;

/// Create a copy of CodeActionContext
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? diagnostics = null,Object? only = freezed,Object? triggerKind = freezed,}) {
  return _then(_self.copyWith(
diagnostics: null == diagnostics ? _self.diagnostics : diagnostics // ignore: cast_nullable_to_non_nullable
as List<Diagnostic>,only: freezed == only ? _self.only : only // ignore: cast_nullable_to_non_nullable
as List<CodeActionKind>?,triggerKind: freezed == triggerKind ? _self.triggerKind : triggerKind // ignore: cast_nullable_to_non_nullable
as CodeActionTriggerKind?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _CodeActionContext implements CodeActionContext {
  const _CodeActionContext({required final  List<Diagnostic> diagnostics, final  List<CodeActionKind>? only, this.triggerKind}): _diagnostics = diagnostics,_only = only;
  factory _CodeActionContext.fromJson(Map<String, dynamic> json) => _$CodeActionContextFromJson(json);

/// An array of diagnostics known on the client side overlapping the range
/// provided to the `textDocument/codeAction` request. They are provided so
/// that the server knows which errors are currently presented to the user
/// for the given range. There is no guarantee that these accurately
/// reflect the error state of the resource. The primary parameter to
/// compute code actions is the provided range.
 final  List<Diagnostic> _diagnostics;
/// An array of diagnostics known on the client side overlapping the range
/// provided to the `textDocument/codeAction` request. They are provided so
/// that the server knows which errors are currently presented to the user
/// for the given range. There is no guarantee that these accurately
/// reflect the error state of the resource. The primary parameter to
/// compute code actions is the provided range.
@override List<Diagnostic> get diagnostics {
  if (_diagnostics is EqualUnmodifiableListView) return _diagnostics;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_diagnostics);
}

/// Requested kind of actions to return.
/// Actions not of this kind are filtered out by the client before being
/// shown. So servers can omit computing them.
 final  List<CodeActionKind>? _only;
/// Requested kind of actions to return.
/// Actions not of this kind are filtered out by the client before being
/// shown. So servers can omit computing them.
@override List<CodeActionKind>? get only {
  final value = _only;
  if (value == null) return null;
  if (_only is EqualUnmodifiableListView) return _only;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

/// The reason why code actions were requested.
/// @since 3.17.0
@override final  CodeActionTriggerKind? triggerKind;

/// Create a copy of CodeActionContext
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CodeActionContextCopyWith<_CodeActionContext> get copyWith => __$CodeActionContextCopyWithImpl<_CodeActionContext>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CodeActionContextToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CodeActionContext&&const DeepCollectionEquality().equals(other._diagnostics, _diagnostics)&&const DeepCollectionEquality().equals(other._only, _only)&&(identical(other.triggerKind, triggerKind) || other.triggerKind == triggerKind));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_diagnostics),const DeepCollectionEquality().hash(_only),triggerKind);

@override
String toString() {
  return 'CodeActionContext(diagnostics: $diagnostics, only: $only, triggerKind: $triggerKind)';
}


}

/// @nodoc
abstract mixin class _$CodeActionContextCopyWith<$Res> implements $CodeActionContextCopyWith<$Res> {
  factory _$CodeActionContextCopyWith(_CodeActionContext value, $Res Function(_CodeActionContext) _then) = __$CodeActionContextCopyWithImpl;
@override @useResult
$Res call({
 List<Diagnostic> diagnostics, List<CodeActionKind>? only, CodeActionTriggerKind? triggerKind
});




}
/// @nodoc
class __$CodeActionContextCopyWithImpl<$Res>
    implements _$CodeActionContextCopyWith<$Res> {
  __$CodeActionContextCopyWithImpl(this._self, this._then);

  final _CodeActionContext _self;
  final $Res Function(_CodeActionContext) _then;

/// Create a copy of CodeActionContext
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? diagnostics = null,Object? only = freezed,Object? triggerKind = freezed,}) {
  return _then(_CodeActionContext(
diagnostics: null == diagnostics ? _self._diagnostics : diagnostics // ignore: cast_nullable_to_non_nullable
as List<Diagnostic>,only: freezed == only ? _self._only : only // ignore: cast_nullable_to_non_nullable
as List<CodeActionKind>?,triggerKind: freezed == triggerKind ? _self.triggerKind : triggerKind // ignore: cast_nullable_to_non_nullable
as CodeActionTriggerKind?,
  ));
}


}


/// @nodoc
mixin _$CodeActionOptions {

/// CodeActionKinds that this server may return.
/// The list of kinds may be generic, such as `CodeActionKind.Refactor`, or
/// the server may list out every specific kind they provide.
 List<CodeActionKind>? get codeActionKinds;/// The server provides support to resolve additional information for a
/// code action.
/// @since 3.16.0
 bool? get resolveProvider; bool? get workDoneProgress;
/// Create a copy of CodeActionOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CodeActionOptionsCopyWith<CodeActionOptions> get copyWith => _$CodeActionOptionsCopyWithImpl<CodeActionOptions>(this as CodeActionOptions, _$identity);

  /// Serializes this CodeActionOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CodeActionOptions&&const DeepCollectionEquality().equals(other.codeActionKinds, codeActionKinds)&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(codeActionKinds),resolveProvider,workDoneProgress);

@override
String toString() {
  return 'CodeActionOptions(codeActionKinds: $codeActionKinds, resolveProvider: $resolveProvider, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $CodeActionOptionsCopyWith<$Res>  {
  factory $CodeActionOptionsCopyWith(CodeActionOptions value, $Res Function(CodeActionOptions) _then) = _$CodeActionOptionsCopyWithImpl;
@useResult
$Res call({
 List<CodeActionKind>? codeActionKinds, bool? resolveProvider, bool? workDoneProgress
});




}
/// @nodoc
class _$CodeActionOptionsCopyWithImpl<$Res>
    implements $CodeActionOptionsCopyWith<$Res> {
  _$CodeActionOptionsCopyWithImpl(this._self, this._then);

  final CodeActionOptions _self;
  final $Res Function(CodeActionOptions) _then;

/// Create a copy of CodeActionOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? codeActionKinds = freezed,Object? resolveProvider = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
codeActionKinds: freezed == codeActionKinds ? _self.codeActionKinds : codeActionKinds // ignore: cast_nullable_to_non_nullable
as List<CodeActionKind>?,resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _CodeActionOptions implements CodeActionOptions {
  const _CodeActionOptions({final  List<CodeActionKind>? codeActionKinds, this.resolveProvider, this.workDoneProgress}): _codeActionKinds = codeActionKinds;
  factory _CodeActionOptions.fromJson(Map<String, dynamic> json) => _$CodeActionOptionsFromJson(json);

/// CodeActionKinds that this server may return.
/// The list of kinds may be generic, such as `CodeActionKind.Refactor`, or
/// the server may list out every specific kind they provide.
 final  List<CodeActionKind>? _codeActionKinds;
/// CodeActionKinds that this server may return.
/// The list of kinds may be generic, such as `CodeActionKind.Refactor`, or
/// the server may list out every specific kind they provide.
@override List<CodeActionKind>? get codeActionKinds {
  final value = _codeActionKinds;
  if (value == null) return null;
  if (_codeActionKinds is EqualUnmodifiableListView) return _codeActionKinds;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

/// The server provides support to resolve additional information for a
/// code action.
/// @since 3.16.0
@override final  bool? resolveProvider;
@override final  bool? workDoneProgress;

/// Create a copy of CodeActionOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CodeActionOptionsCopyWith<_CodeActionOptions> get copyWith => __$CodeActionOptionsCopyWithImpl<_CodeActionOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CodeActionOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CodeActionOptions&&const DeepCollectionEquality().equals(other._codeActionKinds, _codeActionKinds)&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_codeActionKinds),resolveProvider,workDoneProgress);

@override
String toString() {
  return 'CodeActionOptions(codeActionKinds: $codeActionKinds, resolveProvider: $resolveProvider, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$CodeActionOptionsCopyWith<$Res> implements $CodeActionOptionsCopyWith<$Res> {
  factory _$CodeActionOptionsCopyWith(_CodeActionOptions value, $Res Function(_CodeActionOptions) _then) = __$CodeActionOptionsCopyWithImpl;
@override @useResult
$Res call({
 List<CodeActionKind>? codeActionKinds, bool? resolveProvider, bool? workDoneProgress
});




}
/// @nodoc
class __$CodeActionOptionsCopyWithImpl<$Res>
    implements _$CodeActionOptionsCopyWith<$Res> {
  __$CodeActionOptionsCopyWithImpl(this._self, this._then);

  final _CodeActionOptions _self;
  final $Res Function(_CodeActionOptions) _then;

/// Create a copy of CodeActionOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? codeActionKinds = freezed,Object? resolveProvider = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_CodeActionOptions(
codeActionKinds: freezed == codeActionKinds ? _self._codeActionKinds : codeActionKinds // ignore: cast_nullable_to_non_nullable
as List<CodeActionKind>?,resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$WorkspaceSymbolOptions {

/// The server provides support to resolve additional information for a
/// workspace symbol.
/// @since 3.17.0
 bool? get resolveProvider; bool? get workDoneProgress;
/// Create a copy of WorkspaceSymbolOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkspaceSymbolOptionsCopyWith<WorkspaceSymbolOptions> get copyWith => _$WorkspaceSymbolOptionsCopyWithImpl<WorkspaceSymbolOptions>(this as WorkspaceSymbolOptions, _$identity);

  /// Serializes this WorkspaceSymbolOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkspaceSymbolOptions&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,resolveProvider,workDoneProgress);

@override
String toString() {
  return 'WorkspaceSymbolOptions(resolveProvider: $resolveProvider, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $WorkspaceSymbolOptionsCopyWith<$Res>  {
  factory $WorkspaceSymbolOptionsCopyWith(WorkspaceSymbolOptions value, $Res Function(WorkspaceSymbolOptions) _then) = _$WorkspaceSymbolOptionsCopyWithImpl;
@useResult
$Res call({
 bool? resolveProvider, bool? workDoneProgress
});




}
/// @nodoc
class _$WorkspaceSymbolOptionsCopyWithImpl<$Res>
    implements $WorkspaceSymbolOptionsCopyWith<$Res> {
  _$WorkspaceSymbolOptionsCopyWithImpl(this._self, this._then);

  final WorkspaceSymbolOptions _self;
  final $Res Function(WorkspaceSymbolOptions) _then;

/// Create a copy of WorkspaceSymbolOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? resolveProvider = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _WorkspaceSymbolOptions implements WorkspaceSymbolOptions {
  const _WorkspaceSymbolOptions({this.resolveProvider, this.workDoneProgress});
  factory _WorkspaceSymbolOptions.fromJson(Map<String, dynamic> json) => _$WorkspaceSymbolOptionsFromJson(json);

/// The server provides support to resolve additional information for a
/// workspace symbol.
/// @since 3.17.0
@override final  bool? resolveProvider;
@override final  bool? workDoneProgress;

/// Create a copy of WorkspaceSymbolOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkspaceSymbolOptionsCopyWith<_WorkspaceSymbolOptions> get copyWith => __$WorkspaceSymbolOptionsCopyWithImpl<_WorkspaceSymbolOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkspaceSymbolOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkspaceSymbolOptions&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,resolveProvider,workDoneProgress);

@override
String toString() {
  return 'WorkspaceSymbolOptions(resolveProvider: $resolveProvider, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$WorkspaceSymbolOptionsCopyWith<$Res> implements $WorkspaceSymbolOptionsCopyWith<$Res> {
  factory _$WorkspaceSymbolOptionsCopyWith(_WorkspaceSymbolOptions value, $Res Function(_WorkspaceSymbolOptions) _then) = __$WorkspaceSymbolOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? resolveProvider, bool? workDoneProgress
});




}
/// @nodoc
class __$WorkspaceSymbolOptionsCopyWithImpl<$Res>
    implements _$WorkspaceSymbolOptionsCopyWith<$Res> {
  __$WorkspaceSymbolOptionsCopyWithImpl(this._self, this._then);

  final _WorkspaceSymbolOptions _self;
  final $Res Function(_WorkspaceSymbolOptions) _then;

/// Create a copy of WorkspaceSymbolOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? resolveProvider = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_WorkspaceSymbolOptions(
resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$CodeLensOptions {

/// Code lens has a resolve provider as well.
 bool? get resolveProvider; bool? get workDoneProgress;
/// Create a copy of CodeLensOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CodeLensOptionsCopyWith<CodeLensOptions> get copyWith => _$CodeLensOptionsCopyWithImpl<CodeLensOptions>(this as CodeLensOptions, _$identity);

  /// Serializes this CodeLensOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CodeLensOptions&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,resolveProvider,workDoneProgress);

@override
String toString() {
  return 'CodeLensOptions(resolveProvider: $resolveProvider, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $CodeLensOptionsCopyWith<$Res>  {
  factory $CodeLensOptionsCopyWith(CodeLensOptions value, $Res Function(CodeLensOptions) _then) = _$CodeLensOptionsCopyWithImpl;
@useResult
$Res call({
 bool? resolveProvider, bool? workDoneProgress
});




}
/// @nodoc
class _$CodeLensOptionsCopyWithImpl<$Res>
    implements $CodeLensOptionsCopyWith<$Res> {
  _$CodeLensOptionsCopyWithImpl(this._self, this._then);

  final CodeLensOptions _self;
  final $Res Function(CodeLensOptions) _then;

/// Create a copy of CodeLensOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? resolveProvider = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _CodeLensOptions implements CodeLensOptions {
  const _CodeLensOptions({this.resolveProvider, this.workDoneProgress});
  factory _CodeLensOptions.fromJson(Map<String, dynamic> json) => _$CodeLensOptionsFromJson(json);

/// Code lens has a resolve provider as well.
@override final  bool? resolveProvider;
@override final  bool? workDoneProgress;

/// Create a copy of CodeLensOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CodeLensOptionsCopyWith<_CodeLensOptions> get copyWith => __$CodeLensOptionsCopyWithImpl<_CodeLensOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CodeLensOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CodeLensOptions&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,resolveProvider,workDoneProgress);

@override
String toString() {
  return 'CodeLensOptions(resolveProvider: $resolveProvider, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$CodeLensOptionsCopyWith<$Res> implements $CodeLensOptionsCopyWith<$Res> {
  factory _$CodeLensOptionsCopyWith(_CodeLensOptions value, $Res Function(_CodeLensOptions) _then) = __$CodeLensOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? resolveProvider, bool? workDoneProgress
});




}
/// @nodoc
class __$CodeLensOptionsCopyWithImpl<$Res>
    implements _$CodeLensOptionsCopyWith<$Res> {
  __$CodeLensOptionsCopyWithImpl(this._self, this._then);

  final _CodeLensOptions _self;
  final $Res Function(_CodeLensOptions) _then;

/// Create a copy of CodeLensOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? resolveProvider = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_CodeLensOptions(
resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DocumentLinkOptions {

/// Document links have a resolve provider as well.
 bool? get resolveProvider; bool? get workDoneProgress;
/// Create a copy of DocumentLinkOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentLinkOptionsCopyWith<DocumentLinkOptions> get copyWith => _$DocumentLinkOptionsCopyWithImpl<DocumentLinkOptions>(this as DocumentLinkOptions, _$identity);

  /// Serializes this DocumentLinkOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentLinkOptions&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,resolveProvider,workDoneProgress);

@override
String toString() {
  return 'DocumentLinkOptions(resolveProvider: $resolveProvider, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $DocumentLinkOptionsCopyWith<$Res>  {
  factory $DocumentLinkOptionsCopyWith(DocumentLinkOptions value, $Res Function(DocumentLinkOptions) _then) = _$DocumentLinkOptionsCopyWithImpl;
@useResult
$Res call({
 bool? resolveProvider, bool? workDoneProgress
});




}
/// @nodoc
class _$DocumentLinkOptionsCopyWithImpl<$Res>
    implements $DocumentLinkOptionsCopyWith<$Res> {
  _$DocumentLinkOptionsCopyWithImpl(this._self, this._then);

  final DocumentLinkOptions _self;
  final $Res Function(DocumentLinkOptions) _then;

/// Create a copy of DocumentLinkOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? resolveProvider = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DocumentLinkOptions implements DocumentLinkOptions {
  const _DocumentLinkOptions({this.resolveProvider, this.workDoneProgress});
  factory _DocumentLinkOptions.fromJson(Map<String, dynamic> json) => _$DocumentLinkOptionsFromJson(json);

/// Document links have a resolve provider as well.
@override final  bool? resolveProvider;
@override final  bool? workDoneProgress;

/// Create a copy of DocumentLinkOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentLinkOptionsCopyWith<_DocumentLinkOptions> get copyWith => __$DocumentLinkOptionsCopyWithImpl<_DocumentLinkOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentLinkOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentLinkOptions&&(identical(other.resolveProvider, resolveProvider) || other.resolveProvider == resolveProvider)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,resolveProvider,workDoneProgress);

@override
String toString() {
  return 'DocumentLinkOptions(resolveProvider: $resolveProvider, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$DocumentLinkOptionsCopyWith<$Res> implements $DocumentLinkOptionsCopyWith<$Res> {
  factory _$DocumentLinkOptionsCopyWith(_DocumentLinkOptions value, $Res Function(_DocumentLinkOptions) _then) = __$DocumentLinkOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? resolveProvider, bool? workDoneProgress
});




}
/// @nodoc
class __$DocumentLinkOptionsCopyWithImpl<$Res>
    implements _$DocumentLinkOptionsCopyWith<$Res> {
  __$DocumentLinkOptionsCopyWithImpl(this._self, this._then);

  final _DocumentLinkOptions _self;
  final $Res Function(_DocumentLinkOptions) _then;

/// Create a copy of DocumentLinkOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? resolveProvider = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_DocumentLinkOptions(
resolveProvider: freezed == resolveProvider ? _self.resolveProvider : resolveProvider // ignore: cast_nullable_to_non_nullable
as bool?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$FormattingOptions {

/// Insert a newline character at the end of the file if one does not exist.
/// @since 3.15.0
 bool? get insertFinalNewline;/// Prefer spaces over tabs.
 bool get insertSpaces;/// Size of a tab in spaces.
 int get tabSize;/// Trim all newlines after the final newline at the end of the file.
/// @since 3.15.0
 bool? get trimFinalNewlines;/// Trim trailing whitespace on a line.
/// @since 3.15.0
 bool? get trimTrailingWhitespace;
/// Create a copy of FormattingOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FormattingOptionsCopyWith<FormattingOptions> get copyWith => _$FormattingOptionsCopyWithImpl<FormattingOptions>(this as FormattingOptions, _$identity);

  /// Serializes this FormattingOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FormattingOptions&&(identical(other.insertFinalNewline, insertFinalNewline) || other.insertFinalNewline == insertFinalNewline)&&(identical(other.insertSpaces, insertSpaces) || other.insertSpaces == insertSpaces)&&(identical(other.tabSize, tabSize) || other.tabSize == tabSize)&&(identical(other.trimFinalNewlines, trimFinalNewlines) || other.trimFinalNewlines == trimFinalNewlines)&&(identical(other.trimTrailingWhitespace, trimTrailingWhitespace) || other.trimTrailingWhitespace == trimTrailingWhitespace));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,insertFinalNewline,insertSpaces,tabSize,trimFinalNewlines,trimTrailingWhitespace);

@override
String toString() {
  return 'FormattingOptions(insertFinalNewline: $insertFinalNewline, insertSpaces: $insertSpaces, tabSize: $tabSize, trimFinalNewlines: $trimFinalNewlines, trimTrailingWhitespace: $trimTrailingWhitespace)';
}


}

/// @nodoc
abstract mixin class $FormattingOptionsCopyWith<$Res>  {
  factory $FormattingOptionsCopyWith(FormattingOptions value, $Res Function(FormattingOptions) _then) = _$FormattingOptionsCopyWithImpl;
@useResult
$Res call({
 bool? insertFinalNewline, bool insertSpaces, int tabSize, bool? trimFinalNewlines, bool? trimTrailingWhitespace
});




}
/// @nodoc
class _$FormattingOptionsCopyWithImpl<$Res>
    implements $FormattingOptionsCopyWith<$Res> {
  _$FormattingOptionsCopyWithImpl(this._self, this._then);

  final FormattingOptions _self;
  final $Res Function(FormattingOptions) _then;

/// Create a copy of FormattingOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? insertFinalNewline = freezed,Object? insertSpaces = null,Object? tabSize = null,Object? trimFinalNewlines = freezed,Object? trimTrailingWhitespace = freezed,}) {
  return _then(_self.copyWith(
insertFinalNewline: freezed == insertFinalNewline ? _self.insertFinalNewline : insertFinalNewline // ignore: cast_nullable_to_non_nullable
as bool?,insertSpaces: null == insertSpaces ? _self.insertSpaces : insertSpaces // ignore: cast_nullable_to_non_nullable
as bool,tabSize: null == tabSize ? _self.tabSize : tabSize // ignore: cast_nullable_to_non_nullable
as int,trimFinalNewlines: freezed == trimFinalNewlines ? _self.trimFinalNewlines : trimFinalNewlines // ignore: cast_nullable_to_non_nullable
as bool?,trimTrailingWhitespace: freezed == trimTrailingWhitespace ? _self.trimTrailingWhitespace : trimTrailingWhitespace // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _FormattingOptions implements FormattingOptions {
  const _FormattingOptions({this.insertFinalNewline, required this.insertSpaces, required this.tabSize, this.trimFinalNewlines, this.trimTrailingWhitespace});
  factory _FormattingOptions.fromJson(Map<String, dynamic> json) => _$FormattingOptionsFromJson(json);

/// Insert a newline character at the end of the file if one does not exist.
/// @since 3.15.0
@override final  bool? insertFinalNewline;
/// Prefer spaces over tabs.
@override final  bool insertSpaces;
/// Size of a tab in spaces.
@override final  int tabSize;
/// Trim all newlines after the final newline at the end of the file.
/// @since 3.15.0
@override final  bool? trimFinalNewlines;
/// Trim trailing whitespace on a line.
/// @since 3.15.0
@override final  bool? trimTrailingWhitespace;

/// Create a copy of FormattingOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$FormattingOptionsCopyWith<_FormattingOptions> get copyWith => __$FormattingOptionsCopyWithImpl<_FormattingOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$FormattingOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _FormattingOptions&&(identical(other.insertFinalNewline, insertFinalNewline) || other.insertFinalNewline == insertFinalNewline)&&(identical(other.insertSpaces, insertSpaces) || other.insertSpaces == insertSpaces)&&(identical(other.tabSize, tabSize) || other.tabSize == tabSize)&&(identical(other.trimFinalNewlines, trimFinalNewlines) || other.trimFinalNewlines == trimFinalNewlines)&&(identical(other.trimTrailingWhitespace, trimTrailingWhitespace) || other.trimTrailingWhitespace == trimTrailingWhitespace));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,insertFinalNewline,insertSpaces,tabSize,trimFinalNewlines,trimTrailingWhitespace);

@override
String toString() {
  return 'FormattingOptions(insertFinalNewline: $insertFinalNewline, insertSpaces: $insertSpaces, tabSize: $tabSize, trimFinalNewlines: $trimFinalNewlines, trimTrailingWhitespace: $trimTrailingWhitespace)';
}


}

/// @nodoc
abstract mixin class _$FormattingOptionsCopyWith<$Res> implements $FormattingOptionsCopyWith<$Res> {
  factory _$FormattingOptionsCopyWith(_FormattingOptions value, $Res Function(_FormattingOptions) _then) = __$FormattingOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? insertFinalNewline, bool insertSpaces, int tabSize, bool? trimFinalNewlines, bool? trimTrailingWhitespace
});




}
/// @nodoc
class __$FormattingOptionsCopyWithImpl<$Res>
    implements _$FormattingOptionsCopyWith<$Res> {
  __$FormattingOptionsCopyWithImpl(this._self, this._then);

  final _FormattingOptions _self;
  final $Res Function(_FormattingOptions) _then;

/// Create a copy of FormattingOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? insertFinalNewline = freezed,Object? insertSpaces = null,Object? tabSize = null,Object? trimFinalNewlines = freezed,Object? trimTrailingWhitespace = freezed,}) {
  return _then(_FormattingOptions(
insertFinalNewline: freezed == insertFinalNewline ? _self.insertFinalNewline : insertFinalNewline // ignore: cast_nullable_to_non_nullable
as bool?,insertSpaces: null == insertSpaces ? _self.insertSpaces : insertSpaces // ignore: cast_nullable_to_non_nullable
as bool,tabSize: null == tabSize ? _self.tabSize : tabSize // ignore: cast_nullable_to_non_nullable
as int,trimFinalNewlines: freezed == trimFinalNewlines ? _self.trimFinalNewlines : trimFinalNewlines // ignore: cast_nullable_to_non_nullable
as bool?,trimTrailingWhitespace: freezed == trimTrailingWhitespace ? _self.trimTrailingWhitespace : trimTrailingWhitespace // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DocumentFormattingOptions {

 bool? get workDoneProgress;
/// Create a copy of DocumentFormattingOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentFormattingOptionsCopyWith<DocumentFormattingOptions> get copyWith => _$DocumentFormattingOptionsCopyWithImpl<DocumentFormattingOptions>(this as DocumentFormattingOptions, _$identity);

  /// Serializes this DocumentFormattingOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentFormattingOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'DocumentFormattingOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $DocumentFormattingOptionsCopyWith<$Res>  {
  factory $DocumentFormattingOptionsCopyWith(DocumentFormattingOptions value, $Res Function(DocumentFormattingOptions) _then) = _$DocumentFormattingOptionsCopyWithImpl;
@useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class _$DocumentFormattingOptionsCopyWithImpl<$Res>
    implements $DocumentFormattingOptionsCopyWith<$Res> {
  _$DocumentFormattingOptionsCopyWithImpl(this._self, this._then);

  final DocumentFormattingOptions _self;
  final $Res Function(DocumentFormattingOptions) _then;

/// Create a copy of DocumentFormattingOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DocumentFormattingOptions implements DocumentFormattingOptions {
  const _DocumentFormattingOptions({this.workDoneProgress});
  factory _DocumentFormattingOptions.fromJson(Map<String, dynamic> json) => _$DocumentFormattingOptionsFromJson(json);

@override final  bool? workDoneProgress;

/// Create a copy of DocumentFormattingOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentFormattingOptionsCopyWith<_DocumentFormattingOptions> get copyWith => __$DocumentFormattingOptionsCopyWithImpl<_DocumentFormattingOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentFormattingOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentFormattingOptions&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,workDoneProgress);

@override
String toString() {
  return 'DocumentFormattingOptions(workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$DocumentFormattingOptionsCopyWith<$Res> implements $DocumentFormattingOptionsCopyWith<$Res> {
  factory _$DocumentFormattingOptionsCopyWith(_DocumentFormattingOptions value, $Res Function(_DocumentFormattingOptions) _then) = __$DocumentFormattingOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? workDoneProgress
});




}
/// @nodoc
class __$DocumentFormattingOptionsCopyWithImpl<$Res>
    implements _$DocumentFormattingOptionsCopyWith<$Res> {
  __$DocumentFormattingOptionsCopyWithImpl(this._self, this._then);

  final _DocumentFormattingOptions _self;
  final $Res Function(_DocumentFormattingOptions) _then;

/// Create a copy of DocumentFormattingOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? workDoneProgress = freezed,}) {
  return _then(_DocumentFormattingOptions(
workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DocumentRangeFormattingOptions {

/// Whether the server supports formatting multiple ranges at once.
/// @since 3.18.0 @proposed
 bool? get rangesSupport; bool? get workDoneProgress;
/// Create a copy of DocumentRangeFormattingOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentRangeFormattingOptionsCopyWith<DocumentRangeFormattingOptions> get copyWith => _$DocumentRangeFormattingOptionsCopyWithImpl<DocumentRangeFormattingOptions>(this as DocumentRangeFormattingOptions, _$identity);

  /// Serializes this DocumentRangeFormattingOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentRangeFormattingOptions&&(identical(other.rangesSupport, rangesSupport) || other.rangesSupport == rangesSupport)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,rangesSupport,workDoneProgress);

@override
String toString() {
  return 'DocumentRangeFormattingOptions(rangesSupport: $rangesSupport, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $DocumentRangeFormattingOptionsCopyWith<$Res>  {
  factory $DocumentRangeFormattingOptionsCopyWith(DocumentRangeFormattingOptions value, $Res Function(DocumentRangeFormattingOptions) _then) = _$DocumentRangeFormattingOptionsCopyWithImpl;
@useResult
$Res call({
 bool? rangesSupport, bool? workDoneProgress
});




}
/// @nodoc
class _$DocumentRangeFormattingOptionsCopyWithImpl<$Res>
    implements $DocumentRangeFormattingOptionsCopyWith<$Res> {
  _$DocumentRangeFormattingOptionsCopyWithImpl(this._self, this._then);

  final DocumentRangeFormattingOptions _self;
  final $Res Function(DocumentRangeFormattingOptions) _then;

/// Create a copy of DocumentRangeFormattingOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? rangesSupport = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
rangesSupport: freezed == rangesSupport ? _self.rangesSupport : rangesSupport // ignore: cast_nullable_to_non_nullable
as bool?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DocumentRangeFormattingOptions implements DocumentRangeFormattingOptions {
  const _DocumentRangeFormattingOptions({this.rangesSupport, this.workDoneProgress});
  factory _DocumentRangeFormattingOptions.fromJson(Map<String, dynamic> json) => _$DocumentRangeFormattingOptionsFromJson(json);

/// Whether the server supports formatting multiple ranges at once.
/// @since 3.18.0 @proposed
@override final  bool? rangesSupport;
@override final  bool? workDoneProgress;

/// Create a copy of DocumentRangeFormattingOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentRangeFormattingOptionsCopyWith<_DocumentRangeFormattingOptions> get copyWith => __$DocumentRangeFormattingOptionsCopyWithImpl<_DocumentRangeFormattingOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentRangeFormattingOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentRangeFormattingOptions&&(identical(other.rangesSupport, rangesSupport) || other.rangesSupport == rangesSupport)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,rangesSupport,workDoneProgress);

@override
String toString() {
  return 'DocumentRangeFormattingOptions(rangesSupport: $rangesSupport, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$DocumentRangeFormattingOptionsCopyWith<$Res> implements $DocumentRangeFormattingOptionsCopyWith<$Res> {
  factory _$DocumentRangeFormattingOptionsCopyWith(_DocumentRangeFormattingOptions value, $Res Function(_DocumentRangeFormattingOptions) _then) = __$DocumentRangeFormattingOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? rangesSupport, bool? workDoneProgress
});




}
/// @nodoc
class __$DocumentRangeFormattingOptionsCopyWithImpl<$Res>
    implements _$DocumentRangeFormattingOptionsCopyWith<$Res> {
  __$DocumentRangeFormattingOptionsCopyWithImpl(this._self, this._then);

  final _DocumentRangeFormattingOptions _self;
  final $Res Function(_DocumentRangeFormattingOptions) _then;

/// Create a copy of DocumentRangeFormattingOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? rangesSupport = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_DocumentRangeFormattingOptions(
rangesSupport: freezed == rangesSupport ? _self.rangesSupport : rangesSupport // ignore: cast_nullable_to_non_nullable
as bool?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DocumentOnTypeFormattingOptions {

/// A character on which formatting should be triggered, like `{`.
 String get firstTriggerCharacter;/// More trigger characters.
 List<String>? get moreTriggerCharacter;
/// Create a copy of DocumentOnTypeFormattingOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentOnTypeFormattingOptionsCopyWith<DocumentOnTypeFormattingOptions> get copyWith => _$DocumentOnTypeFormattingOptionsCopyWithImpl<DocumentOnTypeFormattingOptions>(this as DocumentOnTypeFormattingOptions, _$identity);

  /// Serializes this DocumentOnTypeFormattingOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentOnTypeFormattingOptions&&(identical(other.firstTriggerCharacter, firstTriggerCharacter) || other.firstTriggerCharacter == firstTriggerCharacter)&&const DeepCollectionEquality().equals(other.moreTriggerCharacter, moreTriggerCharacter));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,firstTriggerCharacter,const DeepCollectionEquality().hash(moreTriggerCharacter));

@override
String toString() {
  return 'DocumentOnTypeFormattingOptions(firstTriggerCharacter: $firstTriggerCharacter, moreTriggerCharacter: $moreTriggerCharacter)';
}


}

/// @nodoc
abstract mixin class $DocumentOnTypeFormattingOptionsCopyWith<$Res>  {
  factory $DocumentOnTypeFormattingOptionsCopyWith(DocumentOnTypeFormattingOptions value, $Res Function(DocumentOnTypeFormattingOptions) _then) = _$DocumentOnTypeFormattingOptionsCopyWithImpl;
@useResult
$Res call({
 String firstTriggerCharacter, List<String>? moreTriggerCharacter
});




}
/// @nodoc
class _$DocumentOnTypeFormattingOptionsCopyWithImpl<$Res>
    implements $DocumentOnTypeFormattingOptionsCopyWith<$Res> {
  _$DocumentOnTypeFormattingOptionsCopyWithImpl(this._self, this._then);

  final DocumentOnTypeFormattingOptions _self;
  final $Res Function(DocumentOnTypeFormattingOptions) _then;

/// Create a copy of DocumentOnTypeFormattingOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? firstTriggerCharacter = null,Object? moreTriggerCharacter = freezed,}) {
  return _then(_self.copyWith(
firstTriggerCharacter: null == firstTriggerCharacter ? _self.firstTriggerCharacter : firstTriggerCharacter // ignore: cast_nullable_to_non_nullable
as String,moreTriggerCharacter: freezed == moreTriggerCharacter ? _self.moreTriggerCharacter : moreTriggerCharacter // ignore: cast_nullable_to_non_nullable
as List<String>?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DocumentOnTypeFormattingOptions implements DocumentOnTypeFormattingOptions {
  const _DocumentOnTypeFormattingOptions({required this.firstTriggerCharacter, final  List<String>? moreTriggerCharacter}): _moreTriggerCharacter = moreTriggerCharacter;
  factory _DocumentOnTypeFormattingOptions.fromJson(Map<String, dynamic> json) => _$DocumentOnTypeFormattingOptionsFromJson(json);

/// A character on which formatting should be triggered, like `{`.
@override final  String firstTriggerCharacter;
/// More trigger characters.
 final  List<String>? _moreTriggerCharacter;
/// More trigger characters.
@override List<String>? get moreTriggerCharacter {
  final value = _moreTriggerCharacter;
  if (value == null) return null;
  if (_moreTriggerCharacter is EqualUnmodifiableListView) return _moreTriggerCharacter;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}


/// Create a copy of DocumentOnTypeFormattingOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentOnTypeFormattingOptionsCopyWith<_DocumentOnTypeFormattingOptions> get copyWith => __$DocumentOnTypeFormattingOptionsCopyWithImpl<_DocumentOnTypeFormattingOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentOnTypeFormattingOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentOnTypeFormattingOptions&&(identical(other.firstTriggerCharacter, firstTriggerCharacter) || other.firstTriggerCharacter == firstTriggerCharacter)&&const DeepCollectionEquality().equals(other._moreTriggerCharacter, _moreTriggerCharacter));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,firstTriggerCharacter,const DeepCollectionEquality().hash(_moreTriggerCharacter));

@override
String toString() {
  return 'DocumentOnTypeFormattingOptions(firstTriggerCharacter: $firstTriggerCharacter, moreTriggerCharacter: $moreTriggerCharacter)';
}


}

/// @nodoc
abstract mixin class _$DocumentOnTypeFormattingOptionsCopyWith<$Res> implements $DocumentOnTypeFormattingOptionsCopyWith<$Res> {
  factory _$DocumentOnTypeFormattingOptionsCopyWith(_DocumentOnTypeFormattingOptions value, $Res Function(_DocumentOnTypeFormattingOptions) _then) = __$DocumentOnTypeFormattingOptionsCopyWithImpl;
@override @useResult
$Res call({
 String firstTriggerCharacter, List<String>? moreTriggerCharacter
});




}
/// @nodoc
class __$DocumentOnTypeFormattingOptionsCopyWithImpl<$Res>
    implements _$DocumentOnTypeFormattingOptionsCopyWith<$Res> {
  __$DocumentOnTypeFormattingOptionsCopyWithImpl(this._self, this._then);

  final _DocumentOnTypeFormattingOptions _self;
  final $Res Function(_DocumentOnTypeFormattingOptions) _then;

/// Create a copy of DocumentOnTypeFormattingOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? firstTriggerCharacter = null,Object? moreTriggerCharacter = freezed,}) {
  return _then(_DocumentOnTypeFormattingOptions(
firstTriggerCharacter: null == firstTriggerCharacter ? _self.firstTriggerCharacter : firstTriggerCharacter // ignore: cast_nullable_to_non_nullable
as String,moreTriggerCharacter: freezed == moreTriggerCharacter ? _self._moreTriggerCharacter : moreTriggerCharacter // ignore: cast_nullable_to_non_nullable
as List<String>?,
  ));
}


}


/// @nodoc
mixin _$RenameOptions {

/// Renames should be checked and tested before being executed.
/// @since version 3.12.0
 bool? get prepareProvider; bool? get workDoneProgress;
/// Create a copy of RenameOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RenameOptionsCopyWith<RenameOptions> get copyWith => _$RenameOptionsCopyWithImpl<RenameOptions>(this as RenameOptions, _$identity);

  /// Serializes this RenameOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RenameOptions&&(identical(other.prepareProvider, prepareProvider) || other.prepareProvider == prepareProvider)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,prepareProvider,workDoneProgress);

@override
String toString() {
  return 'RenameOptions(prepareProvider: $prepareProvider, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $RenameOptionsCopyWith<$Res>  {
  factory $RenameOptionsCopyWith(RenameOptions value, $Res Function(RenameOptions) _then) = _$RenameOptionsCopyWithImpl;
@useResult
$Res call({
 bool? prepareProvider, bool? workDoneProgress
});




}
/// @nodoc
class _$RenameOptionsCopyWithImpl<$Res>
    implements $RenameOptionsCopyWith<$Res> {
  _$RenameOptionsCopyWithImpl(this._self, this._then);

  final RenameOptions _self;
  final $Res Function(RenameOptions) _then;

/// Create a copy of RenameOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? prepareProvider = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
prepareProvider: freezed == prepareProvider ? _self.prepareProvider : prepareProvider // ignore: cast_nullable_to_non_nullable
as bool?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _RenameOptions implements RenameOptions {
  const _RenameOptions({this.prepareProvider, this.workDoneProgress});
  factory _RenameOptions.fromJson(Map<String, dynamic> json) => _$RenameOptionsFromJson(json);

/// Renames should be checked and tested before being executed.
/// @since version 3.12.0
@override final  bool? prepareProvider;
@override final  bool? workDoneProgress;

/// Create a copy of RenameOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RenameOptionsCopyWith<_RenameOptions> get copyWith => __$RenameOptionsCopyWithImpl<_RenameOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$RenameOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _RenameOptions&&(identical(other.prepareProvider, prepareProvider) || other.prepareProvider == prepareProvider)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,prepareProvider,workDoneProgress);

@override
String toString() {
  return 'RenameOptions(prepareProvider: $prepareProvider, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$RenameOptionsCopyWith<$Res> implements $RenameOptionsCopyWith<$Res> {
  factory _$RenameOptionsCopyWith(_RenameOptions value, $Res Function(_RenameOptions) _then) = __$RenameOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? prepareProvider, bool? workDoneProgress
});




}
/// @nodoc
class __$RenameOptionsCopyWithImpl<$Res>
    implements _$RenameOptionsCopyWith<$Res> {
  __$RenameOptionsCopyWithImpl(this._self, this._then);

  final _RenameOptions _self;
  final $Res Function(_RenameOptions) _then;

/// Create a copy of RenameOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? prepareProvider = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_RenameOptions(
prepareProvider: freezed == prepareProvider ? _self.prepareProvider : prepareProvider // ignore: cast_nullable_to_non_nullable
as bool?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$ExecuteCommandOptions {

/// The commands to be executed on the server
 List<String> get commands; bool? get workDoneProgress;
/// Create a copy of ExecuteCommandOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ExecuteCommandOptionsCopyWith<ExecuteCommandOptions> get copyWith => _$ExecuteCommandOptionsCopyWithImpl<ExecuteCommandOptions>(this as ExecuteCommandOptions, _$identity);

  /// Serializes this ExecuteCommandOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ExecuteCommandOptions&&const DeepCollectionEquality().equals(other.commands, commands)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(commands),workDoneProgress);

@override
String toString() {
  return 'ExecuteCommandOptions(commands: $commands, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $ExecuteCommandOptionsCopyWith<$Res>  {
  factory $ExecuteCommandOptionsCopyWith(ExecuteCommandOptions value, $Res Function(ExecuteCommandOptions) _then) = _$ExecuteCommandOptionsCopyWithImpl;
@useResult
$Res call({
 List<String> commands, bool? workDoneProgress
});




}
/// @nodoc
class _$ExecuteCommandOptionsCopyWithImpl<$Res>
    implements $ExecuteCommandOptionsCopyWith<$Res> {
  _$ExecuteCommandOptionsCopyWithImpl(this._self, this._then);

  final ExecuteCommandOptions _self;
  final $Res Function(ExecuteCommandOptions) _then;

/// Create a copy of ExecuteCommandOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? commands = null,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
commands: null == commands ? _self.commands : commands // ignore: cast_nullable_to_non_nullable
as List<String>,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _ExecuteCommandOptions implements ExecuteCommandOptions {
  const _ExecuteCommandOptions({required final  List<String> commands, this.workDoneProgress}): _commands = commands;
  factory _ExecuteCommandOptions.fromJson(Map<String, dynamic> json) => _$ExecuteCommandOptionsFromJson(json);

/// The commands to be executed on the server
 final  List<String> _commands;
/// The commands to be executed on the server
@override List<String> get commands {
  if (_commands is EqualUnmodifiableListView) return _commands;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_commands);
}

@override final  bool? workDoneProgress;

/// Create a copy of ExecuteCommandOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ExecuteCommandOptionsCopyWith<_ExecuteCommandOptions> get copyWith => __$ExecuteCommandOptionsCopyWithImpl<_ExecuteCommandOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ExecuteCommandOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ExecuteCommandOptions&&const DeepCollectionEquality().equals(other._commands, _commands)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_commands),workDoneProgress);

@override
String toString() {
  return 'ExecuteCommandOptions(commands: $commands, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$ExecuteCommandOptionsCopyWith<$Res> implements $ExecuteCommandOptionsCopyWith<$Res> {
  factory _$ExecuteCommandOptionsCopyWith(_ExecuteCommandOptions value, $Res Function(_ExecuteCommandOptions) _then) = __$ExecuteCommandOptionsCopyWithImpl;
@override @useResult
$Res call({
 List<String> commands, bool? workDoneProgress
});




}
/// @nodoc
class __$ExecuteCommandOptionsCopyWithImpl<$Res>
    implements _$ExecuteCommandOptionsCopyWith<$Res> {
  __$ExecuteCommandOptionsCopyWithImpl(this._self, this._then);

  final _ExecuteCommandOptions _self;
  final $Res Function(_ExecuteCommandOptions) _then;

/// Create a copy of ExecuteCommandOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? commands = null,Object? workDoneProgress = freezed,}) {
  return _then(_ExecuteCommandOptions(
commands: null == commands ? _self._commands : commands // ignore: cast_nullable_to_non_nullable
as List<String>,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$SemanticTokensLegend {

/// The token modifiers a server uses.
 List<String> get tokenModifiers;/// The token types a server uses.
 List<String> get tokenTypes;
/// Create a copy of SemanticTokensLegend
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SemanticTokensLegendCopyWith<SemanticTokensLegend> get copyWith => _$SemanticTokensLegendCopyWithImpl<SemanticTokensLegend>(this as SemanticTokensLegend, _$identity);

  /// Serializes this SemanticTokensLegend to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SemanticTokensLegend&&const DeepCollectionEquality().equals(other.tokenModifiers, tokenModifiers)&&const DeepCollectionEquality().equals(other.tokenTypes, tokenTypes));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(tokenModifiers),const DeepCollectionEquality().hash(tokenTypes));

@override
String toString() {
  return 'SemanticTokensLegend(tokenModifiers: $tokenModifiers, tokenTypes: $tokenTypes)';
}


}

/// @nodoc
abstract mixin class $SemanticTokensLegendCopyWith<$Res>  {
  factory $SemanticTokensLegendCopyWith(SemanticTokensLegend value, $Res Function(SemanticTokensLegend) _then) = _$SemanticTokensLegendCopyWithImpl;
@useResult
$Res call({
 List<String> tokenModifiers, List<String> tokenTypes
});




}
/// @nodoc
class _$SemanticTokensLegendCopyWithImpl<$Res>
    implements $SemanticTokensLegendCopyWith<$Res> {
  _$SemanticTokensLegendCopyWithImpl(this._self, this._then);

  final SemanticTokensLegend _self;
  final $Res Function(SemanticTokensLegend) _then;

/// Create a copy of SemanticTokensLegend
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? tokenModifiers = null,Object? tokenTypes = null,}) {
  return _then(_self.copyWith(
tokenModifiers: null == tokenModifiers ? _self.tokenModifiers : tokenModifiers // ignore: cast_nullable_to_non_nullable
as List<String>,tokenTypes: null == tokenTypes ? _self.tokenTypes : tokenTypes // ignore: cast_nullable_to_non_nullable
as List<String>,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _SemanticTokensLegend implements SemanticTokensLegend {
  const _SemanticTokensLegend({required final  List<String> tokenModifiers, required final  List<String> tokenTypes}): _tokenModifiers = tokenModifiers,_tokenTypes = tokenTypes;
  factory _SemanticTokensLegend.fromJson(Map<String, dynamic> json) => _$SemanticTokensLegendFromJson(json);

/// The token modifiers a server uses.
 final  List<String> _tokenModifiers;
/// The token modifiers a server uses.
@override List<String> get tokenModifiers {
  if (_tokenModifiers is EqualUnmodifiableListView) return _tokenModifiers;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_tokenModifiers);
}

/// The token types a server uses.
 final  List<String> _tokenTypes;
/// The token types a server uses.
@override List<String> get tokenTypes {
  if (_tokenTypes is EqualUnmodifiableListView) return _tokenTypes;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_tokenTypes);
}


/// Create a copy of SemanticTokensLegend
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SemanticTokensLegendCopyWith<_SemanticTokensLegend> get copyWith => __$SemanticTokensLegendCopyWithImpl<_SemanticTokensLegend>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SemanticTokensLegendToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SemanticTokensLegend&&const DeepCollectionEquality().equals(other._tokenModifiers, _tokenModifiers)&&const DeepCollectionEquality().equals(other._tokenTypes, _tokenTypes));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_tokenModifiers),const DeepCollectionEquality().hash(_tokenTypes));

@override
String toString() {
  return 'SemanticTokensLegend(tokenModifiers: $tokenModifiers, tokenTypes: $tokenTypes)';
}


}

/// @nodoc
abstract mixin class _$SemanticTokensLegendCopyWith<$Res> implements $SemanticTokensLegendCopyWith<$Res> {
  factory _$SemanticTokensLegendCopyWith(_SemanticTokensLegend value, $Res Function(_SemanticTokensLegend) _then) = __$SemanticTokensLegendCopyWithImpl;
@override @useResult
$Res call({
 List<String> tokenModifiers, List<String> tokenTypes
});




}
/// @nodoc
class __$SemanticTokensLegendCopyWithImpl<$Res>
    implements _$SemanticTokensLegendCopyWith<$Res> {
  __$SemanticTokensLegendCopyWithImpl(this._self, this._then);

  final _SemanticTokensLegend _self;
  final $Res Function(_SemanticTokensLegend) _then;

/// Create a copy of SemanticTokensLegend
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? tokenModifiers = null,Object? tokenTypes = null,}) {
  return _then(_SemanticTokensLegend(
tokenModifiers: null == tokenModifiers ? _self._tokenModifiers : tokenModifiers // ignore: cast_nullable_to_non_nullable
as List<String>,tokenTypes: null == tokenTypes ? _self._tokenTypes : tokenTypes // ignore: cast_nullable_to_non_nullable
as List<String>,
  ));
}


}


/// @nodoc
mixin _$OptionalVersionedTextDocumentIdentifier {

/// The text document's uri.
 String get uri;/// The version number of this document. If a versioned text document
/// identifier is sent from the server to the client and the file is not
/// open in the editor (the server has not received an open notification
/// before) the server can send `null` to indicate that the version is
/// unknown and the content on disk is the truth (as specified with
/// document content ownership).
 Sealed28 get version;
/// Create a copy of OptionalVersionedTextDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$OptionalVersionedTextDocumentIdentifierCopyWith<OptionalVersionedTextDocumentIdentifier> get copyWith => _$OptionalVersionedTextDocumentIdentifierCopyWithImpl<OptionalVersionedTextDocumentIdentifier>(this as OptionalVersionedTextDocumentIdentifier, _$identity);

  /// Serializes this OptionalVersionedTextDocumentIdentifier to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is OptionalVersionedTextDocumentIdentifier&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.version, version) || other.version == version));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri,version);

@override
String toString() {
  return 'OptionalVersionedTextDocumentIdentifier(uri: $uri, version: $version)';
}


}

/// @nodoc
abstract mixin class $OptionalVersionedTextDocumentIdentifierCopyWith<$Res>  {
  factory $OptionalVersionedTextDocumentIdentifierCopyWith(OptionalVersionedTextDocumentIdentifier value, $Res Function(OptionalVersionedTextDocumentIdentifier) _then) = _$OptionalVersionedTextDocumentIdentifierCopyWithImpl;
@useResult
$Res call({
 String uri, Sealed28 version
});




}
/// @nodoc
class _$OptionalVersionedTextDocumentIdentifierCopyWithImpl<$Res>
    implements $OptionalVersionedTextDocumentIdentifierCopyWith<$Res> {
  _$OptionalVersionedTextDocumentIdentifierCopyWithImpl(this._self, this._then);

  final OptionalVersionedTextDocumentIdentifier _self;
  final $Res Function(OptionalVersionedTextDocumentIdentifier) _then;

/// Create a copy of OptionalVersionedTextDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? uri = null,Object? version = null,}) {
  return _then(_self.copyWith(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,version: null == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as Sealed28,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _OptionalVersionedTextDocumentIdentifier implements OptionalVersionedTextDocumentIdentifier {
  const _OptionalVersionedTextDocumentIdentifier({required this.uri, required this.version});
  factory _OptionalVersionedTextDocumentIdentifier.fromJson(Map<String, dynamic> json) => _$OptionalVersionedTextDocumentIdentifierFromJson(json);

/// The text document's uri.
@override final  String uri;
/// The version number of this document. If a versioned text document
/// identifier is sent from the server to the client and the file is not
/// open in the editor (the server has not received an open notification
/// before) the server can send `null` to indicate that the version is
/// unknown and the content on disk is the truth (as specified with
/// document content ownership).
@override final  Sealed28 version;

/// Create a copy of OptionalVersionedTextDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$OptionalVersionedTextDocumentIdentifierCopyWith<_OptionalVersionedTextDocumentIdentifier> get copyWith => __$OptionalVersionedTextDocumentIdentifierCopyWithImpl<_OptionalVersionedTextDocumentIdentifier>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$OptionalVersionedTextDocumentIdentifierToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _OptionalVersionedTextDocumentIdentifier&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.version, version) || other.version == version));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,uri,version);

@override
String toString() {
  return 'OptionalVersionedTextDocumentIdentifier(uri: $uri, version: $version)';
}


}

/// @nodoc
abstract mixin class _$OptionalVersionedTextDocumentIdentifierCopyWith<$Res> implements $OptionalVersionedTextDocumentIdentifierCopyWith<$Res> {
  factory _$OptionalVersionedTextDocumentIdentifierCopyWith(_OptionalVersionedTextDocumentIdentifier value, $Res Function(_OptionalVersionedTextDocumentIdentifier) _then) = __$OptionalVersionedTextDocumentIdentifierCopyWithImpl;
@override @useResult
$Res call({
 String uri, Sealed28 version
});




}
/// @nodoc
class __$OptionalVersionedTextDocumentIdentifierCopyWithImpl<$Res>
    implements _$OptionalVersionedTextDocumentIdentifierCopyWith<$Res> {
  __$OptionalVersionedTextDocumentIdentifierCopyWithImpl(this._self, this._then);

  final _OptionalVersionedTextDocumentIdentifier _self;
  final $Res Function(_OptionalVersionedTextDocumentIdentifier) _then;

/// Create a copy of OptionalVersionedTextDocumentIdentifier
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? uri = null,Object? version = null,}) {
  return _then(_OptionalVersionedTextDocumentIdentifier(
uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,version: null == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as Sealed28,
  ));
}


}


/// @nodoc
mixin _$AnnotatedTextEdit {

/// The actual identifier of the change annotation
 ChangeAnnotationIdentifier get annotationId;/// The string to be inserted. For delete operations use an empty string.
 String get newText;/// The range of the text document to be manipulated. To insert text into a
/// document create a range where start === end.
 Range get range;
/// Create a copy of AnnotatedTextEdit
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$AnnotatedTextEditCopyWith<AnnotatedTextEdit> get copyWith => _$AnnotatedTextEditCopyWithImpl<AnnotatedTextEdit>(this as AnnotatedTextEdit, _$identity);

  /// Serializes this AnnotatedTextEdit to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is AnnotatedTextEdit&&(identical(other.annotationId, annotationId) || other.annotationId == annotationId)&&(identical(other.newText, newText) || other.newText == newText)&&(identical(other.range, range) || other.range == range));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,annotationId,newText,range);

@override
String toString() {
  return 'AnnotatedTextEdit(annotationId: $annotationId, newText: $newText, range: $range)';
}


}

/// @nodoc
abstract mixin class $AnnotatedTextEditCopyWith<$Res>  {
  factory $AnnotatedTextEditCopyWith(AnnotatedTextEdit value, $Res Function(AnnotatedTextEdit) _then) = _$AnnotatedTextEditCopyWithImpl;
@useResult
$Res call({
 ChangeAnnotationIdentifier annotationId, String newText, Range range
});


$RangeCopyWith<$Res> get range;

}
/// @nodoc
class _$AnnotatedTextEditCopyWithImpl<$Res>
    implements $AnnotatedTextEditCopyWith<$Res> {
  _$AnnotatedTextEditCopyWithImpl(this._self, this._then);

  final AnnotatedTextEdit _self;
  final $Res Function(AnnotatedTextEdit) _then;

/// Create a copy of AnnotatedTextEdit
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? annotationId = null,Object? newText = null,Object? range = null,}) {
  return _then(_self.copyWith(
annotationId: null == annotationId ? _self.annotationId : annotationId // ignore: cast_nullable_to_non_nullable
as ChangeAnnotationIdentifier,newText: null == newText ? _self.newText : newText // ignore: cast_nullable_to_non_nullable
as String,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,
  ));
}
/// Create a copy of AnnotatedTextEdit
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _AnnotatedTextEdit implements AnnotatedTextEdit {
  const _AnnotatedTextEdit({required this.annotationId, required this.newText, required this.range});
  factory _AnnotatedTextEdit.fromJson(Map<String, dynamic> json) => _$AnnotatedTextEditFromJson(json);

/// The actual identifier of the change annotation
@override final  ChangeAnnotationIdentifier annotationId;
/// The string to be inserted. For delete operations use an empty string.
@override final  String newText;
/// The range of the text document to be manipulated. To insert text into a
/// document create a range where start === end.
@override final  Range range;

/// Create a copy of AnnotatedTextEdit
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$AnnotatedTextEditCopyWith<_AnnotatedTextEdit> get copyWith => __$AnnotatedTextEditCopyWithImpl<_AnnotatedTextEdit>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$AnnotatedTextEditToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _AnnotatedTextEdit&&(identical(other.annotationId, annotationId) || other.annotationId == annotationId)&&(identical(other.newText, newText) || other.newText == newText)&&(identical(other.range, range) || other.range == range));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,annotationId,newText,range);

@override
String toString() {
  return 'AnnotatedTextEdit(annotationId: $annotationId, newText: $newText, range: $range)';
}


}

/// @nodoc
abstract mixin class _$AnnotatedTextEditCopyWith<$Res> implements $AnnotatedTextEditCopyWith<$Res> {
  factory _$AnnotatedTextEditCopyWith(_AnnotatedTextEdit value, $Res Function(_AnnotatedTextEdit) _then) = __$AnnotatedTextEditCopyWithImpl;
@override @useResult
$Res call({
 ChangeAnnotationIdentifier annotationId, String newText, Range range
});


@override $RangeCopyWith<$Res> get range;

}
/// @nodoc
class __$AnnotatedTextEditCopyWithImpl<$Res>
    implements _$AnnotatedTextEditCopyWith<$Res> {
  __$AnnotatedTextEditCopyWithImpl(this._self, this._then);

  final _AnnotatedTextEdit _self;
  final $Res Function(_AnnotatedTextEdit) _then;

/// Create a copy of AnnotatedTextEdit
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? annotationId = null,Object? newText = null,Object? range = null,}) {
  return _then(_AnnotatedTextEdit(
annotationId: null == annotationId ? _self.annotationId : annotationId // ignore: cast_nullable_to_non_nullable
as ChangeAnnotationIdentifier,newText: null == newText ? _self.newText : newText // ignore: cast_nullable_to_non_nullable
as String,range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,
  ));
}

/// Create a copy of AnnotatedTextEdit
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}


/// @nodoc
mixin _$ResourceOperation {

/// An optional annotation identifier describing the operation.
/// @since 3.16.0
 ChangeAnnotationIdentifier? get annotationId;/// The resource operation kind.
 String get kind;
/// Create a copy of ResourceOperation
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ResourceOperationCopyWith<ResourceOperation> get copyWith => _$ResourceOperationCopyWithImpl<ResourceOperation>(this as ResourceOperation, _$identity);

  /// Serializes this ResourceOperation to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ResourceOperation&&(identical(other.annotationId, annotationId) || other.annotationId == annotationId)&&(identical(other.kind, kind) || other.kind == kind));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,annotationId,kind);

@override
String toString() {
  return 'ResourceOperation(annotationId: $annotationId, kind: $kind)';
}


}

/// @nodoc
abstract mixin class $ResourceOperationCopyWith<$Res>  {
  factory $ResourceOperationCopyWith(ResourceOperation value, $Res Function(ResourceOperation) _then) = _$ResourceOperationCopyWithImpl;
@useResult
$Res call({
 ChangeAnnotationIdentifier? annotationId, String kind
});




}
/// @nodoc
class _$ResourceOperationCopyWithImpl<$Res>
    implements $ResourceOperationCopyWith<$Res> {
  _$ResourceOperationCopyWithImpl(this._self, this._then);

  final ResourceOperation _self;
  final $Res Function(ResourceOperation) _then;

/// Create a copy of ResourceOperation
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? annotationId = freezed,Object? kind = null,}) {
  return _then(_self.copyWith(
annotationId: freezed == annotationId ? _self.annotationId : annotationId // ignore: cast_nullable_to_non_nullable
as ChangeAnnotationIdentifier?,kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _ResourceOperation implements ResourceOperation {
  const _ResourceOperation({this.annotationId, required this.kind});
  factory _ResourceOperation.fromJson(Map<String, dynamic> json) => _$ResourceOperationFromJson(json);

/// An optional annotation identifier describing the operation.
/// @since 3.16.0
@override final  ChangeAnnotationIdentifier? annotationId;
/// The resource operation kind.
@override final  String kind;

/// Create a copy of ResourceOperation
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ResourceOperationCopyWith<_ResourceOperation> get copyWith => __$ResourceOperationCopyWithImpl<_ResourceOperation>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ResourceOperationToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ResourceOperation&&(identical(other.annotationId, annotationId) || other.annotationId == annotationId)&&(identical(other.kind, kind) || other.kind == kind));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,annotationId,kind);

@override
String toString() {
  return 'ResourceOperation(annotationId: $annotationId, kind: $kind)';
}


}

/// @nodoc
abstract mixin class _$ResourceOperationCopyWith<$Res> implements $ResourceOperationCopyWith<$Res> {
  factory _$ResourceOperationCopyWith(_ResourceOperation value, $Res Function(_ResourceOperation) _then) = __$ResourceOperationCopyWithImpl;
@override @useResult
$Res call({
 ChangeAnnotationIdentifier? annotationId, String kind
});




}
/// @nodoc
class __$ResourceOperationCopyWithImpl<$Res>
    implements _$ResourceOperationCopyWith<$Res> {
  __$ResourceOperationCopyWithImpl(this._self, this._then);

  final _ResourceOperation _self;
  final $Res Function(_ResourceOperation) _then;

/// Create a copy of ResourceOperation
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? annotationId = freezed,Object? kind = null,}) {
  return _then(_ResourceOperation(
annotationId: freezed == annotationId ? _self.annotationId : annotationId // ignore: cast_nullable_to_non_nullable
as ChangeAnnotationIdentifier?,kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}


/// @nodoc
mixin _$CreateFileOptions {

/// Ignore if exists.
 bool? get ignoreIfExists;/// Overwrite existing file. Overwrite wins over `ignoreIfExists`
 bool? get overwrite;
/// Create a copy of CreateFileOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CreateFileOptionsCopyWith<CreateFileOptions> get copyWith => _$CreateFileOptionsCopyWithImpl<CreateFileOptions>(this as CreateFileOptions, _$identity);

  /// Serializes this CreateFileOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CreateFileOptions&&(identical(other.ignoreIfExists, ignoreIfExists) || other.ignoreIfExists == ignoreIfExists)&&(identical(other.overwrite, overwrite) || other.overwrite == overwrite));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,ignoreIfExists,overwrite);

@override
String toString() {
  return 'CreateFileOptions(ignoreIfExists: $ignoreIfExists, overwrite: $overwrite)';
}


}

/// @nodoc
abstract mixin class $CreateFileOptionsCopyWith<$Res>  {
  factory $CreateFileOptionsCopyWith(CreateFileOptions value, $Res Function(CreateFileOptions) _then) = _$CreateFileOptionsCopyWithImpl;
@useResult
$Res call({
 bool? ignoreIfExists, bool? overwrite
});




}
/// @nodoc
class _$CreateFileOptionsCopyWithImpl<$Res>
    implements $CreateFileOptionsCopyWith<$Res> {
  _$CreateFileOptionsCopyWithImpl(this._self, this._then);

  final CreateFileOptions _self;
  final $Res Function(CreateFileOptions) _then;

/// Create a copy of CreateFileOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? ignoreIfExists = freezed,Object? overwrite = freezed,}) {
  return _then(_self.copyWith(
ignoreIfExists: freezed == ignoreIfExists ? _self.ignoreIfExists : ignoreIfExists // ignore: cast_nullable_to_non_nullable
as bool?,overwrite: freezed == overwrite ? _self.overwrite : overwrite // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _CreateFileOptions implements CreateFileOptions {
  const _CreateFileOptions({this.ignoreIfExists, this.overwrite});
  factory _CreateFileOptions.fromJson(Map<String, dynamic> json) => _$CreateFileOptionsFromJson(json);

/// Ignore if exists.
@override final  bool? ignoreIfExists;
/// Overwrite existing file. Overwrite wins over `ignoreIfExists`
@override final  bool? overwrite;

/// Create a copy of CreateFileOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CreateFileOptionsCopyWith<_CreateFileOptions> get copyWith => __$CreateFileOptionsCopyWithImpl<_CreateFileOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CreateFileOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CreateFileOptions&&(identical(other.ignoreIfExists, ignoreIfExists) || other.ignoreIfExists == ignoreIfExists)&&(identical(other.overwrite, overwrite) || other.overwrite == overwrite));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,ignoreIfExists,overwrite);

@override
String toString() {
  return 'CreateFileOptions(ignoreIfExists: $ignoreIfExists, overwrite: $overwrite)';
}


}

/// @nodoc
abstract mixin class _$CreateFileOptionsCopyWith<$Res> implements $CreateFileOptionsCopyWith<$Res> {
  factory _$CreateFileOptionsCopyWith(_CreateFileOptions value, $Res Function(_CreateFileOptions) _then) = __$CreateFileOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? ignoreIfExists, bool? overwrite
});




}
/// @nodoc
class __$CreateFileOptionsCopyWithImpl<$Res>
    implements _$CreateFileOptionsCopyWith<$Res> {
  __$CreateFileOptionsCopyWithImpl(this._self, this._then);

  final _CreateFileOptions _self;
  final $Res Function(_CreateFileOptions) _then;

/// Create a copy of CreateFileOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? ignoreIfExists = freezed,Object? overwrite = freezed,}) {
  return _then(_CreateFileOptions(
ignoreIfExists: freezed == ignoreIfExists ? _self.ignoreIfExists : ignoreIfExists // ignore: cast_nullable_to_non_nullable
as bool?,overwrite: freezed == overwrite ? _self.overwrite : overwrite // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$RenameFileOptions {

/// Ignores if target exists.
 bool? get ignoreIfExists;/// Overwrite target if existing. Overwrite wins over `ignoreIfExists`
 bool? get overwrite;
/// Create a copy of RenameFileOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RenameFileOptionsCopyWith<RenameFileOptions> get copyWith => _$RenameFileOptionsCopyWithImpl<RenameFileOptions>(this as RenameFileOptions, _$identity);

  /// Serializes this RenameFileOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RenameFileOptions&&(identical(other.ignoreIfExists, ignoreIfExists) || other.ignoreIfExists == ignoreIfExists)&&(identical(other.overwrite, overwrite) || other.overwrite == overwrite));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,ignoreIfExists,overwrite);

@override
String toString() {
  return 'RenameFileOptions(ignoreIfExists: $ignoreIfExists, overwrite: $overwrite)';
}


}

/// @nodoc
abstract mixin class $RenameFileOptionsCopyWith<$Res>  {
  factory $RenameFileOptionsCopyWith(RenameFileOptions value, $Res Function(RenameFileOptions) _then) = _$RenameFileOptionsCopyWithImpl;
@useResult
$Res call({
 bool? ignoreIfExists, bool? overwrite
});




}
/// @nodoc
class _$RenameFileOptionsCopyWithImpl<$Res>
    implements $RenameFileOptionsCopyWith<$Res> {
  _$RenameFileOptionsCopyWithImpl(this._self, this._then);

  final RenameFileOptions _self;
  final $Res Function(RenameFileOptions) _then;

/// Create a copy of RenameFileOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? ignoreIfExists = freezed,Object? overwrite = freezed,}) {
  return _then(_self.copyWith(
ignoreIfExists: freezed == ignoreIfExists ? _self.ignoreIfExists : ignoreIfExists // ignore: cast_nullable_to_non_nullable
as bool?,overwrite: freezed == overwrite ? _self.overwrite : overwrite // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _RenameFileOptions implements RenameFileOptions {
  const _RenameFileOptions({this.ignoreIfExists, this.overwrite});
  factory _RenameFileOptions.fromJson(Map<String, dynamic> json) => _$RenameFileOptionsFromJson(json);

/// Ignores if target exists.
@override final  bool? ignoreIfExists;
/// Overwrite target if existing. Overwrite wins over `ignoreIfExists`
@override final  bool? overwrite;

/// Create a copy of RenameFileOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RenameFileOptionsCopyWith<_RenameFileOptions> get copyWith => __$RenameFileOptionsCopyWithImpl<_RenameFileOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$RenameFileOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _RenameFileOptions&&(identical(other.ignoreIfExists, ignoreIfExists) || other.ignoreIfExists == ignoreIfExists)&&(identical(other.overwrite, overwrite) || other.overwrite == overwrite));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,ignoreIfExists,overwrite);

@override
String toString() {
  return 'RenameFileOptions(ignoreIfExists: $ignoreIfExists, overwrite: $overwrite)';
}


}

/// @nodoc
abstract mixin class _$RenameFileOptionsCopyWith<$Res> implements $RenameFileOptionsCopyWith<$Res> {
  factory _$RenameFileOptionsCopyWith(_RenameFileOptions value, $Res Function(_RenameFileOptions) _then) = __$RenameFileOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? ignoreIfExists, bool? overwrite
});




}
/// @nodoc
class __$RenameFileOptionsCopyWithImpl<$Res>
    implements _$RenameFileOptionsCopyWith<$Res> {
  __$RenameFileOptionsCopyWithImpl(this._self, this._then);

  final _RenameFileOptions _self;
  final $Res Function(_RenameFileOptions) _then;

/// Create a copy of RenameFileOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? ignoreIfExists = freezed,Object? overwrite = freezed,}) {
  return _then(_RenameFileOptions(
ignoreIfExists: freezed == ignoreIfExists ? _self.ignoreIfExists : ignoreIfExists // ignore: cast_nullable_to_non_nullable
as bool?,overwrite: freezed == overwrite ? _self.overwrite : overwrite // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DeleteFileOptions {

/// Ignore the operation if the file doesn't exist.
 bool? get ignoreIfNotExists;/// Delete the content recursively if a folder is denoted.
 bool? get recursive;
/// Create a copy of DeleteFileOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DeleteFileOptionsCopyWith<DeleteFileOptions> get copyWith => _$DeleteFileOptionsCopyWithImpl<DeleteFileOptions>(this as DeleteFileOptions, _$identity);

  /// Serializes this DeleteFileOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DeleteFileOptions&&(identical(other.ignoreIfNotExists, ignoreIfNotExists) || other.ignoreIfNotExists == ignoreIfNotExists)&&(identical(other.recursive, recursive) || other.recursive == recursive));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,ignoreIfNotExists,recursive);

@override
String toString() {
  return 'DeleteFileOptions(ignoreIfNotExists: $ignoreIfNotExists, recursive: $recursive)';
}


}

/// @nodoc
abstract mixin class $DeleteFileOptionsCopyWith<$Res>  {
  factory $DeleteFileOptionsCopyWith(DeleteFileOptions value, $Res Function(DeleteFileOptions) _then) = _$DeleteFileOptionsCopyWithImpl;
@useResult
$Res call({
 bool? ignoreIfNotExists, bool? recursive
});




}
/// @nodoc
class _$DeleteFileOptionsCopyWithImpl<$Res>
    implements $DeleteFileOptionsCopyWith<$Res> {
  _$DeleteFileOptionsCopyWithImpl(this._self, this._then);

  final DeleteFileOptions _self;
  final $Res Function(DeleteFileOptions) _then;

/// Create a copy of DeleteFileOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? ignoreIfNotExists = freezed,Object? recursive = freezed,}) {
  return _then(_self.copyWith(
ignoreIfNotExists: freezed == ignoreIfNotExists ? _self.ignoreIfNotExists : ignoreIfNotExists // ignore: cast_nullable_to_non_nullable
as bool?,recursive: freezed == recursive ? _self.recursive : recursive // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DeleteFileOptions implements DeleteFileOptions {
  const _DeleteFileOptions({this.ignoreIfNotExists, this.recursive});
  factory _DeleteFileOptions.fromJson(Map<String, dynamic> json) => _$DeleteFileOptionsFromJson(json);

/// Ignore the operation if the file doesn't exist.
@override final  bool? ignoreIfNotExists;
/// Delete the content recursively if a folder is denoted.
@override final  bool? recursive;

/// Create a copy of DeleteFileOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DeleteFileOptionsCopyWith<_DeleteFileOptions> get copyWith => __$DeleteFileOptionsCopyWithImpl<_DeleteFileOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DeleteFileOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DeleteFileOptions&&(identical(other.ignoreIfNotExists, ignoreIfNotExists) || other.ignoreIfNotExists == ignoreIfNotExists)&&(identical(other.recursive, recursive) || other.recursive == recursive));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,ignoreIfNotExists,recursive);

@override
String toString() {
  return 'DeleteFileOptions(ignoreIfNotExists: $ignoreIfNotExists, recursive: $recursive)';
}


}

/// @nodoc
abstract mixin class _$DeleteFileOptionsCopyWith<$Res> implements $DeleteFileOptionsCopyWith<$Res> {
  factory _$DeleteFileOptionsCopyWith(_DeleteFileOptions value, $Res Function(_DeleteFileOptions) _then) = __$DeleteFileOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? ignoreIfNotExists, bool? recursive
});




}
/// @nodoc
class __$DeleteFileOptionsCopyWithImpl<$Res>
    implements _$DeleteFileOptionsCopyWith<$Res> {
  __$DeleteFileOptionsCopyWithImpl(this._self, this._then);

  final _DeleteFileOptions _self;
  final $Res Function(_DeleteFileOptions) _then;

/// Create a copy of DeleteFileOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? ignoreIfNotExists = freezed,Object? recursive = freezed,}) {
  return _then(_DeleteFileOptions(
ignoreIfNotExists: freezed == ignoreIfNotExists ? _self.ignoreIfNotExists : ignoreIfNotExists // ignore: cast_nullable_to_non_nullable
as bool?,recursive: freezed == recursive ? _self.recursive : recursive // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$FileOperationPattern {

/// The glob pattern to match. Glob patterns can have the following syntax:
/// - `*` to match zero or more characters in a path segment - `?` to match
/// on one character in a path segment - `**` to match any number of path
/// segments, including none - `{}` to group sub patterns into an OR
/// expression. (e.g. `**/*.{ts,js}` matches all TypeScript and JavaScript
/// files) - `[]` to declare a range of characters to match in a path
/// segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, )
/// - `[!...]` to negate a range of characters to match in a path segment
/// (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not
/// `example.0`)
 String get glob;/// Whether to match files or folders with this pattern.
/// Matches both if undefined.
 FileOperationPatternKind? get matches;/// Additional options used during matching.
 FileOperationPatternOptions? get options;
/// Create a copy of FileOperationPattern
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FileOperationPatternCopyWith<FileOperationPattern> get copyWith => _$FileOperationPatternCopyWithImpl<FileOperationPattern>(this as FileOperationPattern, _$identity);

  /// Serializes this FileOperationPattern to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FileOperationPattern&&(identical(other.glob, glob) || other.glob == glob)&&(identical(other.matches, matches) || other.matches == matches)&&(identical(other.options, options) || other.options == options));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,glob,matches,options);

@override
String toString() {
  return 'FileOperationPattern(glob: $glob, matches: $matches, options: $options)';
}


}

/// @nodoc
abstract mixin class $FileOperationPatternCopyWith<$Res>  {
  factory $FileOperationPatternCopyWith(FileOperationPattern value, $Res Function(FileOperationPattern) _then) = _$FileOperationPatternCopyWithImpl;
@useResult
$Res call({
 String glob, FileOperationPatternKind? matches, FileOperationPatternOptions? options
});


$FileOperationPatternOptionsCopyWith<$Res>? get options;

}
/// @nodoc
class _$FileOperationPatternCopyWithImpl<$Res>
    implements $FileOperationPatternCopyWith<$Res> {
  _$FileOperationPatternCopyWithImpl(this._self, this._then);

  final FileOperationPattern _self;
  final $Res Function(FileOperationPattern) _then;

/// Create a copy of FileOperationPattern
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? glob = null,Object? matches = freezed,Object? options = freezed,}) {
  return _then(_self.copyWith(
glob: null == glob ? _self.glob : glob // ignore: cast_nullable_to_non_nullable
as String,matches: freezed == matches ? _self.matches : matches // ignore: cast_nullable_to_non_nullable
as FileOperationPatternKind?,options: freezed == options ? _self.options : options // ignore: cast_nullable_to_non_nullable
as FileOperationPatternOptions?,
  ));
}
/// Create a copy of FileOperationPattern
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FileOperationPatternOptionsCopyWith<$Res>? get options {
    if (_self.options == null) {
    return null;
  }

  return $FileOperationPatternOptionsCopyWith<$Res>(_self.options!, (value) {
    return _then(_self.copyWith(options: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _FileOperationPattern implements FileOperationPattern {
  const _FileOperationPattern({required this.glob, this.matches, this.options});
  factory _FileOperationPattern.fromJson(Map<String, dynamic> json) => _$FileOperationPatternFromJson(json);

/// The glob pattern to match. Glob patterns can have the following syntax:
/// - `*` to match zero or more characters in a path segment - `?` to match
/// on one character in a path segment - `**` to match any number of path
/// segments, including none - `{}` to group sub patterns into an OR
/// expression. (e.g. `**/*.{ts,js}` matches all TypeScript and JavaScript
/// files) - `[]` to declare a range of characters to match in a path
/// segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, )
/// - `[!...]` to negate a range of characters to match in a path segment
/// (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not
/// `example.0`)
@override final  String glob;
/// Whether to match files or folders with this pattern.
/// Matches both if undefined.
@override final  FileOperationPatternKind? matches;
/// Additional options used during matching.
@override final  FileOperationPatternOptions? options;

/// Create a copy of FileOperationPattern
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$FileOperationPatternCopyWith<_FileOperationPattern> get copyWith => __$FileOperationPatternCopyWithImpl<_FileOperationPattern>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$FileOperationPatternToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _FileOperationPattern&&(identical(other.glob, glob) || other.glob == glob)&&(identical(other.matches, matches) || other.matches == matches)&&(identical(other.options, options) || other.options == options));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,glob,matches,options);

@override
String toString() {
  return 'FileOperationPattern(glob: $glob, matches: $matches, options: $options)';
}


}

/// @nodoc
abstract mixin class _$FileOperationPatternCopyWith<$Res> implements $FileOperationPatternCopyWith<$Res> {
  factory _$FileOperationPatternCopyWith(_FileOperationPattern value, $Res Function(_FileOperationPattern) _then) = __$FileOperationPatternCopyWithImpl;
@override @useResult
$Res call({
 String glob, FileOperationPatternKind? matches, FileOperationPatternOptions? options
});


@override $FileOperationPatternOptionsCopyWith<$Res>? get options;

}
/// @nodoc
class __$FileOperationPatternCopyWithImpl<$Res>
    implements _$FileOperationPatternCopyWith<$Res> {
  __$FileOperationPatternCopyWithImpl(this._self, this._then);

  final _FileOperationPattern _self;
  final $Res Function(_FileOperationPattern) _then;

/// Create a copy of FileOperationPattern
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? glob = null,Object? matches = freezed,Object? options = freezed,}) {
  return _then(_FileOperationPattern(
glob: null == glob ? _self.glob : glob // ignore: cast_nullable_to_non_nullable
as String,matches: freezed == matches ? _self.matches : matches // ignore: cast_nullable_to_non_nullable
as FileOperationPatternKind?,options: freezed == options ? _self.options : options // ignore: cast_nullable_to_non_nullable
as FileOperationPatternOptions?,
  ));
}

/// Create a copy of FileOperationPattern
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FileOperationPatternOptionsCopyWith<$Res>? get options {
    if (_self.options == null) {
    return null;
  }

  return $FileOperationPatternOptionsCopyWith<$Res>(_self.options!, (value) {
    return _then(_self.copyWith(options: value));
  });
}
}


/// @nodoc
mixin _$WorkspaceFullDocumentDiagnosticReport {

/// The actual items.
 List<Diagnostic> get items;/// A full document diagnostic report.
 StringLiteralRef get kind;/// An optional result id. If provided it will be sent on the next
/// diagnostic request for the same document.
 String? get resultId;/// The URI for which diagnostic information is reported.
 String get uri;/// The version number for which the diagnostics are reported. If the
/// document is not marked as open `null` can be provided.
 Sealed28 get version;
/// Create a copy of WorkspaceFullDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkspaceFullDocumentDiagnosticReportCopyWith<WorkspaceFullDocumentDiagnosticReport> get copyWith => _$WorkspaceFullDocumentDiagnosticReportCopyWithImpl<WorkspaceFullDocumentDiagnosticReport>(this as WorkspaceFullDocumentDiagnosticReport, _$identity);

  /// Serializes this WorkspaceFullDocumentDiagnosticReport to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkspaceFullDocumentDiagnosticReport&&const DeepCollectionEquality().equals(other.items, items)&&const DeepCollectionEquality().equals(other.kind, kind)&&(identical(other.resultId, resultId) || other.resultId == resultId)&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.version, version) || other.version == version));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(items),const DeepCollectionEquality().hash(kind),resultId,uri,version);

@override
String toString() {
  return 'WorkspaceFullDocumentDiagnosticReport(items: $items, kind: $kind, resultId: $resultId, uri: $uri, version: $version)';
}


}

/// @nodoc
abstract mixin class $WorkspaceFullDocumentDiagnosticReportCopyWith<$Res>  {
  factory $WorkspaceFullDocumentDiagnosticReportCopyWith(WorkspaceFullDocumentDiagnosticReport value, $Res Function(WorkspaceFullDocumentDiagnosticReport) _then) = _$WorkspaceFullDocumentDiagnosticReportCopyWithImpl;
@useResult
$Res call({
 List<Diagnostic> items, StringLiteralRef kind, String? resultId, String uri, Sealed28 version
});




}
/// @nodoc
class _$WorkspaceFullDocumentDiagnosticReportCopyWithImpl<$Res>
    implements $WorkspaceFullDocumentDiagnosticReportCopyWith<$Res> {
  _$WorkspaceFullDocumentDiagnosticReportCopyWithImpl(this._self, this._then);

  final WorkspaceFullDocumentDiagnosticReport _self;
  final $Res Function(WorkspaceFullDocumentDiagnosticReport) _then;

/// Create a copy of WorkspaceFullDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? items = null,Object? kind = freezed,Object? resultId = freezed,Object? uri = null,Object? version = null,}) {
  return _then(_self.copyWith(
items: null == items ? _self.items : items // ignore: cast_nullable_to_non_nullable
as List<Diagnostic>,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as StringLiteralRef,resultId: freezed == resultId ? _self.resultId : resultId // ignore: cast_nullable_to_non_nullable
as String?,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,version: null == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as Sealed28,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _WorkspaceFullDocumentDiagnosticReport implements WorkspaceFullDocumentDiagnosticReport {
  const _WorkspaceFullDocumentDiagnosticReport({required final  List<Diagnostic> items, required this.kind, this.resultId, required this.uri, required this.version}): _items = items;
  factory _WorkspaceFullDocumentDiagnosticReport.fromJson(Map<String, dynamic> json) => _$WorkspaceFullDocumentDiagnosticReportFromJson(json);

/// The actual items.
 final  List<Diagnostic> _items;
/// The actual items.
@override List<Diagnostic> get items {
  if (_items is EqualUnmodifiableListView) return _items;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_items);
}

/// A full document diagnostic report.
@override final  StringLiteralRef kind;
/// An optional result id. If provided it will be sent on the next
/// diagnostic request for the same document.
@override final  String? resultId;
/// The URI for which diagnostic information is reported.
@override final  String uri;
/// The version number for which the diagnostics are reported. If the
/// document is not marked as open `null` can be provided.
@override final  Sealed28 version;

/// Create a copy of WorkspaceFullDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkspaceFullDocumentDiagnosticReportCopyWith<_WorkspaceFullDocumentDiagnosticReport> get copyWith => __$WorkspaceFullDocumentDiagnosticReportCopyWithImpl<_WorkspaceFullDocumentDiagnosticReport>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkspaceFullDocumentDiagnosticReportToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkspaceFullDocumentDiagnosticReport&&const DeepCollectionEquality().equals(other._items, _items)&&const DeepCollectionEquality().equals(other.kind, kind)&&(identical(other.resultId, resultId) || other.resultId == resultId)&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.version, version) || other.version == version));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_items),const DeepCollectionEquality().hash(kind),resultId,uri,version);

@override
String toString() {
  return 'WorkspaceFullDocumentDiagnosticReport(items: $items, kind: $kind, resultId: $resultId, uri: $uri, version: $version)';
}


}

/// @nodoc
abstract mixin class _$WorkspaceFullDocumentDiagnosticReportCopyWith<$Res> implements $WorkspaceFullDocumentDiagnosticReportCopyWith<$Res> {
  factory _$WorkspaceFullDocumentDiagnosticReportCopyWith(_WorkspaceFullDocumentDiagnosticReport value, $Res Function(_WorkspaceFullDocumentDiagnosticReport) _then) = __$WorkspaceFullDocumentDiagnosticReportCopyWithImpl;
@override @useResult
$Res call({
 List<Diagnostic> items, StringLiteralRef kind, String? resultId, String uri, Sealed28 version
});




}
/// @nodoc
class __$WorkspaceFullDocumentDiagnosticReportCopyWithImpl<$Res>
    implements _$WorkspaceFullDocumentDiagnosticReportCopyWith<$Res> {
  __$WorkspaceFullDocumentDiagnosticReportCopyWithImpl(this._self, this._then);

  final _WorkspaceFullDocumentDiagnosticReport _self;
  final $Res Function(_WorkspaceFullDocumentDiagnosticReport) _then;

/// Create a copy of WorkspaceFullDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? items = null,Object? kind = freezed,Object? resultId = freezed,Object? uri = null,Object? version = null,}) {
  return _then(_WorkspaceFullDocumentDiagnosticReport(
items: null == items ? _self._items : items // ignore: cast_nullable_to_non_nullable
as List<Diagnostic>,kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as StringLiteralRef,resultId: freezed == resultId ? _self.resultId : resultId // ignore: cast_nullable_to_non_nullable
as String?,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,version: null == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as Sealed28,
  ));
}


}


/// @nodoc
mixin _$WorkspaceUnchangedDocumentDiagnosticReport {

/// A document diagnostic report indicating no changes to the last result.
/// A server can only return `unchanged` if result ids are provided.
 StringLiteralRef get kind;/// A result id which will be sent on the next diagnostic request for the
/// same document.
 String get resultId;/// The URI for which diagnostic information is reported.
 String get uri;/// The version number for which the diagnostics are reported. If the
/// document is not marked as open `null` can be provided.
 Sealed28 get version;
/// Create a copy of WorkspaceUnchangedDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkspaceUnchangedDocumentDiagnosticReportCopyWith<WorkspaceUnchangedDocumentDiagnosticReport> get copyWith => _$WorkspaceUnchangedDocumentDiagnosticReportCopyWithImpl<WorkspaceUnchangedDocumentDiagnosticReport>(this as WorkspaceUnchangedDocumentDiagnosticReport, _$identity);

  /// Serializes this WorkspaceUnchangedDocumentDiagnosticReport to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkspaceUnchangedDocumentDiagnosticReport&&const DeepCollectionEquality().equals(other.kind, kind)&&(identical(other.resultId, resultId) || other.resultId == resultId)&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.version, version) || other.version == version));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(kind),resultId,uri,version);

@override
String toString() {
  return 'WorkspaceUnchangedDocumentDiagnosticReport(kind: $kind, resultId: $resultId, uri: $uri, version: $version)';
}


}

/// @nodoc
abstract mixin class $WorkspaceUnchangedDocumentDiagnosticReportCopyWith<$Res>  {
  factory $WorkspaceUnchangedDocumentDiagnosticReportCopyWith(WorkspaceUnchangedDocumentDiagnosticReport value, $Res Function(WorkspaceUnchangedDocumentDiagnosticReport) _then) = _$WorkspaceUnchangedDocumentDiagnosticReportCopyWithImpl;
@useResult
$Res call({
 StringLiteralRef kind, String resultId, String uri, Sealed28 version
});




}
/// @nodoc
class _$WorkspaceUnchangedDocumentDiagnosticReportCopyWithImpl<$Res>
    implements $WorkspaceUnchangedDocumentDiagnosticReportCopyWith<$Res> {
  _$WorkspaceUnchangedDocumentDiagnosticReportCopyWithImpl(this._self, this._then);

  final WorkspaceUnchangedDocumentDiagnosticReport _self;
  final $Res Function(WorkspaceUnchangedDocumentDiagnosticReport) _then;

/// Create a copy of WorkspaceUnchangedDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? kind = freezed,Object? resultId = null,Object? uri = null,Object? version = null,}) {
  return _then(_self.copyWith(
kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as StringLiteralRef,resultId: null == resultId ? _self.resultId : resultId // ignore: cast_nullable_to_non_nullable
as String,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,version: null == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as Sealed28,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _WorkspaceUnchangedDocumentDiagnosticReport implements WorkspaceUnchangedDocumentDiagnosticReport {
  const _WorkspaceUnchangedDocumentDiagnosticReport({required this.kind, required this.resultId, required this.uri, required this.version});
  factory _WorkspaceUnchangedDocumentDiagnosticReport.fromJson(Map<String, dynamic> json) => _$WorkspaceUnchangedDocumentDiagnosticReportFromJson(json);

/// A document diagnostic report indicating no changes to the last result.
/// A server can only return `unchanged` if result ids are provided.
@override final  StringLiteralRef kind;
/// A result id which will be sent on the next diagnostic request for the
/// same document.
@override final  String resultId;
/// The URI for which diagnostic information is reported.
@override final  String uri;
/// The version number for which the diagnostics are reported. If the
/// document is not marked as open `null` can be provided.
@override final  Sealed28 version;

/// Create a copy of WorkspaceUnchangedDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkspaceUnchangedDocumentDiagnosticReportCopyWith<_WorkspaceUnchangedDocumentDiagnosticReport> get copyWith => __$WorkspaceUnchangedDocumentDiagnosticReportCopyWithImpl<_WorkspaceUnchangedDocumentDiagnosticReport>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkspaceUnchangedDocumentDiagnosticReportToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkspaceUnchangedDocumentDiagnosticReport&&const DeepCollectionEquality().equals(other.kind, kind)&&(identical(other.resultId, resultId) || other.resultId == resultId)&&(identical(other.uri, uri) || other.uri == uri)&&(identical(other.version, version) || other.version == version));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(kind),resultId,uri,version);

@override
String toString() {
  return 'WorkspaceUnchangedDocumentDiagnosticReport(kind: $kind, resultId: $resultId, uri: $uri, version: $version)';
}


}

/// @nodoc
abstract mixin class _$WorkspaceUnchangedDocumentDiagnosticReportCopyWith<$Res> implements $WorkspaceUnchangedDocumentDiagnosticReportCopyWith<$Res> {
  factory _$WorkspaceUnchangedDocumentDiagnosticReportCopyWith(_WorkspaceUnchangedDocumentDiagnosticReport value, $Res Function(_WorkspaceUnchangedDocumentDiagnosticReport) _then) = __$WorkspaceUnchangedDocumentDiagnosticReportCopyWithImpl;
@override @useResult
$Res call({
 StringLiteralRef kind, String resultId, String uri, Sealed28 version
});




}
/// @nodoc
class __$WorkspaceUnchangedDocumentDiagnosticReportCopyWithImpl<$Res>
    implements _$WorkspaceUnchangedDocumentDiagnosticReportCopyWith<$Res> {
  __$WorkspaceUnchangedDocumentDiagnosticReportCopyWithImpl(this._self, this._then);

  final _WorkspaceUnchangedDocumentDiagnosticReport _self;
  final $Res Function(_WorkspaceUnchangedDocumentDiagnosticReport) _then;

/// Create a copy of WorkspaceUnchangedDocumentDiagnosticReport
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? kind = freezed,Object? resultId = null,Object? uri = null,Object? version = null,}) {
  return _then(_WorkspaceUnchangedDocumentDiagnosticReport(
kind: freezed == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as StringLiteralRef,resultId: null == resultId ? _self.resultId : resultId // ignore: cast_nullable_to_non_nullable
as String,uri: null == uri ? _self.uri : uri // ignore: cast_nullable_to_non_nullable
as String,version: null == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as Sealed28,
  ));
}


}


/// @nodoc
mixin _$NotebookCell {

/// The URI of the cell's text document content.
 String get document;/// Additional execution summary information if supported by the client.
 ExecutionSummary? get executionSummary;/// The cell's kind
 NotebookCellKind get kind;/// Additional metadata stored with the cell.
/// Note: should always be an object literal (e.g. LSPObject)
 LSPObject? get metadata;
/// Create a copy of NotebookCell
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$NotebookCellCopyWith<NotebookCell> get copyWith => _$NotebookCellCopyWithImpl<NotebookCell>(this as NotebookCell, _$identity);

  /// Serializes this NotebookCell to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is NotebookCell&&(identical(other.document, document) || other.document == document)&&(identical(other.executionSummary, executionSummary) || other.executionSummary == executionSummary)&&(identical(other.kind, kind) || other.kind == kind)&&const DeepCollectionEquality().equals(other.metadata, metadata));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,document,executionSummary,kind,const DeepCollectionEquality().hash(metadata));

@override
String toString() {
  return 'NotebookCell(document: $document, executionSummary: $executionSummary, kind: $kind, metadata: $metadata)';
}


}

/// @nodoc
abstract mixin class $NotebookCellCopyWith<$Res>  {
  factory $NotebookCellCopyWith(NotebookCell value, $Res Function(NotebookCell) _then) = _$NotebookCellCopyWithImpl;
@useResult
$Res call({
 String document, ExecutionSummary? executionSummary, NotebookCellKind kind, LSPObject? metadata
});


$ExecutionSummaryCopyWith<$Res>? get executionSummary;

}
/// @nodoc
class _$NotebookCellCopyWithImpl<$Res>
    implements $NotebookCellCopyWith<$Res> {
  _$NotebookCellCopyWithImpl(this._self, this._then);

  final NotebookCell _self;
  final $Res Function(NotebookCell) _then;

/// Create a copy of NotebookCell
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? document = null,Object? executionSummary = freezed,Object? kind = null,Object? metadata = freezed,}) {
  return _then(_self.copyWith(
document: null == document ? _self.document : document // ignore: cast_nullable_to_non_nullable
as String,executionSummary: freezed == executionSummary ? _self.executionSummary : executionSummary // ignore: cast_nullable_to_non_nullable
as ExecutionSummary?,kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as NotebookCellKind,metadata: freezed == metadata ? _self.metadata : metadata // ignore: cast_nullable_to_non_nullable
as LSPObject?,
  ));
}
/// Create a copy of NotebookCell
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ExecutionSummaryCopyWith<$Res>? get executionSummary {
    if (_self.executionSummary == null) {
    return null;
  }

  return $ExecutionSummaryCopyWith<$Res>(_self.executionSummary!, (value) {
    return _then(_self.copyWith(executionSummary: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _NotebookCell implements NotebookCell {
  const _NotebookCell({required this.document, this.executionSummary, required this.kind, final  LSPObject? metadata}): _metadata = metadata;
  factory _NotebookCell.fromJson(Map<String, dynamic> json) => _$NotebookCellFromJson(json);

/// The URI of the cell's text document content.
@override final  String document;
/// Additional execution summary information if supported by the client.
@override final  ExecutionSummary? executionSummary;
/// The cell's kind
@override final  NotebookCellKind kind;
/// Additional metadata stored with the cell.
/// Note: should always be an object literal (e.g. LSPObject)
 final  LSPObject? _metadata;
/// Additional metadata stored with the cell.
/// Note: should always be an object literal (e.g. LSPObject)
@override LSPObject? get metadata {
  final value = _metadata;
  if (value == null) return null;
  if (_metadata is EqualUnmodifiableMapView) return _metadata;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableMapView(value);
}


/// Create a copy of NotebookCell
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$NotebookCellCopyWith<_NotebookCell> get copyWith => __$NotebookCellCopyWithImpl<_NotebookCell>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$NotebookCellToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _NotebookCell&&(identical(other.document, document) || other.document == document)&&(identical(other.executionSummary, executionSummary) || other.executionSummary == executionSummary)&&(identical(other.kind, kind) || other.kind == kind)&&const DeepCollectionEquality().equals(other._metadata, _metadata));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,document,executionSummary,kind,const DeepCollectionEquality().hash(_metadata));

@override
String toString() {
  return 'NotebookCell(document: $document, executionSummary: $executionSummary, kind: $kind, metadata: $metadata)';
}


}

/// @nodoc
abstract mixin class _$NotebookCellCopyWith<$Res> implements $NotebookCellCopyWith<$Res> {
  factory _$NotebookCellCopyWith(_NotebookCell value, $Res Function(_NotebookCell) _then) = __$NotebookCellCopyWithImpl;
@override @useResult
$Res call({
 String document, ExecutionSummary? executionSummary, NotebookCellKind kind, LSPObject? metadata
});


@override $ExecutionSummaryCopyWith<$Res>? get executionSummary;

}
/// @nodoc
class __$NotebookCellCopyWithImpl<$Res>
    implements _$NotebookCellCopyWith<$Res> {
  __$NotebookCellCopyWithImpl(this._self, this._then);

  final _NotebookCell _self;
  final $Res Function(_NotebookCell) _then;

/// Create a copy of NotebookCell
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? document = null,Object? executionSummary = freezed,Object? kind = null,Object? metadata = freezed,}) {
  return _then(_NotebookCell(
document: null == document ? _self.document : document // ignore: cast_nullable_to_non_nullable
as String,executionSummary: freezed == executionSummary ? _self.executionSummary : executionSummary // ignore: cast_nullable_to_non_nullable
as ExecutionSummary?,kind: null == kind ? _self.kind : kind // ignore: cast_nullable_to_non_nullable
as NotebookCellKind,metadata: freezed == metadata ? _self._metadata : metadata // ignore: cast_nullable_to_non_nullable
as LSPObject?,
  ));
}

/// Create a copy of NotebookCell
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ExecutionSummaryCopyWith<$Res>? get executionSummary {
    if (_self.executionSummary == null) {
    return null;
  }

  return $ExecutionSummaryCopyWith<$Res>(_self.executionSummary!, (value) {
    return _then(_self.copyWith(executionSummary: value));
  });
}
}


/// @nodoc
mixin _$NotebookCellArrayChange {

/// The new cells, if any
 List<NotebookCell>? get cells;/// The deleted cells
 int get deleteCount;/// The start oftest of the cell that changed.
 int get start;
/// Create a copy of NotebookCellArrayChange
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$NotebookCellArrayChangeCopyWith<NotebookCellArrayChange> get copyWith => _$NotebookCellArrayChangeCopyWithImpl<NotebookCellArrayChange>(this as NotebookCellArrayChange, _$identity);

  /// Serializes this NotebookCellArrayChange to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is NotebookCellArrayChange&&const DeepCollectionEquality().equals(other.cells, cells)&&(identical(other.deleteCount, deleteCount) || other.deleteCount == deleteCount)&&(identical(other.start, start) || other.start == start));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(cells),deleteCount,start);

@override
String toString() {
  return 'NotebookCellArrayChange(cells: $cells, deleteCount: $deleteCount, start: $start)';
}


}

/// @nodoc
abstract mixin class $NotebookCellArrayChangeCopyWith<$Res>  {
  factory $NotebookCellArrayChangeCopyWith(NotebookCellArrayChange value, $Res Function(NotebookCellArrayChange) _then) = _$NotebookCellArrayChangeCopyWithImpl;
@useResult
$Res call({
 List<NotebookCell>? cells, int deleteCount, int start
});




}
/// @nodoc
class _$NotebookCellArrayChangeCopyWithImpl<$Res>
    implements $NotebookCellArrayChangeCopyWith<$Res> {
  _$NotebookCellArrayChangeCopyWithImpl(this._self, this._then);

  final NotebookCellArrayChange _self;
  final $Res Function(NotebookCellArrayChange) _then;

/// Create a copy of NotebookCellArrayChange
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? cells = freezed,Object? deleteCount = null,Object? start = null,}) {
  return _then(_self.copyWith(
cells: freezed == cells ? _self.cells : cells // ignore: cast_nullable_to_non_nullable
as List<NotebookCell>?,deleteCount: null == deleteCount ? _self.deleteCount : deleteCount // ignore: cast_nullable_to_non_nullable
as int,start: null == start ? _self.start : start // ignore: cast_nullable_to_non_nullable
as int,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _NotebookCellArrayChange implements NotebookCellArrayChange {
  const _NotebookCellArrayChange({final  List<NotebookCell>? cells, required this.deleteCount, required this.start}): _cells = cells;
  factory _NotebookCellArrayChange.fromJson(Map<String, dynamic> json) => _$NotebookCellArrayChangeFromJson(json);

/// The new cells, if any
 final  List<NotebookCell>? _cells;
/// The new cells, if any
@override List<NotebookCell>? get cells {
  final value = _cells;
  if (value == null) return null;
  if (_cells is EqualUnmodifiableListView) return _cells;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

/// The deleted cells
@override final  int deleteCount;
/// The start oftest of the cell that changed.
@override final  int start;

/// Create a copy of NotebookCellArrayChange
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$NotebookCellArrayChangeCopyWith<_NotebookCellArrayChange> get copyWith => __$NotebookCellArrayChangeCopyWithImpl<_NotebookCellArrayChange>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$NotebookCellArrayChangeToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _NotebookCellArrayChange&&const DeepCollectionEquality().equals(other._cells, _cells)&&(identical(other.deleteCount, deleteCount) || other.deleteCount == deleteCount)&&(identical(other.start, start) || other.start == start));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_cells),deleteCount,start);

@override
String toString() {
  return 'NotebookCellArrayChange(cells: $cells, deleteCount: $deleteCount, start: $start)';
}


}

/// @nodoc
abstract mixin class _$NotebookCellArrayChangeCopyWith<$Res> implements $NotebookCellArrayChangeCopyWith<$Res> {
  factory _$NotebookCellArrayChangeCopyWith(_NotebookCellArrayChange value, $Res Function(_NotebookCellArrayChange) _then) = __$NotebookCellArrayChangeCopyWithImpl;
@override @useResult
$Res call({
 List<NotebookCell>? cells, int deleteCount, int start
});




}
/// @nodoc
class __$NotebookCellArrayChangeCopyWithImpl<$Res>
    implements _$NotebookCellArrayChangeCopyWith<$Res> {
  __$NotebookCellArrayChangeCopyWithImpl(this._self, this._then);

  final _NotebookCellArrayChange _self;
  final $Res Function(_NotebookCellArrayChange) _then;

/// Create a copy of NotebookCellArrayChange
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? cells = freezed,Object? deleteCount = null,Object? start = null,}) {
  return _then(_NotebookCellArrayChange(
cells: freezed == cells ? _self._cells : cells // ignore: cast_nullable_to_non_nullable
as List<NotebookCell>?,deleteCount: null == deleteCount ? _self.deleteCount : deleteCount // ignore: cast_nullable_to_non_nullable
as int,start: null == start ? _self.start : start // ignore: cast_nullable_to_non_nullable
as int,
  ));
}


}


/// @nodoc
mixin _$SelectedCompletionInfo {

/// The range that will be replaced if this completion item is accepted.
 Range get range;/// The text the range will be replaced with if this completion is accepted.
 String get text;
/// Create a copy of SelectedCompletionInfo
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SelectedCompletionInfoCopyWith<SelectedCompletionInfo> get copyWith => _$SelectedCompletionInfoCopyWithImpl<SelectedCompletionInfo>(this as SelectedCompletionInfo, _$identity);

  /// Serializes this SelectedCompletionInfo to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SelectedCompletionInfo&&(identical(other.range, range) || other.range == range)&&(identical(other.text, text) || other.text == text));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,range,text);

@override
String toString() {
  return 'SelectedCompletionInfo(range: $range, text: $text)';
}


}

/// @nodoc
abstract mixin class $SelectedCompletionInfoCopyWith<$Res>  {
  factory $SelectedCompletionInfoCopyWith(SelectedCompletionInfo value, $Res Function(SelectedCompletionInfo) _then) = _$SelectedCompletionInfoCopyWithImpl;
@useResult
$Res call({
 Range range, String text
});


$RangeCopyWith<$Res> get range;

}
/// @nodoc
class _$SelectedCompletionInfoCopyWithImpl<$Res>
    implements $SelectedCompletionInfoCopyWith<$Res> {
  _$SelectedCompletionInfoCopyWithImpl(this._self, this._then);

  final SelectedCompletionInfo _self;
  final $Res Function(SelectedCompletionInfo) _then;

/// Create a copy of SelectedCompletionInfo
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? range = null,Object? text = null,}) {
  return _then(_self.copyWith(
range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,text: null == text ? _self.text : text // ignore: cast_nullable_to_non_nullable
as String,
  ));
}
/// Create a copy of SelectedCompletionInfo
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _SelectedCompletionInfo implements SelectedCompletionInfo {
  const _SelectedCompletionInfo({required this.range, required this.text});
  factory _SelectedCompletionInfo.fromJson(Map<String, dynamic> json) => _$SelectedCompletionInfoFromJson(json);

/// The range that will be replaced if this completion item is accepted.
@override final  Range range;
/// The text the range will be replaced with if this completion is accepted.
@override final  String text;

/// Create a copy of SelectedCompletionInfo
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SelectedCompletionInfoCopyWith<_SelectedCompletionInfo> get copyWith => __$SelectedCompletionInfoCopyWithImpl<_SelectedCompletionInfo>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SelectedCompletionInfoToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SelectedCompletionInfo&&(identical(other.range, range) || other.range == range)&&(identical(other.text, text) || other.text == text));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,range,text);

@override
String toString() {
  return 'SelectedCompletionInfo(range: $range, text: $text)';
}


}

/// @nodoc
abstract mixin class _$SelectedCompletionInfoCopyWith<$Res> implements $SelectedCompletionInfoCopyWith<$Res> {
  factory _$SelectedCompletionInfoCopyWith(_SelectedCompletionInfo value, $Res Function(_SelectedCompletionInfo) _then) = __$SelectedCompletionInfoCopyWithImpl;
@override @useResult
$Res call({
 Range range, String text
});


@override $RangeCopyWith<$Res> get range;

}
/// @nodoc
class __$SelectedCompletionInfoCopyWithImpl<$Res>
    implements _$SelectedCompletionInfoCopyWith<$Res> {
  __$SelectedCompletionInfoCopyWithImpl(this._self, this._then);

  final _SelectedCompletionInfo _self;
  final $Res Function(_SelectedCompletionInfo) _then;

/// Create a copy of SelectedCompletionInfo
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? range = null,Object? text = null,}) {
  return _then(_SelectedCompletionInfo(
range: null == range ? _self.range : range // ignore: cast_nullable_to_non_nullable
as Range,text: null == text ? _self.text : text // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

/// Create a copy of SelectedCompletionInfo
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RangeCopyWith<$Res> get range {
  
  return $RangeCopyWith<$Res>(_self.range, (value) {
    return _then(_self.copyWith(range: value));
  });
}
}


/// @nodoc
mixin _$ClientCapabilities {

/// Experimental client capabilities.
 LSPAny? get experimental;/// General client capabilities.
/// @since 3.16.0
 GeneralClientCapabilities? get general;/// Capabilities specific to the notebook document support.
/// @since 3.17.0
 NotebookDocumentClientCapabilities? get notebookDocument;/// Text document specific client capabilities.
 TextDocumentClientCapabilities? get textDocument;/// Window specific client capabilities.
 WindowClientCapabilities? get window;/// Workspace specific client capabilities.
 WorkspaceClientCapabilities? get workspace;
/// Create a copy of ClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ClientCapabilitiesCopyWith<ClientCapabilities> get copyWith => _$ClientCapabilitiesCopyWithImpl<ClientCapabilities>(this as ClientCapabilities, _$identity);

  /// Serializes this ClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ClientCapabilities&&(identical(other.experimental, experimental) || other.experimental == experimental)&&(identical(other.general, general) || other.general == general)&&(identical(other.notebookDocument, notebookDocument) || other.notebookDocument == notebookDocument)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.window, window) || other.window == window)&&(identical(other.workspace, workspace) || other.workspace == workspace));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,experimental,general,notebookDocument,textDocument,window,workspace);

@override
String toString() {
  return 'ClientCapabilities(experimental: $experimental, general: $general, notebookDocument: $notebookDocument, textDocument: $textDocument, window: $window, workspace: $workspace)';
}


}

/// @nodoc
abstract mixin class $ClientCapabilitiesCopyWith<$Res>  {
  factory $ClientCapabilitiesCopyWith(ClientCapabilities value, $Res Function(ClientCapabilities) _then) = _$ClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 LSPAny? experimental, GeneralClientCapabilities? general, NotebookDocumentClientCapabilities? notebookDocument, TextDocumentClientCapabilities? textDocument, WindowClientCapabilities? window, WorkspaceClientCapabilities? workspace
});


$GeneralClientCapabilitiesCopyWith<$Res>? get general;$NotebookDocumentClientCapabilitiesCopyWith<$Res>? get notebookDocument;$TextDocumentClientCapabilitiesCopyWith<$Res>? get textDocument;$WindowClientCapabilitiesCopyWith<$Res>? get window;$WorkspaceClientCapabilitiesCopyWith<$Res>? get workspace;

}
/// @nodoc
class _$ClientCapabilitiesCopyWithImpl<$Res>
    implements $ClientCapabilitiesCopyWith<$Res> {
  _$ClientCapabilitiesCopyWithImpl(this._self, this._then);

  final ClientCapabilities _self;
  final $Res Function(ClientCapabilities) _then;

/// Create a copy of ClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? experimental = freezed,Object? general = freezed,Object? notebookDocument = freezed,Object? textDocument = freezed,Object? window = freezed,Object? workspace = freezed,}) {
  return _then(_self.copyWith(
experimental: freezed == experimental ? _self.experimental : experimental // ignore: cast_nullable_to_non_nullable
as LSPAny?,general: freezed == general ? _self.general : general // ignore: cast_nullable_to_non_nullable
as GeneralClientCapabilities?,notebookDocument: freezed == notebookDocument ? _self.notebookDocument : notebookDocument // ignore: cast_nullable_to_non_nullable
as NotebookDocumentClientCapabilities?,textDocument: freezed == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentClientCapabilities?,window: freezed == window ? _self.window : window // ignore: cast_nullable_to_non_nullable
as WindowClientCapabilities?,workspace: freezed == workspace ? _self.workspace : workspace // ignore: cast_nullable_to_non_nullable
as WorkspaceClientCapabilities?,
  ));
}
/// Create a copy of ClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$GeneralClientCapabilitiesCopyWith<$Res>? get general {
    if (_self.general == null) {
    return null;
  }

  return $GeneralClientCapabilitiesCopyWith<$Res>(_self.general!, (value) {
    return _then(_self.copyWith(general: value));
  });
}/// Create a copy of ClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$NotebookDocumentClientCapabilitiesCopyWith<$Res>? get notebookDocument {
    if (_self.notebookDocument == null) {
    return null;
  }

  return $NotebookDocumentClientCapabilitiesCopyWith<$Res>(_self.notebookDocument!, (value) {
    return _then(_self.copyWith(notebookDocument: value));
  });
}/// Create a copy of ClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentClientCapabilitiesCopyWith<$Res>? get textDocument {
    if (_self.textDocument == null) {
    return null;
  }

  return $TextDocumentClientCapabilitiesCopyWith<$Res>(_self.textDocument!, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of ClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$WindowClientCapabilitiesCopyWith<$Res>? get window {
    if (_self.window == null) {
    return null;
  }

  return $WindowClientCapabilitiesCopyWith<$Res>(_self.window!, (value) {
    return _then(_self.copyWith(window: value));
  });
}/// Create a copy of ClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$WorkspaceClientCapabilitiesCopyWith<$Res>? get workspace {
    if (_self.workspace == null) {
    return null;
  }

  return $WorkspaceClientCapabilitiesCopyWith<$Res>(_self.workspace!, (value) {
    return _then(_self.copyWith(workspace: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _ClientCapabilities implements ClientCapabilities {
  const _ClientCapabilities({this.experimental, this.general, this.notebookDocument, this.textDocument, this.window, this.workspace});
  factory _ClientCapabilities.fromJson(Map<String, dynamic> json) => _$ClientCapabilitiesFromJson(json);

/// Experimental client capabilities.
@override final  LSPAny? experimental;
/// General client capabilities.
/// @since 3.16.0
@override final  GeneralClientCapabilities? general;
/// Capabilities specific to the notebook document support.
/// @since 3.17.0
@override final  NotebookDocumentClientCapabilities? notebookDocument;
/// Text document specific client capabilities.
@override final  TextDocumentClientCapabilities? textDocument;
/// Window specific client capabilities.
@override final  WindowClientCapabilities? window;
/// Workspace specific client capabilities.
@override final  WorkspaceClientCapabilities? workspace;

/// Create a copy of ClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ClientCapabilitiesCopyWith<_ClientCapabilities> get copyWith => __$ClientCapabilitiesCopyWithImpl<_ClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ClientCapabilities&&(identical(other.experimental, experimental) || other.experimental == experimental)&&(identical(other.general, general) || other.general == general)&&(identical(other.notebookDocument, notebookDocument) || other.notebookDocument == notebookDocument)&&(identical(other.textDocument, textDocument) || other.textDocument == textDocument)&&(identical(other.window, window) || other.window == window)&&(identical(other.workspace, workspace) || other.workspace == workspace));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,experimental,general,notebookDocument,textDocument,window,workspace);

@override
String toString() {
  return 'ClientCapabilities(experimental: $experimental, general: $general, notebookDocument: $notebookDocument, textDocument: $textDocument, window: $window, workspace: $workspace)';
}


}

/// @nodoc
abstract mixin class _$ClientCapabilitiesCopyWith<$Res> implements $ClientCapabilitiesCopyWith<$Res> {
  factory _$ClientCapabilitiesCopyWith(_ClientCapabilities value, $Res Function(_ClientCapabilities) _then) = __$ClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 LSPAny? experimental, GeneralClientCapabilities? general, NotebookDocumentClientCapabilities? notebookDocument, TextDocumentClientCapabilities? textDocument, WindowClientCapabilities? window, WorkspaceClientCapabilities? workspace
});


@override $GeneralClientCapabilitiesCopyWith<$Res>? get general;@override $NotebookDocumentClientCapabilitiesCopyWith<$Res>? get notebookDocument;@override $TextDocumentClientCapabilitiesCopyWith<$Res>? get textDocument;@override $WindowClientCapabilitiesCopyWith<$Res>? get window;@override $WorkspaceClientCapabilitiesCopyWith<$Res>? get workspace;

}
/// @nodoc
class __$ClientCapabilitiesCopyWithImpl<$Res>
    implements _$ClientCapabilitiesCopyWith<$Res> {
  __$ClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _ClientCapabilities _self;
  final $Res Function(_ClientCapabilities) _then;

/// Create a copy of ClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? experimental = freezed,Object? general = freezed,Object? notebookDocument = freezed,Object? textDocument = freezed,Object? window = freezed,Object? workspace = freezed,}) {
  return _then(_ClientCapabilities(
experimental: freezed == experimental ? _self.experimental : experimental // ignore: cast_nullable_to_non_nullable
as LSPAny?,general: freezed == general ? _self.general : general // ignore: cast_nullable_to_non_nullable
as GeneralClientCapabilities?,notebookDocument: freezed == notebookDocument ? _self.notebookDocument : notebookDocument // ignore: cast_nullable_to_non_nullable
as NotebookDocumentClientCapabilities?,textDocument: freezed == textDocument ? _self.textDocument : textDocument // ignore: cast_nullable_to_non_nullable
as TextDocumentClientCapabilities?,window: freezed == window ? _self.window : window // ignore: cast_nullable_to_non_nullable
as WindowClientCapabilities?,workspace: freezed == workspace ? _self.workspace : workspace // ignore: cast_nullable_to_non_nullable
as WorkspaceClientCapabilities?,
  ));
}

/// Create a copy of ClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$GeneralClientCapabilitiesCopyWith<$Res>? get general {
    if (_self.general == null) {
    return null;
  }

  return $GeneralClientCapabilitiesCopyWith<$Res>(_self.general!, (value) {
    return _then(_self.copyWith(general: value));
  });
}/// Create a copy of ClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$NotebookDocumentClientCapabilitiesCopyWith<$Res>? get notebookDocument {
    if (_self.notebookDocument == null) {
    return null;
  }

  return $NotebookDocumentClientCapabilitiesCopyWith<$Res>(_self.notebookDocument!, (value) {
    return _then(_self.copyWith(notebookDocument: value));
  });
}/// Create a copy of ClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentClientCapabilitiesCopyWith<$Res>? get textDocument {
    if (_self.textDocument == null) {
    return null;
  }

  return $TextDocumentClientCapabilitiesCopyWith<$Res>(_self.textDocument!, (value) {
    return _then(_self.copyWith(textDocument: value));
  });
}/// Create a copy of ClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$WindowClientCapabilitiesCopyWith<$Res>? get window {
    if (_self.window == null) {
    return null;
  }

  return $WindowClientCapabilitiesCopyWith<$Res>(_self.window!, (value) {
    return _then(_self.copyWith(window: value));
  });
}/// Create a copy of ClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$WorkspaceClientCapabilitiesCopyWith<$Res>? get workspace {
    if (_self.workspace == null) {
    return null;
  }

  return $WorkspaceClientCapabilitiesCopyWith<$Res>(_self.workspace!, (value) {
    return _then(_self.copyWith(workspace: value));
  });
}
}


/// @nodoc
mixin _$TextDocumentSyncOptions {

/// Change notifications are sent to the server. See
/// TextDocumentSyncKind.None, TextDocumentSyncKind.Full and
/// TextDocumentSyncKind.Incremental. If omitted it defaults to
/// TextDocumentSyncKind.None.
 TextDocumentSyncKind? get change;/// Open and close notifications are sent to the server. If omitted open
/// close notification should not be sent.
 bool? get openClose;/// If present save notifications are sent to the server. If omitted the
/// notification should not be sent.
 Sealed58? get save;/// If present will save notifications are sent to the server. If omitted
/// the notification should not be sent.
 bool? get willSave;/// If present will save wait until requests are sent to the server. If
/// omitted the request should not be sent.
 bool? get willSaveWaitUntil;
/// Create a copy of TextDocumentSyncOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TextDocumentSyncOptionsCopyWith<TextDocumentSyncOptions> get copyWith => _$TextDocumentSyncOptionsCopyWithImpl<TextDocumentSyncOptions>(this as TextDocumentSyncOptions, _$identity);

  /// Serializes this TextDocumentSyncOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TextDocumentSyncOptions&&(identical(other.change, change) || other.change == change)&&(identical(other.openClose, openClose) || other.openClose == openClose)&&(identical(other.save, save) || other.save == save)&&(identical(other.willSave, willSave) || other.willSave == willSave)&&(identical(other.willSaveWaitUntil, willSaveWaitUntil) || other.willSaveWaitUntil == willSaveWaitUntil));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,change,openClose,save,willSave,willSaveWaitUntil);

@override
String toString() {
  return 'TextDocumentSyncOptions(change: $change, openClose: $openClose, save: $save, willSave: $willSave, willSaveWaitUntil: $willSaveWaitUntil)';
}


}

/// @nodoc
abstract mixin class $TextDocumentSyncOptionsCopyWith<$Res>  {
  factory $TextDocumentSyncOptionsCopyWith(TextDocumentSyncOptions value, $Res Function(TextDocumentSyncOptions) _then) = _$TextDocumentSyncOptionsCopyWithImpl;
@useResult
$Res call({
 TextDocumentSyncKind? change, bool? openClose, Sealed58? save, bool? willSave, bool? willSaveWaitUntil
});




}
/// @nodoc
class _$TextDocumentSyncOptionsCopyWithImpl<$Res>
    implements $TextDocumentSyncOptionsCopyWith<$Res> {
  _$TextDocumentSyncOptionsCopyWithImpl(this._self, this._then);

  final TextDocumentSyncOptions _self;
  final $Res Function(TextDocumentSyncOptions) _then;

/// Create a copy of TextDocumentSyncOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? change = freezed,Object? openClose = freezed,Object? save = freezed,Object? willSave = freezed,Object? willSaveWaitUntil = freezed,}) {
  return _then(_self.copyWith(
change: freezed == change ? _self.change : change // ignore: cast_nullable_to_non_nullable
as TextDocumentSyncKind?,openClose: freezed == openClose ? _self.openClose : openClose // ignore: cast_nullable_to_non_nullable
as bool?,save: freezed == save ? _self.save : save // ignore: cast_nullable_to_non_nullable
as Sealed58?,willSave: freezed == willSave ? _self.willSave : willSave // ignore: cast_nullable_to_non_nullable
as bool?,willSaveWaitUntil: freezed == willSaveWaitUntil ? _self.willSaveWaitUntil : willSaveWaitUntil // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _TextDocumentSyncOptions implements TextDocumentSyncOptions {
  const _TextDocumentSyncOptions({this.change, this.openClose, this.save, this.willSave, this.willSaveWaitUntil});
  factory _TextDocumentSyncOptions.fromJson(Map<String, dynamic> json) => _$TextDocumentSyncOptionsFromJson(json);

/// Change notifications are sent to the server. See
/// TextDocumentSyncKind.None, TextDocumentSyncKind.Full and
/// TextDocumentSyncKind.Incremental. If omitted it defaults to
/// TextDocumentSyncKind.None.
@override final  TextDocumentSyncKind? change;
/// Open and close notifications are sent to the server. If omitted open
/// close notification should not be sent.
@override final  bool? openClose;
/// If present save notifications are sent to the server. If omitted the
/// notification should not be sent.
@override final  Sealed58? save;
/// If present will save notifications are sent to the server. If omitted
/// the notification should not be sent.
@override final  bool? willSave;
/// If present will save wait until requests are sent to the server. If
/// omitted the request should not be sent.
@override final  bool? willSaveWaitUntil;

/// Create a copy of TextDocumentSyncOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TextDocumentSyncOptionsCopyWith<_TextDocumentSyncOptions> get copyWith => __$TextDocumentSyncOptionsCopyWithImpl<_TextDocumentSyncOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TextDocumentSyncOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TextDocumentSyncOptions&&(identical(other.change, change) || other.change == change)&&(identical(other.openClose, openClose) || other.openClose == openClose)&&(identical(other.save, save) || other.save == save)&&(identical(other.willSave, willSave) || other.willSave == willSave)&&(identical(other.willSaveWaitUntil, willSaveWaitUntil) || other.willSaveWaitUntil == willSaveWaitUntil));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,change,openClose,save,willSave,willSaveWaitUntil);

@override
String toString() {
  return 'TextDocumentSyncOptions(change: $change, openClose: $openClose, save: $save, willSave: $willSave, willSaveWaitUntil: $willSaveWaitUntil)';
}


}

/// @nodoc
abstract mixin class _$TextDocumentSyncOptionsCopyWith<$Res> implements $TextDocumentSyncOptionsCopyWith<$Res> {
  factory _$TextDocumentSyncOptionsCopyWith(_TextDocumentSyncOptions value, $Res Function(_TextDocumentSyncOptions) _then) = __$TextDocumentSyncOptionsCopyWithImpl;
@override @useResult
$Res call({
 TextDocumentSyncKind? change, bool? openClose, Sealed58? save, bool? willSave, bool? willSaveWaitUntil
});




}
/// @nodoc
class __$TextDocumentSyncOptionsCopyWithImpl<$Res>
    implements _$TextDocumentSyncOptionsCopyWith<$Res> {
  __$TextDocumentSyncOptionsCopyWithImpl(this._self, this._then);

  final _TextDocumentSyncOptions _self;
  final $Res Function(_TextDocumentSyncOptions) _then;

/// Create a copy of TextDocumentSyncOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? change = freezed,Object? openClose = freezed,Object? save = freezed,Object? willSave = freezed,Object? willSaveWaitUntil = freezed,}) {
  return _then(_TextDocumentSyncOptions(
change: freezed == change ? _self.change : change // ignore: cast_nullable_to_non_nullable
as TextDocumentSyncKind?,openClose: freezed == openClose ? _self.openClose : openClose // ignore: cast_nullable_to_non_nullable
as bool?,save: freezed == save ? _self.save : save // ignore: cast_nullable_to_non_nullable
as Sealed58?,willSave: freezed == willSave ? _self.willSave : willSave // ignore: cast_nullable_to_non_nullable
as bool?,willSaveWaitUntil: freezed == willSaveWaitUntil ? _self.willSaveWaitUntil : willSaveWaitUntil // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$NotebookDocumentSyncOptions {

/// The notebooks to be synced
 List<Sealed59> get notebookSelector;/// Whether save notification should be forwarded to the server. Will only
/// be honored if mode === `notebook`.
 bool? get save;
/// Create a copy of NotebookDocumentSyncOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$NotebookDocumentSyncOptionsCopyWith<NotebookDocumentSyncOptions> get copyWith => _$NotebookDocumentSyncOptionsCopyWithImpl<NotebookDocumentSyncOptions>(this as NotebookDocumentSyncOptions, _$identity);

  /// Serializes this NotebookDocumentSyncOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is NotebookDocumentSyncOptions&&const DeepCollectionEquality().equals(other.notebookSelector, notebookSelector)&&(identical(other.save, save) || other.save == save));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(notebookSelector),save);

@override
String toString() {
  return 'NotebookDocumentSyncOptions(notebookSelector: $notebookSelector, save: $save)';
}


}

/// @nodoc
abstract mixin class $NotebookDocumentSyncOptionsCopyWith<$Res>  {
  factory $NotebookDocumentSyncOptionsCopyWith(NotebookDocumentSyncOptions value, $Res Function(NotebookDocumentSyncOptions) _then) = _$NotebookDocumentSyncOptionsCopyWithImpl;
@useResult
$Res call({
 List<Sealed59> notebookSelector, bool? save
});




}
/// @nodoc
class _$NotebookDocumentSyncOptionsCopyWithImpl<$Res>
    implements $NotebookDocumentSyncOptionsCopyWith<$Res> {
  _$NotebookDocumentSyncOptionsCopyWithImpl(this._self, this._then);

  final NotebookDocumentSyncOptions _self;
  final $Res Function(NotebookDocumentSyncOptions) _then;

/// Create a copy of NotebookDocumentSyncOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? notebookSelector = null,Object? save = freezed,}) {
  return _then(_self.copyWith(
notebookSelector: null == notebookSelector ? _self.notebookSelector : notebookSelector // ignore: cast_nullable_to_non_nullable
as List<Sealed59>,save: freezed == save ? _self.save : save // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _NotebookDocumentSyncOptions implements NotebookDocumentSyncOptions {
  const _NotebookDocumentSyncOptions({required final  List<Sealed59> notebookSelector, this.save}): _notebookSelector = notebookSelector;
  factory _NotebookDocumentSyncOptions.fromJson(Map<String, dynamic> json) => _$NotebookDocumentSyncOptionsFromJson(json);

/// The notebooks to be synced
 final  List<Sealed59> _notebookSelector;
/// The notebooks to be synced
@override List<Sealed59> get notebookSelector {
  if (_notebookSelector is EqualUnmodifiableListView) return _notebookSelector;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_notebookSelector);
}

/// Whether save notification should be forwarded to the server. Will only
/// be honored if mode === `notebook`.
@override final  bool? save;

/// Create a copy of NotebookDocumentSyncOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$NotebookDocumentSyncOptionsCopyWith<_NotebookDocumentSyncOptions> get copyWith => __$NotebookDocumentSyncOptionsCopyWithImpl<_NotebookDocumentSyncOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$NotebookDocumentSyncOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _NotebookDocumentSyncOptions&&const DeepCollectionEquality().equals(other._notebookSelector, _notebookSelector)&&(identical(other.save, save) || other.save == save));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_notebookSelector),save);

@override
String toString() {
  return 'NotebookDocumentSyncOptions(notebookSelector: $notebookSelector, save: $save)';
}


}

/// @nodoc
abstract mixin class _$NotebookDocumentSyncOptionsCopyWith<$Res> implements $NotebookDocumentSyncOptionsCopyWith<$Res> {
  factory _$NotebookDocumentSyncOptionsCopyWith(_NotebookDocumentSyncOptions value, $Res Function(_NotebookDocumentSyncOptions) _then) = __$NotebookDocumentSyncOptionsCopyWithImpl;
@override @useResult
$Res call({
 List<Sealed59> notebookSelector, bool? save
});




}
/// @nodoc
class __$NotebookDocumentSyncOptionsCopyWithImpl<$Res>
    implements _$NotebookDocumentSyncOptionsCopyWith<$Res> {
  __$NotebookDocumentSyncOptionsCopyWithImpl(this._self, this._then);

  final _NotebookDocumentSyncOptions _self;
  final $Res Function(_NotebookDocumentSyncOptions) _then;

/// Create a copy of NotebookDocumentSyncOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? notebookSelector = null,Object? save = freezed,}) {
  return _then(_NotebookDocumentSyncOptions(
notebookSelector: null == notebookSelector ? _self._notebookSelector : notebookSelector // ignore: cast_nullable_to_non_nullable
as List<Sealed59>,save: freezed == save ? _self.save : save // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$NotebookDocumentSyncRegistrationOptions {

/// The id used to register the request. The id can be used to deregister
/// the request again. See also Registration#id.
 String? get id;/// The notebooks to be synced
 List<Sealed59> get notebookSelector;/// Whether save notification should be forwarded to the server. Will only
/// be honored if mode === `notebook`.
 bool? get save;
/// Create a copy of NotebookDocumentSyncRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$NotebookDocumentSyncRegistrationOptionsCopyWith<NotebookDocumentSyncRegistrationOptions> get copyWith => _$NotebookDocumentSyncRegistrationOptionsCopyWithImpl<NotebookDocumentSyncRegistrationOptions>(this as NotebookDocumentSyncRegistrationOptions, _$identity);

  /// Serializes this NotebookDocumentSyncRegistrationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is NotebookDocumentSyncRegistrationOptions&&(identical(other.id, id) || other.id == id)&&const DeepCollectionEquality().equals(other.notebookSelector, notebookSelector)&&(identical(other.save, save) || other.save == save));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,const DeepCollectionEquality().hash(notebookSelector),save);

@override
String toString() {
  return 'NotebookDocumentSyncRegistrationOptions(id: $id, notebookSelector: $notebookSelector, save: $save)';
}


}

/// @nodoc
abstract mixin class $NotebookDocumentSyncRegistrationOptionsCopyWith<$Res>  {
  factory $NotebookDocumentSyncRegistrationOptionsCopyWith(NotebookDocumentSyncRegistrationOptions value, $Res Function(NotebookDocumentSyncRegistrationOptions) _then) = _$NotebookDocumentSyncRegistrationOptionsCopyWithImpl;
@useResult
$Res call({
 String? id, List<Sealed59> notebookSelector, bool? save
});




}
/// @nodoc
class _$NotebookDocumentSyncRegistrationOptionsCopyWithImpl<$Res>
    implements $NotebookDocumentSyncRegistrationOptionsCopyWith<$Res> {
  _$NotebookDocumentSyncRegistrationOptionsCopyWithImpl(this._self, this._then);

  final NotebookDocumentSyncRegistrationOptions _self;
  final $Res Function(NotebookDocumentSyncRegistrationOptions) _then;

/// Create a copy of NotebookDocumentSyncRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = freezed,Object? notebookSelector = null,Object? save = freezed,}) {
  return _then(_self.copyWith(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,notebookSelector: null == notebookSelector ? _self.notebookSelector : notebookSelector // ignore: cast_nullable_to_non_nullable
as List<Sealed59>,save: freezed == save ? _self.save : save // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _NotebookDocumentSyncRegistrationOptions implements NotebookDocumentSyncRegistrationOptions {
  const _NotebookDocumentSyncRegistrationOptions({this.id, required final  List<Sealed59> notebookSelector, this.save}): _notebookSelector = notebookSelector;
  factory _NotebookDocumentSyncRegistrationOptions.fromJson(Map<String, dynamic> json) => _$NotebookDocumentSyncRegistrationOptionsFromJson(json);

/// The id used to register the request. The id can be used to deregister
/// the request again. See also Registration#id.
@override final  String? id;
/// The notebooks to be synced
 final  List<Sealed59> _notebookSelector;
/// The notebooks to be synced
@override List<Sealed59> get notebookSelector {
  if (_notebookSelector is EqualUnmodifiableListView) return _notebookSelector;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_notebookSelector);
}

/// Whether save notification should be forwarded to the server. Will only
/// be honored if mode === `notebook`.
@override final  bool? save;

/// Create a copy of NotebookDocumentSyncRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$NotebookDocumentSyncRegistrationOptionsCopyWith<_NotebookDocumentSyncRegistrationOptions> get copyWith => __$NotebookDocumentSyncRegistrationOptionsCopyWithImpl<_NotebookDocumentSyncRegistrationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$NotebookDocumentSyncRegistrationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _NotebookDocumentSyncRegistrationOptions&&(identical(other.id, id) || other.id == id)&&const DeepCollectionEquality().equals(other._notebookSelector, _notebookSelector)&&(identical(other.save, save) || other.save == save));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,id,const DeepCollectionEquality().hash(_notebookSelector),save);

@override
String toString() {
  return 'NotebookDocumentSyncRegistrationOptions(id: $id, notebookSelector: $notebookSelector, save: $save)';
}


}

/// @nodoc
abstract mixin class _$NotebookDocumentSyncRegistrationOptionsCopyWith<$Res> implements $NotebookDocumentSyncRegistrationOptionsCopyWith<$Res> {
  factory _$NotebookDocumentSyncRegistrationOptionsCopyWith(_NotebookDocumentSyncRegistrationOptions value, $Res Function(_NotebookDocumentSyncRegistrationOptions) _then) = __$NotebookDocumentSyncRegistrationOptionsCopyWithImpl;
@override @useResult
$Res call({
 String? id, List<Sealed59> notebookSelector, bool? save
});




}
/// @nodoc
class __$NotebookDocumentSyncRegistrationOptionsCopyWithImpl<$Res>
    implements _$NotebookDocumentSyncRegistrationOptionsCopyWith<$Res> {
  __$NotebookDocumentSyncRegistrationOptionsCopyWithImpl(this._self, this._then);

  final _NotebookDocumentSyncRegistrationOptions _self;
  final $Res Function(_NotebookDocumentSyncRegistrationOptions) _then;

/// Create a copy of NotebookDocumentSyncRegistrationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? id = freezed,Object? notebookSelector = null,Object? save = freezed,}) {
  return _then(_NotebookDocumentSyncRegistrationOptions(
id: freezed == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as String?,notebookSelector: null == notebookSelector ? _self._notebookSelector : notebookSelector // ignore: cast_nullable_to_non_nullable
as List<Sealed59>,save: freezed == save ? _self.save : save // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$WorkspaceFoldersServerCapabilities {

/// Whether the server wants to receive workspace folder change
/// notifications.
/// If a string is provided the string is treated as an ID under which the
/// notification is registered on the client side. The ID can be used to
/// unregister for these events using the `client/unregisterCapability`
/// request.
 Sealed60? get changeNotifications;/// The server has support for workspace folders
 bool? get supported;
/// Create a copy of WorkspaceFoldersServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkspaceFoldersServerCapabilitiesCopyWith<WorkspaceFoldersServerCapabilities> get copyWith => _$WorkspaceFoldersServerCapabilitiesCopyWithImpl<WorkspaceFoldersServerCapabilities>(this as WorkspaceFoldersServerCapabilities, _$identity);

  /// Serializes this WorkspaceFoldersServerCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkspaceFoldersServerCapabilities&&(identical(other.changeNotifications, changeNotifications) || other.changeNotifications == changeNotifications)&&(identical(other.supported, supported) || other.supported == supported));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,changeNotifications,supported);

@override
String toString() {
  return 'WorkspaceFoldersServerCapabilities(changeNotifications: $changeNotifications, supported: $supported)';
}


}

/// @nodoc
abstract mixin class $WorkspaceFoldersServerCapabilitiesCopyWith<$Res>  {
  factory $WorkspaceFoldersServerCapabilitiesCopyWith(WorkspaceFoldersServerCapabilities value, $Res Function(WorkspaceFoldersServerCapabilities) _then) = _$WorkspaceFoldersServerCapabilitiesCopyWithImpl;
@useResult
$Res call({
 Sealed60? changeNotifications, bool? supported
});




}
/// @nodoc
class _$WorkspaceFoldersServerCapabilitiesCopyWithImpl<$Res>
    implements $WorkspaceFoldersServerCapabilitiesCopyWith<$Res> {
  _$WorkspaceFoldersServerCapabilitiesCopyWithImpl(this._self, this._then);

  final WorkspaceFoldersServerCapabilities _self;
  final $Res Function(WorkspaceFoldersServerCapabilities) _then;

/// Create a copy of WorkspaceFoldersServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? changeNotifications = freezed,Object? supported = freezed,}) {
  return _then(_self.copyWith(
changeNotifications: freezed == changeNotifications ? _self.changeNotifications : changeNotifications // ignore: cast_nullable_to_non_nullable
as Sealed60?,supported: freezed == supported ? _self.supported : supported // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _WorkspaceFoldersServerCapabilities implements WorkspaceFoldersServerCapabilities {
  const _WorkspaceFoldersServerCapabilities({this.changeNotifications, this.supported});
  factory _WorkspaceFoldersServerCapabilities.fromJson(Map<String, dynamic> json) => _$WorkspaceFoldersServerCapabilitiesFromJson(json);

/// Whether the server wants to receive workspace folder change
/// notifications.
/// If a string is provided the string is treated as an ID under which the
/// notification is registered on the client side. The ID can be used to
/// unregister for these events using the `client/unregisterCapability`
/// request.
@override final  Sealed60? changeNotifications;
/// The server has support for workspace folders
@override final  bool? supported;

/// Create a copy of WorkspaceFoldersServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkspaceFoldersServerCapabilitiesCopyWith<_WorkspaceFoldersServerCapabilities> get copyWith => __$WorkspaceFoldersServerCapabilitiesCopyWithImpl<_WorkspaceFoldersServerCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkspaceFoldersServerCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkspaceFoldersServerCapabilities&&(identical(other.changeNotifications, changeNotifications) || other.changeNotifications == changeNotifications)&&(identical(other.supported, supported) || other.supported == supported));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,changeNotifications,supported);

@override
String toString() {
  return 'WorkspaceFoldersServerCapabilities(changeNotifications: $changeNotifications, supported: $supported)';
}


}

/// @nodoc
abstract mixin class _$WorkspaceFoldersServerCapabilitiesCopyWith<$Res> implements $WorkspaceFoldersServerCapabilitiesCopyWith<$Res> {
  factory _$WorkspaceFoldersServerCapabilitiesCopyWith(_WorkspaceFoldersServerCapabilities value, $Res Function(_WorkspaceFoldersServerCapabilities) _then) = __$WorkspaceFoldersServerCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 Sealed60? changeNotifications, bool? supported
});




}
/// @nodoc
class __$WorkspaceFoldersServerCapabilitiesCopyWithImpl<$Res>
    implements _$WorkspaceFoldersServerCapabilitiesCopyWith<$Res> {
  __$WorkspaceFoldersServerCapabilitiesCopyWithImpl(this._self, this._then);

  final _WorkspaceFoldersServerCapabilities _self;
  final $Res Function(_WorkspaceFoldersServerCapabilities) _then;

/// Create a copy of WorkspaceFoldersServerCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? changeNotifications = freezed,Object? supported = freezed,}) {
  return _then(_WorkspaceFoldersServerCapabilities(
changeNotifications: freezed == changeNotifications ? _self.changeNotifications : changeNotifications // ignore: cast_nullable_to_non_nullable
as Sealed60?,supported: freezed == supported ? _self.supported : supported // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$FileOperationOptions {

/// The server is interested in receiving didCreateFiles notifications.
 FileOperationRegistrationOptions? get didCreate;/// The server is interested in receiving didDeleteFiles file notifications.
 FileOperationRegistrationOptions? get didDelete;/// The server is interested in receiving didRenameFiles notifications.
 FileOperationRegistrationOptions? get didRename;/// The server is interested in receiving willCreateFiles requests.
 FileOperationRegistrationOptions? get willCreate;/// The server is interested in receiving willDeleteFiles file requests.
 FileOperationRegistrationOptions? get willDelete;/// The server is interested in receiving willRenameFiles requests.
 FileOperationRegistrationOptions? get willRename;
/// Create a copy of FileOperationOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FileOperationOptionsCopyWith<FileOperationOptions> get copyWith => _$FileOperationOptionsCopyWithImpl<FileOperationOptions>(this as FileOperationOptions, _$identity);

  /// Serializes this FileOperationOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FileOperationOptions&&(identical(other.didCreate, didCreate) || other.didCreate == didCreate)&&(identical(other.didDelete, didDelete) || other.didDelete == didDelete)&&(identical(other.didRename, didRename) || other.didRename == didRename)&&(identical(other.willCreate, willCreate) || other.willCreate == willCreate)&&(identical(other.willDelete, willDelete) || other.willDelete == willDelete)&&(identical(other.willRename, willRename) || other.willRename == willRename));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,didCreate,didDelete,didRename,willCreate,willDelete,willRename);

@override
String toString() {
  return 'FileOperationOptions(didCreate: $didCreate, didDelete: $didDelete, didRename: $didRename, willCreate: $willCreate, willDelete: $willDelete, willRename: $willRename)';
}


}

/// @nodoc
abstract mixin class $FileOperationOptionsCopyWith<$Res>  {
  factory $FileOperationOptionsCopyWith(FileOperationOptions value, $Res Function(FileOperationOptions) _then) = _$FileOperationOptionsCopyWithImpl;
@useResult
$Res call({
 FileOperationRegistrationOptions? didCreate, FileOperationRegistrationOptions? didDelete, FileOperationRegistrationOptions? didRename, FileOperationRegistrationOptions? willCreate, FileOperationRegistrationOptions? willDelete, FileOperationRegistrationOptions? willRename
});


$FileOperationRegistrationOptionsCopyWith<$Res>? get didCreate;$FileOperationRegistrationOptionsCopyWith<$Res>? get didDelete;$FileOperationRegistrationOptionsCopyWith<$Res>? get didRename;$FileOperationRegistrationOptionsCopyWith<$Res>? get willCreate;$FileOperationRegistrationOptionsCopyWith<$Res>? get willDelete;$FileOperationRegistrationOptionsCopyWith<$Res>? get willRename;

}
/// @nodoc
class _$FileOperationOptionsCopyWithImpl<$Res>
    implements $FileOperationOptionsCopyWith<$Res> {
  _$FileOperationOptionsCopyWithImpl(this._self, this._then);

  final FileOperationOptions _self;
  final $Res Function(FileOperationOptions) _then;

/// Create a copy of FileOperationOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? didCreate = freezed,Object? didDelete = freezed,Object? didRename = freezed,Object? willCreate = freezed,Object? willDelete = freezed,Object? willRename = freezed,}) {
  return _then(_self.copyWith(
didCreate: freezed == didCreate ? _self.didCreate : didCreate // ignore: cast_nullable_to_non_nullable
as FileOperationRegistrationOptions?,didDelete: freezed == didDelete ? _self.didDelete : didDelete // ignore: cast_nullable_to_non_nullable
as FileOperationRegistrationOptions?,didRename: freezed == didRename ? _self.didRename : didRename // ignore: cast_nullable_to_non_nullable
as FileOperationRegistrationOptions?,willCreate: freezed == willCreate ? _self.willCreate : willCreate // ignore: cast_nullable_to_non_nullable
as FileOperationRegistrationOptions?,willDelete: freezed == willDelete ? _self.willDelete : willDelete // ignore: cast_nullable_to_non_nullable
as FileOperationRegistrationOptions?,willRename: freezed == willRename ? _self.willRename : willRename // ignore: cast_nullable_to_non_nullable
as FileOperationRegistrationOptions?,
  ));
}
/// Create a copy of FileOperationOptions
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FileOperationRegistrationOptionsCopyWith<$Res>? get didCreate {
    if (_self.didCreate == null) {
    return null;
  }

  return $FileOperationRegistrationOptionsCopyWith<$Res>(_self.didCreate!, (value) {
    return _then(_self.copyWith(didCreate: value));
  });
}/// Create a copy of FileOperationOptions
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FileOperationRegistrationOptionsCopyWith<$Res>? get didDelete {
    if (_self.didDelete == null) {
    return null;
  }

  return $FileOperationRegistrationOptionsCopyWith<$Res>(_self.didDelete!, (value) {
    return _then(_self.copyWith(didDelete: value));
  });
}/// Create a copy of FileOperationOptions
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FileOperationRegistrationOptionsCopyWith<$Res>? get didRename {
    if (_self.didRename == null) {
    return null;
  }

  return $FileOperationRegistrationOptionsCopyWith<$Res>(_self.didRename!, (value) {
    return _then(_self.copyWith(didRename: value));
  });
}/// Create a copy of FileOperationOptions
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FileOperationRegistrationOptionsCopyWith<$Res>? get willCreate {
    if (_self.willCreate == null) {
    return null;
  }

  return $FileOperationRegistrationOptionsCopyWith<$Res>(_self.willCreate!, (value) {
    return _then(_self.copyWith(willCreate: value));
  });
}/// Create a copy of FileOperationOptions
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FileOperationRegistrationOptionsCopyWith<$Res>? get willDelete {
    if (_self.willDelete == null) {
    return null;
  }

  return $FileOperationRegistrationOptionsCopyWith<$Res>(_self.willDelete!, (value) {
    return _then(_self.copyWith(willDelete: value));
  });
}/// Create a copy of FileOperationOptions
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FileOperationRegistrationOptionsCopyWith<$Res>? get willRename {
    if (_self.willRename == null) {
    return null;
  }

  return $FileOperationRegistrationOptionsCopyWith<$Res>(_self.willRename!, (value) {
    return _then(_self.copyWith(willRename: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _FileOperationOptions implements FileOperationOptions {
  const _FileOperationOptions({this.didCreate, this.didDelete, this.didRename, this.willCreate, this.willDelete, this.willRename});
  factory _FileOperationOptions.fromJson(Map<String, dynamic> json) => _$FileOperationOptionsFromJson(json);

/// The server is interested in receiving didCreateFiles notifications.
@override final  FileOperationRegistrationOptions? didCreate;
/// The server is interested in receiving didDeleteFiles file notifications.
@override final  FileOperationRegistrationOptions? didDelete;
/// The server is interested in receiving didRenameFiles notifications.
@override final  FileOperationRegistrationOptions? didRename;
/// The server is interested in receiving willCreateFiles requests.
@override final  FileOperationRegistrationOptions? willCreate;
/// The server is interested in receiving willDeleteFiles file requests.
@override final  FileOperationRegistrationOptions? willDelete;
/// The server is interested in receiving willRenameFiles requests.
@override final  FileOperationRegistrationOptions? willRename;

/// Create a copy of FileOperationOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$FileOperationOptionsCopyWith<_FileOperationOptions> get copyWith => __$FileOperationOptionsCopyWithImpl<_FileOperationOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$FileOperationOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _FileOperationOptions&&(identical(other.didCreate, didCreate) || other.didCreate == didCreate)&&(identical(other.didDelete, didDelete) || other.didDelete == didDelete)&&(identical(other.didRename, didRename) || other.didRename == didRename)&&(identical(other.willCreate, willCreate) || other.willCreate == willCreate)&&(identical(other.willDelete, willDelete) || other.willDelete == willDelete)&&(identical(other.willRename, willRename) || other.willRename == willRename));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,didCreate,didDelete,didRename,willCreate,willDelete,willRename);

@override
String toString() {
  return 'FileOperationOptions(didCreate: $didCreate, didDelete: $didDelete, didRename: $didRename, willCreate: $willCreate, willDelete: $willDelete, willRename: $willRename)';
}


}

/// @nodoc
abstract mixin class _$FileOperationOptionsCopyWith<$Res> implements $FileOperationOptionsCopyWith<$Res> {
  factory _$FileOperationOptionsCopyWith(_FileOperationOptions value, $Res Function(_FileOperationOptions) _then) = __$FileOperationOptionsCopyWithImpl;
@override @useResult
$Res call({
 FileOperationRegistrationOptions? didCreate, FileOperationRegistrationOptions? didDelete, FileOperationRegistrationOptions? didRename, FileOperationRegistrationOptions? willCreate, FileOperationRegistrationOptions? willDelete, FileOperationRegistrationOptions? willRename
});


@override $FileOperationRegistrationOptionsCopyWith<$Res>? get didCreate;@override $FileOperationRegistrationOptionsCopyWith<$Res>? get didDelete;@override $FileOperationRegistrationOptionsCopyWith<$Res>? get didRename;@override $FileOperationRegistrationOptionsCopyWith<$Res>? get willCreate;@override $FileOperationRegistrationOptionsCopyWith<$Res>? get willDelete;@override $FileOperationRegistrationOptionsCopyWith<$Res>? get willRename;

}
/// @nodoc
class __$FileOperationOptionsCopyWithImpl<$Res>
    implements _$FileOperationOptionsCopyWith<$Res> {
  __$FileOperationOptionsCopyWithImpl(this._self, this._then);

  final _FileOperationOptions _self;
  final $Res Function(_FileOperationOptions) _then;

/// Create a copy of FileOperationOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? didCreate = freezed,Object? didDelete = freezed,Object? didRename = freezed,Object? willCreate = freezed,Object? willDelete = freezed,Object? willRename = freezed,}) {
  return _then(_FileOperationOptions(
didCreate: freezed == didCreate ? _self.didCreate : didCreate // ignore: cast_nullable_to_non_nullable
as FileOperationRegistrationOptions?,didDelete: freezed == didDelete ? _self.didDelete : didDelete // ignore: cast_nullable_to_non_nullable
as FileOperationRegistrationOptions?,didRename: freezed == didRename ? _self.didRename : didRename // ignore: cast_nullable_to_non_nullable
as FileOperationRegistrationOptions?,willCreate: freezed == willCreate ? _self.willCreate : willCreate // ignore: cast_nullable_to_non_nullable
as FileOperationRegistrationOptions?,willDelete: freezed == willDelete ? _self.willDelete : willDelete // ignore: cast_nullable_to_non_nullable
as FileOperationRegistrationOptions?,willRename: freezed == willRename ? _self.willRename : willRename // ignore: cast_nullable_to_non_nullable
as FileOperationRegistrationOptions?,
  ));
}

/// Create a copy of FileOperationOptions
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FileOperationRegistrationOptionsCopyWith<$Res>? get didCreate {
    if (_self.didCreate == null) {
    return null;
  }

  return $FileOperationRegistrationOptionsCopyWith<$Res>(_self.didCreate!, (value) {
    return _then(_self.copyWith(didCreate: value));
  });
}/// Create a copy of FileOperationOptions
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FileOperationRegistrationOptionsCopyWith<$Res>? get didDelete {
    if (_self.didDelete == null) {
    return null;
  }

  return $FileOperationRegistrationOptionsCopyWith<$Res>(_self.didDelete!, (value) {
    return _then(_self.copyWith(didDelete: value));
  });
}/// Create a copy of FileOperationOptions
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FileOperationRegistrationOptionsCopyWith<$Res>? get didRename {
    if (_self.didRename == null) {
    return null;
  }

  return $FileOperationRegistrationOptionsCopyWith<$Res>(_self.didRename!, (value) {
    return _then(_self.copyWith(didRename: value));
  });
}/// Create a copy of FileOperationOptions
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FileOperationRegistrationOptionsCopyWith<$Res>? get willCreate {
    if (_self.willCreate == null) {
    return null;
  }

  return $FileOperationRegistrationOptionsCopyWith<$Res>(_self.willCreate!, (value) {
    return _then(_self.copyWith(willCreate: value));
  });
}/// Create a copy of FileOperationOptions
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FileOperationRegistrationOptionsCopyWith<$Res>? get willDelete {
    if (_self.willDelete == null) {
    return null;
  }

  return $FileOperationRegistrationOptionsCopyWith<$Res>(_self.willDelete!, (value) {
    return _then(_self.copyWith(willDelete: value));
  });
}/// Create a copy of FileOperationOptions
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FileOperationRegistrationOptionsCopyWith<$Res>? get willRename {
    if (_self.willRename == null) {
    return null;
  }

  return $FileOperationRegistrationOptionsCopyWith<$Res>(_self.willRename!, (value) {
    return _then(_self.copyWith(willRename: value));
  });
}
}


/// @nodoc
mixin _$CodeDescription {

/// An URI to open with more information about the diagnostic error.
 String get href;
/// Create a copy of CodeDescription
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CodeDescriptionCopyWith<CodeDescription> get copyWith => _$CodeDescriptionCopyWithImpl<CodeDescription>(this as CodeDescription, _$identity);

  /// Serializes this CodeDescription to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CodeDescription&&(identical(other.href, href) || other.href == href));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,href);

@override
String toString() {
  return 'CodeDescription(href: $href)';
}


}

/// @nodoc
abstract mixin class $CodeDescriptionCopyWith<$Res>  {
  factory $CodeDescriptionCopyWith(CodeDescription value, $Res Function(CodeDescription) _then) = _$CodeDescriptionCopyWithImpl;
@useResult
$Res call({
 String href
});




}
/// @nodoc
class _$CodeDescriptionCopyWithImpl<$Res>
    implements $CodeDescriptionCopyWith<$Res> {
  _$CodeDescriptionCopyWithImpl(this._self, this._then);

  final CodeDescription _self;
  final $Res Function(CodeDescription) _then;

/// Create a copy of CodeDescription
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? href = null,}) {
  return _then(_self.copyWith(
href: null == href ? _self.href : href // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _CodeDescription implements CodeDescription {
  const _CodeDescription({required this.href});
  factory _CodeDescription.fromJson(Map<String, dynamic> json) => _$CodeDescriptionFromJson(json);

/// An URI to open with more information about the diagnostic error.
@override final  String href;

/// Create a copy of CodeDescription
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CodeDescriptionCopyWith<_CodeDescription> get copyWith => __$CodeDescriptionCopyWithImpl<_CodeDescription>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CodeDescriptionToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CodeDescription&&(identical(other.href, href) || other.href == href));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,href);

@override
String toString() {
  return 'CodeDescription(href: $href)';
}


}

/// @nodoc
abstract mixin class _$CodeDescriptionCopyWith<$Res> implements $CodeDescriptionCopyWith<$Res> {
  factory _$CodeDescriptionCopyWith(_CodeDescription value, $Res Function(_CodeDescription) _then) = __$CodeDescriptionCopyWithImpl;
@override @useResult
$Res call({
 String href
});




}
/// @nodoc
class __$CodeDescriptionCopyWithImpl<$Res>
    implements _$CodeDescriptionCopyWith<$Res> {
  __$CodeDescriptionCopyWithImpl(this._self, this._then);

  final _CodeDescription _self;
  final $Res Function(_CodeDescription) _then;

/// Create a copy of CodeDescription
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? href = null,}) {
  return _then(_CodeDescription(
href: null == href ? _self.href : href // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}


/// @nodoc
mixin _$DiagnosticRelatedInformation {

/// The location of this related diagnostic information.
 Location get location;/// The message of this related diagnostic information.
 String get message;
/// Create a copy of DiagnosticRelatedInformation
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DiagnosticRelatedInformationCopyWith<DiagnosticRelatedInformation> get copyWith => _$DiagnosticRelatedInformationCopyWithImpl<DiagnosticRelatedInformation>(this as DiagnosticRelatedInformation, _$identity);

  /// Serializes this DiagnosticRelatedInformation to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DiagnosticRelatedInformation&&(identical(other.location, location) || other.location == location)&&(identical(other.message, message) || other.message == message));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,location,message);

@override
String toString() {
  return 'DiagnosticRelatedInformation(location: $location, message: $message)';
}


}

/// @nodoc
abstract mixin class $DiagnosticRelatedInformationCopyWith<$Res>  {
  factory $DiagnosticRelatedInformationCopyWith(DiagnosticRelatedInformation value, $Res Function(DiagnosticRelatedInformation) _then) = _$DiagnosticRelatedInformationCopyWithImpl;
@useResult
$Res call({
 Location location, String message
});


$LocationCopyWith<$Res> get location;

}
/// @nodoc
class _$DiagnosticRelatedInformationCopyWithImpl<$Res>
    implements $DiagnosticRelatedInformationCopyWith<$Res> {
  _$DiagnosticRelatedInformationCopyWithImpl(this._self, this._then);

  final DiagnosticRelatedInformation _self;
  final $Res Function(DiagnosticRelatedInformation) _then;

/// Create a copy of DiagnosticRelatedInformation
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? location = null,Object? message = null,}) {
  return _then(_self.copyWith(
location: null == location ? _self.location : location // ignore: cast_nullable_to_non_nullable
as Location,message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,
  ));
}
/// Create a copy of DiagnosticRelatedInformation
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$LocationCopyWith<$Res> get location {
  
  return $LocationCopyWith<$Res>(_self.location, (value) {
    return _then(_self.copyWith(location: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _DiagnosticRelatedInformation implements DiagnosticRelatedInformation {
  const _DiagnosticRelatedInformation({required this.location, required this.message});
  factory _DiagnosticRelatedInformation.fromJson(Map<String, dynamic> json) => _$DiagnosticRelatedInformationFromJson(json);

/// The location of this related diagnostic information.
@override final  Location location;
/// The message of this related diagnostic information.
@override final  String message;

/// Create a copy of DiagnosticRelatedInformation
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DiagnosticRelatedInformationCopyWith<_DiagnosticRelatedInformation> get copyWith => __$DiagnosticRelatedInformationCopyWithImpl<_DiagnosticRelatedInformation>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DiagnosticRelatedInformationToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DiagnosticRelatedInformation&&(identical(other.location, location) || other.location == location)&&(identical(other.message, message) || other.message == message));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,location,message);

@override
String toString() {
  return 'DiagnosticRelatedInformation(location: $location, message: $message)';
}


}

/// @nodoc
abstract mixin class _$DiagnosticRelatedInformationCopyWith<$Res> implements $DiagnosticRelatedInformationCopyWith<$Res> {
  factory _$DiagnosticRelatedInformationCopyWith(_DiagnosticRelatedInformation value, $Res Function(_DiagnosticRelatedInformation) _then) = __$DiagnosticRelatedInformationCopyWithImpl;
@override @useResult
$Res call({
 Location location, String message
});


@override $LocationCopyWith<$Res> get location;

}
/// @nodoc
class __$DiagnosticRelatedInformationCopyWithImpl<$Res>
    implements _$DiagnosticRelatedInformationCopyWith<$Res> {
  __$DiagnosticRelatedInformationCopyWithImpl(this._self, this._then);

  final _DiagnosticRelatedInformation _self;
  final $Res Function(_DiagnosticRelatedInformation) _then;

/// Create a copy of DiagnosticRelatedInformation
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? location = null,Object? message = null,}) {
  return _then(_DiagnosticRelatedInformation(
location: null == location ? _self.location : location // ignore: cast_nullable_to_non_nullable
as Location,message: null == message ? _self.message : message // ignore: cast_nullable_to_non_nullable
as String,
  ));
}

/// Create a copy of DiagnosticRelatedInformation
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$LocationCopyWith<$Res> get location {
  
  return $LocationCopyWith<$Res>(_self.location, (value) {
    return _then(_self.copyWith(location: value));
  });
}
}


/// @nodoc
mixin _$ParameterInformation {

/// The human-readable doc-comment of this parameter. Will be shown in the
/// UI but can be omitted.
 Sealed17? get documentation;/// The label of this parameter information.
/// Either a string or an inclusive start and exclusive end offsets within
/// its containing signature label. (see SignatureInformation.label). The
/// offsets are based on a UTF-16 string representation as `Position` and
/// `Range` does.
/// *Note*: a label of type string should be a substring of its containing
/// signature label. Its intended use case is to highlight the parameter
/// label part in the `SignatureInformation.label`.
 Sealed61 get label;
/// Create a copy of ParameterInformation
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ParameterInformationCopyWith<ParameterInformation> get copyWith => _$ParameterInformationCopyWithImpl<ParameterInformation>(this as ParameterInformation, _$identity);

  /// Serializes this ParameterInformation to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ParameterInformation&&(identical(other.documentation, documentation) || other.documentation == documentation)&&(identical(other.label, label) || other.label == label));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentation,label);

@override
String toString() {
  return 'ParameterInformation(documentation: $documentation, label: $label)';
}


}

/// @nodoc
abstract mixin class $ParameterInformationCopyWith<$Res>  {
  factory $ParameterInformationCopyWith(ParameterInformation value, $Res Function(ParameterInformation) _then) = _$ParameterInformationCopyWithImpl;
@useResult
$Res call({
 Sealed17? documentation, Sealed61 label
});




}
/// @nodoc
class _$ParameterInformationCopyWithImpl<$Res>
    implements $ParameterInformationCopyWith<$Res> {
  _$ParameterInformationCopyWithImpl(this._self, this._then);

  final ParameterInformation _self;
  final $Res Function(ParameterInformation) _then;

/// Create a copy of ParameterInformation
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? documentation = freezed,Object? label = null,}) {
  return _then(_self.copyWith(
documentation: freezed == documentation ? _self.documentation : documentation // ignore: cast_nullable_to_non_nullable
as Sealed17?,label: null == label ? _self.label : label // ignore: cast_nullable_to_non_nullable
as Sealed61,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _ParameterInformation implements ParameterInformation {
  const _ParameterInformation({this.documentation, required this.label});
  factory _ParameterInformation.fromJson(Map<String, dynamic> json) => _$ParameterInformationFromJson(json);

/// The human-readable doc-comment of this parameter. Will be shown in the
/// UI but can be omitted.
@override final  Sealed17? documentation;
/// The label of this parameter information.
/// Either a string or an inclusive start and exclusive end offsets within
/// its containing signature label. (see SignatureInformation.label). The
/// offsets are based on a UTF-16 string representation as `Position` and
/// `Range` does.
/// *Note*: a label of type string should be a substring of its containing
/// signature label. Its intended use case is to highlight the parameter
/// label part in the `SignatureInformation.label`.
@override final  Sealed61 label;

/// Create a copy of ParameterInformation
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ParameterInformationCopyWith<_ParameterInformation> get copyWith => __$ParameterInformationCopyWithImpl<_ParameterInformation>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ParameterInformationToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ParameterInformation&&(identical(other.documentation, documentation) || other.documentation == documentation)&&(identical(other.label, label) || other.label == label));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,documentation,label);

@override
String toString() {
  return 'ParameterInformation(documentation: $documentation, label: $label)';
}


}

/// @nodoc
abstract mixin class _$ParameterInformationCopyWith<$Res> implements $ParameterInformationCopyWith<$Res> {
  factory _$ParameterInformationCopyWith(_ParameterInformation value, $Res Function(_ParameterInformation) _then) = __$ParameterInformationCopyWithImpl;
@override @useResult
$Res call({
 Sealed17? documentation, Sealed61 label
});




}
/// @nodoc
class __$ParameterInformationCopyWithImpl<$Res>
    implements _$ParameterInformationCopyWith<$Res> {
  __$ParameterInformationCopyWithImpl(this._self, this._then);

  final _ParameterInformation _self;
  final $Res Function(_ParameterInformation) _then;

/// Create a copy of ParameterInformation
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? documentation = freezed,Object? label = null,}) {
  return _then(_ParameterInformation(
documentation: freezed == documentation ? _self.documentation : documentation // ignore: cast_nullable_to_non_nullable
as Sealed17?,label: null == label ? _self.label : label // ignore: cast_nullable_to_non_nullable
as Sealed61,
  ));
}


}


/// @nodoc
mixin _$NotebookCellTextDocumentFilter {

/// A language id like `python`.
/// Will be matched against the language id of the notebook cell document.
/// '*' matches every language.
 String? get language;/// A filter that matches against the notebook containing the notebook
/// cell. If a string value is provided it matches against the notebook
/// type. '*' matches every notebook.
 Sealed62 get notebook;
/// Create a copy of NotebookCellTextDocumentFilter
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$NotebookCellTextDocumentFilterCopyWith<NotebookCellTextDocumentFilter> get copyWith => _$NotebookCellTextDocumentFilterCopyWithImpl<NotebookCellTextDocumentFilter>(this as NotebookCellTextDocumentFilter, _$identity);

  /// Serializes this NotebookCellTextDocumentFilter to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is NotebookCellTextDocumentFilter&&(identical(other.language, language) || other.language == language)&&(identical(other.notebook, notebook) || other.notebook == notebook));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,language,notebook);

@override
String toString() {
  return 'NotebookCellTextDocumentFilter(language: $language, notebook: $notebook)';
}


}

/// @nodoc
abstract mixin class $NotebookCellTextDocumentFilterCopyWith<$Res>  {
  factory $NotebookCellTextDocumentFilterCopyWith(NotebookCellTextDocumentFilter value, $Res Function(NotebookCellTextDocumentFilter) _then) = _$NotebookCellTextDocumentFilterCopyWithImpl;
@useResult
$Res call({
 String? language, Sealed62 notebook
});




}
/// @nodoc
class _$NotebookCellTextDocumentFilterCopyWithImpl<$Res>
    implements $NotebookCellTextDocumentFilterCopyWith<$Res> {
  _$NotebookCellTextDocumentFilterCopyWithImpl(this._self, this._then);

  final NotebookCellTextDocumentFilter _self;
  final $Res Function(NotebookCellTextDocumentFilter) _then;

/// Create a copy of NotebookCellTextDocumentFilter
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? language = freezed,Object? notebook = null,}) {
  return _then(_self.copyWith(
language: freezed == language ? _self.language : language // ignore: cast_nullable_to_non_nullable
as String?,notebook: null == notebook ? _self.notebook : notebook // ignore: cast_nullable_to_non_nullable
as Sealed62,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _NotebookCellTextDocumentFilter implements NotebookCellTextDocumentFilter {
  const _NotebookCellTextDocumentFilter({this.language, required this.notebook});
  factory _NotebookCellTextDocumentFilter.fromJson(Map<String, dynamic> json) => _$NotebookCellTextDocumentFilterFromJson(json);

/// A language id like `python`.
/// Will be matched against the language id of the notebook cell document.
/// '*' matches every language.
@override final  String? language;
/// A filter that matches against the notebook containing the notebook
/// cell. If a string value is provided it matches against the notebook
/// type. '*' matches every notebook.
@override final  Sealed62 notebook;

/// Create a copy of NotebookCellTextDocumentFilter
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$NotebookCellTextDocumentFilterCopyWith<_NotebookCellTextDocumentFilter> get copyWith => __$NotebookCellTextDocumentFilterCopyWithImpl<_NotebookCellTextDocumentFilter>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$NotebookCellTextDocumentFilterToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _NotebookCellTextDocumentFilter&&(identical(other.language, language) || other.language == language)&&(identical(other.notebook, notebook) || other.notebook == notebook));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,language,notebook);

@override
String toString() {
  return 'NotebookCellTextDocumentFilter(language: $language, notebook: $notebook)';
}


}

/// @nodoc
abstract mixin class _$NotebookCellTextDocumentFilterCopyWith<$Res> implements $NotebookCellTextDocumentFilterCopyWith<$Res> {
  factory _$NotebookCellTextDocumentFilterCopyWith(_NotebookCellTextDocumentFilter value, $Res Function(_NotebookCellTextDocumentFilter) _then) = __$NotebookCellTextDocumentFilterCopyWithImpl;
@override @useResult
$Res call({
 String? language, Sealed62 notebook
});




}
/// @nodoc
class __$NotebookCellTextDocumentFilterCopyWithImpl<$Res>
    implements _$NotebookCellTextDocumentFilterCopyWith<$Res> {
  __$NotebookCellTextDocumentFilterCopyWithImpl(this._self, this._then);

  final _NotebookCellTextDocumentFilter _self;
  final $Res Function(_NotebookCellTextDocumentFilter) _then;

/// Create a copy of NotebookCellTextDocumentFilter
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? language = freezed,Object? notebook = null,}) {
  return _then(_NotebookCellTextDocumentFilter(
language: freezed == language ? _self.language : language // ignore: cast_nullable_to_non_nullable
as String?,notebook: null == notebook ? _self.notebook : notebook // ignore: cast_nullable_to_non_nullable
as Sealed62,
  ));
}


}


/// @nodoc
mixin _$FileOperationPatternOptions {

/// The pattern should be matched ignoring casing.
 bool? get ignoreCase;
/// Create a copy of FileOperationPatternOptions
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FileOperationPatternOptionsCopyWith<FileOperationPatternOptions> get copyWith => _$FileOperationPatternOptionsCopyWithImpl<FileOperationPatternOptions>(this as FileOperationPatternOptions, _$identity);

  /// Serializes this FileOperationPatternOptions to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FileOperationPatternOptions&&(identical(other.ignoreCase, ignoreCase) || other.ignoreCase == ignoreCase));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,ignoreCase);

@override
String toString() {
  return 'FileOperationPatternOptions(ignoreCase: $ignoreCase)';
}


}

/// @nodoc
abstract mixin class $FileOperationPatternOptionsCopyWith<$Res>  {
  factory $FileOperationPatternOptionsCopyWith(FileOperationPatternOptions value, $Res Function(FileOperationPatternOptions) _then) = _$FileOperationPatternOptionsCopyWithImpl;
@useResult
$Res call({
 bool? ignoreCase
});




}
/// @nodoc
class _$FileOperationPatternOptionsCopyWithImpl<$Res>
    implements $FileOperationPatternOptionsCopyWith<$Res> {
  _$FileOperationPatternOptionsCopyWithImpl(this._self, this._then);

  final FileOperationPatternOptions _self;
  final $Res Function(FileOperationPatternOptions) _then;

/// Create a copy of FileOperationPatternOptions
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? ignoreCase = freezed,}) {
  return _then(_self.copyWith(
ignoreCase: freezed == ignoreCase ? _self.ignoreCase : ignoreCase // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _FileOperationPatternOptions implements FileOperationPatternOptions {
  const _FileOperationPatternOptions({this.ignoreCase});
  factory _FileOperationPatternOptions.fromJson(Map<String, dynamic> json) => _$FileOperationPatternOptionsFromJson(json);

/// The pattern should be matched ignoring casing.
@override final  bool? ignoreCase;

/// Create a copy of FileOperationPatternOptions
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$FileOperationPatternOptionsCopyWith<_FileOperationPatternOptions> get copyWith => __$FileOperationPatternOptionsCopyWithImpl<_FileOperationPatternOptions>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$FileOperationPatternOptionsToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _FileOperationPatternOptions&&(identical(other.ignoreCase, ignoreCase) || other.ignoreCase == ignoreCase));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,ignoreCase);

@override
String toString() {
  return 'FileOperationPatternOptions(ignoreCase: $ignoreCase)';
}


}

/// @nodoc
abstract mixin class _$FileOperationPatternOptionsCopyWith<$Res> implements $FileOperationPatternOptionsCopyWith<$Res> {
  factory _$FileOperationPatternOptionsCopyWith(_FileOperationPatternOptions value, $Res Function(_FileOperationPatternOptions) _then) = __$FileOperationPatternOptionsCopyWithImpl;
@override @useResult
$Res call({
 bool? ignoreCase
});




}
/// @nodoc
class __$FileOperationPatternOptionsCopyWithImpl<$Res>
    implements _$FileOperationPatternOptionsCopyWith<$Res> {
  __$FileOperationPatternOptionsCopyWithImpl(this._self, this._then);

  final _FileOperationPatternOptions _self;
  final $Res Function(_FileOperationPatternOptions) _then;

/// Create a copy of FileOperationPatternOptions
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? ignoreCase = freezed,}) {
  return _then(_FileOperationPatternOptions(
ignoreCase: freezed == ignoreCase ? _self.ignoreCase : ignoreCase // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$ExecutionSummary {

/// A strict monotonically increasing value indicating the execution order
/// of a cell inside a notebook.
 int get executionOrder;/// Whether the execution was successful or not if known by the client.
 bool? get success;
/// Create a copy of ExecutionSummary
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ExecutionSummaryCopyWith<ExecutionSummary> get copyWith => _$ExecutionSummaryCopyWithImpl<ExecutionSummary>(this as ExecutionSummary, _$identity);

  /// Serializes this ExecutionSummary to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ExecutionSummary&&(identical(other.executionOrder, executionOrder) || other.executionOrder == executionOrder)&&(identical(other.success, success) || other.success == success));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,executionOrder,success);

@override
String toString() {
  return 'ExecutionSummary(executionOrder: $executionOrder, success: $success)';
}


}

/// @nodoc
abstract mixin class $ExecutionSummaryCopyWith<$Res>  {
  factory $ExecutionSummaryCopyWith(ExecutionSummary value, $Res Function(ExecutionSummary) _then) = _$ExecutionSummaryCopyWithImpl;
@useResult
$Res call({
 int executionOrder, bool? success
});




}
/// @nodoc
class _$ExecutionSummaryCopyWithImpl<$Res>
    implements $ExecutionSummaryCopyWith<$Res> {
  _$ExecutionSummaryCopyWithImpl(this._self, this._then);

  final ExecutionSummary _self;
  final $Res Function(ExecutionSummary) _then;

/// Create a copy of ExecutionSummary
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? executionOrder = null,Object? success = freezed,}) {
  return _then(_self.copyWith(
executionOrder: null == executionOrder ? _self.executionOrder : executionOrder // ignore: cast_nullable_to_non_nullable
as int,success: freezed == success ? _self.success : success // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _ExecutionSummary implements ExecutionSummary {
  const _ExecutionSummary({required this.executionOrder, this.success});
  factory _ExecutionSummary.fromJson(Map<String, dynamic> json) => _$ExecutionSummaryFromJson(json);

/// A strict monotonically increasing value indicating the execution order
/// of a cell inside a notebook.
@override final  int executionOrder;
/// Whether the execution was successful or not if known by the client.
@override final  bool? success;

/// Create a copy of ExecutionSummary
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ExecutionSummaryCopyWith<_ExecutionSummary> get copyWith => __$ExecutionSummaryCopyWithImpl<_ExecutionSummary>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ExecutionSummaryToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ExecutionSummary&&(identical(other.executionOrder, executionOrder) || other.executionOrder == executionOrder)&&(identical(other.success, success) || other.success == success));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,executionOrder,success);

@override
String toString() {
  return 'ExecutionSummary(executionOrder: $executionOrder, success: $success)';
}


}

/// @nodoc
abstract mixin class _$ExecutionSummaryCopyWith<$Res> implements $ExecutionSummaryCopyWith<$Res> {
  factory _$ExecutionSummaryCopyWith(_ExecutionSummary value, $Res Function(_ExecutionSummary) _then) = __$ExecutionSummaryCopyWithImpl;
@override @useResult
$Res call({
 int executionOrder, bool? success
});




}
/// @nodoc
class __$ExecutionSummaryCopyWithImpl<$Res>
    implements _$ExecutionSummaryCopyWith<$Res> {
  __$ExecutionSummaryCopyWithImpl(this._self, this._then);

  final _ExecutionSummary _self;
  final $Res Function(_ExecutionSummary) _then;

/// Create a copy of ExecutionSummary
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? executionOrder = null,Object? success = freezed,}) {
  return _then(_ExecutionSummary(
executionOrder: null == executionOrder ? _self.executionOrder : executionOrder // ignore: cast_nullable_to_non_nullable
as int,success: freezed == success ? _self.success : success // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$WorkspaceClientCapabilities {

/// The client supports applying batch edits to the workspace by supporting
/// the request 'workspace/applyEdit'
 bool? get applyEdit;/// Capabilities specific to the code lens requests scoped to the workspace.
/// @since 3.16.0.
 CodeLensWorkspaceClientCapabilities? get codeLens;/// The client supports `workspace/configuration` requests.
/// @since 3.6.0
 bool? get configuration;/// Capabilities specific to the diagnostic requests scoped to the
/// workspace.
/// @since 3.17.0.
 DiagnosticWorkspaceClientCapabilities? get diagnostics;/// Capabilities specific to the `workspace/didChangeConfiguration`
/// notification.
 DidChangeConfigurationClientCapabilities? get didChangeConfiguration;/// Capabilities specific to the `workspace/didChangeWatchedFiles`
/// notification.
 DidChangeWatchedFilesClientCapabilities? get didChangeWatchedFiles;/// Capabilities specific to the `workspace/executeCommand` request.
 ExecuteCommandClientCapabilities? get executeCommand;/// The client has support for file notifications/requests for user
/// operations on files.
/// Since 3.16.0
 FileOperationClientCapabilities? get fileOperations;/// Capabilities specific to the folding range requests scoped to the
/// workspace.
/// @since 3.18.0 @proposed
 FoldingRangeWorkspaceClientCapabilities? get foldingRange;/// Capabilities specific to the inlay hint requests scoped to the
/// workspace.
/// @since 3.17.0.
 InlayHintWorkspaceClientCapabilities? get inlayHint;/// Capabilities specific to the inline values requests scoped to the
/// workspace.
/// @since 3.17.0.
 InlineValueWorkspaceClientCapabilities? get inlineValue;/// Capabilities specific to the semantic token requests scoped to the
/// workspace.
/// @since 3.16.0.
 SemanticTokensWorkspaceClientCapabilities? get semanticTokens;/// Capabilities specific to the `workspace/symbol` request.
 WorkspaceSymbolClientCapabilities? get symbol;/// Capabilities specific to `WorkspaceEdit`s.
 WorkspaceEditClientCapabilities? get workspaceEdit;/// The client has support for workspace folders.
/// @since 3.6.0
 bool? get workspaceFolders;
/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkspaceClientCapabilitiesCopyWith<WorkspaceClientCapabilities> get copyWith => _$WorkspaceClientCapabilitiesCopyWithImpl<WorkspaceClientCapabilities>(this as WorkspaceClientCapabilities, _$identity);

  /// Serializes this WorkspaceClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkspaceClientCapabilities&&(identical(other.applyEdit, applyEdit) || other.applyEdit == applyEdit)&&(identical(other.codeLens, codeLens) || other.codeLens == codeLens)&&(identical(other.configuration, configuration) || other.configuration == configuration)&&(identical(other.diagnostics, diagnostics) || other.diagnostics == diagnostics)&&(identical(other.didChangeConfiguration, didChangeConfiguration) || other.didChangeConfiguration == didChangeConfiguration)&&(identical(other.didChangeWatchedFiles, didChangeWatchedFiles) || other.didChangeWatchedFiles == didChangeWatchedFiles)&&(identical(other.executeCommand, executeCommand) || other.executeCommand == executeCommand)&&(identical(other.fileOperations, fileOperations) || other.fileOperations == fileOperations)&&(identical(other.foldingRange, foldingRange) || other.foldingRange == foldingRange)&&(identical(other.inlayHint, inlayHint) || other.inlayHint == inlayHint)&&(identical(other.inlineValue, inlineValue) || other.inlineValue == inlineValue)&&(identical(other.semanticTokens, semanticTokens) || other.semanticTokens == semanticTokens)&&(identical(other.symbol, symbol) || other.symbol == symbol)&&(identical(other.workspaceEdit, workspaceEdit) || other.workspaceEdit == workspaceEdit)&&(identical(other.workspaceFolders, workspaceFolders) || other.workspaceFolders == workspaceFolders));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,applyEdit,codeLens,configuration,diagnostics,didChangeConfiguration,didChangeWatchedFiles,executeCommand,fileOperations,foldingRange,inlayHint,inlineValue,semanticTokens,symbol,workspaceEdit,workspaceFolders);

@override
String toString() {
  return 'WorkspaceClientCapabilities(applyEdit: $applyEdit, codeLens: $codeLens, configuration: $configuration, diagnostics: $diagnostics, didChangeConfiguration: $didChangeConfiguration, didChangeWatchedFiles: $didChangeWatchedFiles, executeCommand: $executeCommand, fileOperations: $fileOperations, foldingRange: $foldingRange, inlayHint: $inlayHint, inlineValue: $inlineValue, semanticTokens: $semanticTokens, symbol: $symbol, workspaceEdit: $workspaceEdit, workspaceFolders: $workspaceFolders)';
}


}

/// @nodoc
abstract mixin class $WorkspaceClientCapabilitiesCopyWith<$Res>  {
  factory $WorkspaceClientCapabilitiesCopyWith(WorkspaceClientCapabilities value, $Res Function(WorkspaceClientCapabilities) _then) = _$WorkspaceClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? applyEdit, CodeLensWorkspaceClientCapabilities? codeLens, bool? configuration, DiagnosticWorkspaceClientCapabilities? diagnostics, DidChangeConfigurationClientCapabilities? didChangeConfiguration, DidChangeWatchedFilesClientCapabilities? didChangeWatchedFiles, ExecuteCommandClientCapabilities? executeCommand, FileOperationClientCapabilities? fileOperations, FoldingRangeWorkspaceClientCapabilities? foldingRange, InlayHintWorkspaceClientCapabilities? inlayHint, InlineValueWorkspaceClientCapabilities? inlineValue, SemanticTokensWorkspaceClientCapabilities? semanticTokens, WorkspaceSymbolClientCapabilities? symbol, WorkspaceEditClientCapabilities? workspaceEdit, bool? workspaceFolders
});


$CodeLensWorkspaceClientCapabilitiesCopyWith<$Res>? get codeLens;$DiagnosticWorkspaceClientCapabilitiesCopyWith<$Res>? get diagnostics;$DidChangeConfigurationClientCapabilitiesCopyWith<$Res>? get didChangeConfiguration;$DidChangeWatchedFilesClientCapabilitiesCopyWith<$Res>? get didChangeWatchedFiles;$ExecuteCommandClientCapabilitiesCopyWith<$Res>? get executeCommand;$FileOperationClientCapabilitiesCopyWith<$Res>? get fileOperations;$FoldingRangeWorkspaceClientCapabilitiesCopyWith<$Res>? get foldingRange;$InlayHintWorkspaceClientCapabilitiesCopyWith<$Res>? get inlayHint;$InlineValueWorkspaceClientCapabilitiesCopyWith<$Res>? get inlineValue;$SemanticTokensWorkspaceClientCapabilitiesCopyWith<$Res>? get semanticTokens;$WorkspaceSymbolClientCapabilitiesCopyWith<$Res>? get symbol;$WorkspaceEditClientCapabilitiesCopyWith<$Res>? get workspaceEdit;

}
/// @nodoc
class _$WorkspaceClientCapabilitiesCopyWithImpl<$Res>
    implements $WorkspaceClientCapabilitiesCopyWith<$Res> {
  _$WorkspaceClientCapabilitiesCopyWithImpl(this._self, this._then);

  final WorkspaceClientCapabilities _self;
  final $Res Function(WorkspaceClientCapabilities) _then;

/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? applyEdit = freezed,Object? codeLens = freezed,Object? configuration = freezed,Object? diagnostics = freezed,Object? didChangeConfiguration = freezed,Object? didChangeWatchedFiles = freezed,Object? executeCommand = freezed,Object? fileOperations = freezed,Object? foldingRange = freezed,Object? inlayHint = freezed,Object? inlineValue = freezed,Object? semanticTokens = freezed,Object? symbol = freezed,Object? workspaceEdit = freezed,Object? workspaceFolders = freezed,}) {
  return _then(_self.copyWith(
applyEdit: freezed == applyEdit ? _self.applyEdit : applyEdit // ignore: cast_nullable_to_non_nullable
as bool?,codeLens: freezed == codeLens ? _self.codeLens : codeLens // ignore: cast_nullable_to_non_nullable
as CodeLensWorkspaceClientCapabilities?,configuration: freezed == configuration ? _self.configuration : configuration // ignore: cast_nullable_to_non_nullable
as bool?,diagnostics: freezed == diagnostics ? _self.diagnostics : diagnostics // ignore: cast_nullable_to_non_nullable
as DiagnosticWorkspaceClientCapabilities?,didChangeConfiguration: freezed == didChangeConfiguration ? _self.didChangeConfiguration : didChangeConfiguration // ignore: cast_nullable_to_non_nullable
as DidChangeConfigurationClientCapabilities?,didChangeWatchedFiles: freezed == didChangeWatchedFiles ? _self.didChangeWatchedFiles : didChangeWatchedFiles // ignore: cast_nullable_to_non_nullable
as DidChangeWatchedFilesClientCapabilities?,executeCommand: freezed == executeCommand ? _self.executeCommand : executeCommand // ignore: cast_nullable_to_non_nullable
as ExecuteCommandClientCapabilities?,fileOperations: freezed == fileOperations ? _self.fileOperations : fileOperations // ignore: cast_nullable_to_non_nullable
as FileOperationClientCapabilities?,foldingRange: freezed == foldingRange ? _self.foldingRange : foldingRange // ignore: cast_nullable_to_non_nullable
as FoldingRangeWorkspaceClientCapabilities?,inlayHint: freezed == inlayHint ? _self.inlayHint : inlayHint // ignore: cast_nullable_to_non_nullable
as InlayHintWorkspaceClientCapabilities?,inlineValue: freezed == inlineValue ? _self.inlineValue : inlineValue // ignore: cast_nullable_to_non_nullable
as InlineValueWorkspaceClientCapabilities?,semanticTokens: freezed == semanticTokens ? _self.semanticTokens : semanticTokens // ignore: cast_nullable_to_non_nullable
as SemanticTokensWorkspaceClientCapabilities?,symbol: freezed == symbol ? _self.symbol : symbol // ignore: cast_nullable_to_non_nullable
as WorkspaceSymbolClientCapabilities?,workspaceEdit: freezed == workspaceEdit ? _self.workspaceEdit : workspaceEdit // ignore: cast_nullable_to_non_nullable
as WorkspaceEditClientCapabilities?,workspaceFolders: freezed == workspaceFolders ? _self.workspaceFolders : workspaceFolders // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}
/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CodeLensWorkspaceClientCapabilitiesCopyWith<$Res>? get codeLens {
    if (_self.codeLens == null) {
    return null;
  }

  return $CodeLensWorkspaceClientCapabilitiesCopyWith<$Res>(_self.codeLens!, (value) {
    return _then(_self.copyWith(codeLens: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DiagnosticWorkspaceClientCapabilitiesCopyWith<$Res>? get diagnostics {
    if (_self.diagnostics == null) {
    return null;
  }

  return $DiagnosticWorkspaceClientCapabilitiesCopyWith<$Res>(_self.diagnostics!, (value) {
    return _then(_self.copyWith(diagnostics: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DidChangeConfigurationClientCapabilitiesCopyWith<$Res>? get didChangeConfiguration {
    if (_self.didChangeConfiguration == null) {
    return null;
  }

  return $DidChangeConfigurationClientCapabilitiesCopyWith<$Res>(_self.didChangeConfiguration!, (value) {
    return _then(_self.copyWith(didChangeConfiguration: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DidChangeWatchedFilesClientCapabilitiesCopyWith<$Res>? get didChangeWatchedFiles {
    if (_self.didChangeWatchedFiles == null) {
    return null;
  }

  return $DidChangeWatchedFilesClientCapabilitiesCopyWith<$Res>(_self.didChangeWatchedFiles!, (value) {
    return _then(_self.copyWith(didChangeWatchedFiles: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ExecuteCommandClientCapabilitiesCopyWith<$Res>? get executeCommand {
    if (_self.executeCommand == null) {
    return null;
  }

  return $ExecuteCommandClientCapabilitiesCopyWith<$Res>(_self.executeCommand!, (value) {
    return _then(_self.copyWith(executeCommand: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FileOperationClientCapabilitiesCopyWith<$Res>? get fileOperations {
    if (_self.fileOperations == null) {
    return null;
  }

  return $FileOperationClientCapabilitiesCopyWith<$Res>(_self.fileOperations!, (value) {
    return _then(_self.copyWith(fileOperations: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FoldingRangeWorkspaceClientCapabilitiesCopyWith<$Res>? get foldingRange {
    if (_self.foldingRange == null) {
    return null;
  }

  return $FoldingRangeWorkspaceClientCapabilitiesCopyWith<$Res>(_self.foldingRange!, (value) {
    return _then(_self.copyWith(foldingRange: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$InlayHintWorkspaceClientCapabilitiesCopyWith<$Res>? get inlayHint {
    if (_self.inlayHint == null) {
    return null;
  }

  return $InlayHintWorkspaceClientCapabilitiesCopyWith<$Res>(_self.inlayHint!, (value) {
    return _then(_self.copyWith(inlayHint: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$InlineValueWorkspaceClientCapabilitiesCopyWith<$Res>? get inlineValue {
    if (_self.inlineValue == null) {
    return null;
  }

  return $InlineValueWorkspaceClientCapabilitiesCopyWith<$Res>(_self.inlineValue!, (value) {
    return _then(_self.copyWith(inlineValue: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SemanticTokensWorkspaceClientCapabilitiesCopyWith<$Res>? get semanticTokens {
    if (_self.semanticTokens == null) {
    return null;
  }

  return $SemanticTokensWorkspaceClientCapabilitiesCopyWith<$Res>(_self.semanticTokens!, (value) {
    return _then(_self.copyWith(semanticTokens: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$WorkspaceSymbolClientCapabilitiesCopyWith<$Res>? get symbol {
    if (_self.symbol == null) {
    return null;
  }

  return $WorkspaceSymbolClientCapabilitiesCopyWith<$Res>(_self.symbol!, (value) {
    return _then(_self.copyWith(symbol: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$WorkspaceEditClientCapabilitiesCopyWith<$Res>? get workspaceEdit {
    if (_self.workspaceEdit == null) {
    return null;
  }

  return $WorkspaceEditClientCapabilitiesCopyWith<$Res>(_self.workspaceEdit!, (value) {
    return _then(_self.copyWith(workspaceEdit: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _WorkspaceClientCapabilities implements WorkspaceClientCapabilities {
  const _WorkspaceClientCapabilities({this.applyEdit, this.codeLens, this.configuration, this.diagnostics, this.didChangeConfiguration, this.didChangeWatchedFiles, this.executeCommand, this.fileOperations, this.foldingRange, this.inlayHint, this.inlineValue, this.semanticTokens, this.symbol, this.workspaceEdit, this.workspaceFolders});
  factory _WorkspaceClientCapabilities.fromJson(Map<String, dynamic> json) => _$WorkspaceClientCapabilitiesFromJson(json);

/// The client supports applying batch edits to the workspace by supporting
/// the request 'workspace/applyEdit'
@override final  bool? applyEdit;
/// Capabilities specific to the code lens requests scoped to the workspace.
/// @since 3.16.0.
@override final  CodeLensWorkspaceClientCapabilities? codeLens;
/// The client supports `workspace/configuration` requests.
/// @since 3.6.0
@override final  bool? configuration;
/// Capabilities specific to the diagnostic requests scoped to the
/// workspace.
/// @since 3.17.0.
@override final  DiagnosticWorkspaceClientCapabilities? diagnostics;
/// Capabilities specific to the `workspace/didChangeConfiguration`
/// notification.
@override final  DidChangeConfigurationClientCapabilities? didChangeConfiguration;
/// Capabilities specific to the `workspace/didChangeWatchedFiles`
/// notification.
@override final  DidChangeWatchedFilesClientCapabilities? didChangeWatchedFiles;
/// Capabilities specific to the `workspace/executeCommand` request.
@override final  ExecuteCommandClientCapabilities? executeCommand;
/// The client has support for file notifications/requests for user
/// operations on files.
/// Since 3.16.0
@override final  FileOperationClientCapabilities? fileOperations;
/// Capabilities specific to the folding range requests scoped to the
/// workspace.
/// @since 3.18.0 @proposed
@override final  FoldingRangeWorkspaceClientCapabilities? foldingRange;
/// Capabilities specific to the inlay hint requests scoped to the
/// workspace.
/// @since 3.17.0.
@override final  InlayHintWorkspaceClientCapabilities? inlayHint;
/// Capabilities specific to the inline values requests scoped to the
/// workspace.
/// @since 3.17.0.
@override final  InlineValueWorkspaceClientCapabilities? inlineValue;
/// Capabilities specific to the semantic token requests scoped to the
/// workspace.
/// @since 3.16.0.
@override final  SemanticTokensWorkspaceClientCapabilities? semanticTokens;
/// Capabilities specific to the `workspace/symbol` request.
@override final  WorkspaceSymbolClientCapabilities? symbol;
/// Capabilities specific to `WorkspaceEdit`s.
@override final  WorkspaceEditClientCapabilities? workspaceEdit;
/// The client has support for workspace folders.
/// @since 3.6.0
@override final  bool? workspaceFolders;

/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkspaceClientCapabilitiesCopyWith<_WorkspaceClientCapabilities> get copyWith => __$WorkspaceClientCapabilitiesCopyWithImpl<_WorkspaceClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkspaceClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkspaceClientCapabilities&&(identical(other.applyEdit, applyEdit) || other.applyEdit == applyEdit)&&(identical(other.codeLens, codeLens) || other.codeLens == codeLens)&&(identical(other.configuration, configuration) || other.configuration == configuration)&&(identical(other.diagnostics, diagnostics) || other.diagnostics == diagnostics)&&(identical(other.didChangeConfiguration, didChangeConfiguration) || other.didChangeConfiguration == didChangeConfiguration)&&(identical(other.didChangeWatchedFiles, didChangeWatchedFiles) || other.didChangeWatchedFiles == didChangeWatchedFiles)&&(identical(other.executeCommand, executeCommand) || other.executeCommand == executeCommand)&&(identical(other.fileOperations, fileOperations) || other.fileOperations == fileOperations)&&(identical(other.foldingRange, foldingRange) || other.foldingRange == foldingRange)&&(identical(other.inlayHint, inlayHint) || other.inlayHint == inlayHint)&&(identical(other.inlineValue, inlineValue) || other.inlineValue == inlineValue)&&(identical(other.semanticTokens, semanticTokens) || other.semanticTokens == semanticTokens)&&(identical(other.symbol, symbol) || other.symbol == symbol)&&(identical(other.workspaceEdit, workspaceEdit) || other.workspaceEdit == workspaceEdit)&&(identical(other.workspaceFolders, workspaceFolders) || other.workspaceFolders == workspaceFolders));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,applyEdit,codeLens,configuration,diagnostics,didChangeConfiguration,didChangeWatchedFiles,executeCommand,fileOperations,foldingRange,inlayHint,inlineValue,semanticTokens,symbol,workspaceEdit,workspaceFolders);

@override
String toString() {
  return 'WorkspaceClientCapabilities(applyEdit: $applyEdit, codeLens: $codeLens, configuration: $configuration, diagnostics: $diagnostics, didChangeConfiguration: $didChangeConfiguration, didChangeWatchedFiles: $didChangeWatchedFiles, executeCommand: $executeCommand, fileOperations: $fileOperations, foldingRange: $foldingRange, inlayHint: $inlayHint, inlineValue: $inlineValue, semanticTokens: $semanticTokens, symbol: $symbol, workspaceEdit: $workspaceEdit, workspaceFolders: $workspaceFolders)';
}


}

/// @nodoc
abstract mixin class _$WorkspaceClientCapabilitiesCopyWith<$Res> implements $WorkspaceClientCapabilitiesCopyWith<$Res> {
  factory _$WorkspaceClientCapabilitiesCopyWith(_WorkspaceClientCapabilities value, $Res Function(_WorkspaceClientCapabilities) _then) = __$WorkspaceClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? applyEdit, CodeLensWorkspaceClientCapabilities? codeLens, bool? configuration, DiagnosticWorkspaceClientCapabilities? diagnostics, DidChangeConfigurationClientCapabilities? didChangeConfiguration, DidChangeWatchedFilesClientCapabilities? didChangeWatchedFiles, ExecuteCommandClientCapabilities? executeCommand, FileOperationClientCapabilities? fileOperations, FoldingRangeWorkspaceClientCapabilities? foldingRange, InlayHintWorkspaceClientCapabilities? inlayHint, InlineValueWorkspaceClientCapabilities? inlineValue, SemanticTokensWorkspaceClientCapabilities? semanticTokens, WorkspaceSymbolClientCapabilities? symbol, WorkspaceEditClientCapabilities? workspaceEdit, bool? workspaceFolders
});


@override $CodeLensWorkspaceClientCapabilitiesCopyWith<$Res>? get codeLens;@override $DiagnosticWorkspaceClientCapabilitiesCopyWith<$Res>? get diagnostics;@override $DidChangeConfigurationClientCapabilitiesCopyWith<$Res>? get didChangeConfiguration;@override $DidChangeWatchedFilesClientCapabilitiesCopyWith<$Res>? get didChangeWatchedFiles;@override $ExecuteCommandClientCapabilitiesCopyWith<$Res>? get executeCommand;@override $FileOperationClientCapabilitiesCopyWith<$Res>? get fileOperations;@override $FoldingRangeWorkspaceClientCapabilitiesCopyWith<$Res>? get foldingRange;@override $InlayHintWorkspaceClientCapabilitiesCopyWith<$Res>? get inlayHint;@override $InlineValueWorkspaceClientCapabilitiesCopyWith<$Res>? get inlineValue;@override $SemanticTokensWorkspaceClientCapabilitiesCopyWith<$Res>? get semanticTokens;@override $WorkspaceSymbolClientCapabilitiesCopyWith<$Res>? get symbol;@override $WorkspaceEditClientCapabilitiesCopyWith<$Res>? get workspaceEdit;

}
/// @nodoc
class __$WorkspaceClientCapabilitiesCopyWithImpl<$Res>
    implements _$WorkspaceClientCapabilitiesCopyWith<$Res> {
  __$WorkspaceClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _WorkspaceClientCapabilities _self;
  final $Res Function(_WorkspaceClientCapabilities) _then;

/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? applyEdit = freezed,Object? codeLens = freezed,Object? configuration = freezed,Object? diagnostics = freezed,Object? didChangeConfiguration = freezed,Object? didChangeWatchedFiles = freezed,Object? executeCommand = freezed,Object? fileOperations = freezed,Object? foldingRange = freezed,Object? inlayHint = freezed,Object? inlineValue = freezed,Object? semanticTokens = freezed,Object? symbol = freezed,Object? workspaceEdit = freezed,Object? workspaceFolders = freezed,}) {
  return _then(_WorkspaceClientCapabilities(
applyEdit: freezed == applyEdit ? _self.applyEdit : applyEdit // ignore: cast_nullable_to_non_nullable
as bool?,codeLens: freezed == codeLens ? _self.codeLens : codeLens // ignore: cast_nullable_to_non_nullable
as CodeLensWorkspaceClientCapabilities?,configuration: freezed == configuration ? _self.configuration : configuration // ignore: cast_nullable_to_non_nullable
as bool?,diagnostics: freezed == diagnostics ? _self.diagnostics : diagnostics // ignore: cast_nullable_to_non_nullable
as DiagnosticWorkspaceClientCapabilities?,didChangeConfiguration: freezed == didChangeConfiguration ? _self.didChangeConfiguration : didChangeConfiguration // ignore: cast_nullable_to_non_nullable
as DidChangeConfigurationClientCapabilities?,didChangeWatchedFiles: freezed == didChangeWatchedFiles ? _self.didChangeWatchedFiles : didChangeWatchedFiles // ignore: cast_nullable_to_non_nullable
as DidChangeWatchedFilesClientCapabilities?,executeCommand: freezed == executeCommand ? _self.executeCommand : executeCommand // ignore: cast_nullable_to_non_nullable
as ExecuteCommandClientCapabilities?,fileOperations: freezed == fileOperations ? _self.fileOperations : fileOperations // ignore: cast_nullable_to_non_nullable
as FileOperationClientCapabilities?,foldingRange: freezed == foldingRange ? _self.foldingRange : foldingRange // ignore: cast_nullable_to_non_nullable
as FoldingRangeWorkspaceClientCapabilities?,inlayHint: freezed == inlayHint ? _self.inlayHint : inlayHint // ignore: cast_nullable_to_non_nullable
as InlayHintWorkspaceClientCapabilities?,inlineValue: freezed == inlineValue ? _self.inlineValue : inlineValue // ignore: cast_nullable_to_non_nullable
as InlineValueWorkspaceClientCapabilities?,semanticTokens: freezed == semanticTokens ? _self.semanticTokens : semanticTokens // ignore: cast_nullable_to_non_nullable
as SemanticTokensWorkspaceClientCapabilities?,symbol: freezed == symbol ? _self.symbol : symbol // ignore: cast_nullable_to_non_nullable
as WorkspaceSymbolClientCapabilities?,workspaceEdit: freezed == workspaceEdit ? _self.workspaceEdit : workspaceEdit // ignore: cast_nullable_to_non_nullable
as WorkspaceEditClientCapabilities?,workspaceFolders: freezed == workspaceFolders ? _self.workspaceFolders : workspaceFolders // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CodeLensWorkspaceClientCapabilitiesCopyWith<$Res>? get codeLens {
    if (_self.codeLens == null) {
    return null;
  }

  return $CodeLensWorkspaceClientCapabilitiesCopyWith<$Res>(_self.codeLens!, (value) {
    return _then(_self.copyWith(codeLens: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DiagnosticWorkspaceClientCapabilitiesCopyWith<$Res>? get diagnostics {
    if (_self.diagnostics == null) {
    return null;
  }

  return $DiagnosticWorkspaceClientCapabilitiesCopyWith<$Res>(_self.diagnostics!, (value) {
    return _then(_self.copyWith(diagnostics: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DidChangeConfigurationClientCapabilitiesCopyWith<$Res>? get didChangeConfiguration {
    if (_self.didChangeConfiguration == null) {
    return null;
  }

  return $DidChangeConfigurationClientCapabilitiesCopyWith<$Res>(_self.didChangeConfiguration!, (value) {
    return _then(_self.copyWith(didChangeConfiguration: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DidChangeWatchedFilesClientCapabilitiesCopyWith<$Res>? get didChangeWatchedFiles {
    if (_self.didChangeWatchedFiles == null) {
    return null;
  }

  return $DidChangeWatchedFilesClientCapabilitiesCopyWith<$Res>(_self.didChangeWatchedFiles!, (value) {
    return _then(_self.copyWith(didChangeWatchedFiles: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ExecuteCommandClientCapabilitiesCopyWith<$Res>? get executeCommand {
    if (_self.executeCommand == null) {
    return null;
  }

  return $ExecuteCommandClientCapabilitiesCopyWith<$Res>(_self.executeCommand!, (value) {
    return _then(_self.copyWith(executeCommand: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FileOperationClientCapabilitiesCopyWith<$Res>? get fileOperations {
    if (_self.fileOperations == null) {
    return null;
  }

  return $FileOperationClientCapabilitiesCopyWith<$Res>(_self.fileOperations!, (value) {
    return _then(_self.copyWith(fileOperations: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FoldingRangeWorkspaceClientCapabilitiesCopyWith<$Res>? get foldingRange {
    if (_self.foldingRange == null) {
    return null;
  }

  return $FoldingRangeWorkspaceClientCapabilitiesCopyWith<$Res>(_self.foldingRange!, (value) {
    return _then(_self.copyWith(foldingRange: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$InlayHintWorkspaceClientCapabilitiesCopyWith<$Res>? get inlayHint {
    if (_self.inlayHint == null) {
    return null;
  }

  return $InlayHintWorkspaceClientCapabilitiesCopyWith<$Res>(_self.inlayHint!, (value) {
    return _then(_self.copyWith(inlayHint: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$InlineValueWorkspaceClientCapabilitiesCopyWith<$Res>? get inlineValue {
    if (_self.inlineValue == null) {
    return null;
  }

  return $InlineValueWorkspaceClientCapabilitiesCopyWith<$Res>(_self.inlineValue!, (value) {
    return _then(_self.copyWith(inlineValue: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SemanticTokensWorkspaceClientCapabilitiesCopyWith<$Res>? get semanticTokens {
    if (_self.semanticTokens == null) {
    return null;
  }

  return $SemanticTokensWorkspaceClientCapabilitiesCopyWith<$Res>(_self.semanticTokens!, (value) {
    return _then(_self.copyWith(semanticTokens: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$WorkspaceSymbolClientCapabilitiesCopyWith<$Res>? get symbol {
    if (_self.symbol == null) {
    return null;
  }

  return $WorkspaceSymbolClientCapabilitiesCopyWith<$Res>(_self.symbol!, (value) {
    return _then(_self.copyWith(symbol: value));
  });
}/// Create a copy of WorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$WorkspaceEditClientCapabilitiesCopyWith<$Res>? get workspaceEdit {
    if (_self.workspaceEdit == null) {
    return null;
  }

  return $WorkspaceEditClientCapabilitiesCopyWith<$Res>(_self.workspaceEdit!, (value) {
    return _then(_self.copyWith(workspaceEdit: value));
  });
}
}


/// @nodoc
mixin _$TextDocumentClientCapabilities {

/// Capabilities specific to the various call hierarchy requests.
/// @since 3.16.0
 CallHierarchyClientCapabilities? get callHierarchy;/// Capabilities specific to the `textDocument/codeAction` request.
 CodeActionClientCapabilities? get codeAction;/// Capabilities specific to the `textDocument/codeLens` request.
 CodeLensClientCapabilities? get codeLens;/// Capabilities specific to the `textDocument/documentColor` and the
/// `textDocument/colorPresentation` request.
/// @since 3.6.0
 DocumentColorClientCapabilities? get colorProvider;/// Capabilities specific to the `textDocument/completion` request.
 CompletionClientCapabilities? get completion;/// Capabilities specific to the `textDocument/declaration` request.
/// @since 3.14.0
 DeclarationClientCapabilities? get declaration;/// Capabilities specific to the `textDocument/definition` request.
 DefinitionClientCapabilities? get definition;/// Capabilities specific to the diagnostic pull model.
/// @since 3.17.0
 DiagnosticClientCapabilities? get diagnostic;/// Capabilities specific to the `textDocument/documentHighlight` request.
 DocumentHighlightClientCapabilities? get documentHighlight;/// Capabilities specific to the `textDocument/documentLink` request.
 DocumentLinkClientCapabilities? get documentLink;/// Capabilities specific to the `textDocument/documentSymbol` request.
 DocumentSymbolClientCapabilities? get documentSymbol;/// Capabilities specific to the `textDocument/foldingRange` request.
/// @since 3.10.0
 FoldingRangeClientCapabilities? get foldingRange;/// Capabilities specific to the `textDocument/formatting` request.
 DocumentFormattingClientCapabilities? get formatting;/// Capabilities specific to the `textDocument/hover` request.
 HoverClientCapabilities? get hover;/// Capabilities specific to the `textDocument/implementation` request.
/// @since 3.6.0
 ImplementationClientCapabilities? get implementation;/// Capabilities specific to the `textDocument/inlayHint` request.
/// @since 3.17.0
 InlayHintClientCapabilities? get inlayHint;/// Client capabilities specific to inline completions.
/// @since 3.18.0 @proposed
 InlineCompletionClientCapabilities? get inlineCompletion;/// Capabilities specific to the `textDocument/inlineValue` request.
/// @since 3.17.0
 InlineValueClientCapabilities? get inlineValue;/// Capabilities specific to the `textDocument/linkedEditingRange` request.
/// @since 3.16.0
 LinkedEditingRangeClientCapabilities? get linkedEditingRange;/// Client capabilities specific to the `textDocument/moniker` request.
/// @since 3.16.0
 MonikerClientCapabilities? get moniker;/// Capabilities specific to the `textDocument/onTypeFormatting` request.
 DocumentOnTypeFormattingClientCapabilities? get onTypeFormatting;/// Capabilities specific to the `textDocument/publishDiagnostics`
/// notification.
 PublishDiagnosticsClientCapabilities? get publishDiagnostics;/// Capabilities specific to the `textDocument/rangeFormatting` request.
 DocumentRangeFormattingClientCapabilities? get rangeFormatting;/// Capabilities specific to the `textDocument/references` request.
 ReferenceClientCapabilities? get references;/// Capabilities specific to the `textDocument/rename` request.
 RenameClientCapabilities? get rename;/// Capabilities specific to the `textDocument/selectionRange` request.
/// @since 3.15.0
 SelectionRangeClientCapabilities? get selectionRange;/// Capabilities specific to the various semantic token request.
/// @since 3.16.0
 SemanticTokensClientCapabilities? get semanticTokens;/// Capabilities specific to the `textDocument/signatureHelp` request.
 SignatureHelpClientCapabilities? get signatureHelp;/// Defines which synchronization capabilities the client supports.
 TextDocumentSyncClientCapabilities? get synchronization;/// Capabilities specific to the `textDocument/typeDefinition` request.
/// @since 3.6.0
 TypeDefinitionClientCapabilities? get typeDefinition;/// Capabilities specific to the various type hierarchy requests.
/// @since 3.17.0
 TypeHierarchyClientCapabilities? get typeHierarchy;
/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TextDocumentClientCapabilitiesCopyWith<TextDocumentClientCapabilities> get copyWith => _$TextDocumentClientCapabilitiesCopyWithImpl<TextDocumentClientCapabilities>(this as TextDocumentClientCapabilities, _$identity);

  /// Serializes this TextDocumentClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TextDocumentClientCapabilities&&(identical(other.callHierarchy, callHierarchy) || other.callHierarchy == callHierarchy)&&(identical(other.codeAction, codeAction) || other.codeAction == codeAction)&&(identical(other.codeLens, codeLens) || other.codeLens == codeLens)&&(identical(other.colorProvider, colorProvider) || other.colorProvider == colorProvider)&&(identical(other.completion, completion) || other.completion == completion)&&(identical(other.declaration, declaration) || other.declaration == declaration)&&(identical(other.definition, definition) || other.definition == definition)&&(identical(other.diagnostic, diagnostic) || other.diagnostic == diagnostic)&&(identical(other.documentHighlight, documentHighlight) || other.documentHighlight == documentHighlight)&&(identical(other.documentLink, documentLink) || other.documentLink == documentLink)&&(identical(other.documentSymbol, documentSymbol) || other.documentSymbol == documentSymbol)&&(identical(other.foldingRange, foldingRange) || other.foldingRange == foldingRange)&&(identical(other.formatting, formatting) || other.formatting == formatting)&&(identical(other.hover, hover) || other.hover == hover)&&(identical(other.implementation, implementation) || other.implementation == implementation)&&(identical(other.inlayHint, inlayHint) || other.inlayHint == inlayHint)&&(identical(other.inlineCompletion, inlineCompletion) || other.inlineCompletion == inlineCompletion)&&(identical(other.inlineValue, inlineValue) || other.inlineValue == inlineValue)&&(identical(other.linkedEditingRange, linkedEditingRange) || other.linkedEditingRange == linkedEditingRange)&&(identical(other.moniker, moniker) || other.moniker == moniker)&&(identical(other.onTypeFormatting, onTypeFormatting) || other.onTypeFormatting == onTypeFormatting)&&(identical(other.publishDiagnostics, publishDiagnostics) || other.publishDiagnostics == publishDiagnostics)&&(identical(other.rangeFormatting, rangeFormatting) || other.rangeFormatting == rangeFormatting)&&(identical(other.references, references) || other.references == references)&&(identical(other.rename, rename) || other.rename == rename)&&(identical(other.selectionRange, selectionRange) || other.selectionRange == selectionRange)&&(identical(other.semanticTokens, semanticTokens) || other.semanticTokens == semanticTokens)&&(identical(other.signatureHelp, signatureHelp) || other.signatureHelp == signatureHelp)&&(identical(other.synchronization, synchronization) || other.synchronization == synchronization)&&(identical(other.typeDefinition, typeDefinition) || other.typeDefinition == typeDefinition)&&(identical(other.typeHierarchy, typeHierarchy) || other.typeHierarchy == typeHierarchy));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hashAll([runtimeType,callHierarchy,codeAction,codeLens,colorProvider,completion,declaration,definition,diagnostic,documentHighlight,documentLink,documentSymbol,foldingRange,formatting,hover,implementation,inlayHint,inlineCompletion,inlineValue,linkedEditingRange,moniker,onTypeFormatting,publishDiagnostics,rangeFormatting,references,rename,selectionRange,semanticTokens,signatureHelp,synchronization,typeDefinition,typeHierarchy]);

@override
String toString() {
  return 'TextDocumentClientCapabilities(callHierarchy: $callHierarchy, codeAction: $codeAction, codeLens: $codeLens, colorProvider: $colorProvider, completion: $completion, declaration: $declaration, definition: $definition, diagnostic: $diagnostic, documentHighlight: $documentHighlight, documentLink: $documentLink, documentSymbol: $documentSymbol, foldingRange: $foldingRange, formatting: $formatting, hover: $hover, implementation: $implementation, inlayHint: $inlayHint, inlineCompletion: $inlineCompletion, inlineValue: $inlineValue, linkedEditingRange: $linkedEditingRange, moniker: $moniker, onTypeFormatting: $onTypeFormatting, publishDiagnostics: $publishDiagnostics, rangeFormatting: $rangeFormatting, references: $references, rename: $rename, selectionRange: $selectionRange, semanticTokens: $semanticTokens, signatureHelp: $signatureHelp, synchronization: $synchronization, typeDefinition: $typeDefinition, typeHierarchy: $typeHierarchy)';
}


}

/// @nodoc
abstract mixin class $TextDocumentClientCapabilitiesCopyWith<$Res>  {
  factory $TextDocumentClientCapabilitiesCopyWith(TextDocumentClientCapabilities value, $Res Function(TextDocumentClientCapabilities) _then) = _$TextDocumentClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 CallHierarchyClientCapabilities? callHierarchy, CodeActionClientCapabilities? codeAction, CodeLensClientCapabilities? codeLens, DocumentColorClientCapabilities? colorProvider, CompletionClientCapabilities? completion, DeclarationClientCapabilities? declaration, DefinitionClientCapabilities? definition, DiagnosticClientCapabilities? diagnostic, DocumentHighlightClientCapabilities? documentHighlight, DocumentLinkClientCapabilities? documentLink, DocumentSymbolClientCapabilities? documentSymbol, FoldingRangeClientCapabilities? foldingRange, DocumentFormattingClientCapabilities? formatting, HoverClientCapabilities? hover, ImplementationClientCapabilities? implementation, InlayHintClientCapabilities? inlayHint, InlineCompletionClientCapabilities? inlineCompletion, InlineValueClientCapabilities? inlineValue, LinkedEditingRangeClientCapabilities? linkedEditingRange, MonikerClientCapabilities? moniker, DocumentOnTypeFormattingClientCapabilities? onTypeFormatting, PublishDiagnosticsClientCapabilities? publishDiagnostics, DocumentRangeFormattingClientCapabilities? rangeFormatting, ReferenceClientCapabilities? references, RenameClientCapabilities? rename, SelectionRangeClientCapabilities? selectionRange, SemanticTokensClientCapabilities? semanticTokens, SignatureHelpClientCapabilities? signatureHelp, TextDocumentSyncClientCapabilities? synchronization, TypeDefinitionClientCapabilities? typeDefinition, TypeHierarchyClientCapabilities? typeHierarchy
});


$CallHierarchyClientCapabilitiesCopyWith<$Res>? get callHierarchy;$CodeActionClientCapabilitiesCopyWith<$Res>? get codeAction;$CodeLensClientCapabilitiesCopyWith<$Res>? get codeLens;$DocumentColorClientCapabilitiesCopyWith<$Res>? get colorProvider;$CompletionClientCapabilitiesCopyWith<$Res>? get completion;$DeclarationClientCapabilitiesCopyWith<$Res>? get declaration;$DefinitionClientCapabilitiesCopyWith<$Res>? get definition;$DiagnosticClientCapabilitiesCopyWith<$Res>? get diagnostic;$DocumentHighlightClientCapabilitiesCopyWith<$Res>? get documentHighlight;$DocumentLinkClientCapabilitiesCopyWith<$Res>? get documentLink;$DocumentSymbolClientCapabilitiesCopyWith<$Res>? get documentSymbol;$FoldingRangeClientCapabilitiesCopyWith<$Res>? get foldingRange;$DocumentFormattingClientCapabilitiesCopyWith<$Res>? get formatting;$HoverClientCapabilitiesCopyWith<$Res>? get hover;$ImplementationClientCapabilitiesCopyWith<$Res>? get implementation;$InlayHintClientCapabilitiesCopyWith<$Res>? get inlayHint;$InlineCompletionClientCapabilitiesCopyWith<$Res>? get inlineCompletion;$InlineValueClientCapabilitiesCopyWith<$Res>? get inlineValue;$LinkedEditingRangeClientCapabilitiesCopyWith<$Res>? get linkedEditingRange;$MonikerClientCapabilitiesCopyWith<$Res>? get moniker;$DocumentOnTypeFormattingClientCapabilitiesCopyWith<$Res>? get onTypeFormatting;$PublishDiagnosticsClientCapabilitiesCopyWith<$Res>? get publishDiagnostics;$DocumentRangeFormattingClientCapabilitiesCopyWith<$Res>? get rangeFormatting;$ReferenceClientCapabilitiesCopyWith<$Res>? get references;$RenameClientCapabilitiesCopyWith<$Res>? get rename;$SelectionRangeClientCapabilitiesCopyWith<$Res>? get selectionRange;$SemanticTokensClientCapabilitiesCopyWith<$Res>? get semanticTokens;$SignatureHelpClientCapabilitiesCopyWith<$Res>? get signatureHelp;$TextDocumentSyncClientCapabilitiesCopyWith<$Res>? get synchronization;$TypeDefinitionClientCapabilitiesCopyWith<$Res>? get typeDefinition;$TypeHierarchyClientCapabilitiesCopyWith<$Res>? get typeHierarchy;

}
/// @nodoc
class _$TextDocumentClientCapabilitiesCopyWithImpl<$Res>
    implements $TextDocumentClientCapabilitiesCopyWith<$Res> {
  _$TextDocumentClientCapabilitiesCopyWithImpl(this._self, this._then);

  final TextDocumentClientCapabilities _self;
  final $Res Function(TextDocumentClientCapabilities) _then;

/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? callHierarchy = freezed,Object? codeAction = freezed,Object? codeLens = freezed,Object? colorProvider = freezed,Object? completion = freezed,Object? declaration = freezed,Object? definition = freezed,Object? diagnostic = freezed,Object? documentHighlight = freezed,Object? documentLink = freezed,Object? documentSymbol = freezed,Object? foldingRange = freezed,Object? formatting = freezed,Object? hover = freezed,Object? implementation = freezed,Object? inlayHint = freezed,Object? inlineCompletion = freezed,Object? inlineValue = freezed,Object? linkedEditingRange = freezed,Object? moniker = freezed,Object? onTypeFormatting = freezed,Object? publishDiagnostics = freezed,Object? rangeFormatting = freezed,Object? references = freezed,Object? rename = freezed,Object? selectionRange = freezed,Object? semanticTokens = freezed,Object? signatureHelp = freezed,Object? synchronization = freezed,Object? typeDefinition = freezed,Object? typeHierarchy = freezed,}) {
  return _then(_self.copyWith(
callHierarchy: freezed == callHierarchy ? _self.callHierarchy : callHierarchy // ignore: cast_nullable_to_non_nullable
as CallHierarchyClientCapabilities?,codeAction: freezed == codeAction ? _self.codeAction : codeAction // ignore: cast_nullable_to_non_nullable
as CodeActionClientCapabilities?,codeLens: freezed == codeLens ? _self.codeLens : codeLens // ignore: cast_nullable_to_non_nullable
as CodeLensClientCapabilities?,colorProvider: freezed == colorProvider ? _self.colorProvider : colorProvider // ignore: cast_nullable_to_non_nullable
as DocumentColorClientCapabilities?,completion: freezed == completion ? _self.completion : completion // ignore: cast_nullable_to_non_nullable
as CompletionClientCapabilities?,declaration: freezed == declaration ? _self.declaration : declaration // ignore: cast_nullable_to_non_nullable
as DeclarationClientCapabilities?,definition: freezed == definition ? _self.definition : definition // ignore: cast_nullable_to_non_nullable
as DefinitionClientCapabilities?,diagnostic: freezed == diagnostic ? _self.diagnostic : diagnostic // ignore: cast_nullable_to_non_nullable
as DiagnosticClientCapabilities?,documentHighlight: freezed == documentHighlight ? _self.documentHighlight : documentHighlight // ignore: cast_nullable_to_non_nullable
as DocumentHighlightClientCapabilities?,documentLink: freezed == documentLink ? _self.documentLink : documentLink // ignore: cast_nullable_to_non_nullable
as DocumentLinkClientCapabilities?,documentSymbol: freezed == documentSymbol ? _self.documentSymbol : documentSymbol // ignore: cast_nullable_to_non_nullable
as DocumentSymbolClientCapabilities?,foldingRange: freezed == foldingRange ? _self.foldingRange : foldingRange // ignore: cast_nullable_to_non_nullable
as FoldingRangeClientCapabilities?,formatting: freezed == formatting ? _self.formatting : formatting // ignore: cast_nullable_to_non_nullable
as DocumentFormattingClientCapabilities?,hover: freezed == hover ? _self.hover : hover // ignore: cast_nullable_to_non_nullable
as HoverClientCapabilities?,implementation: freezed == implementation ? _self.implementation : implementation // ignore: cast_nullable_to_non_nullable
as ImplementationClientCapabilities?,inlayHint: freezed == inlayHint ? _self.inlayHint : inlayHint // ignore: cast_nullable_to_non_nullable
as InlayHintClientCapabilities?,inlineCompletion: freezed == inlineCompletion ? _self.inlineCompletion : inlineCompletion // ignore: cast_nullable_to_non_nullable
as InlineCompletionClientCapabilities?,inlineValue: freezed == inlineValue ? _self.inlineValue : inlineValue // ignore: cast_nullable_to_non_nullable
as InlineValueClientCapabilities?,linkedEditingRange: freezed == linkedEditingRange ? _self.linkedEditingRange : linkedEditingRange // ignore: cast_nullable_to_non_nullable
as LinkedEditingRangeClientCapabilities?,moniker: freezed == moniker ? _self.moniker : moniker // ignore: cast_nullable_to_non_nullable
as MonikerClientCapabilities?,onTypeFormatting: freezed == onTypeFormatting ? _self.onTypeFormatting : onTypeFormatting // ignore: cast_nullable_to_non_nullable
as DocumentOnTypeFormattingClientCapabilities?,publishDiagnostics: freezed == publishDiagnostics ? _self.publishDiagnostics : publishDiagnostics // ignore: cast_nullable_to_non_nullable
as PublishDiagnosticsClientCapabilities?,rangeFormatting: freezed == rangeFormatting ? _self.rangeFormatting : rangeFormatting // ignore: cast_nullable_to_non_nullable
as DocumentRangeFormattingClientCapabilities?,references: freezed == references ? _self.references : references // ignore: cast_nullable_to_non_nullable
as ReferenceClientCapabilities?,rename: freezed == rename ? _self.rename : rename // ignore: cast_nullable_to_non_nullable
as RenameClientCapabilities?,selectionRange: freezed == selectionRange ? _self.selectionRange : selectionRange // ignore: cast_nullable_to_non_nullable
as SelectionRangeClientCapabilities?,semanticTokens: freezed == semanticTokens ? _self.semanticTokens : semanticTokens // ignore: cast_nullable_to_non_nullable
as SemanticTokensClientCapabilities?,signatureHelp: freezed == signatureHelp ? _self.signatureHelp : signatureHelp // ignore: cast_nullable_to_non_nullable
as SignatureHelpClientCapabilities?,synchronization: freezed == synchronization ? _self.synchronization : synchronization // ignore: cast_nullable_to_non_nullable
as TextDocumentSyncClientCapabilities?,typeDefinition: freezed == typeDefinition ? _self.typeDefinition : typeDefinition // ignore: cast_nullable_to_non_nullable
as TypeDefinitionClientCapabilities?,typeHierarchy: freezed == typeHierarchy ? _self.typeHierarchy : typeHierarchy // ignore: cast_nullable_to_non_nullable
as TypeHierarchyClientCapabilities?,
  ));
}
/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CallHierarchyClientCapabilitiesCopyWith<$Res>? get callHierarchy {
    if (_self.callHierarchy == null) {
    return null;
  }

  return $CallHierarchyClientCapabilitiesCopyWith<$Res>(_self.callHierarchy!, (value) {
    return _then(_self.copyWith(callHierarchy: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CodeActionClientCapabilitiesCopyWith<$Res>? get codeAction {
    if (_self.codeAction == null) {
    return null;
  }

  return $CodeActionClientCapabilitiesCopyWith<$Res>(_self.codeAction!, (value) {
    return _then(_self.copyWith(codeAction: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CodeLensClientCapabilitiesCopyWith<$Res>? get codeLens {
    if (_self.codeLens == null) {
    return null;
  }

  return $CodeLensClientCapabilitiesCopyWith<$Res>(_self.codeLens!, (value) {
    return _then(_self.copyWith(codeLens: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DocumentColorClientCapabilitiesCopyWith<$Res>? get colorProvider {
    if (_self.colorProvider == null) {
    return null;
  }

  return $DocumentColorClientCapabilitiesCopyWith<$Res>(_self.colorProvider!, (value) {
    return _then(_self.copyWith(colorProvider: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CompletionClientCapabilitiesCopyWith<$Res>? get completion {
    if (_self.completion == null) {
    return null;
  }

  return $CompletionClientCapabilitiesCopyWith<$Res>(_self.completion!, (value) {
    return _then(_self.copyWith(completion: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DeclarationClientCapabilitiesCopyWith<$Res>? get declaration {
    if (_self.declaration == null) {
    return null;
  }

  return $DeclarationClientCapabilitiesCopyWith<$Res>(_self.declaration!, (value) {
    return _then(_self.copyWith(declaration: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DefinitionClientCapabilitiesCopyWith<$Res>? get definition {
    if (_self.definition == null) {
    return null;
  }

  return $DefinitionClientCapabilitiesCopyWith<$Res>(_self.definition!, (value) {
    return _then(_self.copyWith(definition: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DiagnosticClientCapabilitiesCopyWith<$Res>? get diagnostic {
    if (_self.diagnostic == null) {
    return null;
  }

  return $DiagnosticClientCapabilitiesCopyWith<$Res>(_self.diagnostic!, (value) {
    return _then(_self.copyWith(diagnostic: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DocumentHighlightClientCapabilitiesCopyWith<$Res>? get documentHighlight {
    if (_self.documentHighlight == null) {
    return null;
  }

  return $DocumentHighlightClientCapabilitiesCopyWith<$Res>(_self.documentHighlight!, (value) {
    return _then(_self.copyWith(documentHighlight: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DocumentLinkClientCapabilitiesCopyWith<$Res>? get documentLink {
    if (_self.documentLink == null) {
    return null;
  }

  return $DocumentLinkClientCapabilitiesCopyWith<$Res>(_self.documentLink!, (value) {
    return _then(_self.copyWith(documentLink: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DocumentSymbolClientCapabilitiesCopyWith<$Res>? get documentSymbol {
    if (_self.documentSymbol == null) {
    return null;
  }

  return $DocumentSymbolClientCapabilitiesCopyWith<$Res>(_self.documentSymbol!, (value) {
    return _then(_self.copyWith(documentSymbol: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FoldingRangeClientCapabilitiesCopyWith<$Res>? get foldingRange {
    if (_self.foldingRange == null) {
    return null;
  }

  return $FoldingRangeClientCapabilitiesCopyWith<$Res>(_self.foldingRange!, (value) {
    return _then(_self.copyWith(foldingRange: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DocumentFormattingClientCapabilitiesCopyWith<$Res>? get formatting {
    if (_self.formatting == null) {
    return null;
  }

  return $DocumentFormattingClientCapabilitiesCopyWith<$Res>(_self.formatting!, (value) {
    return _then(_self.copyWith(formatting: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$HoverClientCapabilitiesCopyWith<$Res>? get hover {
    if (_self.hover == null) {
    return null;
  }

  return $HoverClientCapabilitiesCopyWith<$Res>(_self.hover!, (value) {
    return _then(_self.copyWith(hover: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ImplementationClientCapabilitiesCopyWith<$Res>? get implementation {
    if (_self.implementation == null) {
    return null;
  }

  return $ImplementationClientCapabilitiesCopyWith<$Res>(_self.implementation!, (value) {
    return _then(_self.copyWith(implementation: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$InlayHintClientCapabilitiesCopyWith<$Res>? get inlayHint {
    if (_self.inlayHint == null) {
    return null;
  }

  return $InlayHintClientCapabilitiesCopyWith<$Res>(_self.inlayHint!, (value) {
    return _then(_self.copyWith(inlayHint: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$InlineCompletionClientCapabilitiesCopyWith<$Res>? get inlineCompletion {
    if (_self.inlineCompletion == null) {
    return null;
  }

  return $InlineCompletionClientCapabilitiesCopyWith<$Res>(_self.inlineCompletion!, (value) {
    return _then(_self.copyWith(inlineCompletion: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$InlineValueClientCapabilitiesCopyWith<$Res>? get inlineValue {
    if (_self.inlineValue == null) {
    return null;
  }

  return $InlineValueClientCapabilitiesCopyWith<$Res>(_self.inlineValue!, (value) {
    return _then(_self.copyWith(inlineValue: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$LinkedEditingRangeClientCapabilitiesCopyWith<$Res>? get linkedEditingRange {
    if (_self.linkedEditingRange == null) {
    return null;
  }

  return $LinkedEditingRangeClientCapabilitiesCopyWith<$Res>(_self.linkedEditingRange!, (value) {
    return _then(_self.copyWith(linkedEditingRange: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$MonikerClientCapabilitiesCopyWith<$Res>? get moniker {
    if (_self.moniker == null) {
    return null;
  }

  return $MonikerClientCapabilitiesCopyWith<$Res>(_self.moniker!, (value) {
    return _then(_self.copyWith(moniker: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DocumentOnTypeFormattingClientCapabilitiesCopyWith<$Res>? get onTypeFormatting {
    if (_self.onTypeFormatting == null) {
    return null;
  }

  return $DocumentOnTypeFormattingClientCapabilitiesCopyWith<$Res>(_self.onTypeFormatting!, (value) {
    return _then(_self.copyWith(onTypeFormatting: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PublishDiagnosticsClientCapabilitiesCopyWith<$Res>? get publishDiagnostics {
    if (_self.publishDiagnostics == null) {
    return null;
  }

  return $PublishDiagnosticsClientCapabilitiesCopyWith<$Res>(_self.publishDiagnostics!, (value) {
    return _then(_self.copyWith(publishDiagnostics: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DocumentRangeFormattingClientCapabilitiesCopyWith<$Res>? get rangeFormatting {
    if (_self.rangeFormatting == null) {
    return null;
  }

  return $DocumentRangeFormattingClientCapabilitiesCopyWith<$Res>(_self.rangeFormatting!, (value) {
    return _then(_self.copyWith(rangeFormatting: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ReferenceClientCapabilitiesCopyWith<$Res>? get references {
    if (_self.references == null) {
    return null;
  }

  return $ReferenceClientCapabilitiesCopyWith<$Res>(_self.references!, (value) {
    return _then(_self.copyWith(references: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RenameClientCapabilitiesCopyWith<$Res>? get rename {
    if (_self.rename == null) {
    return null;
  }

  return $RenameClientCapabilitiesCopyWith<$Res>(_self.rename!, (value) {
    return _then(_self.copyWith(rename: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SelectionRangeClientCapabilitiesCopyWith<$Res>? get selectionRange {
    if (_self.selectionRange == null) {
    return null;
  }

  return $SelectionRangeClientCapabilitiesCopyWith<$Res>(_self.selectionRange!, (value) {
    return _then(_self.copyWith(selectionRange: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SemanticTokensClientCapabilitiesCopyWith<$Res>? get semanticTokens {
    if (_self.semanticTokens == null) {
    return null;
  }

  return $SemanticTokensClientCapabilitiesCopyWith<$Res>(_self.semanticTokens!, (value) {
    return _then(_self.copyWith(semanticTokens: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SignatureHelpClientCapabilitiesCopyWith<$Res>? get signatureHelp {
    if (_self.signatureHelp == null) {
    return null;
  }

  return $SignatureHelpClientCapabilitiesCopyWith<$Res>(_self.signatureHelp!, (value) {
    return _then(_self.copyWith(signatureHelp: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentSyncClientCapabilitiesCopyWith<$Res>? get synchronization {
    if (_self.synchronization == null) {
    return null;
  }

  return $TextDocumentSyncClientCapabilitiesCopyWith<$Res>(_self.synchronization!, (value) {
    return _then(_self.copyWith(synchronization: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TypeDefinitionClientCapabilitiesCopyWith<$Res>? get typeDefinition {
    if (_self.typeDefinition == null) {
    return null;
  }

  return $TypeDefinitionClientCapabilitiesCopyWith<$Res>(_self.typeDefinition!, (value) {
    return _then(_self.copyWith(typeDefinition: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TypeHierarchyClientCapabilitiesCopyWith<$Res>? get typeHierarchy {
    if (_self.typeHierarchy == null) {
    return null;
  }

  return $TypeHierarchyClientCapabilitiesCopyWith<$Res>(_self.typeHierarchy!, (value) {
    return _then(_self.copyWith(typeHierarchy: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _TextDocumentClientCapabilities implements TextDocumentClientCapabilities {
  const _TextDocumentClientCapabilities({this.callHierarchy, this.codeAction, this.codeLens, this.colorProvider, this.completion, this.declaration, this.definition, this.diagnostic, this.documentHighlight, this.documentLink, this.documentSymbol, this.foldingRange, this.formatting, this.hover, this.implementation, this.inlayHint, this.inlineCompletion, this.inlineValue, this.linkedEditingRange, this.moniker, this.onTypeFormatting, this.publishDiagnostics, this.rangeFormatting, this.references, this.rename, this.selectionRange, this.semanticTokens, this.signatureHelp, this.synchronization, this.typeDefinition, this.typeHierarchy});
  factory _TextDocumentClientCapabilities.fromJson(Map<String, dynamic> json) => _$TextDocumentClientCapabilitiesFromJson(json);

/// Capabilities specific to the various call hierarchy requests.
/// @since 3.16.0
@override final  CallHierarchyClientCapabilities? callHierarchy;
/// Capabilities specific to the `textDocument/codeAction` request.
@override final  CodeActionClientCapabilities? codeAction;
/// Capabilities specific to the `textDocument/codeLens` request.
@override final  CodeLensClientCapabilities? codeLens;
/// Capabilities specific to the `textDocument/documentColor` and the
/// `textDocument/colorPresentation` request.
/// @since 3.6.0
@override final  DocumentColorClientCapabilities? colorProvider;
/// Capabilities specific to the `textDocument/completion` request.
@override final  CompletionClientCapabilities? completion;
/// Capabilities specific to the `textDocument/declaration` request.
/// @since 3.14.0
@override final  DeclarationClientCapabilities? declaration;
/// Capabilities specific to the `textDocument/definition` request.
@override final  DefinitionClientCapabilities? definition;
/// Capabilities specific to the diagnostic pull model.
/// @since 3.17.0
@override final  DiagnosticClientCapabilities? diagnostic;
/// Capabilities specific to the `textDocument/documentHighlight` request.
@override final  DocumentHighlightClientCapabilities? documentHighlight;
/// Capabilities specific to the `textDocument/documentLink` request.
@override final  DocumentLinkClientCapabilities? documentLink;
/// Capabilities specific to the `textDocument/documentSymbol` request.
@override final  DocumentSymbolClientCapabilities? documentSymbol;
/// Capabilities specific to the `textDocument/foldingRange` request.
/// @since 3.10.0
@override final  FoldingRangeClientCapabilities? foldingRange;
/// Capabilities specific to the `textDocument/formatting` request.
@override final  DocumentFormattingClientCapabilities? formatting;
/// Capabilities specific to the `textDocument/hover` request.
@override final  HoverClientCapabilities? hover;
/// Capabilities specific to the `textDocument/implementation` request.
/// @since 3.6.0
@override final  ImplementationClientCapabilities? implementation;
/// Capabilities specific to the `textDocument/inlayHint` request.
/// @since 3.17.0
@override final  InlayHintClientCapabilities? inlayHint;
/// Client capabilities specific to inline completions.
/// @since 3.18.0 @proposed
@override final  InlineCompletionClientCapabilities? inlineCompletion;
/// Capabilities specific to the `textDocument/inlineValue` request.
/// @since 3.17.0
@override final  InlineValueClientCapabilities? inlineValue;
/// Capabilities specific to the `textDocument/linkedEditingRange` request.
/// @since 3.16.0
@override final  LinkedEditingRangeClientCapabilities? linkedEditingRange;
/// Client capabilities specific to the `textDocument/moniker` request.
/// @since 3.16.0
@override final  MonikerClientCapabilities? moniker;
/// Capabilities specific to the `textDocument/onTypeFormatting` request.
@override final  DocumentOnTypeFormattingClientCapabilities? onTypeFormatting;
/// Capabilities specific to the `textDocument/publishDiagnostics`
/// notification.
@override final  PublishDiagnosticsClientCapabilities? publishDiagnostics;
/// Capabilities specific to the `textDocument/rangeFormatting` request.
@override final  DocumentRangeFormattingClientCapabilities? rangeFormatting;
/// Capabilities specific to the `textDocument/references` request.
@override final  ReferenceClientCapabilities? references;
/// Capabilities specific to the `textDocument/rename` request.
@override final  RenameClientCapabilities? rename;
/// Capabilities specific to the `textDocument/selectionRange` request.
/// @since 3.15.0
@override final  SelectionRangeClientCapabilities? selectionRange;
/// Capabilities specific to the various semantic token request.
/// @since 3.16.0
@override final  SemanticTokensClientCapabilities? semanticTokens;
/// Capabilities specific to the `textDocument/signatureHelp` request.
@override final  SignatureHelpClientCapabilities? signatureHelp;
/// Defines which synchronization capabilities the client supports.
@override final  TextDocumentSyncClientCapabilities? synchronization;
/// Capabilities specific to the `textDocument/typeDefinition` request.
/// @since 3.6.0
@override final  TypeDefinitionClientCapabilities? typeDefinition;
/// Capabilities specific to the various type hierarchy requests.
/// @since 3.17.0
@override final  TypeHierarchyClientCapabilities? typeHierarchy;

/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TextDocumentClientCapabilitiesCopyWith<_TextDocumentClientCapabilities> get copyWith => __$TextDocumentClientCapabilitiesCopyWithImpl<_TextDocumentClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TextDocumentClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TextDocumentClientCapabilities&&(identical(other.callHierarchy, callHierarchy) || other.callHierarchy == callHierarchy)&&(identical(other.codeAction, codeAction) || other.codeAction == codeAction)&&(identical(other.codeLens, codeLens) || other.codeLens == codeLens)&&(identical(other.colorProvider, colorProvider) || other.colorProvider == colorProvider)&&(identical(other.completion, completion) || other.completion == completion)&&(identical(other.declaration, declaration) || other.declaration == declaration)&&(identical(other.definition, definition) || other.definition == definition)&&(identical(other.diagnostic, diagnostic) || other.diagnostic == diagnostic)&&(identical(other.documentHighlight, documentHighlight) || other.documentHighlight == documentHighlight)&&(identical(other.documentLink, documentLink) || other.documentLink == documentLink)&&(identical(other.documentSymbol, documentSymbol) || other.documentSymbol == documentSymbol)&&(identical(other.foldingRange, foldingRange) || other.foldingRange == foldingRange)&&(identical(other.formatting, formatting) || other.formatting == formatting)&&(identical(other.hover, hover) || other.hover == hover)&&(identical(other.implementation, implementation) || other.implementation == implementation)&&(identical(other.inlayHint, inlayHint) || other.inlayHint == inlayHint)&&(identical(other.inlineCompletion, inlineCompletion) || other.inlineCompletion == inlineCompletion)&&(identical(other.inlineValue, inlineValue) || other.inlineValue == inlineValue)&&(identical(other.linkedEditingRange, linkedEditingRange) || other.linkedEditingRange == linkedEditingRange)&&(identical(other.moniker, moniker) || other.moniker == moniker)&&(identical(other.onTypeFormatting, onTypeFormatting) || other.onTypeFormatting == onTypeFormatting)&&(identical(other.publishDiagnostics, publishDiagnostics) || other.publishDiagnostics == publishDiagnostics)&&(identical(other.rangeFormatting, rangeFormatting) || other.rangeFormatting == rangeFormatting)&&(identical(other.references, references) || other.references == references)&&(identical(other.rename, rename) || other.rename == rename)&&(identical(other.selectionRange, selectionRange) || other.selectionRange == selectionRange)&&(identical(other.semanticTokens, semanticTokens) || other.semanticTokens == semanticTokens)&&(identical(other.signatureHelp, signatureHelp) || other.signatureHelp == signatureHelp)&&(identical(other.synchronization, synchronization) || other.synchronization == synchronization)&&(identical(other.typeDefinition, typeDefinition) || other.typeDefinition == typeDefinition)&&(identical(other.typeHierarchy, typeHierarchy) || other.typeHierarchy == typeHierarchy));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hashAll([runtimeType,callHierarchy,codeAction,codeLens,colorProvider,completion,declaration,definition,diagnostic,documentHighlight,documentLink,documentSymbol,foldingRange,formatting,hover,implementation,inlayHint,inlineCompletion,inlineValue,linkedEditingRange,moniker,onTypeFormatting,publishDiagnostics,rangeFormatting,references,rename,selectionRange,semanticTokens,signatureHelp,synchronization,typeDefinition,typeHierarchy]);

@override
String toString() {
  return 'TextDocumentClientCapabilities(callHierarchy: $callHierarchy, codeAction: $codeAction, codeLens: $codeLens, colorProvider: $colorProvider, completion: $completion, declaration: $declaration, definition: $definition, diagnostic: $diagnostic, documentHighlight: $documentHighlight, documentLink: $documentLink, documentSymbol: $documentSymbol, foldingRange: $foldingRange, formatting: $formatting, hover: $hover, implementation: $implementation, inlayHint: $inlayHint, inlineCompletion: $inlineCompletion, inlineValue: $inlineValue, linkedEditingRange: $linkedEditingRange, moniker: $moniker, onTypeFormatting: $onTypeFormatting, publishDiagnostics: $publishDiagnostics, rangeFormatting: $rangeFormatting, references: $references, rename: $rename, selectionRange: $selectionRange, semanticTokens: $semanticTokens, signatureHelp: $signatureHelp, synchronization: $synchronization, typeDefinition: $typeDefinition, typeHierarchy: $typeHierarchy)';
}


}

/// @nodoc
abstract mixin class _$TextDocumentClientCapabilitiesCopyWith<$Res> implements $TextDocumentClientCapabilitiesCopyWith<$Res> {
  factory _$TextDocumentClientCapabilitiesCopyWith(_TextDocumentClientCapabilities value, $Res Function(_TextDocumentClientCapabilities) _then) = __$TextDocumentClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 CallHierarchyClientCapabilities? callHierarchy, CodeActionClientCapabilities? codeAction, CodeLensClientCapabilities? codeLens, DocumentColorClientCapabilities? colorProvider, CompletionClientCapabilities? completion, DeclarationClientCapabilities? declaration, DefinitionClientCapabilities? definition, DiagnosticClientCapabilities? diagnostic, DocumentHighlightClientCapabilities? documentHighlight, DocumentLinkClientCapabilities? documentLink, DocumentSymbolClientCapabilities? documentSymbol, FoldingRangeClientCapabilities? foldingRange, DocumentFormattingClientCapabilities? formatting, HoverClientCapabilities? hover, ImplementationClientCapabilities? implementation, InlayHintClientCapabilities? inlayHint, InlineCompletionClientCapabilities? inlineCompletion, InlineValueClientCapabilities? inlineValue, LinkedEditingRangeClientCapabilities? linkedEditingRange, MonikerClientCapabilities? moniker, DocumentOnTypeFormattingClientCapabilities? onTypeFormatting, PublishDiagnosticsClientCapabilities? publishDiagnostics, DocumentRangeFormattingClientCapabilities? rangeFormatting, ReferenceClientCapabilities? references, RenameClientCapabilities? rename, SelectionRangeClientCapabilities? selectionRange, SemanticTokensClientCapabilities? semanticTokens, SignatureHelpClientCapabilities? signatureHelp, TextDocumentSyncClientCapabilities? synchronization, TypeDefinitionClientCapabilities? typeDefinition, TypeHierarchyClientCapabilities? typeHierarchy
});


@override $CallHierarchyClientCapabilitiesCopyWith<$Res>? get callHierarchy;@override $CodeActionClientCapabilitiesCopyWith<$Res>? get codeAction;@override $CodeLensClientCapabilitiesCopyWith<$Res>? get codeLens;@override $DocumentColorClientCapabilitiesCopyWith<$Res>? get colorProvider;@override $CompletionClientCapabilitiesCopyWith<$Res>? get completion;@override $DeclarationClientCapabilitiesCopyWith<$Res>? get declaration;@override $DefinitionClientCapabilitiesCopyWith<$Res>? get definition;@override $DiagnosticClientCapabilitiesCopyWith<$Res>? get diagnostic;@override $DocumentHighlightClientCapabilitiesCopyWith<$Res>? get documentHighlight;@override $DocumentLinkClientCapabilitiesCopyWith<$Res>? get documentLink;@override $DocumentSymbolClientCapabilitiesCopyWith<$Res>? get documentSymbol;@override $FoldingRangeClientCapabilitiesCopyWith<$Res>? get foldingRange;@override $DocumentFormattingClientCapabilitiesCopyWith<$Res>? get formatting;@override $HoverClientCapabilitiesCopyWith<$Res>? get hover;@override $ImplementationClientCapabilitiesCopyWith<$Res>? get implementation;@override $InlayHintClientCapabilitiesCopyWith<$Res>? get inlayHint;@override $InlineCompletionClientCapabilitiesCopyWith<$Res>? get inlineCompletion;@override $InlineValueClientCapabilitiesCopyWith<$Res>? get inlineValue;@override $LinkedEditingRangeClientCapabilitiesCopyWith<$Res>? get linkedEditingRange;@override $MonikerClientCapabilitiesCopyWith<$Res>? get moniker;@override $DocumentOnTypeFormattingClientCapabilitiesCopyWith<$Res>? get onTypeFormatting;@override $PublishDiagnosticsClientCapabilitiesCopyWith<$Res>? get publishDiagnostics;@override $DocumentRangeFormattingClientCapabilitiesCopyWith<$Res>? get rangeFormatting;@override $ReferenceClientCapabilitiesCopyWith<$Res>? get references;@override $RenameClientCapabilitiesCopyWith<$Res>? get rename;@override $SelectionRangeClientCapabilitiesCopyWith<$Res>? get selectionRange;@override $SemanticTokensClientCapabilitiesCopyWith<$Res>? get semanticTokens;@override $SignatureHelpClientCapabilitiesCopyWith<$Res>? get signatureHelp;@override $TextDocumentSyncClientCapabilitiesCopyWith<$Res>? get synchronization;@override $TypeDefinitionClientCapabilitiesCopyWith<$Res>? get typeDefinition;@override $TypeHierarchyClientCapabilitiesCopyWith<$Res>? get typeHierarchy;

}
/// @nodoc
class __$TextDocumentClientCapabilitiesCopyWithImpl<$Res>
    implements _$TextDocumentClientCapabilitiesCopyWith<$Res> {
  __$TextDocumentClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _TextDocumentClientCapabilities _self;
  final $Res Function(_TextDocumentClientCapabilities) _then;

/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? callHierarchy = freezed,Object? codeAction = freezed,Object? codeLens = freezed,Object? colorProvider = freezed,Object? completion = freezed,Object? declaration = freezed,Object? definition = freezed,Object? diagnostic = freezed,Object? documentHighlight = freezed,Object? documentLink = freezed,Object? documentSymbol = freezed,Object? foldingRange = freezed,Object? formatting = freezed,Object? hover = freezed,Object? implementation = freezed,Object? inlayHint = freezed,Object? inlineCompletion = freezed,Object? inlineValue = freezed,Object? linkedEditingRange = freezed,Object? moniker = freezed,Object? onTypeFormatting = freezed,Object? publishDiagnostics = freezed,Object? rangeFormatting = freezed,Object? references = freezed,Object? rename = freezed,Object? selectionRange = freezed,Object? semanticTokens = freezed,Object? signatureHelp = freezed,Object? synchronization = freezed,Object? typeDefinition = freezed,Object? typeHierarchy = freezed,}) {
  return _then(_TextDocumentClientCapabilities(
callHierarchy: freezed == callHierarchy ? _self.callHierarchy : callHierarchy // ignore: cast_nullable_to_non_nullable
as CallHierarchyClientCapabilities?,codeAction: freezed == codeAction ? _self.codeAction : codeAction // ignore: cast_nullable_to_non_nullable
as CodeActionClientCapabilities?,codeLens: freezed == codeLens ? _self.codeLens : codeLens // ignore: cast_nullable_to_non_nullable
as CodeLensClientCapabilities?,colorProvider: freezed == colorProvider ? _self.colorProvider : colorProvider // ignore: cast_nullable_to_non_nullable
as DocumentColorClientCapabilities?,completion: freezed == completion ? _self.completion : completion // ignore: cast_nullable_to_non_nullable
as CompletionClientCapabilities?,declaration: freezed == declaration ? _self.declaration : declaration // ignore: cast_nullable_to_non_nullable
as DeclarationClientCapabilities?,definition: freezed == definition ? _self.definition : definition // ignore: cast_nullable_to_non_nullable
as DefinitionClientCapabilities?,diagnostic: freezed == diagnostic ? _self.diagnostic : diagnostic // ignore: cast_nullable_to_non_nullable
as DiagnosticClientCapabilities?,documentHighlight: freezed == documentHighlight ? _self.documentHighlight : documentHighlight // ignore: cast_nullable_to_non_nullable
as DocumentHighlightClientCapabilities?,documentLink: freezed == documentLink ? _self.documentLink : documentLink // ignore: cast_nullable_to_non_nullable
as DocumentLinkClientCapabilities?,documentSymbol: freezed == documentSymbol ? _self.documentSymbol : documentSymbol // ignore: cast_nullable_to_non_nullable
as DocumentSymbolClientCapabilities?,foldingRange: freezed == foldingRange ? _self.foldingRange : foldingRange // ignore: cast_nullable_to_non_nullable
as FoldingRangeClientCapabilities?,formatting: freezed == formatting ? _self.formatting : formatting // ignore: cast_nullable_to_non_nullable
as DocumentFormattingClientCapabilities?,hover: freezed == hover ? _self.hover : hover // ignore: cast_nullable_to_non_nullable
as HoverClientCapabilities?,implementation: freezed == implementation ? _self.implementation : implementation // ignore: cast_nullable_to_non_nullable
as ImplementationClientCapabilities?,inlayHint: freezed == inlayHint ? _self.inlayHint : inlayHint // ignore: cast_nullable_to_non_nullable
as InlayHintClientCapabilities?,inlineCompletion: freezed == inlineCompletion ? _self.inlineCompletion : inlineCompletion // ignore: cast_nullable_to_non_nullable
as InlineCompletionClientCapabilities?,inlineValue: freezed == inlineValue ? _self.inlineValue : inlineValue // ignore: cast_nullable_to_non_nullable
as InlineValueClientCapabilities?,linkedEditingRange: freezed == linkedEditingRange ? _self.linkedEditingRange : linkedEditingRange // ignore: cast_nullable_to_non_nullable
as LinkedEditingRangeClientCapabilities?,moniker: freezed == moniker ? _self.moniker : moniker // ignore: cast_nullable_to_non_nullable
as MonikerClientCapabilities?,onTypeFormatting: freezed == onTypeFormatting ? _self.onTypeFormatting : onTypeFormatting // ignore: cast_nullable_to_non_nullable
as DocumentOnTypeFormattingClientCapabilities?,publishDiagnostics: freezed == publishDiagnostics ? _self.publishDiagnostics : publishDiagnostics // ignore: cast_nullable_to_non_nullable
as PublishDiagnosticsClientCapabilities?,rangeFormatting: freezed == rangeFormatting ? _self.rangeFormatting : rangeFormatting // ignore: cast_nullable_to_non_nullable
as DocumentRangeFormattingClientCapabilities?,references: freezed == references ? _self.references : references // ignore: cast_nullable_to_non_nullable
as ReferenceClientCapabilities?,rename: freezed == rename ? _self.rename : rename // ignore: cast_nullable_to_non_nullable
as RenameClientCapabilities?,selectionRange: freezed == selectionRange ? _self.selectionRange : selectionRange // ignore: cast_nullable_to_non_nullable
as SelectionRangeClientCapabilities?,semanticTokens: freezed == semanticTokens ? _self.semanticTokens : semanticTokens // ignore: cast_nullable_to_non_nullable
as SemanticTokensClientCapabilities?,signatureHelp: freezed == signatureHelp ? _self.signatureHelp : signatureHelp // ignore: cast_nullable_to_non_nullable
as SignatureHelpClientCapabilities?,synchronization: freezed == synchronization ? _self.synchronization : synchronization // ignore: cast_nullable_to_non_nullable
as TextDocumentSyncClientCapabilities?,typeDefinition: freezed == typeDefinition ? _self.typeDefinition : typeDefinition // ignore: cast_nullable_to_non_nullable
as TypeDefinitionClientCapabilities?,typeHierarchy: freezed == typeHierarchy ? _self.typeHierarchy : typeHierarchy // ignore: cast_nullable_to_non_nullable
as TypeHierarchyClientCapabilities?,
  ));
}

/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CallHierarchyClientCapabilitiesCopyWith<$Res>? get callHierarchy {
    if (_self.callHierarchy == null) {
    return null;
  }

  return $CallHierarchyClientCapabilitiesCopyWith<$Res>(_self.callHierarchy!, (value) {
    return _then(_self.copyWith(callHierarchy: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CodeActionClientCapabilitiesCopyWith<$Res>? get codeAction {
    if (_self.codeAction == null) {
    return null;
  }

  return $CodeActionClientCapabilitiesCopyWith<$Res>(_self.codeAction!, (value) {
    return _then(_self.copyWith(codeAction: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CodeLensClientCapabilitiesCopyWith<$Res>? get codeLens {
    if (_self.codeLens == null) {
    return null;
  }

  return $CodeLensClientCapabilitiesCopyWith<$Res>(_self.codeLens!, (value) {
    return _then(_self.copyWith(codeLens: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DocumentColorClientCapabilitiesCopyWith<$Res>? get colorProvider {
    if (_self.colorProvider == null) {
    return null;
  }

  return $DocumentColorClientCapabilitiesCopyWith<$Res>(_self.colorProvider!, (value) {
    return _then(_self.copyWith(colorProvider: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$CompletionClientCapabilitiesCopyWith<$Res>? get completion {
    if (_self.completion == null) {
    return null;
  }

  return $CompletionClientCapabilitiesCopyWith<$Res>(_self.completion!, (value) {
    return _then(_self.copyWith(completion: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DeclarationClientCapabilitiesCopyWith<$Res>? get declaration {
    if (_self.declaration == null) {
    return null;
  }

  return $DeclarationClientCapabilitiesCopyWith<$Res>(_self.declaration!, (value) {
    return _then(_self.copyWith(declaration: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DefinitionClientCapabilitiesCopyWith<$Res>? get definition {
    if (_self.definition == null) {
    return null;
  }

  return $DefinitionClientCapabilitiesCopyWith<$Res>(_self.definition!, (value) {
    return _then(_self.copyWith(definition: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DiagnosticClientCapabilitiesCopyWith<$Res>? get diagnostic {
    if (_self.diagnostic == null) {
    return null;
  }

  return $DiagnosticClientCapabilitiesCopyWith<$Res>(_self.diagnostic!, (value) {
    return _then(_self.copyWith(diagnostic: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DocumentHighlightClientCapabilitiesCopyWith<$Res>? get documentHighlight {
    if (_self.documentHighlight == null) {
    return null;
  }

  return $DocumentHighlightClientCapabilitiesCopyWith<$Res>(_self.documentHighlight!, (value) {
    return _then(_self.copyWith(documentHighlight: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DocumentLinkClientCapabilitiesCopyWith<$Res>? get documentLink {
    if (_self.documentLink == null) {
    return null;
  }

  return $DocumentLinkClientCapabilitiesCopyWith<$Res>(_self.documentLink!, (value) {
    return _then(_self.copyWith(documentLink: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DocumentSymbolClientCapabilitiesCopyWith<$Res>? get documentSymbol {
    if (_self.documentSymbol == null) {
    return null;
  }

  return $DocumentSymbolClientCapabilitiesCopyWith<$Res>(_self.documentSymbol!, (value) {
    return _then(_self.copyWith(documentSymbol: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$FoldingRangeClientCapabilitiesCopyWith<$Res>? get foldingRange {
    if (_self.foldingRange == null) {
    return null;
  }

  return $FoldingRangeClientCapabilitiesCopyWith<$Res>(_self.foldingRange!, (value) {
    return _then(_self.copyWith(foldingRange: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DocumentFormattingClientCapabilitiesCopyWith<$Res>? get formatting {
    if (_self.formatting == null) {
    return null;
  }

  return $DocumentFormattingClientCapabilitiesCopyWith<$Res>(_self.formatting!, (value) {
    return _then(_self.copyWith(formatting: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$HoverClientCapabilitiesCopyWith<$Res>? get hover {
    if (_self.hover == null) {
    return null;
  }

  return $HoverClientCapabilitiesCopyWith<$Res>(_self.hover!, (value) {
    return _then(_self.copyWith(hover: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ImplementationClientCapabilitiesCopyWith<$Res>? get implementation {
    if (_self.implementation == null) {
    return null;
  }

  return $ImplementationClientCapabilitiesCopyWith<$Res>(_self.implementation!, (value) {
    return _then(_self.copyWith(implementation: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$InlayHintClientCapabilitiesCopyWith<$Res>? get inlayHint {
    if (_self.inlayHint == null) {
    return null;
  }

  return $InlayHintClientCapabilitiesCopyWith<$Res>(_self.inlayHint!, (value) {
    return _then(_self.copyWith(inlayHint: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$InlineCompletionClientCapabilitiesCopyWith<$Res>? get inlineCompletion {
    if (_self.inlineCompletion == null) {
    return null;
  }

  return $InlineCompletionClientCapabilitiesCopyWith<$Res>(_self.inlineCompletion!, (value) {
    return _then(_self.copyWith(inlineCompletion: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$InlineValueClientCapabilitiesCopyWith<$Res>? get inlineValue {
    if (_self.inlineValue == null) {
    return null;
  }

  return $InlineValueClientCapabilitiesCopyWith<$Res>(_self.inlineValue!, (value) {
    return _then(_self.copyWith(inlineValue: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$LinkedEditingRangeClientCapabilitiesCopyWith<$Res>? get linkedEditingRange {
    if (_self.linkedEditingRange == null) {
    return null;
  }

  return $LinkedEditingRangeClientCapabilitiesCopyWith<$Res>(_self.linkedEditingRange!, (value) {
    return _then(_self.copyWith(linkedEditingRange: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$MonikerClientCapabilitiesCopyWith<$Res>? get moniker {
    if (_self.moniker == null) {
    return null;
  }

  return $MonikerClientCapabilitiesCopyWith<$Res>(_self.moniker!, (value) {
    return _then(_self.copyWith(moniker: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DocumentOnTypeFormattingClientCapabilitiesCopyWith<$Res>? get onTypeFormatting {
    if (_self.onTypeFormatting == null) {
    return null;
  }

  return $DocumentOnTypeFormattingClientCapabilitiesCopyWith<$Res>(_self.onTypeFormatting!, (value) {
    return _then(_self.copyWith(onTypeFormatting: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$PublishDiagnosticsClientCapabilitiesCopyWith<$Res>? get publishDiagnostics {
    if (_self.publishDiagnostics == null) {
    return null;
  }

  return $PublishDiagnosticsClientCapabilitiesCopyWith<$Res>(_self.publishDiagnostics!, (value) {
    return _then(_self.copyWith(publishDiagnostics: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$DocumentRangeFormattingClientCapabilitiesCopyWith<$Res>? get rangeFormatting {
    if (_self.rangeFormatting == null) {
    return null;
  }

  return $DocumentRangeFormattingClientCapabilitiesCopyWith<$Res>(_self.rangeFormatting!, (value) {
    return _then(_self.copyWith(rangeFormatting: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ReferenceClientCapabilitiesCopyWith<$Res>? get references {
    if (_self.references == null) {
    return null;
  }

  return $ReferenceClientCapabilitiesCopyWith<$Res>(_self.references!, (value) {
    return _then(_self.copyWith(references: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RenameClientCapabilitiesCopyWith<$Res>? get rename {
    if (_self.rename == null) {
    return null;
  }

  return $RenameClientCapabilitiesCopyWith<$Res>(_self.rename!, (value) {
    return _then(_self.copyWith(rename: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SelectionRangeClientCapabilitiesCopyWith<$Res>? get selectionRange {
    if (_self.selectionRange == null) {
    return null;
  }

  return $SelectionRangeClientCapabilitiesCopyWith<$Res>(_self.selectionRange!, (value) {
    return _then(_self.copyWith(selectionRange: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SemanticTokensClientCapabilitiesCopyWith<$Res>? get semanticTokens {
    if (_self.semanticTokens == null) {
    return null;
  }

  return $SemanticTokensClientCapabilitiesCopyWith<$Res>(_self.semanticTokens!, (value) {
    return _then(_self.copyWith(semanticTokens: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$SignatureHelpClientCapabilitiesCopyWith<$Res>? get signatureHelp {
    if (_self.signatureHelp == null) {
    return null;
  }

  return $SignatureHelpClientCapabilitiesCopyWith<$Res>(_self.signatureHelp!, (value) {
    return _then(_self.copyWith(signatureHelp: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TextDocumentSyncClientCapabilitiesCopyWith<$Res>? get synchronization {
    if (_self.synchronization == null) {
    return null;
  }

  return $TextDocumentSyncClientCapabilitiesCopyWith<$Res>(_self.synchronization!, (value) {
    return _then(_self.copyWith(synchronization: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TypeDefinitionClientCapabilitiesCopyWith<$Res>? get typeDefinition {
    if (_self.typeDefinition == null) {
    return null;
  }

  return $TypeDefinitionClientCapabilitiesCopyWith<$Res>(_self.typeDefinition!, (value) {
    return _then(_self.copyWith(typeDefinition: value));
  });
}/// Create a copy of TextDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$TypeHierarchyClientCapabilitiesCopyWith<$Res>? get typeHierarchy {
    if (_self.typeHierarchy == null) {
    return null;
  }

  return $TypeHierarchyClientCapabilitiesCopyWith<$Res>(_self.typeHierarchy!, (value) {
    return _then(_self.copyWith(typeHierarchy: value));
  });
}
}


/// @nodoc
mixin _$NotebookDocumentClientCapabilities {

/// Capabilities specific to notebook document synchronization
/// @since 3.17.0
 NotebookDocumentSyncClientCapabilities get synchronization;
/// Create a copy of NotebookDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$NotebookDocumentClientCapabilitiesCopyWith<NotebookDocumentClientCapabilities> get copyWith => _$NotebookDocumentClientCapabilitiesCopyWithImpl<NotebookDocumentClientCapabilities>(this as NotebookDocumentClientCapabilities, _$identity);

  /// Serializes this NotebookDocumentClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is NotebookDocumentClientCapabilities&&(identical(other.synchronization, synchronization) || other.synchronization == synchronization));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,synchronization);

@override
String toString() {
  return 'NotebookDocumentClientCapabilities(synchronization: $synchronization)';
}


}

/// @nodoc
abstract mixin class $NotebookDocumentClientCapabilitiesCopyWith<$Res>  {
  factory $NotebookDocumentClientCapabilitiesCopyWith(NotebookDocumentClientCapabilities value, $Res Function(NotebookDocumentClientCapabilities) _then) = _$NotebookDocumentClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 NotebookDocumentSyncClientCapabilities synchronization
});


$NotebookDocumentSyncClientCapabilitiesCopyWith<$Res> get synchronization;

}
/// @nodoc
class _$NotebookDocumentClientCapabilitiesCopyWithImpl<$Res>
    implements $NotebookDocumentClientCapabilitiesCopyWith<$Res> {
  _$NotebookDocumentClientCapabilitiesCopyWithImpl(this._self, this._then);

  final NotebookDocumentClientCapabilities _self;
  final $Res Function(NotebookDocumentClientCapabilities) _then;

/// Create a copy of NotebookDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? synchronization = null,}) {
  return _then(_self.copyWith(
synchronization: null == synchronization ? _self.synchronization : synchronization // ignore: cast_nullable_to_non_nullable
as NotebookDocumentSyncClientCapabilities,
  ));
}
/// Create a copy of NotebookDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$NotebookDocumentSyncClientCapabilitiesCopyWith<$Res> get synchronization {
  
  return $NotebookDocumentSyncClientCapabilitiesCopyWith<$Res>(_self.synchronization, (value) {
    return _then(_self.copyWith(synchronization: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _NotebookDocumentClientCapabilities implements NotebookDocumentClientCapabilities {
  const _NotebookDocumentClientCapabilities({required this.synchronization});
  factory _NotebookDocumentClientCapabilities.fromJson(Map<String, dynamic> json) => _$NotebookDocumentClientCapabilitiesFromJson(json);

/// Capabilities specific to notebook document synchronization
/// @since 3.17.0
@override final  NotebookDocumentSyncClientCapabilities synchronization;

/// Create a copy of NotebookDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$NotebookDocumentClientCapabilitiesCopyWith<_NotebookDocumentClientCapabilities> get copyWith => __$NotebookDocumentClientCapabilitiesCopyWithImpl<_NotebookDocumentClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$NotebookDocumentClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _NotebookDocumentClientCapabilities&&(identical(other.synchronization, synchronization) || other.synchronization == synchronization));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,synchronization);

@override
String toString() {
  return 'NotebookDocumentClientCapabilities(synchronization: $synchronization)';
}


}

/// @nodoc
abstract mixin class _$NotebookDocumentClientCapabilitiesCopyWith<$Res> implements $NotebookDocumentClientCapabilitiesCopyWith<$Res> {
  factory _$NotebookDocumentClientCapabilitiesCopyWith(_NotebookDocumentClientCapabilities value, $Res Function(_NotebookDocumentClientCapabilities) _then) = __$NotebookDocumentClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 NotebookDocumentSyncClientCapabilities synchronization
});


@override $NotebookDocumentSyncClientCapabilitiesCopyWith<$Res> get synchronization;

}
/// @nodoc
class __$NotebookDocumentClientCapabilitiesCopyWithImpl<$Res>
    implements _$NotebookDocumentClientCapabilitiesCopyWith<$Res> {
  __$NotebookDocumentClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _NotebookDocumentClientCapabilities _self;
  final $Res Function(_NotebookDocumentClientCapabilities) _then;

/// Create a copy of NotebookDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? synchronization = null,}) {
  return _then(_NotebookDocumentClientCapabilities(
synchronization: null == synchronization ? _self.synchronization : synchronization // ignore: cast_nullable_to_non_nullable
as NotebookDocumentSyncClientCapabilities,
  ));
}

/// Create a copy of NotebookDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$NotebookDocumentSyncClientCapabilitiesCopyWith<$Res> get synchronization {
  
  return $NotebookDocumentSyncClientCapabilitiesCopyWith<$Res>(_self.synchronization, (value) {
    return _then(_self.copyWith(synchronization: value));
  });
}
}


/// @nodoc
mixin _$WindowClientCapabilities {

/// Capabilities specific to the showDocument request.
/// @since 3.16.0
 ShowDocumentClientCapabilities? get showDocument;/// Capabilities specific to the showMessage request.
/// @since 3.16.0
 ShowMessageRequestClientCapabilities? get showMessage;/// It indicates whether the client supports server initiated progress
/// using the `window/workDoneProgress/create` request.
/// The capability also controls Whether client supports handling of
/// progress notifications. If set servers are allowed to report a
/// `workDoneProgress` property in the request specific server
/// capabilities.
/// @since 3.15.0
 bool? get workDoneProgress;
/// Create a copy of WindowClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WindowClientCapabilitiesCopyWith<WindowClientCapabilities> get copyWith => _$WindowClientCapabilitiesCopyWithImpl<WindowClientCapabilities>(this as WindowClientCapabilities, _$identity);

  /// Serializes this WindowClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WindowClientCapabilities&&(identical(other.showDocument, showDocument) || other.showDocument == showDocument)&&(identical(other.showMessage, showMessage) || other.showMessage == showMessage)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,showDocument,showMessage,workDoneProgress);

@override
String toString() {
  return 'WindowClientCapabilities(showDocument: $showDocument, showMessage: $showMessage, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class $WindowClientCapabilitiesCopyWith<$Res>  {
  factory $WindowClientCapabilitiesCopyWith(WindowClientCapabilities value, $Res Function(WindowClientCapabilities) _then) = _$WindowClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 ShowDocumentClientCapabilities? showDocument, ShowMessageRequestClientCapabilities? showMessage, bool? workDoneProgress
});


$ShowDocumentClientCapabilitiesCopyWith<$Res>? get showDocument;$ShowMessageRequestClientCapabilitiesCopyWith<$Res>? get showMessage;

}
/// @nodoc
class _$WindowClientCapabilitiesCopyWithImpl<$Res>
    implements $WindowClientCapabilitiesCopyWith<$Res> {
  _$WindowClientCapabilitiesCopyWithImpl(this._self, this._then);

  final WindowClientCapabilities _self;
  final $Res Function(WindowClientCapabilities) _then;

/// Create a copy of WindowClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? showDocument = freezed,Object? showMessage = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_self.copyWith(
showDocument: freezed == showDocument ? _self.showDocument : showDocument // ignore: cast_nullable_to_non_nullable
as ShowDocumentClientCapabilities?,showMessage: freezed == showMessage ? _self.showMessage : showMessage // ignore: cast_nullable_to_non_nullable
as ShowMessageRequestClientCapabilities?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}
/// Create a copy of WindowClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ShowDocumentClientCapabilitiesCopyWith<$Res>? get showDocument {
    if (_self.showDocument == null) {
    return null;
  }

  return $ShowDocumentClientCapabilitiesCopyWith<$Res>(_self.showDocument!, (value) {
    return _then(_self.copyWith(showDocument: value));
  });
}/// Create a copy of WindowClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ShowMessageRequestClientCapabilitiesCopyWith<$Res>? get showMessage {
    if (_self.showMessage == null) {
    return null;
  }

  return $ShowMessageRequestClientCapabilitiesCopyWith<$Res>(_self.showMessage!, (value) {
    return _then(_self.copyWith(showMessage: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _WindowClientCapabilities implements WindowClientCapabilities {
  const _WindowClientCapabilities({this.showDocument, this.showMessage, this.workDoneProgress});
  factory _WindowClientCapabilities.fromJson(Map<String, dynamic> json) => _$WindowClientCapabilitiesFromJson(json);

/// Capabilities specific to the showDocument request.
/// @since 3.16.0
@override final  ShowDocumentClientCapabilities? showDocument;
/// Capabilities specific to the showMessage request.
/// @since 3.16.0
@override final  ShowMessageRequestClientCapabilities? showMessage;
/// It indicates whether the client supports server initiated progress
/// using the `window/workDoneProgress/create` request.
/// The capability also controls Whether client supports handling of
/// progress notifications. If set servers are allowed to report a
/// `workDoneProgress` property in the request specific server
/// capabilities.
/// @since 3.15.0
@override final  bool? workDoneProgress;

/// Create a copy of WindowClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WindowClientCapabilitiesCopyWith<_WindowClientCapabilities> get copyWith => __$WindowClientCapabilitiesCopyWithImpl<_WindowClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WindowClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WindowClientCapabilities&&(identical(other.showDocument, showDocument) || other.showDocument == showDocument)&&(identical(other.showMessage, showMessage) || other.showMessage == showMessage)&&(identical(other.workDoneProgress, workDoneProgress) || other.workDoneProgress == workDoneProgress));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,showDocument,showMessage,workDoneProgress);

@override
String toString() {
  return 'WindowClientCapabilities(showDocument: $showDocument, showMessage: $showMessage, workDoneProgress: $workDoneProgress)';
}


}

/// @nodoc
abstract mixin class _$WindowClientCapabilitiesCopyWith<$Res> implements $WindowClientCapabilitiesCopyWith<$Res> {
  factory _$WindowClientCapabilitiesCopyWith(_WindowClientCapabilities value, $Res Function(_WindowClientCapabilities) _then) = __$WindowClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 ShowDocumentClientCapabilities? showDocument, ShowMessageRequestClientCapabilities? showMessage, bool? workDoneProgress
});


@override $ShowDocumentClientCapabilitiesCopyWith<$Res>? get showDocument;@override $ShowMessageRequestClientCapabilitiesCopyWith<$Res>? get showMessage;

}
/// @nodoc
class __$WindowClientCapabilitiesCopyWithImpl<$Res>
    implements _$WindowClientCapabilitiesCopyWith<$Res> {
  __$WindowClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _WindowClientCapabilities _self;
  final $Res Function(_WindowClientCapabilities) _then;

/// Create a copy of WindowClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? showDocument = freezed,Object? showMessage = freezed,Object? workDoneProgress = freezed,}) {
  return _then(_WindowClientCapabilities(
showDocument: freezed == showDocument ? _self.showDocument : showDocument // ignore: cast_nullable_to_non_nullable
as ShowDocumentClientCapabilities?,showMessage: freezed == showMessage ? _self.showMessage : showMessage // ignore: cast_nullable_to_non_nullable
as ShowMessageRequestClientCapabilities?,workDoneProgress: freezed == workDoneProgress ? _self.workDoneProgress : workDoneProgress // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

/// Create a copy of WindowClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ShowDocumentClientCapabilitiesCopyWith<$Res>? get showDocument {
    if (_self.showDocument == null) {
    return null;
  }

  return $ShowDocumentClientCapabilitiesCopyWith<$Res>(_self.showDocument!, (value) {
    return _then(_self.copyWith(showDocument: value));
  });
}/// Create a copy of WindowClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$ShowMessageRequestClientCapabilitiesCopyWith<$Res>? get showMessage {
    if (_self.showMessage == null) {
    return null;
  }

  return $ShowMessageRequestClientCapabilitiesCopyWith<$Res>(_self.showMessage!, (value) {
    return _then(_self.copyWith(showMessage: value));
  });
}
}


/// @nodoc
mixin _$GeneralClientCapabilities {

/// Client capabilities specific to the client's markdown parser.
/// @since 3.16.0
 MarkdownClientCapabilities? get markdown;/// The position encodings supported by the client. Client and server have
/// to agree on the same position encoding to ensure that offsets (e.g.
/// character position in a line) are interpreted the same on both sides.
/// To keep the protocol backwards compatible the following applies: if the
/// value 'utf-16' is missing from the array of position encodings servers
/// can assume that the client supports UTF-16. UTF-16 is therefore a
/// mandatory encoding.
/// If omitted it defaults to ['utf-16'].
/// Implementation considerations: since the conversion from one encoding
/// into another requires the content of the file / line the conversion is
/// best done where the file is read which is usually on the server side.
/// @since 3.17.0
 List<PositionEncodingKind>? get positionEncodings;/// Client capabilities specific to regular expressions.
/// @since 3.16.0
 RegularExpressionsClientCapabilities? get regularExpressions;/// Client capability that signals how the client handles stale requests
/// (e.g. a request for which the client will not process the response
/// anymore since the information is outdated).
/// @since 3.17.0
 BoolCancelStringsRetryOnContentModified? get staleRequestSupport;
/// Create a copy of GeneralClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$GeneralClientCapabilitiesCopyWith<GeneralClientCapabilities> get copyWith => _$GeneralClientCapabilitiesCopyWithImpl<GeneralClientCapabilities>(this as GeneralClientCapabilities, _$identity);

  /// Serializes this GeneralClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is GeneralClientCapabilities&&(identical(other.markdown, markdown) || other.markdown == markdown)&&const DeepCollectionEquality().equals(other.positionEncodings, positionEncodings)&&(identical(other.regularExpressions, regularExpressions) || other.regularExpressions == regularExpressions)&&const DeepCollectionEquality().equals(other.staleRequestSupport, staleRequestSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,markdown,const DeepCollectionEquality().hash(positionEncodings),regularExpressions,const DeepCollectionEquality().hash(staleRequestSupport));

@override
String toString() {
  return 'GeneralClientCapabilities(markdown: $markdown, positionEncodings: $positionEncodings, regularExpressions: $regularExpressions, staleRequestSupport: $staleRequestSupport)';
}


}

/// @nodoc
abstract mixin class $GeneralClientCapabilitiesCopyWith<$Res>  {
  factory $GeneralClientCapabilitiesCopyWith(GeneralClientCapabilities value, $Res Function(GeneralClientCapabilities) _then) = _$GeneralClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 MarkdownClientCapabilities? markdown, List<PositionEncodingKind>? positionEncodings, RegularExpressionsClientCapabilities? regularExpressions, BoolCancelStringsRetryOnContentModified? staleRequestSupport
});


$MarkdownClientCapabilitiesCopyWith<$Res>? get markdown;$RegularExpressionsClientCapabilitiesCopyWith<$Res>? get regularExpressions;

}
/// @nodoc
class _$GeneralClientCapabilitiesCopyWithImpl<$Res>
    implements $GeneralClientCapabilitiesCopyWith<$Res> {
  _$GeneralClientCapabilitiesCopyWithImpl(this._self, this._then);

  final GeneralClientCapabilities _self;
  final $Res Function(GeneralClientCapabilities) _then;

/// Create a copy of GeneralClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? markdown = freezed,Object? positionEncodings = freezed,Object? regularExpressions = freezed,Object? staleRequestSupport = freezed,}) {
  return _then(_self.copyWith(
markdown: freezed == markdown ? _self.markdown : markdown // ignore: cast_nullable_to_non_nullable
as MarkdownClientCapabilities?,positionEncodings: freezed == positionEncodings ? _self.positionEncodings : positionEncodings // ignore: cast_nullable_to_non_nullable
as List<PositionEncodingKind>?,regularExpressions: freezed == regularExpressions ? _self.regularExpressions : regularExpressions // ignore: cast_nullable_to_non_nullable
as RegularExpressionsClientCapabilities?,staleRequestSupport: freezed == staleRequestSupport ? _self.staleRequestSupport : staleRequestSupport // ignore: cast_nullable_to_non_nullable
as BoolCancelStringsRetryOnContentModified?,
  ));
}
/// Create a copy of GeneralClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$MarkdownClientCapabilitiesCopyWith<$Res>? get markdown {
    if (_self.markdown == null) {
    return null;
  }

  return $MarkdownClientCapabilitiesCopyWith<$Res>(_self.markdown!, (value) {
    return _then(_self.copyWith(markdown: value));
  });
}/// Create a copy of GeneralClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RegularExpressionsClientCapabilitiesCopyWith<$Res>? get regularExpressions {
    if (_self.regularExpressions == null) {
    return null;
  }

  return $RegularExpressionsClientCapabilitiesCopyWith<$Res>(_self.regularExpressions!, (value) {
    return _then(_self.copyWith(regularExpressions: value));
  });
}
}



/// @nodoc
@JsonSerializable()

class _GeneralClientCapabilities implements GeneralClientCapabilities {
  const _GeneralClientCapabilities({this.markdown, final  List<PositionEncodingKind>? positionEncodings, this.regularExpressions, this.staleRequestSupport}): _positionEncodings = positionEncodings;
  factory _GeneralClientCapabilities.fromJson(Map<String, dynamic> json) => _$GeneralClientCapabilitiesFromJson(json);

/// Client capabilities specific to the client's markdown parser.
/// @since 3.16.0
@override final  MarkdownClientCapabilities? markdown;
/// The position encodings supported by the client. Client and server have
/// to agree on the same position encoding to ensure that offsets (e.g.
/// character position in a line) are interpreted the same on both sides.
/// To keep the protocol backwards compatible the following applies: if the
/// value 'utf-16' is missing from the array of position encodings servers
/// can assume that the client supports UTF-16. UTF-16 is therefore a
/// mandatory encoding.
/// If omitted it defaults to ['utf-16'].
/// Implementation considerations: since the conversion from one encoding
/// into another requires the content of the file / line the conversion is
/// best done where the file is read which is usually on the server side.
/// @since 3.17.0
 final  List<PositionEncodingKind>? _positionEncodings;
/// The position encodings supported by the client. Client and server have
/// to agree on the same position encoding to ensure that offsets (e.g.
/// character position in a line) are interpreted the same on both sides.
/// To keep the protocol backwards compatible the following applies: if the
/// value 'utf-16' is missing from the array of position encodings servers
/// can assume that the client supports UTF-16. UTF-16 is therefore a
/// mandatory encoding.
/// If omitted it defaults to ['utf-16'].
/// Implementation considerations: since the conversion from one encoding
/// into another requires the content of the file / line the conversion is
/// best done where the file is read which is usually on the server side.
/// @since 3.17.0
@override List<PositionEncodingKind>? get positionEncodings {
  final value = _positionEncodings;
  if (value == null) return null;
  if (_positionEncodings is EqualUnmodifiableListView) return _positionEncodings;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

/// Client capabilities specific to regular expressions.
/// @since 3.16.0
@override final  RegularExpressionsClientCapabilities? regularExpressions;
/// Client capability that signals how the client handles stale requests
/// (e.g. a request for which the client will not process the response
/// anymore since the information is outdated).
/// @since 3.17.0
@override final  BoolCancelStringsRetryOnContentModified? staleRequestSupport;

/// Create a copy of GeneralClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$GeneralClientCapabilitiesCopyWith<_GeneralClientCapabilities> get copyWith => __$GeneralClientCapabilitiesCopyWithImpl<_GeneralClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$GeneralClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _GeneralClientCapabilities&&(identical(other.markdown, markdown) || other.markdown == markdown)&&const DeepCollectionEquality().equals(other._positionEncodings, _positionEncodings)&&(identical(other.regularExpressions, regularExpressions) || other.regularExpressions == regularExpressions)&&const DeepCollectionEquality().equals(other.staleRequestSupport, staleRequestSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,markdown,const DeepCollectionEquality().hash(_positionEncodings),regularExpressions,const DeepCollectionEquality().hash(staleRequestSupport));

@override
String toString() {
  return 'GeneralClientCapabilities(markdown: $markdown, positionEncodings: $positionEncodings, regularExpressions: $regularExpressions, staleRequestSupport: $staleRequestSupport)';
}


}

/// @nodoc
abstract mixin class _$GeneralClientCapabilitiesCopyWith<$Res> implements $GeneralClientCapabilitiesCopyWith<$Res> {
  factory _$GeneralClientCapabilitiesCopyWith(_GeneralClientCapabilities value, $Res Function(_GeneralClientCapabilities) _then) = __$GeneralClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 MarkdownClientCapabilities? markdown, List<PositionEncodingKind>? positionEncodings, RegularExpressionsClientCapabilities? regularExpressions, BoolCancelStringsRetryOnContentModified? staleRequestSupport
});


@override $MarkdownClientCapabilitiesCopyWith<$Res>? get markdown;@override $RegularExpressionsClientCapabilitiesCopyWith<$Res>? get regularExpressions;

}
/// @nodoc
class __$GeneralClientCapabilitiesCopyWithImpl<$Res>
    implements _$GeneralClientCapabilitiesCopyWith<$Res> {
  __$GeneralClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _GeneralClientCapabilities _self;
  final $Res Function(_GeneralClientCapabilities) _then;

/// Create a copy of GeneralClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? markdown = freezed,Object? positionEncodings = freezed,Object? regularExpressions = freezed,Object? staleRequestSupport = freezed,}) {
  return _then(_GeneralClientCapabilities(
markdown: freezed == markdown ? _self.markdown : markdown // ignore: cast_nullable_to_non_nullable
as MarkdownClientCapabilities?,positionEncodings: freezed == positionEncodings ? _self._positionEncodings : positionEncodings // ignore: cast_nullable_to_non_nullable
as List<PositionEncodingKind>?,regularExpressions: freezed == regularExpressions ? _self.regularExpressions : regularExpressions // ignore: cast_nullable_to_non_nullable
as RegularExpressionsClientCapabilities?,staleRequestSupport: freezed == staleRequestSupport ? _self.staleRequestSupport : staleRequestSupport // ignore: cast_nullable_to_non_nullable
as BoolCancelStringsRetryOnContentModified?,
  ));
}

/// Create a copy of GeneralClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$MarkdownClientCapabilitiesCopyWith<$Res>? get markdown {
    if (_self.markdown == null) {
    return null;
  }

  return $MarkdownClientCapabilitiesCopyWith<$Res>(_self.markdown!, (value) {
    return _then(_self.copyWith(markdown: value));
  });
}/// Create a copy of GeneralClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$RegularExpressionsClientCapabilitiesCopyWith<$Res>? get regularExpressions {
    if (_self.regularExpressions == null) {
    return null;
  }

  return $RegularExpressionsClientCapabilitiesCopyWith<$Res>(_self.regularExpressions!, (value) {
    return _then(_self.copyWith(regularExpressions: value));
  });
}
}


/// @nodoc
mixin _$RelativePattern {

/// A workspace folder or a base URI to which this pattern will be matched
/// against relatively.
 Sealed63 get baseUri;/// The actual glob pattern;
 Pattern get pattern;
/// Create a copy of RelativePattern
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RelativePatternCopyWith<RelativePattern> get copyWith => _$RelativePatternCopyWithImpl<RelativePattern>(this as RelativePattern, _$identity);

  /// Serializes this RelativePattern to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RelativePattern&&(identical(other.baseUri, baseUri) || other.baseUri == baseUri)&&(identical(other.pattern, pattern) || other.pattern == pattern));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,baseUri,pattern);

@override
String toString() {
  return 'RelativePattern(baseUri: $baseUri, pattern: $pattern)';
}


}

/// @nodoc
abstract mixin class $RelativePatternCopyWith<$Res>  {
  factory $RelativePatternCopyWith(RelativePattern value, $Res Function(RelativePattern) _then) = _$RelativePatternCopyWithImpl;
@useResult
$Res call({
 Sealed63 baseUri, Pattern pattern
});




}
/// @nodoc
class _$RelativePatternCopyWithImpl<$Res>
    implements $RelativePatternCopyWith<$Res> {
  _$RelativePatternCopyWithImpl(this._self, this._then);

  final RelativePattern _self;
  final $Res Function(RelativePattern) _then;

/// Create a copy of RelativePattern
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? baseUri = null,Object? pattern = null,}) {
  return _then(_self.copyWith(
baseUri: null == baseUri ? _self.baseUri : baseUri // ignore: cast_nullable_to_non_nullable
as Sealed63,pattern: null == pattern ? _self.pattern : pattern // ignore: cast_nullable_to_non_nullable
as Pattern,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _RelativePattern implements RelativePattern {
  const _RelativePattern({required this.baseUri, required this.pattern});
  factory _RelativePattern.fromJson(Map<String, dynamic> json) => _$RelativePatternFromJson(json);

/// A workspace folder or a base URI to which this pattern will be matched
/// against relatively.
@override final  Sealed63 baseUri;
/// The actual glob pattern;
@override final  Pattern pattern;

/// Create a copy of RelativePattern
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RelativePatternCopyWith<_RelativePattern> get copyWith => __$RelativePatternCopyWithImpl<_RelativePattern>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$RelativePatternToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _RelativePattern&&(identical(other.baseUri, baseUri) || other.baseUri == baseUri)&&(identical(other.pattern, pattern) || other.pattern == pattern));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,baseUri,pattern);

@override
String toString() {
  return 'RelativePattern(baseUri: $baseUri, pattern: $pattern)';
}


}

/// @nodoc
abstract mixin class _$RelativePatternCopyWith<$Res> implements $RelativePatternCopyWith<$Res> {
  factory _$RelativePatternCopyWith(_RelativePattern value, $Res Function(_RelativePattern) _then) = __$RelativePatternCopyWithImpl;
@override @useResult
$Res call({
 Sealed63 baseUri, Pattern pattern
});




}
/// @nodoc
class __$RelativePatternCopyWithImpl<$Res>
    implements _$RelativePatternCopyWith<$Res> {
  __$RelativePatternCopyWithImpl(this._self, this._then);

  final _RelativePattern _self;
  final $Res Function(_RelativePattern) _then;

/// Create a copy of RelativePattern
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? baseUri = null,Object? pattern = null,}) {
  return _then(_RelativePattern(
baseUri: null == baseUri ? _self.baseUri : baseUri // ignore: cast_nullable_to_non_nullable
as Sealed63,pattern: null == pattern ? _self.pattern : pattern // ignore: cast_nullable_to_non_nullable
as Pattern,
  ));
}


}


/// @nodoc
mixin _$WorkspaceEditClientCapabilities {

/// Whether the client in general supports change annotations on text
/// edits, create file, rename file and delete file changes.
/// @since 3.16.0
 BoolGroupsOnLabel? get changeAnnotationSupport;/// The client supports versioned document changes in `WorkspaceEdit`s
 bool? get documentChanges;/// The failure handling strategy of a client if applying the workspace
/// edit fails.
/// @since 3.13.0
 FailureHandlingKind? get failureHandling;/// Whether the client normalizes line endings to the client specific
/// setting. If set to `true` the client will normalize line ending
/// characters in a workspace edit to the client-specified new line
/// character.
/// @since 3.16.0
 bool? get normalizesLineEndings;/// The resource operations the client supports. Clients should at least
/// support 'create', 'rename' and 'delete' files and folders.
/// @since 3.13.0
 List<ResourceOperationKind>? get resourceOperations;
/// Create a copy of WorkspaceEditClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkspaceEditClientCapabilitiesCopyWith<WorkspaceEditClientCapabilities> get copyWith => _$WorkspaceEditClientCapabilitiesCopyWithImpl<WorkspaceEditClientCapabilities>(this as WorkspaceEditClientCapabilities, _$identity);

  /// Serializes this WorkspaceEditClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkspaceEditClientCapabilities&&const DeepCollectionEquality().equals(other.changeAnnotationSupport, changeAnnotationSupport)&&(identical(other.documentChanges, documentChanges) || other.documentChanges == documentChanges)&&(identical(other.failureHandling, failureHandling) || other.failureHandling == failureHandling)&&(identical(other.normalizesLineEndings, normalizesLineEndings) || other.normalizesLineEndings == normalizesLineEndings)&&const DeepCollectionEquality().equals(other.resourceOperations, resourceOperations));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(changeAnnotationSupport),documentChanges,failureHandling,normalizesLineEndings,const DeepCollectionEquality().hash(resourceOperations));

@override
String toString() {
  return 'WorkspaceEditClientCapabilities(changeAnnotationSupport: $changeAnnotationSupport, documentChanges: $documentChanges, failureHandling: $failureHandling, normalizesLineEndings: $normalizesLineEndings, resourceOperations: $resourceOperations)';
}


}

/// @nodoc
abstract mixin class $WorkspaceEditClientCapabilitiesCopyWith<$Res>  {
  factory $WorkspaceEditClientCapabilitiesCopyWith(WorkspaceEditClientCapabilities value, $Res Function(WorkspaceEditClientCapabilities) _then) = _$WorkspaceEditClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 BoolGroupsOnLabel? changeAnnotationSupport, bool? documentChanges, FailureHandlingKind? failureHandling, bool? normalizesLineEndings, List<ResourceOperationKind>? resourceOperations
});




}
/// @nodoc
class _$WorkspaceEditClientCapabilitiesCopyWithImpl<$Res>
    implements $WorkspaceEditClientCapabilitiesCopyWith<$Res> {
  _$WorkspaceEditClientCapabilitiesCopyWithImpl(this._self, this._then);

  final WorkspaceEditClientCapabilities _self;
  final $Res Function(WorkspaceEditClientCapabilities) _then;

/// Create a copy of WorkspaceEditClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? changeAnnotationSupport = freezed,Object? documentChanges = freezed,Object? failureHandling = freezed,Object? normalizesLineEndings = freezed,Object? resourceOperations = freezed,}) {
  return _then(_self.copyWith(
changeAnnotationSupport: freezed == changeAnnotationSupport ? _self.changeAnnotationSupport : changeAnnotationSupport // ignore: cast_nullable_to_non_nullable
as BoolGroupsOnLabel?,documentChanges: freezed == documentChanges ? _self.documentChanges : documentChanges // ignore: cast_nullable_to_non_nullable
as bool?,failureHandling: freezed == failureHandling ? _self.failureHandling : failureHandling // ignore: cast_nullable_to_non_nullable
as FailureHandlingKind?,normalizesLineEndings: freezed == normalizesLineEndings ? _self.normalizesLineEndings : normalizesLineEndings // ignore: cast_nullable_to_non_nullable
as bool?,resourceOperations: freezed == resourceOperations ? _self.resourceOperations : resourceOperations // ignore: cast_nullable_to_non_nullable
as List<ResourceOperationKind>?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _WorkspaceEditClientCapabilities implements WorkspaceEditClientCapabilities {
  const _WorkspaceEditClientCapabilities({this.changeAnnotationSupport, this.documentChanges, this.failureHandling, this.normalizesLineEndings, final  List<ResourceOperationKind>? resourceOperations}): _resourceOperations = resourceOperations;
  factory _WorkspaceEditClientCapabilities.fromJson(Map<String, dynamic> json) => _$WorkspaceEditClientCapabilitiesFromJson(json);

/// Whether the client in general supports change annotations on text
/// edits, create file, rename file and delete file changes.
/// @since 3.16.0
@override final  BoolGroupsOnLabel? changeAnnotationSupport;
/// The client supports versioned document changes in `WorkspaceEdit`s
@override final  bool? documentChanges;
/// The failure handling strategy of a client if applying the workspace
/// edit fails.
/// @since 3.13.0
@override final  FailureHandlingKind? failureHandling;
/// Whether the client normalizes line endings to the client specific
/// setting. If set to `true` the client will normalize line ending
/// characters in a workspace edit to the client-specified new line
/// character.
/// @since 3.16.0
@override final  bool? normalizesLineEndings;
/// The resource operations the client supports. Clients should at least
/// support 'create', 'rename' and 'delete' files and folders.
/// @since 3.13.0
 final  List<ResourceOperationKind>? _resourceOperations;
/// The resource operations the client supports. Clients should at least
/// support 'create', 'rename' and 'delete' files and folders.
/// @since 3.13.0
@override List<ResourceOperationKind>? get resourceOperations {
  final value = _resourceOperations;
  if (value == null) return null;
  if (_resourceOperations is EqualUnmodifiableListView) return _resourceOperations;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}


/// Create a copy of WorkspaceEditClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkspaceEditClientCapabilitiesCopyWith<_WorkspaceEditClientCapabilities> get copyWith => __$WorkspaceEditClientCapabilitiesCopyWithImpl<_WorkspaceEditClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkspaceEditClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkspaceEditClientCapabilities&&const DeepCollectionEquality().equals(other.changeAnnotationSupport, changeAnnotationSupport)&&(identical(other.documentChanges, documentChanges) || other.documentChanges == documentChanges)&&(identical(other.failureHandling, failureHandling) || other.failureHandling == failureHandling)&&(identical(other.normalizesLineEndings, normalizesLineEndings) || other.normalizesLineEndings == normalizesLineEndings)&&const DeepCollectionEquality().equals(other._resourceOperations, _resourceOperations));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(changeAnnotationSupport),documentChanges,failureHandling,normalizesLineEndings,const DeepCollectionEquality().hash(_resourceOperations));

@override
String toString() {
  return 'WorkspaceEditClientCapabilities(changeAnnotationSupport: $changeAnnotationSupport, documentChanges: $documentChanges, failureHandling: $failureHandling, normalizesLineEndings: $normalizesLineEndings, resourceOperations: $resourceOperations)';
}


}

/// @nodoc
abstract mixin class _$WorkspaceEditClientCapabilitiesCopyWith<$Res> implements $WorkspaceEditClientCapabilitiesCopyWith<$Res> {
  factory _$WorkspaceEditClientCapabilitiesCopyWith(_WorkspaceEditClientCapabilities value, $Res Function(_WorkspaceEditClientCapabilities) _then) = __$WorkspaceEditClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 BoolGroupsOnLabel? changeAnnotationSupport, bool? documentChanges, FailureHandlingKind? failureHandling, bool? normalizesLineEndings, List<ResourceOperationKind>? resourceOperations
});




}
/// @nodoc
class __$WorkspaceEditClientCapabilitiesCopyWithImpl<$Res>
    implements _$WorkspaceEditClientCapabilitiesCopyWith<$Res> {
  __$WorkspaceEditClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _WorkspaceEditClientCapabilities _self;
  final $Res Function(_WorkspaceEditClientCapabilities) _then;

/// Create a copy of WorkspaceEditClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? changeAnnotationSupport = freezed,Object? documentChanges = freezed,Object? failureHandling = freezed,Object? normalizesLineEndings = freezed,Object? resourceOperations = freezed,}) {
  return _then(_WorkspaceEditClientCapabilities(
changeAnnotationSupport: freezed == changeAnnotationSupport ? _self.changeAnnotationSupport : changeAnnotationSupport // ignore: cast_nullable_to_non_nullable
as BoolGroupsOnLabel?,documentChanges: freezed == documentChanges ? _self.documentChanges : documentChanges // ignore: cast_nullable_to_non_nullable
as bool?,failureHandling: freezed == failureHandling ? _self.failureHandling : failureHandling // ignore: cast_nullable_to_non_nullable
as FailureHandlingKind?,normalizesLineEndings: freezed == normalizesLineEndings ? _self.normalizesLineEndings : normalizesLineEndings // ignore: cast_nullable_to_non_nullable
as bool?,resourceOperations: freezed == resourceOperations ? _self._resourceOperations : resourceOperations // ignore: cast_nullable_to_non_nullable
as List<ResourceOperationKind>?,
  ));
}


}


/// @nodoc
mixin _$DidChangeConfigurationClientCapabilities {

/// Did change configuration notification supports dynamic registration.
 bool? get dynamicRegistration;
/// Create a copy of DidChangeConfigurationClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DidChangeConfigurationClientCapabilitiesCopyWith<DidChangeConfigurationClientCapabilities> get copyWith => _$DidChangeConfigurationClientCapabilitiesCopyWithImpl<DidChangeConfigurationClientCapabilities>(this as DidChangeConfigurationClientCapabilities, _$identity);

  /// Serializes this DidChangeConfigurationClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DidChangeConfigurationClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'DidChangeConfigurationClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $DidChangeConfigurationClientCapabilitiesCopyWith<$Res>  {
  factory $DidChangeConfigurationClientCapabilitiesCopyWith(DidChangeConfigurationClientCapabilities value, $Res Function(DidChangeConfigurationClientCapabilities) _then) = _$DidChangeConfigurationClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class _$DidChangeConfigurationClientCapabilitiesCopyWithImpl<$Res>
    implements $DidChangeConfigurationClientCapabilitiesCopyWith<$Res> {
  _$DidChangeConfigurationClientCapabilitiesCopyWithImpl(this._self, this._then);

  final DidChangeConfigurationClientCapabilities _self;
  final $Res Function(DidChangeConfigurationClientCapabilities) _then;

/// Create a copy of DidChangeConfigurationClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DidChangeConfigurationClientCapabilities implements DidChangeConfigurationClientCapabilities {
  const _DidChangeConfigurationClientCapabilities({this.dynamicRegistration});
  factory _DidChangeConfigurationClientCapabilities.fromJson(Map<String, dynamic> json) => _$DidChangeConfigurationClientCapabilitiesFromJson(json);

/// Did change configuration notification supports dynamic registration.
@override final  bool? dynamicRegistration;

/// Create a copy of DidChangeConfigurationClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DidChangeConfigurationClientCapabilitiesCopyWith<_DidChangeConfigurationClientCapabilities> get copyWith => __$DidChangeConfigurationClientCapabilitiesCopyWithImpl<_DidChangeConfigurationClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DidChangeConfigurationClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DidChangeConfigurationClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'DidChangeConfigurationClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$DidChangeConfigurationClientCapabilitiesCopyWith<$Res> implements $DidChangeConfigurationClientCapabilitiesCopyWith<$Res> {
  factory _$DidChangeConfigurationClientCapabilitiesCopyWith(_DidChangeConfigurationClientCapabilities value, $Res Function(_DidChangeConfigurationClientCapabilities) _then) = __$DidChangeConfigurationClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class __$DidChangeConfigurationClientCapabilitiesCopyWithImpl<$Res>
    implements _$DidChangeConfigurationClientCapabilitiesCopyWith<$Res> {
  __$DidChangeConfigurationClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _DidChangeConfigurationClientCapabilities _self;
  final $Res Function(_DidChangeConfigurationClientCapabilities) _then;

/// Create a copy of DidChangeConfigurationClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_DidChangeConfigurationClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DidChangeWatchedFilesClientCapabilities {

/// Did change watched files notification supports dynamic registration.
/// Please note that the current protocol doesn't support static
/// configuration for file changes from the server side.
 bool? get dynamicRegistration;/// Whether the client has support for {@link RelativePattern relative
/// pattern} or not.
/// @since 3.17.0
 bool? get relativePatternSupport;
/// Create a copy of DidChangeWatchedFilesClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DidChangeWatchedFilesClientCapabilitiesCopyWith<DidChangeWatchedFilesClientCapabilities> get copyWith => _$DidChangeWatchedFilesClientCapabilitiesCopyWithImpl<DidChangeWatchedFilesClientCapabilities>(this as DidChangeWatchedFilesClientCapabilities, _$identity);

  /// Serializes this DidChangeWatchedFilesClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DidChangeWatchedFilesClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&(identical(other.relativePatternSupport, relativePatternSupport) || other.relativePatternSupport == relativePatternSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration,relativePatternSupport);

@override
String toString() {
  return 'DidChangeWatchedFilesClientCapabilities(dynamicRegistration: $dynamicRegistration, relativePatternSupport: $relativePatternSupport)';
}


}

/// @nodoc
abstract mixin class $DidChangeWatchedFilesClientCapabilitiesCopyWith<$Res>  {
  factory $DidChangeWatchedFilesClientCapabilitiesCopyWith(DidChangeWatchedFilesClientCapabilities value, $Res Function(DidChangeWatchedFilesClientCapabilities) _then) = _$DidChangeWatchedFilesClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration, bool? relativePatternSupport
});




}
/// @nodoc
class _$DidChangeWatchedFilesClientCapabilitiesCopyWithImpl<$Res>
    implements $DidChangeWatchedFilesClientCapabilitiesCopyWith<$Res> {
  _$DidChangeWatchedFilesClientCapabilitiesCopyWithImpl(this._self, this._then);

  final DidChangeWatchedFilesClientCapabilities _self;
  final $Res Function(DidChangeWatchedFilesClientCapabilities) _then;

/// Create a copy of DidChangeWatchedFilesClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,Object? relativePatternSupport = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,relativePatternSupport: freezed == relativePatternSupport ? _self.relativePatternSupport : relativePatternSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DidChangeWatchedFilesClientCapabilities implements DidChangeWatchedFilesClientCapabilities {
  const _DidChangeWatchedFilesClientCapabilities({this.dynamicRegistration, this.relativePatternSupport});
  factory _DidChangeWatchedFilesClientCapabilities.fromJson(Map<String, dynamic> json) => _$DidChangeWatchedFilesClientCapabilitiesFromJson(json);

/// Did change watched files notification supports dynamic registration.
/// Please note that the current protocol doesn't support static
/// configuration for file changes from the server side.
@override final  bool? dynamicRegistration;
/// Whether the client has support for {@link RelativePattern relative
/// pattern} or not.
/// @since 3.17.0
@override final  bool? relativePatternSupport;

/// Create a copy of DidChangeWatchedFilesClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DidChangeWatchedFilesClientCapabilitiesCopyWith<_DidChangeWatchedFilesClientCapabilities> get copyWith => __$DidChangeWatchedFilesClientCapabilitiesCopyWithImpl<_DidChangeWatchedFilesClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DidChangeWatchedFilesClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DidChangeWatchedFilesClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&(identical(other.relativePatternSupport, relativePatternSupport) || other.relativePatternSupport == relativePatternSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration,relativePatternSupport);

@override
String toString() {
  return 'DidChangeWatchedFilesClientCapabilities(dynamicRegistration: $dynamicRegistration, relativePatternSupport: $relativePatternSupport)';
}


}

/// @nodoc
abstract mixin class _$DidChangeWatchedFilesClientCapabilitiesCopyWith<$Res> implements $DidChangeWatchedFilesClientCapabilitiesCopyWith<$Res> {
  factory _$DidChangeWatchedFilesClientCapabilitiesCopyWith(_DidChangeWatchedFilesClientCapabilities value, $Res Function(_DidChangeWatchedFilesClientCapabilities) _then) = __$DidChangeWatchedFilesClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration, bool? relativePatternSupport
});




}
/// @nodoc
class __$DidChangeWatchedFilesClientCapabilitiesCopyWithImpl<$Res>
    implements _$DidChangeWatchedFilesClientCapabilitiesCopyWith<$Res> {
  __$DidChangeWatchedFilesClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _DidChangeWatchedFilesClientCapabilities _self;
  final $Res Function(_DidChangeWatchedFilesClientCapabilities) _then;

/// Create a copy of DidChangeWatchedFilesClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,Object? relativePatternSupport = freezed,}) {
  return _then(_DidChangeWatchedFilesClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,relativePatternSupport: freezed == relativePatternSupport ? _self.relativePatternSupport : relativePatternSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$WorkspaceSymbolClientCapabilities {

/// Symbol request supports dynamic registration.
 bool? get dynamicRegistration;/// The client support partial workspace symbols. The client will send the
/// request `workspaceSymbol/resolve` to the server to resolve additional
/// properties.
/// @since 3.17.0
 StringsProperties? get resolveSupport;/// Specific capabilities for the `SymbolKind` in the `workspace/symbol`
/// request.
 SymbolKindsValueSet? get symbolKind;/// The client supports tags on `SymbolInformation`. Clients supporting
/// tags have to handle unknown tags gracefully.
/// @since 3.16.0
 SymbolTagsValueSet? get tagSupport;
/// Create a copy of WorkspaceSymbolClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$WorkspaceSymbolClientCapabilitiesCopyWith<WorkspaceSymbolClientCapabilities> get copyWith => _$WorkspaceSymbolClientCapabilitiesCopyWithImpl<WorkspaceSymbolClientCapabilities>(this as WorkspaceSymbolClientCapabilities, _$identity);

  /// Serializes this WorkspaceSymbolClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is WorkspaceSymbolClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&const DeepCollectionEquality().equals(other.resolveSupport, resolveSupport)&&const DeepCollectionEquality().equals(other.symbolKind, symbolKind)&&const DeepCollectionEquality().equals(other.tagSupport, tagSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration,const DeepCollectionEquality().hash(resolveSupport),const DeepCollectionEquality().hash(symbolKind),const DeepCollectionEquality().hash(tagSupport));

@override
String toString() {
  return 'WorkspaceSymbolClientCapabilities(dynamicRegistration: $dynamicRegistration, resolveSupport: $resolveSupport, symbolKind: $symbolKind, tagSupport: $tagSupport)';
}


}

/// @nodoc
abstract mixin class $WorkspaceSymbolClientCapabilitiesCopyWith<$Res>  {
  factory $WorkspaceSymbolClientCapabilitiesCopyWith(WorkspaceSymbolClientCapabilities value, $Res Function(WorkspaceSymbolClientCapabilities) _then) = _$WorkspaceSymbolClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration, StringsProperties? resolveSupport, SymbolKindsValueSet? symbolKind, SymbolTagsValueSet? tagSupport
});




}
/// @nodoc
class _$WorkspaceSymbolClientCapabilitiesCopyWithImpl<$Res>
    implements $WorkspaceSymbolClientCapabilitiesCopyWith<$Res> {
  _$WorkspaceSymbolClientCapabilitiesCopyWithImpl(this._self, this._then);

  final WorkspaceSymbolClientCapabilities _self;
  final $Res Function(WorkspaceSymbolClientCapabilities) _then;

/// Create a copy of WorkspaceSymbolClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,Object? resolveSupport = freezed,Object? symbolKind = freezed,Object? tagSupport = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,resolveSupport: freezed == resolveSupport ? _self.resolveSupport : resolveSupport // ignore: cast_nullable_to_non_nullable
as StringsProperties?,symbolKind: freezed == symbolKind ? _self.symbolKind : symbolKind // ignore: cast_nullable_to_non_nullable
as SymbolKindsValueSet?,tagSupport: freezed == tagSupport ? _self.tagSupport : tagSupport // ignore: cast_nullable_to_non_nullable
as SymbolTagsValueSet?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _WorkspaceSymbolClientCapabilities implements WorkspaceSymbolClientCapabilities {
  const _WorkspaceSymbolClientCapabilities({this.dynamicRegistration, this.resolveSupport, this.symbolKind, this.tagSupport});
  factory _WorkspaceSymbolClientCapabilities.fromJson(Map<String, dynamic> json) => _$WorkspaceSymbolClientCapabilitiesFromJson(json);

/// Symbol request supports dynamic registration.
@override final  bool? dynamicRegistration;
/// The client support partial workspace symbols. The client will send the
/// request `workspaceSymbol/resolve` to the server to resolve additional
/// properties.
/// @since 3.17.0
@override final  StringsProperties? resolveSupport;
/// Specific capabilities for the `SymbolKind` in the `workspace/symbol`
/// request.
@override final  SymbolKindsValueSet? symbolKind;
/// The client supports tags on `SymbolInformation`. Clients supporting
/// tags have to handle unknown tags gracefully.
/// @since 3.16.0
@override final  SymbolTagsValueSet? tagSupport;

/// Create a copy of WorkspaceSymbolClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$WorkspaceSymbolClientCapabilitiesCopyWith<_WorkspaceSymbolClientCapabilities> get copyWith => __$WorkspaceSymbolClientCapabilitiesCopyWithImpl<_WorkspaceSymbolClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$WorkspaceSymbolClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _WorkspaceSymbolClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&const DeepCollectionEquality().equals(other.resolveSupport, resolveSupport)&&const DeepCollectionEquality().equals(other.symbolKind, symbolKind)&&const DeepCollectionEquality().equals(other.tagSupport, tagSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration,const DeepCollectionEquality().hash(resolveSupport),const DeepCollectionEquality().hash(symbolKind),const DeepCollectionEquality().hash(tagSupport));

@override
String toString() {
  return 'WorkspaceSymbolClientCapabilities(dynamicRegistration: $dynamicRegistration, resolveSupport: $resolveSupport, symbolKind: $symbolKind, tagSupport: $tagSupport)';
}


}

/// @nodoc
abstract mixin class _$WorkspaceSymbolClientCapabilitiesCopyWith<$Res> implements $WorkspaceSymbolClientCapabilitiesCopyWith<$Res> {
  factory _$WorkspaceSymbolClientCapabilitiesCopyWith(_WorkspaceSymbolClientCapabilities value, $Res Function(_WorkspaceSymbolClientCapabilities) _then) = __$WorkspaceSymbolClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration, StringsProperties? resolveSupport, SymbolKindsValueSet? symbolKind, SymbolTagsValueSet? tagSupport
});




}
/// @nodoc
class __$WorkspaceSymbolClientCapabilitiesCopyWithImpl<$Res>
    implements _$WorkspaceSymbolClientCapabilitiesCopyWith<$Res> {
  __$WorkspaceSymbolClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _WorkspaceSymbolClientCapabilities _self;
  final $Res Function(_WorkspaceSymbolClientCapabilities) _then;

/// Create a copy of WorkspaceSymbolClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,Object? resolveSupport = freezed,Object? symbolKind = freezed,Object? tagSupport = freezed,}) {
  return _then(_WorkspaceSymbolClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,resolveSupport: freezed == resolveSupport ? _self.resolveSupport : resolveSupport // ignore: cast_nullable_to_non_nullable
as StringsProperties?,symbolKind: freezed == symbolKind ? _self.symbolKind : symbolKind // ignore: cast_nullable_to_non_nullable
as SymbolKindsValueSet?,tagSupport: freezed == tagSupport ? _self.tagSupport : tagSupport // ignore: cast_nullable_to_non_nullable
as SymbolTagsValueSet?,
  ));
}


}


/// @nodoc
mixin _$ExecuteCommandClientCapabilities {

/// Execute command supports dynamic registration.
 bool? get dynamicRegistration;
/// Create a copy of ExecuteCommandClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ExecuteCommandClientCapabilitiesCopyWith<ExecuteCommandClientCapabilities> get copyWith => _$ExecuteCommandClientCapabilitiesCopyWithImpl<ExecuteCommandClientCapabilities>(this as ExecuteCommandClientCapabilities, _$identity);

  /// Serializes this ExecuteCommandClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ExecuteCommandClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'ExecuteCommandClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $ExecuteCommandClientCapabilitiesCopyWith<$Res>  {
  factory $ExecuteCommandClientCapabilitiesCopyWith(ExecuteCommandClientCapabilities value, $Res Function(ExecuteCommandClientCapabilities) _then) = _$ExecuteCommandClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class _$ExecuteCommandClientCapabilitiesCopyWithImpl<$Res>
    implements $ExecuteCommandClientCapabilitiesCopyWith<$Res> {
  _$ExecuteCommandClientCapabilitiesCopyWithImpl(this._self, this._then);

  final ExecuteCommandClientCapabilities _self;
  final $Res Function(ExecuteCommandClientCapabilities) _then;

/// Create a copy of ExecuteCommandClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _ExecuteCommandClientCapabilities implements ExecuteCommandClientCapabilities {
  const _ExecuteCommandClientCapabilities({this.dynamicRegistration});
  factory _ExecuteCommandClientCapabilities.fromJson(Map<String, dynamic> json) => _$ExecuteCommandClientCapabilitiesFromJson(json);

/// Execute command supports dynamic registration.
@override final  bool? dynamicRegistration;

/// Create a copy of ExecuteCommandClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ExecuteCommandClientCapabilitiesCopyWith<_ExecuteCommandClientCapabilities> get copyWith => __$ExecuteCommandClientCapabilitiesCopyWithImpl<_ExecuteCommandClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ExecuteCommandClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ExecuteCommandClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'ExecuteCommandClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$ExecuteCommandClientCapabilitiesCopyWith<$Res> implements $ExecuteCommandClientCapabilitiesCopyWith<$Res> {
  factory _$ExecuteCommandClientCapabilitiesCopyWith(_ExecuteCommandClientCapabilities value, $Res Function(_ExecuteCommandClientCapabilities) _then) = __$ExecuteCommandClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class __$ExecuteCommandClientCapabilitiesCopyWithImpl<$Res>
    implements _$ExecuteCommandClientCapabilitiesCopyWith<$Res> {
  __$ExecuteCommandClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _ExecuteCommandClientCapabilities _self;
  final $Res Function(_ExecuteCommandClientCapabilities) _then;

/// Create a copy of ExecuteCommandClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_ExecuteCommandClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$SemanticTokensWorkspaceClientCapabilities {

/// Whether the client implementation supports a refresh request sent from
/// the server to the client.
/// Note that this event is global and will force the client to refresh all
/// semantic tokens currently shown. It should be used with absolute care
/// and is useful for situation where a server for example detects a
/// project wide change that requires such a calculation.
 bool? get refreshSupport;
/// Create a copy of SemanticTokensWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SemanticTokensWorkspaceClientCapabilitiesCopyWith<SemanticTokensWorkspaceClientCapabilities> get copyWith => _$SemanticTokensWorkspaceClientCapabilitiesCopyWithImpl<SemanticTokensWorkspaceClientCapabilities>(this as SemanticTokensWorkspaceClientCapabilities, _$identity);

  /// Serializes this SemanticTokensWorkspaceClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SemanticTokensWorkspaceClientCapabilities&&(identical(other.refreshSupport, refreshSupport) || other.refreshSupport == refreshSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,refreshSupport);

@override
String toString() {
  return 'SemanticTokensWorkspaceClientCapabilities(refreshSupport: $refreshSupport)';
}


}

/// @nodoc
abstract mixin class $SemanticTokensWorkspaceClientCapabilitiesCopyWith<$Res>  {
  factory $SemanticTokensWorkspaceClientCapabilitiesCopyWith(SemanticTokensWorkspaceClientCapabilities value, $Res Function(SemanticTokensWorkspaceClientCapabilities) _then) = _$SemanticTokensWorkspaceClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? refreshSupport
});




}
/// @nodoc
class _$SemanticTokensWorkspaceClientCapabilitiesCopyWithImpl<$Res>
    implements $SemanticTokensWorkspaceClientCapabilitiesCopyWith<$Res> {
  _$SemanticTokensWorkspaceClientCapabilitiesCopyWithImpl(this._self, this._then);

  final SemanticTokensWorkspaceClientCapabilities _self;
  final $Res Function(SemanticTokensWorkspaceClientCapabilities) _then;

/// Create a copy of SemanticTokensWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? refreshSupport = freezed,}) {
  return _then(_self.copyWith(
refreshSupport: freezed == refreshSupport ? _self.refreshSupport : refreshSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _SemanticTokensWorkspaceClientCapabilities implements SemanticTokensWorkspaceClientCapabilities {
  const _SemanticTokensWorkspaceClientCapabilities({this.refreshSupport});
  factory _SemanticTokensWorkspaceClientCapabilities.fromJson(Map<String, dynamic> json) => _$SemanticTokensWorkspaceClientCapabilitiesFromJson(json);

/// Whether the client implementation supports a refresh request sent from
/// the server to the client.
/// Note that this event is global and will force the client to refresh all
/// semantic tokens currently shown. It should be used with absolute care
/// and is useful for situation where a server for example detects a
/// project wide change that requires such a calculation.
@override final  bool? refreshSupport;

/// Create a copy of SemanticTokensWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SemanticTokensWorkspaceClientCapabilitiesCopyWith<_SemanticTokensWorkspaceClientCapabilities> get copyWith => __$SemanticTokensWorkspaceClientCapabilitiesCopyWithImpl<_SemanticTokensWorkspaceClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SemanticTokensWorkspaceClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SemanticTokensWorkspaceClientCapabilities&&(identical(other.refreshSupport, refreshSupport) || other.refreshSupport == refreshSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,refreshSupport);

@override
String toString() {
  return 'SemanticTokensWorkspaceClientCapabilities(refreshSupport: $refreshSupport)';
}


}

/// @nodoc
abstract mixin class _$SemanticTokensWorkspaceClientCapabilitiesCopyWith<$Res> implements $SemanticTokensWorkspaceClientCapabilitiesCopyWith<$Res> {
  factory _$SemanticTokensWorkspaceClientCapabilitiesCopyWith(_SemanticTokensWorkspaceClientCapabilities value, $Res Function(_SemanticTokensWorkspaceClientCapabilities) _then) = __$SemanticTokensWorkspaceClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? refreshSupport
});




}
/// @nodoc
class __$SemanticTokensWorkspaceClientCapabilitiesCopyWithImpl<$Res>
    implements _$SemanticTokensWorkspaceClientCapabilitiesCopyWith<$Res> {
  __$SemanticTokensWorkspaceClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _SemanticTokensWorkspaceClientCapabilities _self;
  final $Res Function(_SemanticTokensWorkspaceClientCapabilities) _then;

/// Create a copy of SemanticTokensWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? refreshSupport = freezed,}) {
  return _then(_SemanticTokensWorkspaceClientCapabilities(
refreshSupport: freezed == refreshSupport ? _self.refreshSupport : refreshSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$CodeLensWorkspaceClientCapabilities {

/// Whether the client implementation supports a refresh request sent from
/// the server to the client.
/// Note that this event is global and will force the client to refresh all
/// code lenses currently shown. It should be used with absolute care and
/// is useful for situation where a server for example detect a project
/// wide change that requires such a calculation.
 bool? get refreshSupport;
/// Create a copy of CodeLensWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CodeLensWorkspaceClientCapabilitiesCopyWith<CodeLensWorkspaceClientCapabilities> get copyWith => _$CodeLensWorkspaceClientCapabilitiesCopyWithImpl<CodeLensWorkspaceClientCapabilities>(this as CodeLensWorkspaceClientCapabilities, _$identity);

  /// Serializes this CodeLensWorkspaceClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CodeLensWorkspaceClientCapabilities&&(identical(other.refreshSupport, refreshSupport) || other.refreshSupport == refreshSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,refreshSupport);

@override
String toString() {
  return 'CodeLensWorkspaceClientCapabilities(refreshSupport: $refreshSupport)';
}


}

/// @nodoc
abstract mixin class $CodeLensWorkspaceClientCapabilitiesCopyWith<$Res>  {
  factory $CodeLensWorkspaceClientCapabilitiesCopyWith(CodeLensWorkspaceClientCapabilities value, $Res Function(CodeLensWorkspaceClientCapabilities) _then) = _$CodeLensWorkspaceClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? refreshSupport
});




}
/// @nodoc
class _$CodeLensWorkspaceClientCapabilitiesCopyWithImpl<$Res>
    implements $CodeLensWorkspaceClientCapabilitiesCopyWith<$Res> {
  _$CodeLensWorkspaceClientCapabilitiesCopyWithImpl(this._self, this._then);

  final CodeLensWorkspaceClientCapabilities _self;
  final $Res Function(CodeLensWorkspaceClientCapabilities) _then;

/// Create a copy of CodeLensWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? refreshSupport = freezed,}) {
  return _then(_self.copyWith(
refreshSupport: freezed == refreshSupport ? _self.refreshSupport : refreshSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _CodeLensWorkspaceClientCapabilities implements CodeLensWorkspaceClientCapabilities {
  const _CodeLensWorkspaceClientCapabilities({this.refreshSupport});
  factory _CodeLensWorkspaceClientCapabilities.fromJson(Map<String, dynamic> json) => _$CodeLensWorkspaceClientCapabilitiesFromJson(json);

/// Whether the client implementation supports a refresh request sent from
/// the server to the client.
/// Note that this event is global and will force the client to refresh all
/// code lenses currently shown. It should be used with absolute care and
/// is useful for situation where a server for example detect a project
/// wide change that requires such a calculation.
@override final  bool? refreshSupport;

/// Create a copy of CodeLensWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CodeLensWorkspaceClientCapabilitiesCopyWith<_CodeLensWorkspaceClientCapabilities> get copyWith => __$CodeLensWorkspaceClientCapabilitiesCopyWithImpl<_CodeLensWorkspaceClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CodeLensWorkspaceClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CodeLensWorkspaceClientCapabilities&&(identical(other.refreshSupport, refreshSupport) || other.refreshSupport == refreshSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,refreshSupport);

@override
String toString() {
  return 'CodeLensWorkspaceClientCapabilities(refreshSupport: $refreshSupport)';
}


}

/// @nodoc
abstract mixin class _$CodeLensWorkspaceClientCapabilitiesCopyWith<$Res> implements $CodeLensWorkspaceClientCapabilitiesCopyWith<$Res> {
  factory _$CodeLensWorkspaceClientCapabilitiesCopyWith(_CodeLensWorkspaceClientCapabilities value, $Res Function(_CodeLensWorkspaceClientCapabilities) _then) = __$CodeLensWorkspaceClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? refreshSupport
});




}
/// @nodoc
class __$CodeLensWorkspaceClientCapabilitiesCopyWithImpl<$Res>
    implements _$CodeLensWorkspaceClientCapabilitiesCopyWith<$Res> {
  __$CodeLensWorkspaceClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _CodeLensWorkspaceClientCapabilities _self;
  final $Res Function(_CodeLensWorkspaceClientCapabilities) _then;

/// Create a copy of CodeLensWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? refreshSupport = freezed,}) {
  return _then(_CodeLensWorkspaceClientCapabilities(
refreshSupport: freezed == refreshSupport ? _self.refreshSupport : refreshSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$FileOperationClientCapabilities {

/// The client has support for sending didCreateFiles notifications.
 bool? get didCreate;/// The client has support for sending didDeleteFiles notifications.
 bool? get didDelete;/// The client has support for sending didRenameFiles notifications.
 bool? get didRename;/// Whether the client supports dynamic registration for file
/// requests/notifications.
 bool? get dynamicRegistration;/// The client has support for sending willCreateFiles requests.
 bool? get willCreate;/// The client has support for sending willDeleteFiles requests.
 bool? get willDelete;/// The client has support for sending willRenameFiles requests.
 bool? get willRename;
/// Create a copy of FileOperationClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FileOperationClientCapabilitiesCopyWith<FileOperationClientCapabilities> get copyWith => _$FileOperationClientCapabilitiesCopyWithImpl<FileOperationClientCapabilities>(this as FileOperationClientCapabilities, _$identity);

  /// Serializes this FileOperationClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FileOperationClientCapabilities&&(identical(other.didCreate, didCreate) || other.didCreate == didCreate)&&(identical(other.didDelete, didDelete) || other.didDelete == didDelete)&&(identical(other.didRename, didRename) || other.didRename == didRename)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&(identical(other.willCreate, willCreate) || other.willCreate == willCreate)&&(identical(other.willDelete, willDelete) || other.willDelete == willDelete)&&(identical(other.willRename, willRename) || other.willRename == willRename));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,didCreate,didDelete,didRename,dynamicRegistration,willCreate,willDelete,willRename);

@override
String toString() {
  return 'FileOperationClientCapabilities(didCreate: $didCreate, didDelete: $didDelete, didRename: $didRename, dynamicRegistration: $dynamicRegistration, willCreate: $willCreate, willDelete: $willDelete, willRename: $willRename)';
}


}

/// @nodoc
abstract mixin class $FileOperationClientCapabilitiesCopyWith<$Res>  {
  factory $FileOperationClientCapabilitiesCopyWith(FileOperationClientCapabilities value, $Res Function(FileOperationClientCapabilities) _then) = _$FileOperationClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? didCreate, bool? didDelete, bool? didRename, bool? dynamicRegistration, bool? willCreate, bool? willDelete, bool? willRename
});




}
/// @nodoc
class _$FileOperationClientCapabilitiesCopyWithImpl<$Res>
    implements $FileOperationClientCapabilitiesCopyWith<$Res> {
  _$FileOperationClientCapabilitiesCopyWithImpl(this._self, this._then);

  final FileOperationClientCapabilities _self;
  final $Res Function(FileOperationClientCapabilities) _then;

/// Create a copy of FileOperationClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? didCreate = freezed,Object? didDelete = freezed,Object? didRename = freezed,Object? dynamicRegistration = freezed,Object? willCreate = freezed,Object? willDelete = freezed,Object? willRename = freezed,}) {
  return _then(_self.copyWith(
didCreate: freezed == didCreate ? _self.didCreate : didCreate // ignore: cast_nullable_to_non_nullable
as bool?,didDelete: freezed == didDelete ? _self.didDelete : didDelete // ignore: cast_nullable_to_non_nullable
as bool?,didRename: freezed == didRename ? _self.didRename : didRename // ignore: cast_nullable_to_non_nullable
as bool?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,willCreate: freezed == willCreate ? _self.willCreate : willCreate // ignore: cast_nullable_to_non_nullable
as bool?,willDelete: freezed == willDelete ? _self.willDelete : willDelete // ignore: cast_nullable_to_non_nullable
as bool?,willRename: freezed == willRename ? _self.willRename : willRename // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _FileOperationClientCapabilities implements FileOperationClientCapabilities {
  const _FileOperationClientCapabilities({this.didCreate, this.didDelete, this.didRename, this.dynamicRegistration, this.willCreate, this.willDelete, this.willRename});
  factory _FileOperationClientCapabilities.fromJson(Map<String, dynamic> json) => _$FileOperationClientCapabilitiesFromJson(json);

/// The client has support for sending didCreateFiles notifications.
@override final  bool? didCreate;
/// The client has support for sending didDeleteFiles notifications.
@override final  bool? didDelete;
/// The client has support for sending didRenameFiles notifications.
@override final  bool? didRename;
/// Whether the client supports dynamic registration for file
/// requests/notifications.
@override final  bool? dynamicRegistration;
/// The client has support for sending willCreateFiles requests.
@override final  bool? willCreate;
/// The client has support for sending willDeleteFiles requests.
@override final  bool? willDelete;
/// The client has support for sending willRenameFiles requests.
@override final  bool? willRename;

/// Create a copy of FileOperationClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$FileOperationClientCapabilitiesCopyWith<_FileOperationClientCapabilities> get copyWith => __$FileOperationClientCapabilitiesCopyWithImpl<_FileOperationClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$FileOperationClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _FileOperationClientCapabilities&&(identical(other.didCreate, didCreate) || other.didCreate == didCreate)&&(identical(other.didDelete, didDelete) || other.didDelete == didDelete)&&(identical(other.didRename, didRename) || other.didRename == didRename)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&(identical(other.willCreate, willCreate) || other.willCreate == willCreate)&&(identical(other.willDelete, willDelete) || other.willDelete == willDelete)&&(identical(other.willRename, willRename) || other.willRename == willRename));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,didCreate,didDelete,didRename,dynamicRegistration,willCreate,willDelete,willRename);

@override
String toString() {
  return 'FileOperationClientCapabilities(didCreate: $didCreate, didDelete: $didDelete, didRename: $didRename, dynamicRegistration: $dynamicRegistration, willCreate: $willCreate, willDelete: $willDelete, willRename: $willRename)';
}


}

/// @nodoc
abstract mixin class _$FileOperationClientCapabilitiesCopyWith<$Res> implements $FileOperationClientCapabilitiesCopyWith<$Res> {
  factory _$FileOperationClientCapabilitiesCopyWith(_FileOperationClientCapabilities value, $Res Function(_FileOperationClientCapabilities) _then) = __$FileOperationClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? didCreate, bool? didDelete, bool? didRename, bool? dynamicRegistration, bool? willCreate, bool? willDelete, bool? willRename
});




}
/// @nodoc
class __$FileOperationClientCapabilitiesCopyWithImpl<$Res>
    implements _$FileOperationClientCapabilitiesCopyWith<$Res> {
  __$FileOperationClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _FileOperationClientCapabilities _self;
  final $Res Function(_FileOperationClientCapabilities) _then;

/// Create a copy of FileOperationClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? didCreate = freezed,Object? didDelete = freezed,Object? didRename = freezed,Object? dynamicRegistration = freezed,Object? willCreate = freezed,Object? willDelete = freezed,Object? willRename = freezed,}) {
  return _then(_FileOperationClientCapabilities(
didCreate: freezed == didCreate ? _self.didCreate : didCreate // ignore: cast_nullable_to_non_nullable
as bool?,didDelete: freezed == didDelete ? _self.didDelete : didDelete // ignore: cast_nullable_to_non_nullable
as bool?,didRename: freezed == didRename ? _self.didRename : didRename // ignore: cast_nullable_to_non_nullable
as bool?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,willCreate: freezed == willCreate ? _self.willCreate : willCreate // ignore: cast_nullable_to_non_nullable
as bool?,willDelete: freezed == willDelete ? _self.willDelete : willDelete // ignore: cast_nullable_to_non_nullable
as bool?,willRename: freezed == willRename ? _self.willRename : willRename // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$InlineValueWorkspaceClientCapabilities {

/// Whether the client implementation supports a refresh request sent from
/// the server to the client.
/// Note that this event is global and will force the client to refresh all
/// inline values currently shown. It should be used with absolute care and
/// is useful for situation where a server for example detects a project
/// wide change that requires such a calculation.
 bool? get refreshSupport;
/// Create a copy of InlineValueWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlineValueWorkspaceClientCapabilitiesCopyWith<InlineValueWorkspaceClientCapabilities> get copyWith => _$InlineValueWorkspaceClientCapabilitiesCopyWithImpl<InlineValueWorkspaceClientCapabilities>(this as InlineValueWorkspaceClientCapabilities, _$identity);

  /// Serializes this InlineValueWorkspaceClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlineValueWorkspaceClientCapabilities&&(identical(other.refreshSupport, refreshSupport) || other.refreshSupport == refreshSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,refreshSupport);

@override
String toString() {
  return 'InlineValueWorkspaceClientCapabilities(refreshSupport: $refreshSupport)';
}


}

/// @nodoc
abstract mixin class $InlineValueWorkspaceClientCapabilitiesCopyWith<$Res>  {
  factory $InlineValueWorkspaceClientCapabilitiesCopyWith(InlineValueWorkspaceClientCapabilities value, $Res Function(InlineValueWorkspaceClientCapabilities) _then) = _$InlineValueWorkspaceClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? refreshSupport
});




}
/// @nodoc
class _$InlineValueWorkspaceClientCapabilitiesCopyWithImpl<$Res>
    implements $InlineValueWorkspaceClientCapabilitiesCopyWith<$Res> {
  _$InlineValueWorkspaceClientCapabilitiesCopyWithImpl(this._self, this._then);

  final InlineValueWorkspaceClientCapabilities _self;
  final $Res Function(InlineValueWorkspaceClientCapabilities) _then;

/// Create a copy of InlineValueWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? refreshSupport = freezed,}) {
  return _then(_self.copyWith(
refreshSupport: freezed == refreshSupport ? _self.refreshSupport : refreshSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _InlineValueWorkspaceClientCapabilities implements InlineValueWorkspaceClientCapabilities {
  const _InlineValueWorkspaceClientCapabilities({this.refreshSupport});
  factory _InlineValueWorkspaceClientCapabilities.fromJson(Map<String, dynamic> json) => _$InlineValueWorkspaceClientCapabilitiesFromJson(json);

/// Whether the client implementation supports a refresh request sent from
/// the server to the client.
/// Note that this event is global and will force the client to refresh all
/// inline values currently shown. It should be used with absolute care and
/// is useful for situation where a server for example detects a project
/// wide change that requires such a calculation.
@override final  bool? refreshSupport;

/// Create a copy of InlineValueWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlineValueWorkspaceClientCapabilitiesCopyWith<_InlineValueWorkspaceClientCapabilities> get copyWith => __$InlineValueWorkspaceClientCapabilitiesCopyWithImpl<_InlineValueWorkspaceClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlineValueWorkspaceClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlineValueWorkspaceClientCapabilities&&(identical(other.refreshSupport, refreshSupport) || other.refreshSupport == refreshSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,refreshSupport);

@override
String toString() {
  return 'InlineValueWorkspaceClientCapabilities(refreshSupport: $refreshSupport)';
}


}

/// @nodoc
abstract mixin class _$InlineValueWorkspaceClientCapabilitiesCopyWith<$Res> implements $InlineValueWorkspaceClientCapabilitiesCopyWith<$Res> {
  factory _$InlineValueWorkspaceClientCapabilitiesCopyWith(_InlineValueWorkspaceClientCapabilities value, $Res Function(_InlineValueWorkspaceClientCapabilities) _then) = __$InlineValueWorkspaceClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? refreshSupport
});




}
/// @nodoc
class __$InlineValueWorkspaceClientCapabilitiesCopyWithImpl<$Res>
    implements _$InlineValueWorkspaceClientCapabilitiesCopyWith<$Res> {
  __$InlineValueWorkspaceClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _InlineValueWorkspaceClientCapabilities _self;
  final $Res Function(_InlineValueWorkspaceClientCapabilities) _then;

/// Create a copy of InlineValueWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? refreshSupport = freezed,}) {
  return _then(_InlineValueWorkspaceClientCapabilities(
refreshSupport: freezed == refreshSupport ? _self.refreshSupport : refreshSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$InlayHintWorkspaceClientCapabilities {

/// Whether the client implementation supports a refresh request sent from
/// the server to the client.
/// Note that this event is global and will force the client to refresh all
/// inlay hints currently shown. It should be used with absolute care and
/// is useful for situation where a server for example detects a project
/// wide change that requires such a calculation.
 bool? get refreshSupport;
/// Create a copy of InlayHintWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlayHintWorkspaceClientCapabilitiesCopyWith<InlayHintWorkspaceClientCapabilities> get copyWith => _$InlayHintWorkspaceClientCapabilitiesCopyWithImpl<InlayHintWorkspaceClientCapabilities>(this as InlayHintWorkspaceClientCapabilities, _$identity);

  /// Serializes this InlayHintWorkspaceClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlayHintWorkspaceClientCapabilities&&(identical(other.refreshSupport, refreshSupport) || other.refreshSupport == refreshSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,refreshSupport);

@override
String toString() {
  return 'InlayHintWorkspaceClientCapabilities(refreshSupport: $refreshSupport)';
}


}

/// @nodoc
abstract mixin class $InlayHintWorkspaceClientCapabilitiesCopyWith<$Res>  {
  factory $InlayHintWorkspaceClientCapabilitiesCopyWith(InlayHintWorkspaceClientCapabilities value, $Res Function(InlayHintWorkspaceClientCapabilities) _then) = _$InlayHintWorkspaceClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? refreshSupport
});




}
/// @nodoc
class _$InlayHintWorkspaceClientCapabilitiesCopyWithImpl<$Res>
    implements $InlayHintWorkspaceClientCapabilitiesCopyWith<$Res> {
  _$InlayHintWorkspaceClientCapabilitiesCopyWithImpl(this._self, this._then);

  final InlayHintWorkspaceClientCapabilities _self;
  final $Res Function(InlayHintWorkspaceClientCapabilities) _then;

/// Create a copy of InlayHintWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? refreshSupport = freezed,}) {
  return _then(_self.copyWith(
refreshSupport: freezed == refreshSupport ? _self.refreshSupport : refreshSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _InlayHintWorkspaceClientCapabilities implements InlayHintWorkspaceClientCapabilities {
  const _InlayHintWorkspaceClientCapabilities({this.refreshSupport});
  factory _InlayHintWorkspaceClientCapabilities.fromJson(Map<String, dynamic> json) => _$InlayHintWorkspaceClientCapabilitiesFromJson(json);

/// Whether the client implementation supports a refresh request sent from
/// the server to the client.
/// Note that this event is global and will force the client to refresh all
/// inlay hints currently shown. It should be used with absolute care and
/// is useful for situation where a server for example detects a project
/// wide change that requires such a calculation.
@override final  bool? refreshSupport;

/// Create a copy of InlayHintWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlayHintWorkspaceClientCapabilitiesCopyWith<_InlayHintWorkspaceClientCapabilities> get copyWith => __$InlayHintWorkspaceClientCapabilitiesCopyWithImpl<_InlayHintWorkspaceClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlayHintWorkspaceClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlayHintWorkspaceClientCapabilities&&(identical(other.refreshSupport, refreshSupport) || other.refreshSupport == refreshSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,refreshSupport);

@override
String toString() {
  return 'InlayHintWorkspaceClientCapabilities(refreshSupport: $refreshSupport)';
}


}

/// @nodoc
abstract mixin class _$InlayHintWorkspaceClientCapabilitiesCopyWith<$Res> implements $InlayHintWorkspaceClientCapabilitiesCopyWith<$Res> {
  factory _$InlayHintWorkspaceClientCapabilitiesCopyWith(_InlayHintWorkspaceClientCapabilities value, $Res Function(_InlayHintWorkspaceClientCapabilities) _then) = __$InlayHintWorkspaceClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? refreshSupport
});




}
/// @nodoc
class __$InlayHintWorkspaceClientCapabilitiesCopyWithImpl<$Res>
    implements _$InlayHintWorkspaceClientCapabilitiesCopyWith<$Res> {
  __$InlayHintWorkspaceClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _InlayHintWorkspaceClientCapabilities _self;
  final $Res Function(_InlayHintWorkspaceClientCapabilities) _then;

/// Create a copy of InlayHintWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? refreshSupport = freezed,}) {
  return _then(_InlayHintWorkspaceClientCapabilities(
refreshSupport: freezed == refreshSupport ? _self.refreshSupport : refreshSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DiagnosticWorkspaceClientCapabilities {

/// Whether the client implementation supports a refresh request sent from
/// the server to the client.
/// Note that this event is global and will force the client to refresh all
/// pulled diagnostics currently shown. It should be used with absolute
/// care and is useful for situation where a server for example detects a
/// project wide change that requires such a calculation.
 bool? get refreshSupport;
/// Create a copy of DiagnosticWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DiagnosticWorkspaceClientCapabilitiesCopyWith<DiagnosticWorkspaceClientCapabilities> get copyWith => _$DiagnosticWorkspaceClientCapabilitiesCopyWithImpl<DiagnosticWorkspaceClientCapabilities>(this as DiagnosticWorkspaceClientCapabilities, _$identity);

  /// Serializes this DiagnosticWorkspaceClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DiagnosticWorkspaceClientCapabilities&&(identical(other.refreshSupport, refreshSupport) || other.refreshSupport == refreshSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,refreshSupport);

@override
String toString() {
  return 'DiagnosticWorkspaceClientCapabilities(refreshSupport: $refreshSupport)';
}


}

/// @nodoc
abstract mixin class $DiagnosticWorkspaceClientCapabilitiesCopyWith<$Res>  {
  factory $DiagnosticWorkspaceClientCapabilitiesCopyWith(DiagnosticWorkspaceClientCapabilities value, $Res Function(DiagnosticWorkspaceClientCapabilities) _then) = _$DiagnosticWorkspaceClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? refreshSupport
});




}
/// @nodoc
class _$DiagnosticWorkspaceClientCapabilitiesCopyWithImpl<$Res>
    implements $DiagnosticWorkspaceClientCapabilitiesCopyWith<$Res> {
  _$DiagnosticWorkspaceClientCapabilitiesCopyWithImpl(this._self, this._then);

  final DiagnosticWorkspaceClientCapabilities _self;
  final $Res Function(DiagnosticWorkspaceClientCapabilities) _then;

/// Create a copy of DiagnosticWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? refreshSupport = freezed,}) {
  return _then(_self.copyWith(
refreshSupport: freezed == refreshSupport ? _self.refreshSupport : refreshSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DiagnosticWorkspaceClientCapabilities implements DiagnosticWorkspaceClientCapabilities {
  const _DiagnosticWorkspaceClientCapabilities({this.refreshSupport});
  factory _DiagnosticWorkspaceClientCapabilities.fromJson(Map<String, dynamic> json) => _$DiagnosticWorkspaceClientCapabilitiesFromJson(json);

/// Whether the client implementation supports a refresh request sent from
/// the server to the client.
/// Note that this event is global and will force the client to refresh all
/// pulled diagnostics currently shown. It should be used with absolute
/// care and is useful for situation where a server for example detects a
/// project wide change that requires such a calculation.
@override final  bool? refreshSupport;

/// Create a copy of DiagnosticWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DiagnosticWorkspaceClientCapabilitiesCopyWith<_DiagnosticWorkspaceClientCapabilities> get copyWith => __$DiagnosticWorkspaceClientCapabilitiesCopyWithImpl<_DiagnosticWorkspaceClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DiagnosticWorkspaceClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DiagnosticWorkspaceClientCapabilities&&(identical(other.refreshSupport, refreshSupport) || other.refreshSupport == refreshSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,refreshSupport);

@override
String toString() {
  return 'DiagnosticWorkspaceClientCapabilities(refreshSupport: $refreshSupport)';
}


}

/// @nodoc
abstract mixin class _$DiagnosticWorkspaceClientCapabilitiesCopyWith<$Res> implements $DiagnosticWorkspaceClientCapabilitiesCopyWith<$Res> {
  factory _$DiagnosticWorkspaceClientCapabilitiesCopyWith(_DiagnosticWorkspaceClientCapabilities value, $Res Function(_DiagnosticWorkspaceClientCapabilities) _then) = __$DiagnosticWorkspaceClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? refreshSupport
});




}
/// @nodoc
class __$DiagnosticWorkspaceClientCapabilitiesCopyWithImpl<$Res>
    implements _$DiagnosticWorkspaceClientCapabilitiesCopyWith<$Res> {
  __$DiagnosticWorkspaceClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _DiagnosticWorkspaceClientCapabilities _self;
  final $Res Function(_DiagnosticWorkspaceClientCapabilities) _then;

/// Create a copy of DiagnosticWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? refreshSupport = freezed,}) {
  return _then(_DiagnosticWorkspaceClientCapabilities(
refreshSupport: freezed == refreshSupport ? _self.refreshSupport : refreshSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$FoldingRangeWorkspaceClientCapabilities {

/// Whether the client implementation supports a refresh request sent from
/// the server to the client.
/// Note that this event is global and will force the client to refresh all
/// folding ranges currently shown. It should be used with absolute care
/// and is useful for situation where a server for example detects a
/// project wide change that requires such a calculation.
/// @since 3.18.0 @proposed
 bool? get refreshSupport;
/// Create a copy of FoldingRangeWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FoldingRangeWorkspaceClientCapabilitiesCopyWith<FoldingRangeWorkspaceClientCapabilities> get copyWith => _$FoldingRangeWorkspaceClientCapabilitiesCopyWithImpl<FoldingRangeWorkspaceClientCapabilities>(this as FoldingRangeWorkspaceClientCapabilities, _$identity);

  /// Serializes this FoldingRangeWorkspaceClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FoldingRangeWorkspaceClientCapabilities&&(identical(other.refreshSupport, refreshSupport) || other.refreshSupport == refreshSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,refreshSupport);

@override
String toString() {
  return 'FoldingRangeWorkspaceClientCapabilities(refreshSupport: $refreshSupport)';
}


}

/// @nodoc
abstract mixin class $FoldingRangeWorkspaceClientCapabilitiesCopyWith<$Res>  {
  factory $FoldingRangeWorkspaceClientCapabilitiesCopyWith(FoldingRangeWorkspaceClientCapabilities value, $Res Function(FoldingRangeWorkspaceClientCapabilities) _then) = _$FoldingRangeWorkspaceClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? refreshSupport
});




}
/// @nodoc
class _$FoldingRangeWorkspaceClientCapabilitiesCopyWithImpl<$Res>
    implements $FoldingRangeWorkspaceClientCapabilitiesCopyWith<$Res> {
  _$FoldingRangeWorkspaceClientCapabilitiesCopyWithImpl(this._self, this._then);

  final FoldingRangeWorkspaceClientCapabilities _self;
  final $Res Function(FoldingRangeWorkspaceClientCapabilities) _then;

/// Create a copy of FoldingRangeWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? refreshSupport = freezed,}) {
  return _then(_self.copyWith(
refreshSupport: freezed == refreshSupport ? _self.refreshSupport : refreshSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _FoldingRangeWorkspaceClientCapabilities implements FoldingRangeWorkspaceClientCapabilities {
  const _FoldingRangeWorkspaceClientCapabilities({this.refreshSupport});
  factory _FoldingRangeWorkspaceClientCapabilities.fromJson(Map<String, dynamic> json) => _$FoldingRangeWorkspaceClientCapabilitiesFromJson(json);

/// Whether the client implementation supports a refresh request sent from
/// the server to the client.
/// Note that this event is global and will force the client to refresh all
/// folding ranges currently shown. It should be used with absolute care
/// and is useful for situation where a server for example detects a
/// project wide change that requires such a calculation.
/// @since 3.18.0 @proposed
@override final  bool? refreshSupport;

/// Create a copy of FoldingRangeWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$FoldingRangeWorkspaceClientCapabilitiesCopyWith<_FoldingRangeWorkspaceClientCapabilities> get copyWith => __$FoldingRangeWorkspaceClientCapabilitiesCopyWithImpl<_FoldingRangeWorkspaceClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$FoldingRangeWorkspaceClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _FoldingRangeWorkspaceClientCapabilities&&(identical(other.refreshSupport, refreshSupport) || other.refreshSupport == refreshSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,refreshSupport);

@override
String toString() {
  return 'FoldingRangeWorkspaceClientCapabilities(refreshSupport: $refreshSupport)';
}


}

/// @nodoc
abstract mixin class _$FoldingRangeWorkspaceClientCapabilitiesCopyWith<$Res> implements $FoldingRangeWorkspaceClientCapabilitiesCopyWith<$Res> {
  factory _$FoldingRangeWorkspaceClientCapabilitiesCopyWith(_FoldingRangeWorkspaceClientCapabilities value, $Res Function(_FoldingRangeWorkspaceClientCapabilities) _then) = __$FoldingRangeWorkspaceClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? refreshSupport
});




}
/// @nodoc
class __$FoldingRangeWorkspaceClientCapabilitiesCopyWithImpl<$Res>
    implements _$FoldingRangeWorkspaceClientCapabilitiesCopyWith<$Res> {
  __$FoldingRangeWorkspaceClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _FoldingRangeWorkspaceClientCapabilities _self;
  final $Res Function(_FoldingRangeWorkspaceClientCapabilities) _then;

/// Create a copy of FoldingRangeWorkspaceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? refreshSupport = freezed,}) {
  return _then(_FoldingRangeWorkspaceClientCapabilities(
refreshSupport: freezed == refreshSupport ? _self.refreshSupport : refreshSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$TextDocumentSyncClientCapabilities {

/// The client supports did save notifications.
 bool? get didSave;/// Whether text document synchronization supports dynamic registration.
 bool? get dynamicRegistration;/// The client supports sending will save notifications.
 bool? get willSave;/// The client supports sending a will save request and waits for a
/// response providing text edits which will be applied to the document
/// before it is saved.
 bool? get willSaveWaitUntil;
/// Create a copy of TextDocumentSyncClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TextDocumentSyncClientCapabilitiesCopyWith<TextDocumentSyncClientCapabilities> get copyWith => _$TextDocumentSyncClientCapabilitiesCopyWithImpl<TextDocumentSyncClientCapabilities>(this as TextDocumentSyncClientCapabilities, _$identity);

  /// Serializes this TextDocumentSyncClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TextDocumentSyncClientCapabilities&&(identical(other.didSave, didSave) || other.didSave == didSave)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&(identical(other.willSave, willSave) || other.willSave == willSave)&&(identical(other.willSaveWaitUntil, willSaveWaitUntil) || other.willSaveWaitUntil == willSaveWaitUntil));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,didSave,dynamicRegistration,willSave,willSaveWaitUntil);

@override
String toString() {
  return 'TextDocumentSyncClientCapabilities(didSave: $didSave, dynamicRegistration: $dynamicRegistration, willSave: $willSave, willSaveWaitUntil: $willSaveWaitUntil)';
}


}

/// @nodoc
abstract mixin class $TextDocumentSyncClientCapabilitiesCopyWith<$Res>  {
  factory $TextDocumentSyncClientCapabilitiesCopyWith(TextDocumentSyncClientCapabilities value, $Res Function(TextDocumentSyncClientCapabilities) _then) = _$TextDocumentSyncClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? didSave, bool? dynamicRegistration, bool? willSave, bool? willSaveWaitUntil
});




}
/// @nodoc
class _$TextDocumentSyncClientCapabilitiesCopyWithImpl<$Res>
    implements $TextDocumentSyncClientCapabilitiesCopyWith<$Res> {
  _$TextDocumentSyncClientCapabilitiesCopyWithImpl(this._self, this._then);

  final TextDocumentSyncClientCapabilities _self;
  final $Res Function(TextDocumentSyncClientCapabilities) _then;

/// Create a copy of TextDocumentSyncClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? didSave = freezed,Object? dynamicRegistration = freezed,Object? willSave = freezed,Object? willSaveWaitUntil = freezed,}) {
  return _then(_self.copyWith(
didSave: freezed == didSave ? _self.didSave : didSave // ignore: cast_nullable_to_non_nullable
as bool?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,willSave: freezed == willSave ? _self.willSave : willSave // ignore: cast_nullable_to_non_nullable
as bool?,willSaveWaitUntil: freezed == willSaveWaitUntil ? _self.willSaveWaitUntil : willSaveWaitUntil // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _TextDocumentSyncClientCapabilities implements TextDocumentSyncClientCapabilities {
  const _TextDocumentSyncClientCapabilities({this.didSave, this.dynamicRegistration, this.willSave, this.willSaveWaitUntil});
  factory _TextDocumentSyncClientCapabilities.fromJson(Map<String, dynamic> json) => _$TextDocumentSyncClientCapabilitiesFromJson(json);

/// The client supports did save notifications.
@override final  bool? didSave;
/// Whether text document synchronization supports dynamic registration.
@override final  bool? dynamicRegistration;
/// The client supports sending will save notifications.
@override final  bool? willSave;
/// The client supports sending a will save request and waits for a
/// response providing text edits which will be applied to the document
/// before it is saved.
@override final  bool? willSaveWaitUntil;

/// Create a copy of TextDocumentSyncClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TextDocumentSyncClientCapabilitiesCopyWith<_TextDocumentSyncClientCapabilities> get copyWith => __$TextDocumentSyncClientCapabilitiesCopyWithImpl<_TextDocumentSyncClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TextDocumentSyncClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TextDocumentSyncClientCapabilities&&(identical(other.didSave, didSave) || other.didSave == didSave)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&(identical(other.willSave, willSave) || other.willSave == willSave)&&(identical(other.willSaveWaitUntil, willSaveWaitUntil) || other.willSaveWaitUntil == willSaveWaitUntil));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,didSave,dynamicRegistration,willSave,willSaveWaitUntil);

@override
String toString() {
  return 'TextDocumentSyncClientCapabilities(didSave: $didSave, dynamicRegistration: $dynamicRegistration, willSave: $willSave, willSaveWaitUntil: $willSaveWaitUntil)';
}


}

/// @nodoc
abstract mixin class _$TextDocumentSyncClientCapabilitiesCopyWith<$Res> implements $TextDocumentSyncClientCapabilitiesCopyWith<$Res> {
  factory _$TextDocumentSyncClientCapabilitiesCopyWith(_TextDocumentSyncClientCapabilities value, $Res Function(_TextDocumentSyncClientCapabilities) _then) = __$TextDocumentSyncClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? didSave, bool? dynamicRegistration, bool? willSave, bool? willSaveWaitUntil
});




}
/// @nodoc
class __$TextDocumentSyncClientCapabilitiesCopyWithImpl<$Res>
    implements _$TextDocumentSyncClientCapabilitiesCopyWith<$Res> {
  __$TextDocumentSyncClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _TextDocumentSyncClientCapabilities _self;
  final $Res Function(_TextDocumentSyncClientCapabilities) _then;

/// Create a copy of TextDocumentSyncClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? didSave = freezed,Object? dynamicRegistration = freezed,Object? willSave = freezed,Object? willSaveWaitUntil = freezed,}) {
  return _then(_TextDocumentSyncClientCapabilities(
didSave: freezed == didSave ? _self.didSave : didSave // ignore: cast_nullable_to_non_nullable
as bool?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,willSave: freezed == willSave ? _self.willSave : willSave // ignore: cast_nullable_to_non_nullable
as bool?,willSaveWaitUntil: freezed == willSaveWaitUntil ? _self.willSaveWaitUntil : willSaveWaitUntil // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$CompletionClientCapabilities {

/// The client supports the following `CompletionItem` specific
/// capabilities.
 BoolCommitCharactersSupportBoolDeprecatedSupportBoolInsertReplaceSupportBoolLabelDetailsSupportBoolPreselectSupportBoolSnippetSupportCompletionItemTagsValueSetTagSupportInsertTextModesValueSetInsertTextModeSupportMarkupKindsDocumentationFormatStringsPropertiesResolveSupport? get completionItem; CompletionItemKindsValueSet? get completionItemKind;/// The client supports the following `CompletionList` specific
/// capabilities.
/// @since 3.17.0
 StringsItemDefaults? get completionList;/// The client supports to send additional context information for a
/// `textDocument/completion` request.
 bool? get contextSupport;/// Whether completion supports dynamic registration.
 bool? get dynamicRegistration;/// Defines how the client handles whitespace and indentation when
/// accepting a completion item that uses multi line text in either
/// `insertText` or `textEdit`.
/// @since 3.17.0
 InsertTextMode? get insertTextMode;
/// Create a copy of CompletionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CompletionClientCapabilitiesCopyWith<CompletionClientCapabilities> get copyWith => _$CompletionClientCapabilitiesCopyWithImpl<CompletionClientCapabilities>(this as CompletionClientCapabilities, _$identity);

  /// Serializes this CompletionClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CompletionClientCapabilities&&const DeepCollectionEquality().equals(other.completionItem, completionItem)&&const DeepCollectionEquality().equals(other.completionItemKind, completionItemKind)&&const DeepCollectionEquality().equals(other.completionList, completionList)&&(identical(other.contextSupport, contextSupport) || other.contextSupport == contextSupport)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&(identical(other.insertTextMode, insertTextMode) || other.insertTextMode == insertTextMode));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(completionItem),const DeepCollectionEquality().hash(completionItemKind),const DeepCollectionEquality().hash(completionList),contextSupport,dynamicRegistration,insertTextMode);

@override
String toString() {
  return 'CompletionClientCapabilities(completionItem: $completionItem, completionItemKind: $completionItemKind, completionList: $completionList, contextSupport: $contextSupport, dynamicRegistration: $dynamicRegistration, insertTextMode: $insertTextMode)';
}


}

/// @nodoc
abstract mixin class $CompletionClientCapabilitiesCopyWith<$Res>  {
  factory $CompletionClientCapabilitiesCopyWith(CompletionClientCapabilities value, $Res Function(CompletionClientCapabilities) _then) = _$CompletionClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 BoolCommitCharactersSupportBoolDeprecatedSupportBoolInsertReplaceSupportBoolLabelDetailsSupportBoolPreselectSupportBoolSnippetSupportCompletionItemTagsValueSetTagSupportInsertTextModesValueSetInsertTextModeSupportMarkupKindsDocumentationFormatStringsPropertiesResolveSupport? completionItem, CompletionItemKindsValueSet? completionItemKind, StringsItemDefaults? completionList, bool? contextSupport, bool? dynamicRegistration, InsertTextMode? insertTextMode
});




}
/// @nodoc
class _$CompletionClientCapabilitiesCopyWithImpl<$Res>
    implements $CompletionClientCapabilitiesCopyWith<$Res> {
  _$CompletionClientCapabilitiesCopyWithImpl(this._self, this._then);

  final CompletionClientCapabilities _self;
  final $Res Function(CompletionClientCapabilities) _then;

/// Create a copy of CompletionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? completionItem = freezed,Object? completionItemKind = freezed,Object? completionList = freezed,Object? contextSupport = freezed,Object? dynamicRegistration = freezed,Object? insertTextMode = freezed,}) {
  return _then(_self.copyWith(
completionItem: freezed == completionItem ? _self.completionItem : completionItem // ignore: cast_nullable_to_non_nullable
as BoolCommitCharactersSupportBoolDeprecatedSupportBoolInsertReplaceSupportBoolLabelDetailsSupportBoolPreselectSupportBoolSnippetSupportCompletionItemTagsValueSetTagSupportInsertTextModesValueSetInsertTextModeSupportMarkupKindsDocumentationFormatStringsPropertiesResolveSupport?,completionItemKind: freezed == completionItemKind ? _self.completionItemKind : completionItemKind // ignore: cast_nullable_to_non_nullable
as CompletionItemKindsValueSet?,completionList: freezed == completionList ? _self.completionList : completionList // ignore: cast_nullable_to_non_nullable
as StringsItemDefaults?,contextSupport: freezed == contextSupport ? _self.contextSupport : contextSupport // ignore: cast_nullable_to_non_nullable
as bool?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,insertTextMode: freezed == insertTextMode ? _self.insertTextMode : insertTextMode // ignore: cast_nullable_to_non_nullable
as InsertTextMode?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _CompletionClientCapabilities implements CompletionClientCapabilities {
  const _CompletionClientCapabilities({this.completionItem, this.completionItemKind, this.completionList, this.contextSupport, this.dynamicRegistration, this.insertTextMode});
  factory _CompletionClientCapabilities.fromJson(Map<String, dynamic> json) => _$CompletionClientCapabilitiesFromJson(json);

/// The client supports the following `CompletionItem` specific
/// capabilities.
@override final  BoolCommitCharactersSupportBoolDeprecatedSupportBoolInsertReplaceSupportBoolLabelDetailsSupportBoolPreselectSupportBoolSnippetSupportCompletionItemTagsValueSetTagSupportInsertTextModesValueSetInsertTextModeSupportMarkupKindsDocumentationFormatStringsPropertiesResolveSupport? completionItem;
@override final  CompletionItemKindsValueSet? completionItemKind;
/// The client supports the following `CompletionList` specific
/// capabilities.
/// @since 3.17.0
@override final  StringsItemDefaults? completionList;
/// The client supports to send additional context information for a
/// `textDocument/completion` request.
@override final  bool? contextSupport;
/// Whether completion supports dynamic registration.
@override final  bool? dynamicRegistration;
/// Defines how the client handles whitespace and indentation when
/// accepting a completion item that uses multi line text in either
/// `insertText` or `textEdit`.
/// @since 3.17.0
@override final  InsertTextMode? insertTextMode;

/// Create a copy of CompletionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CompletionClientCapabilitiesCopyWith<_CompletionClientCapabilities> get copyWith => __$CompletionClientCapabilitiesCopyWithImpl<_CompletionClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CompletionClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CompletionClientCapabilities&&const DeepCollectionEquality().equals(other.completionItem, completionItem)&&const DeepCollectionEquality().equals(other.completionItemKind, completionItemKind)&&const DeepCollectionEquality().equals(other.completionList, completionList)&&(identical(other.contextSupport, contextSupport) || other.contextSupport == contextSupport)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&(identical(other.insertTextMode, insertTextMode) || other.insertTextMode == insertTextMode));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(completionItem),const DeepCollectionEquality().hash(completionItemKind),const DeepCollectionEquality().hash(completionList),contextSupport,dynamicRegistration,insertTextMode);

@override
String toString() {
  return 'CompletionClientCapabilities(completionItem: $completionItem, completionItemKind: $completionItemKind, completionList: $completionList, contextSupport: $contextSupport, dynamicRegistration: $dynamicRegistration, insertTextMode: $insertTextMode)';
}


}

/// @nodoc
abstract mixin class _$CompletionClientCapabilitiesCopyWith<$Res> implements $CompletionClientCapabilitiesCopyWith<$Res> {
  factory _$CompletionClientCapabilitiesCopyWith(_CompletionClientCapabilities value, $Res Function(_CompletionClientCapabilities) _then) = __$CompletionClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 BoolCommitCharactersSupportBoolDeprecatedSupportBoolInsertReplaceSupportBoolLabelDetailsSupportBoolPreselectSupportBoolSnippetSupportCompletionItemTagsValueSetTagSupportInsertTextModesValueSetInsertTextModeSupportMarkupKindsDocumentationFormatStringsPropertiesResolveSupport? completionItem, CompletionItemKindsValueSet? completionItemKind, StringsItemDefaults? completionList, bool? contextSupport, bool? dynamicRegistration, InsertTextMode? insertTextMode
});




}
/// @nodoc
class __$CompletionClientCapabilitiesCopyWithImpl<$Res>
    implements _$CompletionClientCapabilitiesCopyWith<$Res> {
  __$CompletionClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _CompletionClientCapabilities _self;
  final $Res Function(_CompletionClientCapabilities) _then;

/// Create a copy of CompletionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? completionItem = freezed,Object? completionItemKind = freezed,Object? completionList = freezed,Object? contextSupport = freezed,Object? dynamicRegistration = freezed,Object? insertTextMode = freezed,}) {
  return _then(_CompletionClientCapabilities(
completionItem: freezed == completionItem ? _self.completionItem : completionItem // ignore: cast_nullable_to_non_nullable
as BoolCommitCharactersSupportBoolDeprecatedSupportBoolInsertReplaceSupportBoolLabelDetailsSupportBoolPreselectSupportBoolSnippetSupportCompletionItemTagsValueSetTagSupportInsertTextModesValueSetInsertTextModeSupportMarkupKindsDocumentationFormatStringsPropertiesResolveSupport?,completionItemKind: freezed == completionItemKind ? _self.completionItemKind : completionItemKind // ignore: cast_nullable_to_non_nullable
as CompletionItemKindsValueSet?,completionList: freezed == completionList ? _self.completionList : completionList // ignore: cast_nullable_to_non_nullable
as StringsItemDefaults?,contextSupport: freezed == contextSupport ? _self.contextSupport : contextSupport // ignore: cast_nullable_to_non_nullable
as bool?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,insertTextMode: freezed == insertTextMode ? _self.insertTextMode : insertTextMode // ignore: cast_nullable_to_non_nullable
as InsertTextMode?,
  ));
}


}


/// @nodoc
mixin _$HoverClientCapabilities {

/// Client supports the following content formats for the content property.
/// The order describes the preferred format of the client.
 List<MarkupKind>? get contentFormat;/// Whether hover supports dynamic registration.
 bool? get dynamicRegistration;
/// Create a copy of HoverClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$HoverClientCapabilitiesCopyWith<HoverClientCapabilities> get copyWith => _$HoverClientCapabilitiesCopyWithImpl<HoverClientCapabilities>(this as HoverClientCapabilities, _$identity);

  /// Serializes this HoverClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is HoverClientCapabilities&&const DeepCollectionEquality().equals(other.contentFormat, contentFormat)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(contentFormat),dynamicRegistration);

@override
String toString() {
  return 'HoverClientCapabilities(contentFormat: $contentFormat, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $HoverClientCapabilitiesCopyWith<$Res>  {
  factory $HoverClientCapabilitiesCopyWith(HoverClientCapabilities value, $Res Function(HoverClientCapabilities) _then) = _$HoverClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 List<MarkupKind>? contentFormat, bool? dynamicRegistration
});




}
/// @nodoc
class _$HoverClientCapabilitiesCopyWithImpl<$Res>
    implements $HoverClientCapabilitiesCopyWith<$Res> {
  _$HoverClientCapabilitiesCopyWithImpl(this._self, this._then);

  final HoverClientCapabilities _self;
  final $Res Function(HoverClientCapabilities) _then;

/// Create a copy of HoverClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? contentFormat = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
contentFormat: freezed == contentFormat ? _self.contentFormat : contentFormat // ignore: cast_nullable_to_non_nullable
as List<MarkupKind>?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _HoverClientCapabilities implements HoverClientCapabilities {
  const _HoverClientCapabilities({final  List<MarkupKind>? contentFormat, this.dynamicRegistration}): _contentFormat = contentFormat;
  factory _HoverClientCapabilities.fromJson(Map<String, dynamic> json) => _$HoverClientCapabilitiesFromJson(json);

/// Client supports the following content formats for the content property.
/// The order describes the preferred format of the client.
 final  List<MarkupKind>? _contentFormat;
/// Client supports the following content formats for the content property.
/// The order describes the preferred format of the client.
@override List<MarkupKind>? get contentFormat {
  final value = _contentFormat;
  if (value == null) return null;
  if (_contentFormat is EqualUnmodifiableListView) return _contentFormat;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

/// Whether hover supports dynamic registration.
@override final  bool? dynamicRegistration;

/// Create a copy of HoverClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$HoverClientCapabilitiesCopyWith<_HoverClientCapabilities> get copyWith => __$HoverClientCapabilitiesCopyWithImpl<_HoverClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$HoverClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _HoverClientCapabilities&&const DeepCollectionEquality().equals(other._contentFormat, _contentFormat)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_contentFormat),dynamicRegistration);

@override
String toString() {
  return 'HoverClientCapabilities(contentFormat: $contentFormat, dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$HoverClientCapabilitiesCopyWith<$Res> implements $HoverClientCapabilitiesCopyWith<$Res> {
  factory _$HoverClientCapabilitiesCopyWith(_HoverClientCapabilities value, $Res Function(_HoverClientCapabilities) _then) = __$HoverClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 List<MarkupKind>? contentFormat, bool? dynamicRegistration
});




}
/// @nodoc
class __$HoverClientCapabilitiesCopyWithImpl<$Res>
    implements _$HoverClientCapabilitiesCopyWith<$Res> {
  __$HoverClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _HoverClientCapabilities _self;
  final $Res Function(_HoverClientCapabilities) _then;

/// Create a copy of HoverClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? contentFormat = freezed,Object? dynamicRegistration = freezed,}) {
  return _then(_HoverClientCapabilities(
contentFormat: freezed == contentFormat ? _self._contentFormat : contentFormat // ignore: cast_nullable_to_non_nullable
as List<MarkupKind>?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$SignatureHelpClientCapabilities {

/// The client supports to send additional context information for a
/// `textDocument/signatureHelp` request. A client that opts into
/// contextSupport will also support the `retriggerCharacters` on
/// `SignatureHelpOptions`.
/// @since 3.15.0
 bool? get contextSupport;/// Whether signature help supports dynamic registration.
 bool? get dynamicRegistration;/// The client supports the following `SignatureInformation` specific
/// properties.
 BoolActiveParameterSupportBoolLabelOffsetSupportParameterInformationMarkupKindsDocumentationFormat? get signatureInformation;
/// Create a copy of SignatureHelpClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SignatureHelpClientCapabilitiesCopyWith<SignatureHelpClientCapabilities> get copyWith => _$SignatureHelpClientCapabilitiesCopyWithImpl<SignatureHelpClientCapabilities>(this as SignatureHelpClientCapabilities, _$identity);

  /// Serializes this SignatureHelpClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SignatureHelpClientCapabilities&&(identical(other.contextSupport, contextSupport) || other.contextSupport == contextSupport)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&const DeepCollectionEquality().equals(other.signatureInformation, signatureInformation));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,contextSupport,dynamicRegistration,const DeepCollectionEquality().hash(signatureInformation));

@override
String toString() {
  return 'SignatureHelpClientCapabilities(contextSupport: $contextSupport, dynamicRegistration: $dynamicRegistration, signatureInformation: $signatureInformation)';
}


}

/// @nodoc
abstract mixin class $SignatureHelpClientCapabilitiesCopyWith<$Res>  {
  factory $SignatureHelpClientCapabilitiesCopyWith(SignatureHelpClientCapabilities value, $Res Function(SignatureHelpClientCapabilities) _then) = _$SignatureHelpClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? contextSupport, bool? dynamicRegistration, BoolActiveParameterSupportBoolLabelOffsetSupportParameterInformationMarkupKindsDocumentationFormat? signatureInformation
});




}
/// @nodoc
class _$SignatureHelpClientCapabilitiesCopyWithImpl<$Res>
    implements $SignatureHelpClientCapabilitiesCopyWith<$Res> {
  _$SignatureHelpClientCapabilitiesCopyWithImpl(this._self, this._then);

  final SignatureHelpClientCapabilities _self;
  final $Res Function(SignatureHelpClientCapabilities) _then;

/// Create a copy of SignatureHelpClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? contextSupport = freezed,Object? dynamicRegistration = freezed,Object? signatureInformation = freezed,}) {
  return _then(_self.copyWith(
contextSupport: freezed == contextSupport ? _self.contextSupport : contextSupport // ignore: cast_nullable_to_non_nullable
as bool?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,signatureInformation: freezed == signatureInformation ? _self.signatureInformation : signatureInformation // ignore: cast_nullable_to_non_nullable
as BoolActiveParameterSupportBoolLabelOffsetSupportParameterInformationMarkupKindsDocumentationFormat?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _SignatureHelpClientCapabilities implements SignatureHelpClientCapabilities {
  const _SignatureHelpClientCapabilities({this.contextSupport, this.dynamicRegistration, this.signatureInformation});
  factory _SignatureHelpClientCapabilities.fromJson(Map<String, dynamic> json) => _$SignatureHelpClientCapabilitiesFromJson(json);

/// The client supports to send additional context information for a
/// `textDocument/signatureHelp` request. A client that opts into
/// contextSupport will also support the `retriggerCharacters` on
/// `SignatureHelpOptions`.
/// @since 3.15.0
@override final  bool? contextSupport;
/// Whether signature help supports dynamic registration.
@override final  bool? dynamicRegistration;
/// The client supports the following `SignatureInformation` specific
/// properties.
@override final  BoolActiveParameterSupportBoolLabelOffsetSupportParameterInformationMarkupKindsDocumentationFormat? signatureInformation;

/// Create a copy of SignatureHelpClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SignatureHelpClientCapabilitiesCopyWith<_SignatureHelpClientCapabilities> get copyWith => __$SignatureHelpClientCapabilitiesCopyWithImpl<_SignatureHelpClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SignatureHelpClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SignatureHelpClientCapabilities&&(identical(other.contextSupport, contextSupport) || other.contextSupport == contextSupport)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&const DeepCollectionEquality().equals(other.signatureInformation, signatureInformation));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,contextSupport,dynamicRegistration,const DeepCollectionEquality().hash(signatureInformation));

@override
String toString() {
  return 'SignatureHelpClientCapabilities(contextSupport: $contextSupport, dynamicRegistration: $dynamicRegistration, signatureInformation: $signatureInformation)';
}


}

/// @nodoc
abstract mixin class _$SignatureHelpClientCapabilitiesCopyWith<$Res> implements $SignatureHelpClientCapabilitiesCopyWith<$Res> {
  factory _$SignatureHelpClientCapabilitiesCopyWith(_SignatureHelpClientCapabilities value, $Res Function(_SignatureHelpClientCapabilities) _then) = __$SignatureHelpClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? contextSupport, bool? dynamicRegistration, BoolActiveParameterSupportBoolLabelOffsetSupportParameterInformationMarkupKindsDocumentationFormat? signatureInformation
});




}
/// @nodoc
class __$SignatureHelpClientCapabilitiesCopyWithImpl<$Res>
    implements _$SignatureHelpClientCapabilitiesCopyWith<$Res> {
  __$SignatureHelpClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _SignatureHelpClientCapabilities _self;
  final $Res Function(_SignatureHelpClientCapabilities) _then;

/// Create a copy of SignatureHelpClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? contextSupport = freezed,Object? dynamicRegistration = freezed,Object? signatureInformation = freezed,}) {
  return _then(_SignatureHelpClientCapabilities(
contextSupport: freezed == contextSupport ? _self.contextSupport : contextSupport // ignore: cast_nullable_to_non_nullable
as bool?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,signatureInformation: freezed == signatureInformation ? _self.signatureInformation : signatureInformation // ignore: cast_nullable_to_non_nullable
as BoolActiveParameterSupportBoolLabelOffsetSupportParameterInformationMarkupKindsDocumentationFormat?,
  ));
}


}


/// @nodoc
mixin _$DeclarationClientCapabilities {

/// Whether declaration supports dynamic registration. If this is set to
/// `true` the client supports the new `DeclarationRegistrationOptions`
/// return value for the corresponding server capability as well.
 bool? get dynamicRegistration;/// The client supports additional metadata in the form of declaration
/// links.
 bool? get linkSupport;
/// Create a copy of DeclarationClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DeclarationClientCapabilitiesCopyWith<DeclarationClientCapabilities> get copyWith => _$DeclarationClientCapabilitiesCopyWithImpl<DeclarationClientCapabilities>(this as DeclarationClientCapabilities, _$identity);

  /// Serializes this DeclarationClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DeclarationClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&(identical(other.linkSupport, linkSupport) || other.linkSupport == linkSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration,linkSupport);

@override
String toString() {
  return 'DeclarationClientCapabilities(dynamicRegistration: $dynamicRegistration, linkSupport: $linkSupport)';
}


}

/// @nodoc
abstract mixin class $DeclarationClientCapabilitiesCopyWith<$Res>  {
  factory $DeclarationClientCapabilitiesCopyWith(DeclarationClientCapabilities value, $Res Function(DeclarationClientCapabilities) _then) = _$DeclarationClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration, bool? linkSupport
});




}
/// @nodoc
class _$DeclarationClientCapabilitiesCopyWithImpl<$Res>
    implements $DeclarationClientCapabilitiesCopyWith<$Res> {
  _$DeclarationClientCapabilitiesCopyWithImpl(this._self, this._then);

  final DeclarationClientCapabilities _self;
  final $Res Function(DeclarationClientCapabilities) _then;

/// Create a copy of DeclarationClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,Object? linkSupport = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,linkSupport: freezed == linkSupport ? _self.linkSupport : linkSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DeclarationClientCapabilities implements DeclarationClientCapabilities {
  const _DeclarationClientCapabilities({this.dynamicRegistration, this.linkSupport});
  factory _DeclarationClientCapabilities.fromJson(Map<String, dynamic> json) => _$DeclarationClientCapabilitiesFromJson(json);

/// Whether declaration supports dynamic registration. If this is set to
/// `true` the client supports the new `DeclarationRegistrationOptions`
/// return value for the corresponding server capability as well.
@override final  bool? dynamicRegistration;
/// The client supports additional metadata in the form of declaration
/// links.
@override final  bool? linkSupport;

/// Create a copy of DeclarationClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DeclarationClientCapabilitiesCopyWith<_DeclarationClientCapabilities> get copyWith => __$DeclarationClientCapabilitiesCopyWithImpl<_DeclarationClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DeclarationClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DeclarationClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&(identical(other.linkSupport, linkSupport) || other.linkSupport == linkSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration,linkSupport);

@override
String toString() {
  return 'DeclarationClientCapabilities(dynamicRegistration: $dynamicRegistration, linkSupport: $linkSupport)';
}


}

/// @nodoc
abstract mixin class _$DeclarationClientCapabilitiesCopyWith<$Res> implements $DeclarationClientCapabilitiesCopyWith<$Res> {
  factory _$DeclarationClientCapabilitiesCopyWith(_DeclarationClientCapabilities value, $Res Function(_DeclarationClientCapabilities) _then) = __$DeclarationClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration, bool? linkSupport
});




}
/// @nodoc
class __$DeclarationClientCapabilitiesCopyWithImpl<$Res>
    implements _$DeclarationClientCapabilitiesCopyWith<$Res> {
  __$DeclarationClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _DeclarationClientCapabilities _self;
  final $Res Function(_DeclarationClientCapabilities) _then;

/// Create a copy of DeclarationClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,Object? linkSupport = freezed,}) {
  return _then(_DeclarationClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,linkSupport: freezed == linkSupport ? _self.linkSupport : linkSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DefinitionClientCapabilities {

/// Whether definition supports dynamic registration.
 bool? get dynamicRegistration;/// The client supports additional metadata in the form of definition links.
/// @since 3.14.0
 bool? get linkSupport;
/// Create a copy of DefinitionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DefinitionClientCapabilitiesCopyWith<DefinitionClientCapabilities> get copyWith => _$DefinitionClientCapabilitiesCopyWithImpl<DefinitionClientCapabilities>(this as DefinitionClientCapabilities, _$identity);

  /// Serializes this DefinitionClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DefinitionClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&(identical(other.linkSupport, linkSupport) || other.linkSupport == linkSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration,linkSupport);

@override
String toString() {
  return 'DefinitionClientCapabilities(dynamicRegistration: $dynamicRegistration, linkSupport: $linkSupport)';
}


}

/// @nodoc
abstract mixin class $DefinitionClientCapabilitiesCopyWith<$Res>  {
  factory $DefinitionClientCapabilitiesCopyWith(DefinitionClientCapabilities value, $Res Function(DefinitionClientCapabilities) _then) = _$DefinitionClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration, bool? linkSupport
});




}
/// @nodoc
class _$DefinitionClientCapabilitiesCopyWithImpl<$Res>
    implements $DefinitionClientCapabilitiesCopyWith<$Res> {
  _$DefinitionClientCapabilitiesCopyWithImpl(this._self, this._then);

  final DefinitionClientCapabilities _self;
  final $Res Function(DefinitionClientCapabilities) _then;

/// Create a copy of DefinitionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,Object? linkSupport = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,linkSupport: freezed == linkSupport ? _self.linkSupport : linkSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DefinitionClientCapabilities implements DefinitionClientCapabilities {
  const _DefinitionClientCapabilities({this.dynamicRegistration, this.linkSupport});
  factory _DefinitionClientCapabilities.fromJson(Map<String, dynamic> json) => _$DefinitionClientCapabilitiesFromJson(json);

/// Whether definition supports dynamic registration.
@override final  bool? dynamicRegistration;
/// The client supports additional metadata in the form of definition links.
/// @since 3.14.0
@override final  bool? linkSupport;

/// Create a copy of DefinitionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DefinitionClientCapabilitiesCopyWith<_DefinitionClientCapabilities> get copyWith => __$DefinitionClientCapabilitiesCopyWithImpl<_DefinitionClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DefinitionClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DefinitionClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&(identical(other.linkSupport, linkSupport) || other.linkSupport == linkSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration,linkSupport);

@override
String toString() {
  return 'DefinitionClientCapabilities(dynamicRegistration: $dynamicRegistration, linkSupport: $linkSupport)';
}


}

/// @nodoc
abstract mixin class _$DefinitionClientCapabilitiesCopyWith<$Res> implements $DefinitionClientCapabilitiesCopyWith<$Res> {
  factory _$DefinitionClientCapabilitiesCopyWith(_DefinitionClientCapabilities value, $Res Function(_DefinitionClientCapabilities) _then) = __$DefinitionClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration, bool? linkSupport
});




}
/// @nodoc
class __$DefinitionClientCapabilitiesCopyWithImpl<$Res>
    implements _$DefinitionClientCapabilitiesCopyWith<$Res> {
  __$DefinitionClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _DefinitionClientCapabilities _self;
  final $Res Function(_DefinitionClientCapabilities) _then;

/// Create a copy of DefinitionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,Object? linkSupport = freezed,}) {
  return _then(_DefinitionClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,linkSupport: freezed == linkSupport ? _self.linkSupport : linkSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$TypeDefinitionClientCapabilities {

/// Whether implementation supports dynamic registration. If this is set to
/// `true` the client supports the new `TypeDefinitionRegistrationOptions`
/// return value for the corresponding server capability as well.
 bool? get dynamicRegistration;/// The client supports additional metadata in the form of definition links.
/// Since 3.14.0
 bool? get linkSupport;
/// Create a copy of TypeDefinitionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TypeDefinitionClientCapabilitiesCopyWith<TypeDefinitionClientCapabilities> get copyWith => _$TypeDefinitionClientCapabilitiesCopyWithImpl<TypeDefinitionClientCapabilities>(this as TypeDefinitionClientCapabilities, _$identity);

  /// Serializes this TypeDefinitionClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TypeDefinitionClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&(identical(other.linkSupport, linkSupport) || other.linkSupport == linkSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration,linkSupport);

@override
String toString() {
  return 'TypeDefinitionClientCapabilities(dynamicRegistration: $dynamicRegistration, linkSupport: $linkSupport)';
}


}

/// @nodoc
abstract mixin class $TypeDefinitionClientCapabilitiesCopyWith<$Res>  {
  factory $TypeDefinitionClientCapabilitiesCopyWith(TypeDefinitionClientCapabilities value, $Res Function(TypeDefinitionClientCapabilities) _then) = _$TypeDefinitionClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration, bool? linkSupport
});




}
/// @nodoc
class _$TypeDefinitionClientCapabilitiesCopyWithImpl<$Res>
    implements $TypeDefinitionClientCapabilitiesCopyWith<$Res> {
  _$TypeDefinitionClientCapabilitiesCopyWithImpl(this._self, this._then);

  final TypeDefinitionClientCapabilities _self;
  final $Res Function(TypeDefinitionClientCapabilities) _then;

/// Create a copy of TypeDefinitionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,Object? linkSupport = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,linkSupport: freezed == linkSupport ? _self.linkSupport : linkSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _TypeDefinitionClientCapabilities implements TypeDefinitionClientCapabilities {
  const _TypeDefinitionClientCapabilities({this.dynamicRegistration, this.linkSupport});
  factory _TypeDefinitionClientCapabilities.fromJson(Map<String, dynamic> json) => _$TypeDefinitionClientCapabilitiesFromJson(json);

/// Whether implementation supports dynamic registration. If this is set to
/// `true` the client supports the new `TypeDefinitionRegistrationOptions`
/// return value for the corresponding server capability as well.
@override final  bool? dynamicRegistration;
/// The client supports additional metadata in the form of definition links.
/// Since 3.14.0
@override final  bool? linkSupport;

/// Create a copy of TypeDefinitionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TypeDefinitionClientCapabilitiesCopyWith<_TypeDefinitionClientCapabilities> get copyWith => __$TypeDefinitionClientCapabilitiesCopyWithImpl<_TypeDefinitionClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TypeDefinitionClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TypeDefinitionClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&(identical(other.linkSupport, linkSupport) || other.linkSupport == linkSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration,linkSupport);

@override
String toString() {
  return 'TypeDefinitionClientCapabilities(dynamicRegistration: $dynamicRegistration, linkSupport: $linkSupport)';
}


}

/// @nodoc
abstract mixin class _$TypeDefinitionClientCapabilitiesCopyWith<$Res> implements $TypeDefinitionClientCapabilitiesCopyWith<$Res> {
  factory _$TypeDefinitionClientCapabilitiesCopyWith(_TypeDefinitionClientCapabilities value, $Res Function(_TypeDefinitionClientCapabilities) _then) = __$TypeDefinitionClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration, bool? linkSupport
});




}
/// @nodoc
class __$TypeDefinitionClientCapabilitiesCopyWithImpl<$Res>
    implements _$TypeDefinitionClientCapabilitiesCopyWith<$Res> {
  __$TypeDefinitionClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _TypeDefinitionClientCapabilities _self;
  final $Res Function(_TypeDefinitionClientCapabilities) _then;

/// Create a copy of TypeDefinitionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,Object? linkSupport = freezed,}) {
  return _then(_TypeDefinitionClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,linkSupport: freezed == linkSupport ? _self.linkSupport : linkSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$ImplementationClientCapabilities {

/// Whether implementation supports dynamic registration. If this is set to
/// `true` the client supports the new `ImplementationRegistrationOptions`
/// return value for the corresponding server capability as well.
 bool? get dynamicRegistration;/// The client supports additional metadata in the form of definition links.
/// @since 3.14.0
 bool? get linkSupport;
/// Create a copy of ImplementationClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ImplementationClientCapabilitiesCopyWith<ImplementationClientCapabilities> get copyWith => _$ImplementationClientCapabilitiesCopyWithImpl<ImplementationClientCapabilities>(this as ImplementationClientCapabilities, _$identity);

  /// Serializes this ImplementationClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ImplementationClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&(identical(other.linkSupport, linkSupport) || other.linkSupport == linkSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration,linkSupport);

@override
String toString() {
  return 'ImplementationClientCapabilities(dynamicRegistration: $dynamicRegistration, linkSupport: $linkSupport)';
}


}

/// @nodoc
abstract mixin class $ImplementationClientCapabilitiesCopyWith<$Res>  {
  factory $ImplementationClientCapabilitiesCopyWith(ImplementationClientCapabilities value, $Res Function(ImplementationClientCapabilities) _then) = _$ImplementationClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration, bool? linkSupport
});




}
/// @nodoc
class _$ImplementationClientCapabilitiesCopyWithImpl<$Res>
    implements $ImplementationClientCapabilitiesCopyWith<$Res> {
  _$ImplementationClientCapabilitiesCopyWithImpl(this._self, this._then);

  final ImplementationClientCapabilities _self;
  final $Res Function(ImplementationClientCapabilities) _then;

/// Create a copy of ImplementationClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,Object? linkSupport = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,linkSupport: freezed == linkSupport ? _self.linkSupport : linkSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _ImplementationClientCapabilities implements ImplementationClientCapabilities {
  const _ImplementationClientCapabilities({this.dynamicRegistration, this.linkSupport});
  factory _ImplementationClientCapabilities.fromJson(Map<String, dynamic> json) => _$ImplementationClientCapabilitiesFromJson(json);

/// Whether implementation supports dynamic registration. If this is set to
/// `true` the client supports the new `ImplementationRegistrationOptions`
/// return value for the corresponding server capability as well.
@override final  bool? dynamicRegistration;
/// The client supports additional metadata in the form of definition links.
/// @since 3.14.0
@override final  bool? linkSupport;

/// Create a copy of ImplementationClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ImplementationClientCapabilitiesCopyWith<_ImplementationClientCapabilities> get copyWith => __$ImplementationClientCapabilitiesCopyWithImpl<_ImplementationClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ImplementationClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ImplementationClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&(identical(other.linkSupport, linkSupport) || other.linkSupport == linkSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration,linkSupport);

@override
String toString() {
  return 'ImplementationClientCapabilities(dynamicRegistration: $dynamicRegistration, linkSupport: $linkSupport)';
}


}

/// @nodoc
abstract mixin class _$ImplementationClientCapabilitiesCopyWith<$Res> implements $ImplementationClientCapabilitiesCopyWith<$Res> {
  factory _$ImplementationClientCapabilitiesCopyWith(_ImplementationClientCapabilities value, $Res Function(_ImplementationClientCapabilities) _then) = __$ImplementationClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration, bool? linkSupport
});




}
/// @nodoc
class __$ImplementationClientCapabilitiesCopyWithImpl<$Res>
    implements _$ImplementationClientCapabilitiesCopyWith<$Res> {
  __$ImplementationClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _ImplementationClientCapabilities _self;
  final $Res Function(_ImplementationClientCapabilities) _then;

/// Create a copy of ImplementationClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,Object? linkSupport = freezed,}) {
  return _then(_ImplementationClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,linkSupport: freezed == linkSupport ? _self.linkSupport : linkSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$ReferenceClientCapabilities {

/// Whether references supports dynamic registration.
 bool? get dynamicRegistration;
/// Create a copy of ReferenceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ReferenceClientCapabilitiesCopyWith<ReferenceClientCapabilities> get copyWith => _$ReferenceClientCapabilitiesCopyWithImpl<ReferenceClientCapabilities>(this as ReferenceClientCapabilities, _$identity);

  /// Serializes this ReferenceClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ReferenceClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'ReferenceClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $ReferenceClientCapabilitiesCopyWith<$Res>  {
  factory $ReferenceClientCapabilitiesCopyWith(ReferenceClientCapabilities value, $Res Function(ReferenceClientCapabilities) _then) = _$ReferenceClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class _$ReferenceClientCapabilitiesCopyWithImpl<$Res>
    implements $ReferenceClientCapabilitiesCopyWith<$Res> {
  _$ReferenceClientCapabilitiesCopyWithImpl(this._self, this._then);

  final ReferenceClientCapabilities _self;
  final $Res Function(ReferenceClientCapabilities) _then;

/// Create a copy of ReferenceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _ReferenceClientCapabilities implements ReferenceClientCapabilities {
  const _ReferenceClientCapabilities({this.dynamicRegistration});
  factory _ReferenceClientCapabilities.fromJson(Map<String, dynamic> json) => _$ReferenceClientCapabilitiesFromJson(json);

/// Whether references supports dynamic registration.
@override final  bool? dynamicRegistration;

/// Create a copy of ReferenceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ReferenceClientCapabilitiesCopyWith<_ReferenceClientCapabilities> get copyWith => __$ReferenceClientCapabilitiesCopyWithImpl<_ReferenceClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ReferenceClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ReferenceClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'ReferenceClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$ReferenceClientCapabilitiesCopyWith<$Res> implements $ReferenceClientCapabilitiesCopyWith<$Res> {
  factory _$ReferenceClientCapabilitiesCopyWith(_ReferenceClientCapabilities value, $Res Function(_ReferenceClientCapabilities) _then) = __$ReferenceClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class __$ReferenceClientCapabilitiesCopyWithImpl<$Res>
    implements _$ReferenceClientCapabilitiesCopyWith<$Res> {
  __$ReferenceClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _ReferenceClientCapabilities _self;
  final $Res Function(_ReferenceClientCapabilities) _then;

/// Create a copy of ReferenceClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_ReferenceClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DocumentHighlightClientCapabilities {

/// Whether document highlight supports dynamic registration.
 bool? get dynamicRegistration;
/// Create a copy of DocumentHighlightClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentHighlightClientCapabilitiesCopyWith<DocumentHighlightClientCapabilities> get copyWith => _$DocumentHighlightClientCapabilitiesCopyWithImpl<DocumentHighlightClientCapabilities>(this as DocumentHighlightClientCapabilities, _$identity);

  /// Serializes this DocumentHighlightClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentHighlightClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'DocumentHighlightClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $DocumentHighlightClientCapabilitiesCopyWith<$Res>  {
  factory $DocumentHighlightClientCapabilitiesCopyWith(DocumentHighlightClientCapabilities value, $Res Function(DocumentHighlightClientCapabilities) _then) = _$DocumentHighlightClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class _$DocumentHighlightClientCapabilitiesCopyWithImpl<$Res>
    implements $DocumentHighlightClientCapabilitiesCopyWith<$Res> {
  _$DocumentHighlightClientCapabilitiesCopyWithImpl(this._self, this._then);

  final DocumentHighlightClientCapabilities _self;
  final $Res Function(DocumentHighlightClientCapabilities) _then;

/// Create a copy of DocumentHighlightClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DocumentHighlightClientCapabilities implements DocumentHighlightClientCapabilities {
  const _DocumentHighlightClientCapabilities({this.dynamicRegistration});
  factory _DocumentHighlightClientCapabilities.fromJson(Map<String, dynamic> json) => _$DocumentHighlightClientCapabilitiesFromJson(json);

/// Whether document highlight supports dynamic registration.
@override final  bool? dynamicRegistration;

/// Create a copy of DocumentHighlightClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentHighlightClientCapabilitiesCopyWith<_DocumentHighlightClientCapabilities> get copyWith => __$DocumentHighlightClientCapabilitiesCopyWithImpl<_DocumentHighlightClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentHighlightClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentHighlightClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'DocumentHighlightClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$DocumentHighlightClientCapabilitiesCopyWith<$Res> implements $DocumentHighlightClientCapabilitiesCopyWith<$Res> {
  factory _$DocumentHighlightClientCapabilitiesCopyWith(_DocumentHighlightClientCapabilities value, $Res Function(_DocumentHighlightClientCapabilities) _then) = __$DocumentHighlightClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class __$DocumentHighlightClientCapabilitiesCopyWithImpl<$Res>
    implements _$DocumentHighlightClientCapabilitiesCopyWith<$Res> {
  __$DocumentHighlightClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _DocumentHighlightClientCapabilities _self;
  final $Res Function(_DocumentHighlightClientCapabilities) _then;

/// Create a copy of DocumentHighlightClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_DocumentHighlightClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DocumentSymbolClientCapabilities {

/// Whether document symbol supports dynamic registration.
 bool? get dynamicRegistration;/// The client supports hierarchical document symbols.
 bool? get hierarchicalDocumentSymbolSupport;/// The client supports an additional label presented in the UI when
/// registering a document symbol provider.
/// @since 3.16.0
 bool? get labelSupport;/// Specific capabilities for the `SymbolKind` in the
/// `textDocument/documentSymbol` request.
 SymbolKindsValueSet? get symbolKind;/// The client supports tags on `SymbolInformation`. Tags are supported on
/// `DocumentSymbol` if `hierarchicalDocumentSymbolSupport` is set to true.
/// Clients supporting tags have to handle unknown tags gracefully.
/// @since 3.16.0
 SymbolTagsValueSet? get tagSupport;
/// Create a copy of DocumentSymbolClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentSymbolClientCapabilitiesCopyWith<DocumentSymbolClientCapabilities> get copyWith => _$DocumentSymbolClientCapabilitiesCopyWithImpl<DocumentSymbolClientCapabilities>(this as DocumentSymbolClientCapabilities, _$identity);

  /// Serializes this DocumentSymbolClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentSymbolClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&(identical(other.hierarchicalDocumentSymbolSupport, hierarchicalDocumentSymbolSupport) || other.hierarchicalDocumentSymbolSupport == hierarchicalDocumentSymbolSupport)&&(identical(other.labelSupport, labelSupport) || other.labelSupport == labelSupport)&&const DeepCollectionEquality().equals(other.symbolKind, symbolKind)&&const DeepCollectionEquality().equals(other.tagSupport, tagSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration,hierarchicalDocumentSymbolSupport,labelSupport,const DeepCollectionEquality().hash(symbolKind),const DeepCollectionEquality().hash(tagSupport));

@override
String toString() {
  return 'DocumentSymbolClientCapabilities(dynamicRegistration: $dynamicRegistration, hierarchicalDocumentSymbolSupport: $hierarchicalDocumentSymbolSupport, labelSupport: $labelSupport, symbolKind: $symbolKind, tagSupport: $tagSupport)';
}


}

/// @nodoc
abstract mixin class $DocumentSymbolClientCapabilitiesCopyWith<$Res>  {
  factory $DocumentSymbolClientCapabilitiesCopyWith(DocumentSymbolClientCapabilities value, $Res Function(DocumentSymbolClientCapabilities) _then) = _$DocumentSymbolClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration, bool? hierarchicalDocumentSymbolSupport, bool? labelSupport, SymbolKindsValueSet? symbolKind, SymbolTagsValueSet? tagSupport
});




}
/// @nodoc
class _$DocumentSymbolClientCapabilitiesCopyWithImpl<$Res>
    implements $DocumentSymbolClientCapabilitiesCopyWith<$Res> {
  _$DocumentSymbolClientCapabilitiesCopyWithImpl(this._self, this._then);

  final DocumentSymbolClientCapabilities _self;
  final $Res Function(DocumentSymbolClientCapabilities) _then;

/// Create a copy of DocumentSymbolClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,Object? hierarchicalDocumentSymbolSupport = freezed,Object? labelSupport = freezed,Object? symbolKind = freezed,Object? tagSupport = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,hierarchicalDocumentSymbolSupport: freezed == hierarchicalDocumentSymbolSupport ? _self.hierarchicalDocumentSymbolSupport : hierarchicalDocumentSymbolSupport // ignore: cast_nullable_to_non_nullable
as bool?,labelSupport: freezed == labelSupport ? _self.labelSupport : labelSupport // ignore: cast_nullable_to_non_nullable
as bool?,symbolKind: freezed == symbolKind ? _self.symbolKind : symbolKind // ignore: cast_nullable_to_non_nullable
as SymbolKindsValueSet?,tagSupport: freezed == tagSupport ? _self.tagSupport : tagSupport // ignore: cast_nullable_to_non_nullable
as SymbolTagsValueSet?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DocumentSymbolClientCapabilities implements DocumentSymbolClientCapabilities {
  const _DocumentSymbolClientCapabilities({this.dynamicRegistration, this.hierarchicalDocumentSymbolSupport, this.labelSupport, this.symbolKind, this.tagSupport});
  factory _DocumentSymbolClientCapabilities.fromJson(Map<String, dynamic> json) => _$DocumentSymbolClientCapabilitiesFromJson(json);

/// Whether document symbol supports dynamic registration.
@override final  bool? dynamicRegistration;
/// The client supports hierarchical document symbols.
@override final  bool? hierarchicalDocumentSymbolSupport;
/// The client supports an additional label presented in the UI when
/// registering a document symbol provider.
/// @since 3.16.0
@override final  bool? labelSupport;
/// Specific capabilities for the `SymbolKind` in the
/// `textDocument/documentSymbol` request.
@override final  SymbolKindsValueSet? symbolKind;
/// The client supports tags on `SymbolInformation`. Tags are supported on
/// `DocumentSymbol` if `hierarchicalDocumentSymbolSupport` is set to true.
/// Clients supporting tags have to handle unknown tags gracefully.
/// @since 3.16.0
@override final  SymbolTagsValueSet? tagSupport;

/// Create a copy of DocumentSymbolClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentSymbolClientCapabilitiesCopyWith<_DocumentSymbolClientCapabilities> get copyWith => __$DocumentSymbolClientCapabilitiesCopyWithImpl<_DocumentSymbolClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentSymbolClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentSymbolClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&(identical(other.hierarchicalDocumentSymbolSupport, hierarchicalDocumentSymbolSupport) || other.hierarchicalDocumentSymbolSupport == hierarchicalDocumentSymbolSupport)&&(identical(other.labelSupport, labelSupport) || other.labelSupport == labelSupport)&&const DeepCollectionEquality().equals(other.symbolKind, symbolKind)&&const DeepCollectionEquality().equals(other.tagSupport, tagSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration,hierarchicalDocumentSymbolSupport,labelSupport,const DeepCollectionEquality().hash(symbolKind),const DeepCollectionEquality().hash(tagSupport));

@override
String toString() {
  return 'DocumentSymbolClientCapabilities(dynamicRegistration: $dynamicRegistration, hierarchicalDocumentSymbolSupport: $hierarchicalDocumentSymbolSupport, labelSupport: $labelSupport, symbolKind: $symbolKind, tagSupport: $tagSupport)';
}


}

/// @nodoc
abstract mixin class _$DocumentSymbolClientCapabilitiesCopyWith<$Res> implements $DocumentSymbolClientCapabilitiesCopyWith<$Res> {
  factory _$DocumentSymbolClientCapabilitiesCopyWith(_DocumentSymbolClientCapabilities value, $Res Function(_DocumentSymbolClientCapabilities) _then) = __$DocumentSymbolClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration, bool? hierarchicalDocumentSymbolSupport, bool? labelSupport, SymbolKindsValueSet? symbolKind, SymbolTagsValueSet? tagSupport
});




}
/// @nodoc
class __$DocumentSymbolClientCapabilitiesCopyWithImpl<$Res>
    implements _$DocumentSymbolClientCapabilitiesCopyWith<$Res> {
  __$DocumentSymbolClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _DocumentSymbolClientCapabilities _self;
  final $Res Function(_DocumentSymbolClientCapabilities) _then;

/// Create a copy of DocumentSymbolClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,Object? hierarchicalDocumentSymbolSupport = freezed,Object? labelSupport = freezed,Object? symbolKind = freezed,Object? tagSupport = freezed,}) {
  return _then(_DocumentSymbolClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,hierarchicalDocumentSymbolSupport: freezed == hierarchicalDocumentSymbolSupport ? _self.hierarchicalDocumentSymbolSupport : hierarchicalDocumentSymbolSupport // ignore: cast_nullable_to_non_nullable
as bool?,labelSupport: freezed == labelSupport ? _self.labelSupport : labelSupport // ignore: cast_nullable_to_non_nullable
as bool?,symbolKind: freezed == symbolKind ? _self.symbolKind : symbolKind // ignore: cast_nullable_to_non_nullable
as SymbolKindsValueSet?,tagSupport: freezed == tagSupport ? _self.tagSupport : tagSupport // ignore: cast_nullable_to_non_nullable
as SymbolTagsValueSet?,
  ));
}


}


/// @nodoc
mixin _$CodeActionClientCapabilities {

/// The client support code action literals of type `CodeAction` as a valid
/// response of the `textDocument/codeAction` request. If the property is
/// not set the request can only return `Command` literals.
/// @since 3.8.0
 CodeActionKindsValueSetCodeActionKind? get codeActionLiteralSupport;/// Whether code action supports the `data` property which is preserved
/// between a `textDocument/codeAction` and a `codeAction/resolve` request.
/// @since 3.16.0
 bool? get dataSupport;/// Whether code action supports the `disabled` property.
/// @since 3.16.0
 bool? get disabledSupport;/// Whether code action supports dynamic registration.
 bool? get dynamicRegistration;/// Whether the client honors the change annotations in text edits and
/// resource operations returned via the `CodeAction#edit` property by for
/// example presenting the workspace edit in the user interface and asking
/// for confirmation.
/// @since 3.16.0
 bool? get honorsChangeAnnotations;/// Whether code action supports the `isPreferred` property.
/// @since 3.15.0
 bool? get isPreferredSupport;/// Whether the client supports resolving additional code action properties
/// via a separate `codeAction/resolve` request.
/// @since 3.16.0
 StringsProperties? get resolveSupport;
/// Create a copy of CodeActionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CodeActionClientCapabilitiesCopyWith<CodeActionClientCapabilities> get copyWith => _$CodeActionClientCapabilitiesCopyWithImpl<CodeActionClientCapabilities>(this as CodeActionClientCapabilities, _$identity);

  /// Serializes this CodeActionClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CodeActionClientCapabilities&&const DeepCollectionEquality().equals(other.codeActionLiteralSupport, codeActionLiteralSupport)&&(identical(other.dataSupport, dataSupport) || other.dataSupport == dataSupport)&&(identical(other.disabledSupport, disabledSupport) || other.disabledSupport == disabledSupport)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&(identical(other.honorsChangeAnnotations, honorsChangeAnnotations) || other.honorsChangeAnnotations == honorsChangeAnnotations)&&(identical(other.isPreferredSupport, isPreferredSupport) || other.isPreferredSupport == isPreferredSupport)&&const DeepCollectionEquality().equals(other.resolveSupport, resolveSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(codeActionLiteralSupport),dataSupport,disabledSupport,dynamicRegistration,honorsChangeAnnotations,isPreferredSupport,const DeepCollectionEquality().hash(resolveSupport));

@override
String toString() {
  return 'CodeActionClientCapabilities(codeActionLiteralSupport: $codeActionLiteralSupport, dataSupport: $dataSupport, disabledSupport: $disabledSupport, dynamicRegistration: $dynamicRegistration, honorsChangeAnnotations: $honorsChangeAnnotations, isPreferredSupport: $isPreferredSupport, resolveSupport: $resolveSupport)';
}


}

/// @nodoc
abstract mixin class $CodeActionClientCapabilitiesCopyWith<$Res>  {
  factory $CodeActionClientCapabilitiesCopyWith(CodeActionClientCapabilities value, $Res Function(CodeActionClientCapabilities) _then) = _$CodeActionClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 CodeActionKindsValueSetCodeActionKind? codeActionLiteralSupport, bool? dataSupport, bool? disabledSupport, bool? dynamicRegistration, bool? honorsChangeAnnotations, bool? isPreferredSupport, StringsProperties? resolveSupport
});




}
/// @nodoc
class _$CodeActionClientCapabilitiesCopyWithImpl<$Res>
    implements $CodeActionClientCapabilitiesCopyWith<$Res> {
  _$CodeActionClientCapabilitiesCopyWithImpl(this._self, this._then);

  final CodeActionClientCapabilities _self;
  final $Res Function(CodeActionClientCapabilities) _then;

/// Create a copy of CodeActionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? codeActionLiteralSupport = freezed,Object? dataSupport = freezed,Object? disabledSupport = freezed,Object? dynamicRegistration = freezed,Object? honorsChangeAnnotations = freezed,Object? isPreferredSupport = freezed,Object? resolveSupport = freezed,}) {
  return _then(_self.copyWith(
codeActionLiteralSupport: freezed == codeActionLiteralSupport ? _self.codeActionLiteralSupport : codeActionLiteralSupport // ignore: cast_nullable_to_non_nullable
as CodeActionKindsValueSetCodeActionKind?,dataSupport: freezed == dataSupport ? _self.dataSupport : dataSupport // ignore: cast_nullable_to_non_nullable
as bool?,disabledSupport: freezed == disabledSupport ? _self.disabledSupport : disabledSupport // ignore: cast_nullable_to_non_nullable
as bool?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,honorsChangeAnnotations: freezed == honorsChangeAnnotations ? _self.honorsChangeAnnotations : honorsChangeAnnotations // ignore: cast_nullable_to_non_nullable
as bool?,isPreferredSupport: freezed == isPreferredSupport ? _self.isPreferredSupport : isPreferredSupport // ignore: cast_nullable_to_non_nullable
as bool?,resolveSupport: freezed == resolveSupport ? _self.resolveSupport : resolveSupport // ignore: cast_nullable_to_non_nullable
as StringsProperties?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _CodeActionClientCapabilities implements CodeActionClientCapabilities {
  const _CodeActionClientCapabilities({this.codeActionLiteralSupport, this.dataSupport, this.disabledSupport, this.dynamicRegistration, this.honorsChangeAnnotations, this.isPreferredSupport, this.resolveSupport});
  factory _CodeActionClientCapabilities.fromJson(Map<String, dynamic> json) => _$CodeActionClientCapabilitiesFromJson(json);

/// The client support code action literals of type `CodeAction` as a valid
/// response of the `textDocument/codeAction` request. If the property is
/// not set the request can only return `Command` literals.
/// @since 3.8.0
@override final  CodeActionKindsValueSetCodeActionKind? codeActionLiteralSupport;
/// Whether code action supports the `data` property which is preserved
/// between a `textDocument/codeAction` and a `codeAction/resolve` request.
/// @since 3.16.0
@override final  bool? dataSupport;
/// Whether code action supports the `disabled` property.
/// @since 3.16.0
@override final  bool? disabledSupport;
/// Whether code action supports dynamic registration.
@override final  bool? dynamicRegistration;
/// Whether the client honors the change annotations in text edits and
/// resource operations returned via the `CodeAction#edit` property by for
/// example presenting the workspace edit in the user interface and asking
/// for confirmation.
/// @since 3.16.0
@override final  bool? honorsChangeAnnotations;
/// Whether code action supports the `isPreferred` property.
/// @since 3.15.0
@override final  bool? isPreferredSupport;
/// Whether the client supports resolving additional code action properties
/// via a separate `codeAction/resolve` request.
/// @since 3.16.0
@override final  StringsProperties? resolveSupport;

/// Create a copy of CodeActionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CodeActionClientCapabilitiesCopyWith<_CodeActionClientCapabilities> get copyWith => __$CodeActionClientCapabilitiesCopyWithImpl<_CodeActionClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CodeActionClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CodeActionClientCapabilities&&const DeepCollectionEquality().equals(other.codeActionLiteralSupport, codeActionLiteralSupport)&&(identical(other.dataSupport, dataSupport) || other.dataSupport == dataSupport)&&(identical(other.disabledSupport, disabledSupport) || other.disabledSupport == disabledSupport)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&(identical(other.honorsChangeAnnotations, honorsChangeAnnotations) || other.honorsChangeAnnotations == honorsChangeAnnotations)&&(identical(other.isPreferredSupport, isPreferredSupport) || other.isPreferredSupport == isPreferredSupport)&&const DeepCollectionEquality().equals(other.resolveSupport, resolveSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(codeActionLiteralSupport),dataSupport,disabledSupport,dynamicRegistration,honorsChangeAnnotations,isPreferredSupport,const DeepCollectionEquality().hash(resolveSupport));

@override
String toString() {
  return 'CodeActionClientCapabilities(codeActionLiteralSupport: $codeActionLiteralSupport, dataSupport: $dataSupport, disabledSupport: $disabledSupport, dynamicRegistration: $dynamicRegistration, honorsChangeAnnotations: $honorsChangeAnnotations, isPreferredSupport: $isPreferredSupport, resolveSupport: $resolveSupport)';
}


}

/// @nodoc
abstract mixin class _$CodeActionClientCapabilitiesCopyWith<$Res> implements $CodeActionClientCapabilitiesCopyWith<$Res> {
  factory _$CodeActionClientCapabilitiesCopyWith(_CodeActionClientCapabilities value, $Res Function(_CodeActionClientCapabilities) _then) = __$CodeActionClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 CodeActionKindsValueSetCodeActionKind? codeActionLiteralSupport, bool? dataSupport, bool? disabledSupport, bool? dynamicRegistration, bool? honorsChangeAnnotations, bool? isPreferredSupport, StringsProperties? resolveSupport
});




}
/// @nodoc
class __$CodeActionClientCapabilitiesCopyWithImpl<$Res>
    implements _$CodeActionClientCapabilitiesCopyWith<$Res> {
  __$CodeActionClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _CodeActionClientCapabilities _self;
  final $Res Function(_CodeActionClientCapabilities) _then;

/// Create a copy of CodeActionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? codeActionLiteralSupport = freezed,Object? dataSupport = freezed,Object? disabledSupport = freezed,Object? dynamicRegistration = freezed,Object? honorsChangeAnnotations = freezed,Object? isPreferredSupport = freezed,Object? resolveSupport = freezed,}) {
  return _then(_CodeActionClientCapabilities(
codeActionLiteralSupport: freezed == codeActionLiteralSupport ? _self.codeActionLiteralSupport : codeActionLiteralSupport // ignore: cast_nullable_to_non_nullable
as CodeActionKindsValueSetCodeActionKind?,dataSupport: freezed == dataSupport ? _self.dataSupport : dataSupport // ignore: cast_nullable_to_non_nullable
as bool?,disabledSupport: freezed == disabledSupport ? _self.disabledSupport : disabledSupport // ignore: cast_nullable_to_non_nullable
as bool?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,honorsChangeAnnotations: freezed == honorsChangeAnnotations ? _self.honorsChangeAnnotations : honorsChangeAnnotations // ignore: cast_nullable_to_non_nullable
as bool?,isPreferredSupport: freezed == isPreferredSupport ? _self.isPreferredSupport : isPreferredSupport // ignore: cast_nullable_to_non_nullable
as bool?,resolveSupport: freezed == resolveSupport ? _self.resolveSupport : resolveSupport // ignore: cast_nullable_to_non_nullable
as StringsProperties?,
  ));
}


}


/// @nodoc
mixin _$CodeLensClientCapabilities {

/// Whether code lens supports dynamic registration.
 bool? get dynamicRegistration;
/// Create a copy of CodeLensClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CodeLensClientCapabilitiesCopyWith<CodeLensClientCapabilities> get copyWith => _$CodeLensClientCapabilitiesCopyWithImpl<CodeLensClientCapabilities>(this as CodeLensClientCapabilities, _$identity);

  /// Serializes this CodeLensClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CodeLensClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'CodeLensClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $CodeLensClientCapabilitiesCopyWith<$Res>  {
  factory $CodeLensClientCapabilitiesCopyWith(CodeLensClientCapabilities value, $Res Function(CodeLensClientCapabilities) _then) = _$CodeLensClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class _$CodeLensClientCapabilitiesCopyWithImpl<$Res>
    implements $CodeLensClientCapabilitiesCopyWith<$Res> {
  _$CodeLensClientCapabilitiesCopyWithImpl(this._self, this._then);

  final CodeLensClientCapabilities _self;
  final $Res Function(CodeLensClientCapabilities) _then;

/// Create a copy of CodeLensClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _CodeLensClientCapabilities implements CodeLensClientCapabilities {
  const _CodeLensClientCapabilities({this.dynamicRegistration});
  factory _CodeLensClientCapabilities.fromJson(Map<String, dynamic> json) => _$CodeLensClientCapabilitiesFromJson(json);

/// Whether code lens supports dynamic registration.
@override final  bool? dynamicRegistration;

/// Create a copy of CodeLensClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CodeLensClientCapabilitiesCopyWith<_CodeLensClientCapabilities> get copyWith => __$CodeLensClientCapabilitiesCopyWithImpl<_CodeLensClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CodeLensClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CodeLensClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'CodeLensClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$CodeLensClientCapabilitiesCopyWith<$Res> implements $CodeLensClientCapabilitiesCopyWith<$Res> {
  factory _$CodeLensClientCapabilitiesCopyWith(_CodeLensClientCapabilities value, $Res Function(_CodeLensClientCapabilities) _then) = __$CodeLensClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class __$CodeLensClientCapabilitiesCopyWithImpl<$Res>
    implements _$CodeLensClientCapabilitiesCopyWith<$Res> {
  __$CodeLensClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _CodeLensClientCapabilities _self;
  final $Res Function(_CodeLensClientCapabilities) _then;

/// Create a copy of CodeLensClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_CodeLensClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DocumentLinkClientCapabilities {

/// Whether document link supports dynamic registration.
 bool? get dynamicRegistration;/// Whether the client supports the `tooltip` property on `DocumentLink`.
/// @since 3.15.0
 bool? get tooltipSupport;
/// Create a copy of DocumentLinkClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentLinkClientCapabilitiesCopyWith<DocumentLinkClientCapabilities> get copyWith => _$DocumentLinkClientCapabilitiesCopyWithImpl<DocumentLinkClientCapabilities>(this as DocumentLinkClientCapabilities, _$identity);

  /// Serializes this DocumentLinkClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentLinkClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&(identical(other.tooltipSupport, tooltipSupport) || other.tooltipSupport == tooltipSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration,tooltipSupport);

@override
String toString() {
  return 'DocumentLinkClientCapabilities(dynamicRegistration: $dynamicRegistration, tooltipSupport: $tooltipSupport)';
}


}

/// @nodoc
abstract mixin class $DocumentLinkClientCapabilitiesCopyWith<$Res>  {
  factory $DocumentLinkClientCapabilitiesCopyWith(DocumentLinkClientCapabilities value, $Res Function(DocumentLinkClientCapabilities) _then) = _$DocumentLinkClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration, bool? tooltipSupport
});




}
/// @nodoc
class _$DocumentLinkClientCapabilitiesCopyWithImpl<$Res>
    implements $DocumentLinkClientCapabilitiesCopyWith<$Res> {
  _$DocumentLinkClientCapabilitiesCopyWithImpl(this._self, this._then);

  final DocumentLinkClientCapabilities _self;
  final $Res Function(DocumentLinkClientCapabilities) _then;

/// Create a copy of DocumentLinkClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,Object? tooltipSupport = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,tooltipSupport: freezed == tooltipSupport ? _self.tooltipSupport : tooltipSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DocumentLinkClientCapabilities implements DocumentLinkClientCapabilities {
  const _DocumentLinkClientCapabilities({this.dynamicRegistration, this.tooltipSupport});
  factory _DocumentLinkClientCapabilities.fromJson(Map<String, dynamic> json) => _$DocumentLinkClientCapabilitiesFromJson(json);

/// Whether document link supports dynamic registration.
@override final  bool? dynamicRegistration;
/// Whether the client supports the `tooltip` property on `DocumentLink`.
/// @since 3.15.0
@override final  bool? tooltipSupport;

/// Create a copy of DocumentLinkClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentLinkClientCapabilitiesCopyWith<_DocumentLinkClientCapabilities> get copyWith => __$DocumentLinkClientCapabilitiesCopyWithImpl<_DocumentLinkClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentLinkClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentLinkClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&(identical(other.tooltipSupport, tooltipSupport) || other.tooltipSupport == tooltipSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration,tooltipSupport);

@override
String toString() {
  return 'DocumentLinkClientCapabilities(dynamicRegistration: $dynamicRegistration, tooltipSupport: $tooltipSupport)';
}


}

/// @nodoc
abstract mixin class _$DocumentLinkClientCapabilitiesCopyWith<$Res> implements $DocumentLinkClientCapabilitiesCopyWith<$Res> {
  factory _$DocumentLinkClientCapabilitiesCopyWith(_DocumentLinkClientCapabilities value, $Res Function(_DocumentLinkClientCapabilities) _then) = __$DocumentLinkClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration, bool? tooltipSupport
});




}
/// @nodoc
class __$DocumentLinkClientCapabilitiesCopyWithImpl<$Res>
    implements _$DocumentLinkClientCapabilitiesCopyWith<$Res> {
  __$DocumentLinkClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _DocumentLinkClientCapabilities _self;
  final $Res Function(_DocumentLinkClientCapabilities) _then;

/// Create a copy of DocumentLinkClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,Object? tooltipSupport = freezed,}) {
  return _then(_DocumentLinkClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,tooltipSupport: freezed == tooltipSupport ? _self.tooltipSupport : tooltipSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DocumentColorClientCapabilities {

/// Whether implementation supports dynamic registration. If this is set to
/// `true` the client supports the new `DocumentColorRegistrationOptions`
/// return value for the corresponding server capability as well.
 bool? get dynamicRegistration;
/// Create a copy of DocumentColorClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentColorClientCapabilitiesCopyWith<DocumentColorClientCapabilities> get copyWith => _$DocumentColorClientCapabilitiesCopyWithImpl<DocumentColorClientCapabilities>(this as DocumentColorClientCapabilities, _$identity);

  /// Serializes this DocumentColorClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentColorClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'DocumentColorClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $DocumentColorClientCapabilitiesCopyWith<$Res>  {
  factory $DocumentColorClientCapabilitiesCopyWith(DocumentColorClientCapabilities value, $Res Function(DocumentColorClientCapabilities) _then) = _$DocumentColorClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class _$DocumentColorClientCapabilitiesCopyWithImpl<$Res>
    implements $DocumentColorClientCapabilitiesCopyWith<$Res> {
  _$DocumentColorClientCapabilitiesCopyWithImpl(this._self, this._then);

  final DocumentColorClientCapabilities _self;
  final $Res Function(DocumentColorClientCapabilities) _then;

/// Create a copy of DocumentColorClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DocumentColorClientCapabilities implements DocumentColorClientCapabilities {
  const _DocumentColorClientCapabilities({this.dynamicRegistration});
  factory _DocumentColorClientCapabilities.fromJson(Map<String, dynamic> json) => _$DocumentColorClientCapabilitiesFromJson(json);

/// Whether implementation supports dynamic registration. If this is set to
/// `true` the client supports the new `DocumentColorRegistrationOptions`
/// return value for the corresponding server capability as well.
@override final  bool? dynamicRegistration;

/// Create a copy of DocumentColorClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentColorClientCapabilitiesCopyWith<_DocumentColorClientCapabilities> get copyWith => __$DocumentColorClientCapabilitiesCopyWithImpl<_DocumentColorClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentColorClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentColorClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'DocumentColorClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$DocumentColorClientCapabilitiesCopyWith<$Res> implements $DocumentColorClientCapabilitiesCopyWith<$Res> {
  factory _$DocumentColorClientCapabilitiesCopyWith(_DocumentColorClientCapabilities value, $Res Function(_DocumentColorClientCapabilities) _then) = __$DocumentColorClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class __$DocumentColorClientCapabilitiesCopyWithImpl<$Res>
    implements _$DocumentColorClientCapabilitiesCopyWith<$Res> {
  __$DocumentColorClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _DocumentColorClientCapabilities _self;
  final $Res Function(_DocumentColorClientCapabilities) _then;

/// Create a copy of DocumentColorClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_DocumentColorClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DocumentFormattingClientCapabilities {

/// Whether formatting supports dynamic registration.
 bool? get dynamicRegistration;
/// Create a copy of DocumentFormattingClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentFormattingClientCapabilitiesCopyWith<DocumentFormattingClientCapabilities> get copyWith => _$DocumentFormattingClientCapabilitiesCopyWithImpl<DocumentFormattingClientCapabilities>(this as DocumentFormattingClientCapabilities, _$identity);

  /// Serializes this DocumentFormattingClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentFormattingClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'DocumentFormattingClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $DocumentFormattingClientCapabilitiesCopyWith<$Res>  {
  factory $DocumentFormattingClientCapabilitiesCopyWith(DocumentFormattingClientCapabilities value, $Res Function(DocumentFormattingClientCapabilities) _then) = _$DocumentFormattingClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class _$DocumentFormattingClientCapabilitiesCopyWithImpl<$Res>
    implements $DocumentFormattingClientCapabilitiesCopyWith<$Res> {
  _$DocumentFormattingClientCapabilitiesCopyWithImpl(this._self, this._then);

  final DocumentFormattingClientCapabilities _self;
  final $Res Function(DocumentFormattingClientCapabilities) _then;

/// Create a copy of DocumentFormattingClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DocumentFormattingClientCapabilities implements DocumentFormattingClientCapabilities {
  const _DocumentFormattingClientCapabilities({this.dynamicRegistration});
  factory _DocumentFormattingClientCapabilities.fromJson(Map<String, dynamic> json) => _$DocumentFormattingClientCapabilitiesFromJson(json);

/// Whether formatting supports dynamic registration.
@override final  bool? dynamicRegistration;

/// Create a copy of DocumentFormattingClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentFormattingClientCapabilitiesCopyWith<_DocumentFormattingClientCapabilities> get copyWith => __$DocumentFormattingClientCapabilitiesCopyWithImpl<_DocumentFormattingClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentFormattingClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentFormattingClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'DocumentFormattingClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$DocumentFormattingClientCapabilitiesCopyWith<$Res> implements $DocumentFormattingClientCapabilitiesCopyWith<$Res> {
  factory _$DocumentFormattingClientCapabilitiesCopyWith(_DocumentFormattingClientCapabilities value, $Res Function(_DocumentFormattingClientCapabilities) _then) = __$DocumentFormattingClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class __$DocumentFormattingClientCapabilitiesCopyWithImpl<$Res>
    implements _$DocumentFormattingClientCapabilitiesCopyWith<$Res> {
  __$DocumentFormattingClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _DocumentFormattingClientCapabilities _self;
  final $Res Function(_DocumentFormattingClientCapabilities) _then;

/// Create a copy of DocumentFormattingClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_DocumentFormattingClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DocumentRangeFormattingClientCapabilities {

/// Whether range formatting supports dynamic registration.
 bool? get dynamicRegistration;/// Whether the client supports formatting multiple ranges at once.
/// @since 3.18.0 @proposed
 bool? get rangesSupport;
/// Create a copy of DocumentRangeFormattingClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentRangeFormattingClientCapabilitiesCopyWith<DocumentRangeFormattingClientCapabilities> get copyWith => _$DocumentRangeFormattingClientCapabilitiesCopyWithImpl<DocumentRangeFormattingClientCapabilities>(this as DocumentRangeFormattingClientCapabilities, _$identity);

  /// Serializes this DocumentRangeFormattingClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentRangeFormattingClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&(identical(other.rangesSupport, rangesSupport) || other.rangesSupport == rangesSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration,rangesSupport);

@override
String toString() {
  return 'DocumentRangeFormattingClientCapabilities(dynamicRegistration: $dynamicRegistration, rangesSupport: $rangesSupport)';
}


}

/// @nodoc
abstract mixin class $DocumentRangeFormattingClientCapabilitiesCopyWith<$Res>  {
  factory $DocumentRangeFormattingClientCapabilitiesCopyWith(DocumentRangeFormattingClientCapabilities value, $Res Function(DocumentRangeFormattingClientCapabilities) _then) = _$DocumentRangeFormattingClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration, bool? rangesSupport
});




}
/// @nodoc
class _$DocumentRangeFormattingClientCapabilitiesCopyWithImpl<$Res>
    implements $DocumentRangeFormattingClientCapabilitiesCopyWith<$Res> {
  _$DocumentRangeFormattingClientCapabilitiesCopyWithImpl(this._self, this._then);

  final DocumentRangeFormattingClientCapabilities _self;
  final $Res Function(DocumentRangeFormattingClientCapabilities) _then;

/// Create a copy of DocumentRangeFormattingClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,Object? rangesSupport = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,rangesSupport: freezed == rangesSupport ? _self.rangesSupport : rangesSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DocumentRangeFormattingClientCapabilities implements DocumentRangeFormattingClientCapabilities {
  const _DocumentRangeFormattingClientCapabilities({this.dynamicRegistration, this.rangesSupport});
  factory _DocumentRangeFormattingClientCapabilities.fromJson(Map<String, dynamic> json) => _$DocumentRangeFormattingClientCapabilitiesFromJson(json);

/// Whether range formatting supports dynamic registration.
@override final  bool? dynamicRegistration;
/// Whether the client supports formatting multiple ranges at once.
/// @since 3.18.0 @proposed
@override final  bool? rangesSupport;

/// Create a copy of DocumentRangeFormattingClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentRangeFormattingClientCapabilitiesCopyWith<_DocumentRangeFormattingClientCapabilities> get copyWith => __$DocumentRangeFormattingClientCapabilitiesCopyWithImpl<_DocumentRangeFormattingClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentRangeFormattingClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentRangeFormattingClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&(identical(other.rangesSupport, rangesSupport) || other.rangesSupport == rangesSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration,rangesSupport);

@override
String toString() {
  return 'DocumentRangeFormattingClientCapabilities(dynamicRegistration: $dynamicRegistration, rangesSupport: $rangesSupport)';
}


}

/// @nodoc
abstract mixin class _$DocumentRangeFormattingClientCapabilitiesCopyWith<$Res> implements $DocumentRangeFormattingClientCapabilitiesCopyWith<$Res> {
  factory _$DocumentRangeFormattingClientCapabilitiesCopyWith(_DocumentRangeFormattingClientCapabilities value, $Res Function(_DocumentRangeFormattingClientCapabilities) _then) = __$DocumentRangeFormattingClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration, bool? rangesSupport
});




}
/// @nodoc
class __$DocumentRangeFormattingClientCapabilitiesCopyWithImpl<$Res>
    implements _$DocumentRangeFormattingClientCapabilitiesCopyWith<$Res> {
  __$DocumentRangeFormattingClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _DocumentRangeFormattingClientCapabilities _self;
  final $Res Function(_DocumentRangeFormattingClientCapabilities) _then;

/// Create a copy of DocumentRangeFormattingClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,Object? rangesSupport = freezed,}) {
  return _then(_DocumentRangeFormattingClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,rangesSupport: freezed == rangesSupport ? _self.rangesSupport : rangesSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$DocumentOnTypeFormattingClientCapabilities {

/// Whether on type formatting supports dynamic registration.
 bool? get dynamicRegistration;
/// Create a copy of DocumentOnTypeFormattingClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DocumentOnTypeFormattingClientCapabilitiesCopyWith<DocumentOnTypeFormattingClientCapabilities> get copyWith => _$DocumentOnTypeFormattingClientCapabilitiesCopyWithImpl<DocumentOnTypeFormattingClientCapabilities>(this as DocumentOnTypeFormattingClientCapabilities, _$identity);

  /// Serializes this DocumentOnTypeFormattingClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DocumentOnTypeFormattingClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'DocumentOnTypeFormattingClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $DocumentOnTypeFormattingClientCapabilitiesCopyWith<$Res>  {
  factory $DocumentOnTypeFormattingClientCapabilitiesCopyWith(DocumentOnTypeFormattingClientCapabilities value, $Res Function(DocumentOnTypeFormattingClientCapabilities) _then) = _$DocumentOnTypeFormattingClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class _$DocumentOnTypeFormattingClientCapabilitiesCopyWithImpl<$Res>
    implements $DocumentOnTypeFormattingClientCapabilitiesCopyWith<$Res> {
  _$DocumentOnTypeFormattingClientCapabilitiesCopyWithImpl(this._self, this._then);

  final DocumentOnTypeFormattingClientCapabilities _self;
  final $Res Function(DocumentOnTypeFormattingClientCapabilities) _then;

/// Create a copy of DocumentOnTypeFormattingClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DocumentOnTypeFormattingClientCapabilities implements DocumentOnTypeFormattingClientCapabilities {
  const _DocumentOnTypeFormattingClientCapabilities({this.dynamicRegistration});
  factory _DocumentOnTypeFormattingClientCapabilities.fromJson(Map<String, dynamic> json) => _$DocumentOnTypeFormattingClientCapabilitiesFromJson(json);

/// Whether on type formatting supports dynamic registration.
@override final  bool? dynamicRegistration;

/// Create a copy of DocumentOnTypeFormattingClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DocumentOnTypeFormattingClientCapabilitiesCopyWith<_DocumentOnTypeFormattingClientCapabilities> get copyWith => __$DocumentOnTypeFormattingClientCapabilitiesCopyWithImpl<_DocumentOnTypeFormattingClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DocumentOnTypeFormattingClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DocumentOnTypeFormattingClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'DocumentOnTypeFormattingClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$DocumentOnTypeFormattingClientCapabilitiesCopyWith<$Res> implements $DocumentOnTypeFormattingClientCapabilitiesCopyWith<$Res> {
  factory _$DocumentOnTypeFormattingClientCapabilitiesCopyWith(_DocumentOnTypeFormattingClientCapabilities value, $Res Function(_DocumentOnTypeFormattingClientCapabilities) _then) = __$DocumentOnTypeFormattingClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class __$DocumentOnTypeFormattingClientCapabilitiesCopyWithImpl<$Res>
    implements _$DocumentOnTypeFormattingClientCapabilitiesCopyWith<$Res> {
  __$DocumentOnTypeFormattingClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _DocumentOnTypeFormattingClientCapabilities _self;
  final $Res Function(_DocumentOnTypeFormattingClientCapabilities) _then;

/// Create a copy of DocumentOnTypeFormattingClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_DocumentOnTypeFormattingClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$RenameClientCapabilities {

/// Whether rename supports dynamic registration.
 bool? get dynamicRegistration;/// Whether the client honors the change annotations in text edits and
/// resource operations returned via the rename request's workspace edit by
/// for example presenting the workspace edit in the user interface and
/// asking for confirmation.
/// @since 3.16.0
 bool? get honorsChangeAnnotations;/// Client supports testing for validity of rename operations before
/// execution.
/// @since 3.12.0
 bool? get prepareSupport;/// Client supports the default behavior result.
/// The value indicates the default behavior used by the client.
/// @since 3.16.0
 PrepareSupportDefaultBehavior? get prepareSupportDefaultBehavior;
/// Create a copy of RenameClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RenameClientCapabilitiesCopyWith<RenameClientCapabilities> get copyWith => _$RenameClientCapabilitiesCopyWithImpl<RenameClientCapabilities>(this as RenameClientCapabilities, _$identity);

  /// Serializes this RenameClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RenameClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&(identical(other.honorsChangeAnnotations, honorsChangeAnnotations) || other.honorsChangeAnnotations == honorsChangeAnnotations)&&(identical(other.prepareSupport, prepareSupport) || other.prepareSupport == prepareSupport)&&(identical(other.prepareSupportDefaultBehavior, prepareSupportDefaultBehavior) || other.prepareSupportDefaultBehavior == prepareSupportDefaultBehavior));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration,honorsChangeAnnotations,prepareSupport,prepareSupportDefaultBehavior);

@override
String toString() {
  return 'RenameClientCapabilities(dynamicRegistration: $dynamicRegistration, honorsChangeAnnotations: $honorsChangeAnnotations, prepareSupport: $prepareSupport, prepareSupportDefaultBehavior: $prepareSupportDefaultBehavior)';
}


}

/// @nodoc
abstract mixin class $RenameClientCapabilitiesCopyWith<$Res>  {
  factory $RenameClientCapabilitiesCopyWith(RenameClientCapabilities value, $Res Function(RenameClientCapabilities) _then) = _$RenameClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration, bool? honorsChangeAnnotations, bool? prepareSupport, PrepareSupportDefaultBehavior? prepareSupportDefaultBehavior
});




}
/// @nodoc
class _$RenameClientCapabilitiesCopyWithImpl<$Res>
    implements $RenameClientCapabilitiesCopyWith<$Res> {
  _$RenameClientCapabilitiesCopyWithImpl(this._self, this._then);

  final RenameClientCapabilities _self;
  final $Res Function(RenameClientCapabilities) _then;

/// Create a copy of RenameClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,Object? honorsChangeAnnotations = freezed,Object? prepareSupport = freezed,Object? prepareSupportDefaultBehavior = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,honorsChangeAnnotations: freezed == honorsChangeAnnotations ? _self.honorsChangeAnnotations : honorsChangeAnnotations // ignore: cast_nullable_to_non_nullable
as bool?,prepareSupport: freezed == prepareSupport ? _self.prepareSupport : prepareSupport // ignore: cast_nullable_to_non_nullable
as bool?,prepareSupportDefaultBehavior: freezed == prepareSupportDefaultBehavior ? _self.prepareSupportDefaultBehavior : prepareSupportDefaultBehavior // ignore: cast_nullable_to_non_nullable
as PrepareSupportDefaultBehavior?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _RenameClientCapabilities implements RenameClientCapabilities {
  const _RenameClientCapabilities({this.dynamicRegistration, this.honorsChangeAnnotations, this.prepareSupport, this.prepareSupportDefaultBehavior});
  factory _RenameClientCapabilities.fromJson(Map<String, dynamic> json) => _$RenameClientCapabilitiesFromJson(json);

/// Whether rename supports dynamic registration.
@override final  bool? dynamicRegistration;
/// Whether the client honors the change annotations in text edits and
/// resource operations returned via the rename request's workspace edit by
/// for example presenting the workspace edit in the user interface and
/// asking for confirmation.
/// @since 3.16.0
@override final  bool? honorsChangeAnnotations;
/// Client supports testing for validity of rename operations before
/// execution.
/// @since 3.12.0
@override final  bool? prepareSupport;
/// Client supports the default behavior result.
/// The value indicates the default behavior used by the client.
/// @since 3.16.0
@override final  PrepareSupportDefaultBehavior? prepareSupportDefaultBehavior;

/// Create a copy of RenameClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RenameClientCapabilitiesCopyWith<_RenameClientCapabilities> get copyWith => __$RenameClientCapabilitiesCopyWithImpl<_RenameClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$RenameClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _RenameClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&(identical(other.honorsChangeAnnotations, honorsChangeAnnotations) || other.honorsChangeAnnotations == honorsChangeAnnotations)&&(identical(other.prepareSupport, prepareSupport) || other.prepareSupport == prepareSupport)&&(identical(other.prepareSupportDefaultBehavior, prepareSupportDefaultBehavior) || other.prepareSupportDefaultBehavior == prepareSupportDefaultBehavior));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration,honorsChangeAnnotations,prepareSupport,prepareSupportDefaultBehavior);

@override
String toString() {
  return 'RenameClientCapabilities(dynamicRegistration: $dynamicRegistration, honorsChangeAnnotations: $honorsChangeAnnotations, prepareSupport: $prepareSupport, prepareSupportDefaultBehavior: $prepareSupportDefaultBehavior)';
}


}

/// @nodoc
abstract mixin class _$RenameClientCapabilitiesCopyWith<$Res> implements $RenameClientCapabilitiesCopyWith<$Res> {
  factory _$RenameClientCapabilitiesCopyWith(_RenameClientCapabilities value, $Res Function(_RenameClientCapabilities) _then) = __$RenameClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration, bool? honorsChangeAnnotations, bool? prepareSupport, PrepareSupportDefaultBehavior? prepareSupportDefaultBehavior
});




}
/// @nodoc
class __$RenameClientCapabilitiesCopyWithImpl<$Res>
    implements _$RenameClientCapabilitiesCopyWith<$Res> {
  __$RenameClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _RenameClientCapabilities _self;
  final $Res Function(_RenameClientCapabilities) _then;

/// Create a copy of RenameClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,Object? honorsChangeAnnotations = freezed,Object? prepareSupport = freezed,Object? prepareSupportDefaultBehavior = freezed,}) {
  return _then(_RenameClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,honorsChangeAnnotations: freezed == honorsChangeAnnotations ? _self.honorsChangeAnnotations : honorsChangeAnnotations // ignore: cast_nullable_to_non_nullable
as bool?,prepareSupport: freezed == prepareSupport ? _self.prepareSupport : prepareSupport // ignore: cast_nullable_to_non_nullable
as bool?,prepareSupportDefaultBehavior: freezed == prepareSupportDefaultBehavior ? _self.prepareSupportDefaultBehavior : prepareSupportDefaultBehavior // ignore: cast_nullable_to_non_nullable
as PrepareSupportDefaultBehavior?,
  ));
}


}


/// @nodoc
mixin _$FoldingRangeClientCapabilities {

/// Whether implementation supports dynamic registration for folding range
/// providers. If this is set to `true` the client supports the new
/// `FoldingRangeRegistrationOptions` return value for the corresponding
/// server capability as well.
 bool? get dynamicRegistration;/// Specific options for the folding range.
/// @since 3.17.0
 BoolCollapsedText? get foldingRange;/// Specific options for the folding range kind.
/// @since 3.17.0
 FoldingRangeKindsValueSet? get foldingRangeKind;/// If set, the client signals that it only supports folding complete
/// lines. If set, client will ignore specified `startCharacter` and
/// `endCharacter` properties in a FoldingRange.
 bool? get lineFoldingOnly;/// The maximum number of folding ranges that the client prefers to receive
/// per document. The value serves as a hint, servers are free to follow
/// the limit.
 int? get rangeLimit;
/// Create a copy of FoldingRangeClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$FoldingRangeClientCapabilitiesCopyWith<FoldingRangeClientCapabilities> get copyWith => _$FoldingRangeClientCapabilitiesCopyWithImpl<FoldingRangeClientCapabilities>(this as FoldingRangeClientCapabilities, _$identity);

  /// Serializes this FoldingRangeClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is FoldingRangeClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&const DeepCollectionEquality().equals(other.foldingRange, foldingRange)&&const DeepCollectionEquality().equals(other.foldingRangeKind, foldingRangeKind)&&(identical(other.lineFoldingOnly, lineFoldingOnly) || other.lineFoldingOnly == lineFoldingOnly)&&(identical(other.rangeLimit, rangeLimit) || other.rangeLimit == rangeLimit));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration,const DeepCollectionEquality().hash(foldingRange),const DeepCollectionEquality().hash(foldingRangeKind),lineFoldingOnly,rangeLimit);

@override
String toString() {
  return 'FoldingRangeClientCapabilities(dynamicRegistration: $dynamicRegistration, foldingRange: $foldingRange, foldingRangeKind: $foldingRangeKind, lineFoldingOnly: $lineFoldingOnly, rangeLimit: $rangeLimit)';
}


}

/// @nodoc
abstract mixin class $FoldingRangeClientCapabilitiesCopyWith<$Res>  {
  factory $FoldingRangeClientCapabilitiesCopyWith(FoldingRangeClientCapabilities value, $Res Function(FoldingRangeClientCapabilities) _then) = _$FoldingRangeClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration, BoolCollapsedText? foldingRange, FoldingRangeKindsValueSet? foldingRangeKind, bool? lineFoldingOnly, int? rangeLimit
});




}
/// @nodoc
class _$FoldingRangeClientCapabilitiesCopyWithImpl<$Res>
    implements $FoldingRangeClientCapabilitiesCopyWith<$Res> {
  _$FoldingRangeClientCapabilitiesCopyWithImpl(this._self, this._then);

  final FoldingRangeClientCapabilities _self;
  final $Res Function(FoldingRangeClientCapabilities) _then;

/// Create a copy of FoldingRangeClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,Object? foldingRange = freezed,Object? foldingRangeKind = freezed,Object? lineFoldingOnly = freezed,Object? rangeLimit = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,foldingRange: freezed == foldingRange ? _self.foldingRange : foldingRange // ignore: cast_nullable_to_non_nullable
as BoolCollapsedText?,foldingRangeKind: freezed == foldingRangeKind ? _self.foldingRangeKind : foldingRangeKind // ignore: cast_nullable_to_non_nullable
as FoldingRangeKindsValueSet?,lineFoldingOnly: freezed == lineFoldingOnly ? _self.lineFoldingOnly : lineFoldingOnly // ignore: cast_nullable_to_non_nullable
as bool?,rangeLimit: freezed == rangeLimit ? _self.rangeLimit : rangeLimit // ignore: cast_nullable_to_non_nullable
as int?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _FoldingRangeClientCapabilities implements FoldingRangeClientCapabilities {
  const _FoldingRangeClientCapabilities({this.dynamicRegistration, this.foldingRange, this.foldingRangeKind, this.lineFoldingOnly, this.rangeLimit});
  factory _FoldingRangeClientCapabilities.fromJson(Map<String, dynamic> json) => _$FoldingRangeClientCapabilitiesFromJson(json);

/// Whether implementation supports dynamic registration for folding range
/// providers. If this is set to `true` the client supports the new
/// `FoldingRangeRegistrationOptions` return value for the corresponding
/// server capability as well.
@override final  bool? dynamicRegistration;
/// Specific options for the folding range.
/// @since 3.17.0
@override final  BoolCollapsedText? foldingRange;
/// Specific options for the folding range kind.
/// @since 3.17.0
@override final  FoldingRangeKindsValueSet? foldingRangeKind;
/// If set, the client signals that it only supports folding complete
/// lines. If set, client will ignore specified `startCharacter` and
/// `endCharacter` properties in a FoldingRange.
@override final  bool? lineFoldingOnly;
/// The maximum number of folding ranges that the client prefers to receive
/// per document. The value serves as a hint, servers are free to follow
/// the limit.
@override final  int? rangeLimit;

/// Create a copy of FoldingRangeClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$FoldingRangeClientCapabilitiesCopyWith<_FoldingRangeClientCapabilities> get copyWith => __$FoldingRangeClientCapabilitiesCopyWithImpl<_FoldingRangeClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$FoldingRangeClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _FoldingRangeClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&const DeepCollectionEquality().equals(other.foldingRange, foldingRange)&&const DeepCollectionEquality().equals(other.foldingRangeKind, foldingRangeKind)&&(identical(other.lineFoldingOnly, lineFoldingOnly) || other.lineFoldingOnly == lineFoldingOnly)&&(identical(other.rangeLimit, rangeLimit) || other.rangeLimit == rangeLimit));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration,const DeepCollectionEquality().hash(foldingRange),const DeepCollectionEquality().hash(foldingRangeKind),lineFoldingOnly,rangeLimit);

@override
String toString() {
  return 'FoldingRangeClientCapabilities(dynamicRegistration: $dynamicRegistration, foldingRange: $foldingRange, foldingRangeKind: $foldingRangeKind, lineFoldingOnly: $lineFoldingOnly, rangeLimit: $rangeLimit)';
}


}

/// @nodoc
abstract mixin class _$FoldingRangeClientCapabilitiesCopyWith<$Res> implements $FoldingRangeClientCapabilitiesCopyWith<$Res> {
  factory _$FoldingRangeClientCapabilitiesCopyWith(_FoldingRangeClientCapabilities value, $Res Function(_FoldingRangeClientCapabilities) _then) = __$FoldingRangeClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration, BoolCollapsedText? foldingRange, FoldingRangeKindsValueSet? foldingRangeKind, bool? lineFoldingOnly, int? rangeLimit
});




}
/// @nodoc
class __$FoldingRangeClientCapabilitiesCopyWithImpl<$Res>
    implements _$FoldingRangeClientCapabilitiesCopyWith<$Res> {
  __$FoldingRangeClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _FoldingRangeClientCapabilities _self;
  final $Res Function(_FoldingRangeClientCapabilities) _then;

/// Create a copy of FoldingRangeClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,Object? foldingRange = freezed,Object? foldingRangeKind = freezed,Object? lineFoldingOnly = freezed,Object? rangeLimit = freezed,}) {
  return _then(_FoldingRangeClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,foldingRange: freezed == foldingRange ? _self.foldingRange : foldingRange // ignore: cast_nullable_to_non_nullable
as BoolCollapsedText?,foldingRangeKind: freezed == foldingRangeKind ? _self.foldingRangeKind : foldingRangeKind // ignore: cast_nullable_to_non_nullable
as FoldingRangeKindsValueSet?,lineFoldingOnly: freezed == lineFoldingOnly ? _self.lineFoldingOnly : lineFoldingOnly // ignore: cast_nullable_to_non_nullable
as bool?,rangeLimit: freezed == rangeLimit ? _self.rangeLimit : rangeLimit // ignore: cast_nullable_to_non_nullable
as int?,
  ));
}


}


/// @nodoc
mixin _$SelectionRangeClientCapabilities {

/// Whether implementation supports dynamic registration for selection
/// range providers. If this is set to `true` the client supports the new
/// `SelectionRangeRegistrationOptions` return value for the corresponding
/// server capability as well.
 bool? get dynamicRegistration;
/// Create a copy of SelectionRangeClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SelectionRangeClientCapabilitiesCopyWith<SelectionRangeClientCapabilities> get copyWith => _$SelectionRangeClientCapabilitiesCopyWithImpl<SelectionRangeClientCapabilities>(this as SelectionRangeClientCapabilities, _$identity);

  /// Serializes this SelectionRangeClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SelectionRangeClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'SelectionRangeClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $SelectionRangeClientCapabilitiesCopyWith<$Res>  {
  factory $SelectionRangeClientCapabilitiesCopyWith(SelectionRangeClientCapabilities value, $Res Function(SelectionRangeClientCapabilities) _then) = _$SelectionRangeClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class _$SelectionRangeClientCapabilitiesCopyWithImpl<$Res>
    implements $SelectionRangeClientCapabilitiesCopyWith<$Res> {
  _$SelectionRangeClientCapabilitiesCopyWithImpl(this._self, this._then);

  final SelectionRangeClientCapabilities _self;
  final $Res Function(SelectionRangeClientCapabilities) _then;

/// Create a copy of SelectionRangeClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _SelectionRangeClientCapabilities implements SelectionRangeClientCapabilities {
  const _SelectionRangeClientCapabilities({this.dynamicRegistration});
  factory _SelectionRangeClientCapabilities.fromJson(Map<String, dynamic> json) => _$SelectionRangeClientCapabilitiesFromJson(json);

/// Whether implementation supports dynamic registration for selection
/// range providers. If this is set to `true` the client supports the new
/// `SelectionRangeRegistrationOptions` return value for the corresponding
/// server capability as well.
@override final  bool? dynamicRegistration;

/// Create a copy of SelectionRangeClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SelectionRangeClientCapabilitiesCopyWith<_SelectionRangeClientCapabilities> get copyWith => __$SelectionRangeClientCapabilitiesCopyWithImpl<_SelectionRangeClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SelectionRangeClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SelectionRangeClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'SelectionRangeClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$SelectionRangeClientCapabilitiesCopyWith<$Res> implements $SelectionRangeClientCapabilitiesCopyWith<$Res> {
  factory _$SelectionRangeClientCapabilitiesCopyWith(_SelectionRangeClientCapabilities value, $Res Function(_SelectionRangeClientCapabilities) _then) = __$SelectionRangeClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class __$SelectionRangeClientCapabilitiesCopyWithImpl<$Res>
    implements _$SelectionRangeClientCapabilitiesCopyWith<$Res> {
  __$SelectionRangeClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _SelectionRangeClientCapabilities _self;
  final $Res Function(_SelectionRangeClientCapabilities) _then;

/// Create a copy of SelectionRangeClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_SelectionRangeClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$PublishDiagnosticsClientCapabilities {

/// Client supports a codeDescription property
/// @since 3.16.0
 bool? get codeDescriptionSupport;/// Whether code action supports the `data` property which is preserved
/// between a `textDocument/publishDiagnostics` and
/// `textDocument/codeAction` request.
/// @since 3.16.0
 bool? get dataSupport;/// Whether the clients accepts diagnostics with related information.
 bool? get relatedInformation;/// Client supports the tag property to provide meta data about a
/// diagnostic. Clients supporting tags have to handle unknown tags
/// gracefully.
/// @since 3.15.0
 DiagnosticTagsValueSet? get tagSupport;/// Whether the client interprets the version property of the
/// `textDocument/publishDiagnostics` notification's parameter.
/// @since 3.15.0
 bool? get versionSupport;
/// Create a copy of PublishDiagnosticsClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$PublishDiagnosticsClientCapabilitiesCopyWith<PublishDiagnosticsClientCapabilities> get copyWith => _$PublishDiagnosticsClientCapabilitiesCopyWithImpl<PublishDiagnosticsClientCapabilities>(this as PublishDiagnosticsClientCapabilities, _$identity);

  /// Serializes this PublishDiagnosticsClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is PublishDiagnosticsClientCapabilities&&(identical(other.codeDescriptionSupport, codeDescriptionSupport) || other.codeDescriptionSupport == codeDescriptionSupport)&&(identical(other.dataSupport, dataSupport) || other.dataSupport == dataSupport)&&(identical(other.relatedInformation, relatedInformation) || other.relatedInformation == relatedInformation)&&const DeepCollectionEquality().equals(other.tagSupport, tagSupport)&&(identical(other.versionSupport, versionSupport) || other.versionSupport == versionSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,codeDescriptionSupport,dataSupport,relatedInformation,const DeepCollectionEquality().hash(tagSupport),versionSupport);

@override
String toString() {
  return 'PublishDiagnosticsClientCapabilities(codeDescriptionSupport: $codeDescriptionSupport, dataSupport: $dataSupport, relatedInformation: $relatedInformation, tagSupport: $tagSupport, versionSupport: $versionSupport)';
}


}

/// @nodoc
abstract mixin class $PublishDiagnosticsClientCapabilitiesCopyWith<$Res>  {
  factory $PublishDiagnosticsClientCapabilitiesCopyWith(PublishDiagnosticsClientCapabilities value, $Res Function(PublishDiagnosticsClientCapabilities) _then) = _$PublishDiagnosticsClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? codeDescriptionSupport, bool? dataSupport, bool? relatedInformation, DiagnosticTagsValueSet? tagSupport, bool? versionSupport
});




}
/// @nodoc
class _$PublishDiagnosticsClientCapabilitiesCopyWithImpl<$Res>
    implements $PublishDiagnosticsClientCapabilitiesCopyWith<$Res> {
  _$PublishDiagnosticsClientCapabilitiesCopyWithImpl(this._self, this._then);

  final PublishDiagnosticsClientCapabilities _self;
  final $Res Function(PublishDiagnosticsClientCapabilities) _then;

/// Create a copy of PublishDiagnosticsClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? codeDescriptionSupport = freezed,Object? dataSupport = freezed,Object? relatedInformation = freezed,Object? tagSupport = freezed,Object? versionSupport = freezed,}) {
  return _then(_self.copyWith(
codeDescriptionSupport: freezed == codeDescriptionSupport ? _self.codeDescriptionSupport : codeDescriptionSupport // ignore: cast_nullable_to_non_nullable
as bool?,dataSupport: freezed == dataSupport ? _self.dataSupport : dataSupport // ignore: cast_nullable_to_non_nullable
as bool?,relatedInformation: freezed == relatedInformation ? _self.relatedInformation : relatedInformation // ignore: cast_nullable_to_non_nullable
as bool?,tagSupport: freezed == tagSupport ? _self.tagSupport : tagSupport // ignore: cast_nullable_to_non_nullable
as DiagnosticTagsValueSet?,versionSupport: freezed == versionSupport ? _self.versionSupport : versionSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _PublishDiagnosticsClientCapabilities implements PublishDiagnosticsClientCapabilities {
  const _PublishDiagnosticsClientCapabilities({this.codeDescriptionSupport, this.dataSupport, this.relatedInformation, this.tagSupport, this.versionSupport});
  factory _PublishDiagnosticsClientCapabilities.fromJson(Map<String, dynamic> json) => _$PublishDiagnosticsClientCapabilitiesFromJson(json);

/// Client supports a codeDescription property
/// @since 3.16.0
@override final  bool? codeDescriptionSupport;
/// Whether code action supports the `data` property which is preserved
/// between a `textDocument/publishDiagnostics` and
/// `textDocument/codeAction` request.
/// @since 3.16.0
@override final  bool? dataSupport;
/// Whether the clients accepts diagnostics with related information.
@override final  bool? relatedInformation;
/// Client supports the tag property to provide meta data about a
/// diagnostic. Clients supporting tags have to handle unknown tags
/// gracefully.
/// @since 3.15.0
@override final  DiagnosticTagsValueSet? tagSupport;
/// Whether the client interprets the version property of the
/// `textDocument/publishDiagnostics` notification's parameter.
/// @since 3.15.0
@override final  bool? versionSupport;

/// Create a copy of PublishDiagnosticsClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$PublishDiagnosticsClientCapabilitiesCopyWith<_PublishDiagnosticsClientCapabilities> get copyWith => __$PublishDiagnosticsClientCapabilitiesCopyWithImpl<_PublishDiagnosticsClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$PublishDiagnosticsClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _PublishDiagnosticsClientCapabilities&&(identical(other.codeDescriptionSupport, codeDescriptionSupport) || other.codeDescriptionSupport == codeDescriptionSupport)&&(identical(other.dataSupport, dataSupport) || other.dataSupport == dataSupport)&&(identical(other.relatedInformation, relatedInformation) || other.relatedInformation == relatedInformation)&&const DeepCollectionEquality().equals(other.tagSupport, tagSupport)&&(identical(other.versionSupport, versionSupport) || other.versionSupport == versionSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,codeDescriptionSupport,dataSupport,relatedInformation,const DeepCollectionEquality().hash(tagSupport),versionSupport);

@override
String toString() {
  return 'PublishDiagnosticsClientCapabilities(codeDescriptionSupport: $codeDescriptionSupport, dataSupport: $dataSupport, relatedInformation: $relatedInformation, tagSupport: $tagSupport, versionSupport: $versionSupport)';
}


}

/// @nodoc
abstract mixin class _$PublishDiagnosticsClientCapabilitiesCopyWith<$Res> implements $PublishDiagnosticsClientCapabilitiesCopyWith<$Res> {
  factory _$PublishDiagnosticsClientCapabilitiesCopyWith(_PublishDiagnosticsClientCapabilities value, $Res Function(_PublishDiagnosticsClientCapabilities) _then) = __$PublishDiagnosticsClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? codeDescriptionSupport, bool? dataSupport, bool? relatedInformation, DiagnosticTagsValueSet? tagSupport, bool? versionSupport
});




}
/// @nodoc
class __$PublishDiagnosticsClientCapabilitiesCopyWithImpl<$Res>
    implements _$PublishDiagnosticsClientCapabilitiesCopyWith<$Res> {
  __$PublishDiagnosticsClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _PublishDiagnosticsClientCapabilities _self;
  final $Res Function(_PublishDiagnosticsClientCapabilities) _then;

/// Create a copy of PublishDiagnosticsClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? codeDescriptionSupport = freezed,Object? dataSupport = freezed,Object? relatedInformation = freezed,Object? tagSupport = freezed,Object? versionSupport = freezed,}) {
  return _then(_PublishDiagnosticsClientCapabilities(
codeDescriptionSupport: freezed == codeDescriptionSupport ? _self.codeDescriptionSupport : codeDescriptionSupport // ignore: cast_nullable_to_non_nullable
as bool?,dataSupport: freezed == dataSupport ? _self.dataSupport : dataSupport // ignore: cast_nullable_to_non_nullable
as bool?,relatedInformation: freezed == relatedInformation ? _self.relatedInformation : relatedInformation // ignore: cast_nullable_to_non_nullable
as bool?,tagSupport: freezed == tagSupport ? _self.tagSupport : tagSupport // ignore: cast_nullable_to_non_nullable
as DiagnosticTagsValueSet?,versionSupport: freezed == versionSupport ? _self.versionSupport : versionSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$CallHierarchyClientCapabilities {

/// Whether implementation supports dynamic registration. If this is set to
/// `true` the client supports the new `(TextDocumentRegistrationOptions &
/// StaticRegistrationOptions)` return value for the corresponding server
/// capability as well.
 bool? get dynamicRegistration;
/// Create a copy of CallHierarchyClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CallHierarchyClientCapabilitiesCopyWith<CallHierarchyClientCapabilities> get copyWith => _$CallHierarchyClientCapabilitiesCopyWithImpl<CallHierarchyClientCapabilities>(this as CallHierarchyClientCapabilities, _$identity);

  /// Serializes this CallHierarchyClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CallHierarchyClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'CallHierarchyClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $CallHierarchyClientCapabilitiesCopyWith<$Res>  {
  factory $CallHierarchyClientCapabilitiesCopyWith(CallHierarchyClientCapabilities value, $Res Function(CallHierarchyClientCapabilities) _then) = _$CallHierarchyClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class _$CallHierarchyClientCapabilitiesCopyWithImpl<$Res>
    implements $CallHierarchyClientCapabilitiesCopyWith<$Res> {
  _$CallHierarchyClientCapabilitiesCopyWithImpl(this._self, this._then);

  final CallHierarchyClientCapabilities _self;
  final $Res Function(CallHierarchyClientCapabilities) _then;

/// Create a copy of CallHierarchyClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _CallHierarchyClientCapabilities implements CallHierarchyClientCapabilities {
  const _CallHierarchyClientCapabilities({this.dynamicRegistration});
  factory _CallHierarchyClientCapabilities.fromJson(Map<String, dynamic> json) => _$CallHierarchyClientCapabilitiesFromJson(json);

/// Whether implementation supports dynamic registration. If this is set to
/// `true` the client supports the new `(TextDocumentRegistrationOptions &
/// StaticRegistrationOptions)` return value for the corresponding server
/// capability as well.
@override final  bool? dynamicRegistration;

/// Create a copy of CallHierarchyClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CallHierarchyClientCapabilitiesCopyWith<_CallHierarchyClientCapabilities> get copyWith => __$CallHierarchyClientCapabilitiesCopyWithImpl<_CallHierarchyClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$CallHierarchyClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CallHierarchyClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'CallHierarchyClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$CallHierarchyClientCapabilitiesCopyWith<$Res> implements $CallHierarchyClientCapabilitiesCopyWith<$Res> {
  factory _$CallHierarchyClientCapabilitiesCopyWith(_CallHierarchyClientCapabilities value, $Res Function(_CallHierarchyClientCapabilities) _then) = __$CallHierarchyClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class __$CallHierarchyClientCapabilitiesCopyWithImpl<$Res>
    implements _$CallHierarchyClientCapabilitiesCopyWith<$Res> {
  __$CallHierarchyClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _CallHierarchyClientCapabilities _self;
  final $Res Function(_CallHierarchyClientCapabilities) _then;

/// Create a copy of CallHierarchyClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_CallHierarchyClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$SemanticTokensClientCapabilities {

/// Whether the client uses semantic tokens to augment existing syntax
/// tokens. If set to `true` client side created syntax tokens and semantic
/// tokens are both used for colorization. If set to `false` the client
/// only uses the returned semantic tokens for colorization.
/// If the value is `undefined` then the client behavior is not specified.
/// @since 3.17.0
 bool? get augmentsSyntaxTokens;/// Whether implementation supports dynamic registration. If this is set to
/// `true` the client supports the new `(TextDocumentRegistrationOptions &
/// StaticRegistrationOptions)` return value for the corresponding server
/// capability as well.
 bool? get dynamicRegistration;/// The token formats the clients supports.
 List<TokenFormat> get formats;/// Whether the client supports tokens that can span multiple lines.
 bool? get multilineTokenSupport;/// Whether the client supports tokens that can overlap each other.
 bool? get overlappingTokenSupport;/// Which requests the client supports and might send to the server
/// depending on the server's capability. Please note that clients might
/// not show semantic tokens or degrade some of the user experience if a
/// range or full request is advertised by the client but not provided by
/// the server. If for example the client capability `requests.full` and
/// `request.range` are both set to true but the server only provides a
/// range provider the client might not render a minimap correctly or might
/// even decide to not show any semantic tokens at all.
 BoolOrBoolDeltaFullOrBoolRange get requests;/// Whether the client allows the server to actively cancel a semantic
/// token request, e.g. supports returning LSPErrorCodes.ServerCancelled.
/// If a server does the client needs to retrigger the request.
/// @since 3.17.0
 bool? get serverCancelSupport;/// The token modifiers that the client supports.
 List<String> get tokenModifiers;/// The token types that the client supports.
 List<String> get tokenTypes;
/// Create a copy of SemanticTokensClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$SemanticTokensClientCapabilitiesCopyWith<SemanticTokensClientCapabilities> get copyWith => _$SemanticTokensClientCapabilitiesCopyWithImpl<SemanticTokensClientCapabilities>(this as SemanticTokensClientCapabilities, _$identity);

  /// Serializes this SemanticTokensClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is SemanticTokensClientCapabilities&&(identical(other.augmentsSyntaxTokens, augmentsSyntaxTokens) || other.augmentsSyntaxTokens == augmentsSyntaxTokens)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&const DeepCollectionEquality().equals(other.formats, formats)&&(identical(other.multilineTokenSupport, multilineTokenSupport) || other.multilineTokenSupport == multilineTokenSupport)&&(identical(other.overlappingTokenSupport, overlappingTokenSupport) || other.overlappingTokenSupport == overlappingTokenSupport)&&(identical(other.requests, requests) || other.requests == requests)&&(identical(other.serverCancelSupport, serverCancelSupport) || other.serverCancelSupport == serverCancelSupport)&&const DeepCollectionEquality().equals(other.tokenModifiers, tokenModifiers)&&const DeepCollectionEquality().equals(other.tokenTypes, tokenTypes));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,augmentsSyntaxTokens,dynamicRegistration,const DeepCollectionEquality().hash(formats),multilineTokenSupport,overlappingTokenSupport,requests,serverCancelSupport,const DeepCollectionEquality().hash(tokenModifiers),const DeepCollectionEquality().hash(tokenTypes));

@override
String toString() {
  return 'SemanticTokensClientCapabilities(augmentsSyntaxTokens: $augmentsSyntaxTokens, dynamicRegistration: $dynamicRegistration, formats: $formats, multilineTokenSupport: $multilineTokenSupport, overlappingTokenSupport: $overlappingTokenSupport, requests: $requests, serverCancelSupport: $serverCancelSupport, tokenModifiers: $tokenModifiers, tokenTypes: $tokenTypes)';
}


}

/// @nodoc
abstract mixin class $SemanticTokensClientCapabilitiesCopyWith<$Res>  {
  factory $SemanticTokensClientCapabilitiesCopyWith(SemanticTokensClientCapabilities value, $Res Function(SemanticTokensClientCapabilities) _then) = _$SemanticTokensClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? augmentsSyntaxTokens, bool? dynamicRegistration, List<TokenFormat> formats, bool? multilineTokenSupport, bool? overlappingTokenSupport, BoolOrBoolDeltaFullOrBoolRange requests, bool? serverCancelSupport, List<String> tokenModifiers, List<String> tokenTypes
});




}
/// @nodoc
class _$SemanticTokensClientCapabilitiesCopyWithImpl<$Res>
    implements $SemanticTokensClientCapabilitiesCopyWith<$Res> {
  _$SemanticTokensClientCapabilitiesCopyWithImpl(this._self, this._then);

  final SemanticTokensClientCapabilities _self;
  final $Res Function(SemanticTokensClientCapabilities) _then;

/// Create a copy of SemanticTokensClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? augmentsSyntaxTokens = freezed,Object? dynamicRegistration = freezed,Object? formats = null,Object? multilineTokenSupport = freezed,Object? overlappingTokenSupport = freezed,Object? requests = null,Object? serverCancelSupport = freezed,Object? tokenModifiers = null,Object? tokenTypes = null,}) {
  return _then(_self.copyWith(
augmentsSyntaxTokens: freezed == augmentsSyntaxTokens ? _self.augmentsSyntaxTokens : augmentsSyntaxTokens // ignore: cast_nullable_to_non_nullable
as bool?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,formats: null == formats ? _self.formats : formats // ignore: cast_nullable_to_non_nullable
as List<TokenFormat>,multilineTokenSupport: freezed == multilineTokenSupport ? _self.multilineTokenSupport : multilineTokenSupport // ignore: cast_nullable_to_non_nullable
as bool?,overlappingTokenSupport: freezed == overlappingTokenSupport ? _self.overlappingTokenSupport : overlappingTokenSupport // ignore: cast_nullable_to_non_nullable
as bool?,requests: null == requests ? _self.requests : requests // ignore: cast_nullable_to_non_nullable
as BoolOrBoolDeltaFullOrBoolRange,serverCancelSupport: freezed == serverCancelSupport ? _self.serverCancelSupport : serverCancelSupport // ignore: cast_nullable_to_non_nullable
as bool?,tokenModifiers: null == tokenModifiers ? _self.tokenModifiers : tokenModifiers // ignore: cast_nullable_to_non_nullable
as List<String>,tokenTypes: null == tokenTypes ? _self.tokenTypes : tokenTypes // ignore: cast_nullable_to_non_nullable
as List<String>,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _SemanticTokensClientCapabilities implements SemanticTokensClientCapabilities {
  const _SemanticTokensClientCapabilities({this.augmentsSyntaxTokens, this.dynamicRegistration, required final  List<TokenFormat> formats, this.multilineTokenSupport, this.overlappingTokenSupport, required this.requests, this.serverCancelSupport, required final  List<String> tokenModifiers, required final  List<String> tokenTypes}): _formats = formats,_tokenModifiers = tokenModifiers,_tokenTypes = tokenTypes;
  factory _SemanticTokensClientCapabilities.fromJson(Map<String, dynamic> json) => _$SemanticTokensClientCapabilitiesFromJson(json);

/// Whether the client uses semantic tokens to augment existing syntax
/// tokens. If set to `true` client side created syntax tokens and semantic
/// tokens are both used for colorization. If set to `false` the client
/// only uses the returned semantic tokens for colorization.
/// If the value is `undefined` then the client behavior is not specified.
/// @since 3.17.0
@override final  bool? augmentsSyntaxTokens;
/// Whether implementation supports dynamic registration. If this is set to
/// `true` the client supports the new `(TextDocumentRegistrationOptions &
/// StaticRegistrationOptions)` return value for the corresponding server
/// capability as well.
@override final  bool? dynamicRegistration;
/// The token formats the clients supports.
 final  List<TokenFormat> _formats;
/// The token formats the clients supports.
@override List<TokenFormat> get formats {
  if (_formats is EqualUnmodifiableListView) return _formats;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_formats);
}

/// Whether the client supports tokens that can span multiple lines.
@override final  bool? multilineTokenSupport;
/// Whether the client supports tokens that can overlap each other.
@override final  bool? overlappingTokenSupport;
/// Which requests the client supports and might send to the server
/// depending on the server's capability. Please note that clients might
/// not show semantic tokens or degrade some of the user experience if a
/// range or full request is advertised by the client but not provided by
/// the server. If for example the client capability `requests.full` and
/// `request.range` are both set to true but the server only provides a
/// range provider the client might not render a minimap correctly or might
/// even decide to not show any semantic tokens at all.
@override final  BoolOrBoolDeltaFullOrBoolRange requests;
/// Whether the client allows the server to actively cancel a semantic
/// token request, e.g. supports returning LSPErrorCodes.ServerCancelled.
/// If a server does the client needs to retrigger the request.
/// @since 3.17.0
@override final  bool? serverCancelSupport;
/// The token modifiers that the client supports.
 final  List<String> _tokenModifiers;
/// The token modifiers that the client supports.
@override List<String> get tokenModifiers {
  if (_tokenModifiers is EqualUnmodifiableListView) return _tokenModifiers;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_tokenModifiers);
}

/// The token types that the client supports.
 final  List<String> _tokenTypes;
/// The token types that the client supports.
@override List<String> get tokenTypes {
  if (_tokenTypes is EqualUnmodifiableListView) return _tokenTypes;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_tokenTypes);
}


/// Create a copy of SemanticTokensClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$SemanticTokensClientCapabilitiesCopyWith<_SemanticTokensClientCapabilities> get copyWith => __$SemanticTokensClientCapabilitiesCopyWithImpl<_SemanticTokensClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$SemanticTokensClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _SemanticTokensClientCapabilities&&(identical(other.augmentsSyntaxTokens, augmentsSyntaxTokens) || other.augmentsSyntaxTokens == augmentsSyntaxTokens)&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&const DeepCollectionEquality().equals(other._formats, _formats)&&(identical(other.multilineTokenSupport, multilineTokenSupport) || other.multilineTokenSupport == multilineTokenSupport)&&(identical(other.overlappingTokenSupport, overlappingTokenSupport) || other.overlappingTokenSupport == overlappingTokenSupport)&&(identical(other.requests, requests) || other.requests == requests)&&(identical(other.serverCancelSupport, serverCancelSupport) || other.serverCancelSupport == serverCancelSupport)&&const DeepCollectionEquality().equals(other._tokenModifiers, _tokenModifiers)&&const DeepCollectionEquality().equals(other._tokenTypes, _tokenTypes));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,augmentsSyntaxTokens,dynamicRegistration,const DeepCollectionEquality().hash(_formats),multilineTokenSupport,overlappingTokenSupport,requests,serverCancelSupport,const DeepCollectionEquality().hash(_tokenModifiers),const DeepCollectionEquality().hash(_tokenTypes));

@override
String toString() {
  return 'SemanticTokensClientCapabilities(augmentsSyntaxTokens: $augmentsSyntaxTokens, dynamicRegistration: $dynamicRegistration, formats: $formats, multilineTokenSupport: $multilineTokenSupport, overlappingTokenSupport: $overlappingTokenSupport, requests: $requests, serverCancelSupport: $serverCancelSupport, tokenModifiers: $tokenModifiers, tokenTypes: $tokenTypes)';
}


}

/// @nodoc
abstract mixin class _$SemanticTokensClientCapabilitiesCopyWith<$Res> implements $SemanticTokensClientCapabilitiesCopyWith<$Res> {
  factory _$SemanticTokensClientCapabilitiesCopyWith(_SemanticTokensClientCapabilities value, $Res Function(_SemanticTokensClientCapabilities) _then) = __$SemanticTokensClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? augmentsSyntaxTokens, bool? dynamicRegistration, List<TokenFormat> formats, bool? multilineTokenSupport, bool? overlappingTokenSupport, BoolOrBoolDeltaFullOrBoolRange requests, bool? serverCancelSupport, List<String> tokenModifiers, List<String> tokenTypes
});




}
/// @nodoc
class __$SemanticTokensClientCapabilitiesCopyWithImpl<$Res>
    implements _$SemanticTokensClientCapabilitiesCopyWith<$Res> {
  __$SemanticTokensClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _SemanticTokensClientCapabilities _self;
  final $Res Function(_SemanticTokensClientCapabilities) _then;

/// Create a copy of SemanticTokensClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? augmentsSyntaxTokens = freezed,Object? dynamicRegistration = freezed,Object? formats = null,Object? multilineTokenSupport = freezed,Object? overlappingTokenSupport = freezed,Object? requests = null,Object? serverCancelSupport = freezed,Object? tokenModifiers = null,Object? tokenTypes = null,}) {
  return _then(_SemanticTokensClientCapabilities(
augmentsSyntaxTokens: freezed == augmentsSyntaxTokens ? _self.augmentsSyntaxTokens : augmentsSyntaxTokens // ignore: cast_nullable_to_non_nullable
as bool?,dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,formats: null == formats ? _self._formats : formats // ignore: cast_nullable_to_non_nullable
as List<TokenFormat>,multilineTokenSupport: freezed == multilineTokenSupport ? _self.multilineTokenSupport : multilineTokenSupport // ignore: cast_nullable_to_non_nullable
as bool?,overlappingTokenSupport: freezed == overlappingTokenSupport ? _self.overlappingTokenSupport : overlappingTokenSupport // ignore: cast_nullable_to_non_nullable
as bool?,requests: null == requests ? _self.requests : requests // ignore: cast_nullable_to_non_nullable
as BoolOrBoolDeltaFullOrBoolRange,serverCancelSupport: freezed == serverCancelSupport ? _self.serverCancelSupport : serverCancelSupport // ignore: cast_nullable_to_non_nullable
as bool?,tokenModifiers: null == tokenModifiers ? _self._tokenModifiers : tokenModifiers // ignore: cast_nullable_to_non_nullable
as List<String>,tokenTypes: null == tokenTypes ? _self._tokenTypes : tokenTypes // ignore: cast_nullable_to_non_nullable
as List<String>,
  ));
}


}


/// @nodoc
mixin _$LinkedEditingRangeClientCapabilities {

/// Whether implementation supports dynamic registration. If this is set to
/// `true` the client supports the new `(TextDocumentRegistrationOptions &
/// StaticRegistrationOptions)` return value for the corresponding server
/// capability as well.
 bool? get dynamicRegistration;
/// Create a copy of LinkedEditingRangeClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$LinkedEditingRangeClientCapabilitiesCopyWith<LinkedEditingRangeClientCapabilities> get copyWith => _$LinkedEditingRangeClientCapabilitiesCopyWithImpl<LinkedEditingRangeClientCapabilities>(this as LinkedEditingRangeClientCapabilities, _$identity);

  /// Serializes this LinkedEditingRangeClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is LinkedEditingRangeClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'LinkedEditingRangeClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $LinkedEditingRangeClientCapabilitiesCopyWith<$Res>  {
  factory $LinkedEditingRangeClientCapabilitiesCopyWith(LinkedEditingRangeClientCapabilities value, $Res Function(LinkedEditingRangeClientCapabilities) _then) = _$LinkedEditingRangeClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class _$LinkedEditingRangeClientCapabilitiesCopyWithImpl<$Res>
    implements $LinkedEditingRangeClientCapabilitiesCopyWith<$Res> {
  _$LinkedEditingRangeClientCapabilitiesCopyWithImpl(this._self, this._then);

  final LinkedEditingRangeClientCapabilities _self;
  final $Res Function(LinkedEditingRangeClientCapabilities) _then;

/// Create a copy of LinkedEditingRangeClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _LinkedEditingRangeClientCapabilities implements LinkedEditingRangeClientCapabilities {
  const _LinkedEditingRangeClientCapabilities({this.dynamicRegistration});
  factory _LinkedEditingRangeClientCapabilities.fromJson(Map<String, dynamic> json) => _$LinkedEditingRangeClientCapabilitiesFromJson(json);

/// Whether implementation supports dynamic registration. If this is set to
/// `true` the client supports the new `(TextDocumentRegistrationOptions &
/// StaticRegistrationOptions)` return value for the corresponding server
/// capability as well.
@override final  bool? dynamicRegistration;

/// Create a copy of LinkedEditingRangeClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$LinkedEditingRangeClientCapabilitiesCopyWith<_LinkedEditingRangeClientCapabilities> get copyWith => __$LinkedEditingRangeClientCapabilitiesCopyWithImpl<_LinkedEditingRangeClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$LinkedEditingRangeClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _LinkedEditingRangeClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'LinkedEditingRangeClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$LinkedEditingRangeClientCapabilitiesCopyWith<$Res> implements $LinkedEditingRangeClientCapabilitiesCopyWith<$Res> {
  factory _$LinkedEditingRangeClientCapabilitiesCopyWith(_LinkedEditingRangeClientCapabilities value, $Res Function(_LinkedEditingRangeClientCapabilities) _then) = __$LinkedEditingRangeClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class __$LinkedEditingRangeClientCapabilitiesCopyWithImpl<$Res>
    implements _$LinkedEditingRangeClientCapabilitiesCopyWith<$Res> {
  __$LinkedEditingRangeClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _LinkedEditingRangeClientCapabilities _self;
  final $Res Function(_LinkedEditingRangeClientCapabilities) _then;

/// Create a copy of LinkedEditingRangeClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_LinkedEditingRangeClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$MonikerClientCapabilities {

/// Whether moniker supports dynamic registration. If this is set to `true`
/// the client supports the new `MonikerRegistrationOptions` return value
/// for the corresponding server capability as well.
 bool? get dynamicRegistration;
/// Create a copy of MonikerClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$MonikerClientCapabilitiesCopyWith<MonikerClientCapabilities> get copyWith => _$MonikerClientCapabilitiesCopyWithImpl<MonikerClientCapabilities>(this as MonikerClientCapabilities, _$identity);

  /// Serializes this MonikerClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is MonikerClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'MonikerClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $MonikerClientCapabilitiesCopyWith<$Res>  {
  factory $MonikerClientCapabilitiesCopyWith(MonikerClientCapabilities value, $Res Function(MonikerClientCapabilities) _then) = _$MonikerClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class _$MonikerClientCapabilitiesCopyWithImpl<$Res>
    implements $MonikerClientCapabilitiesCopyWith<$Res> {
  _$MonikerClientCapabilitiesCopyWithImpl(this._self, this._then);

  final MonikerClientCapabilities _self;
  final $Res Function(MonikerClientCapabilities) _then;

/// Create a copy of MonikerClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _MonikerClientCapabilities implements MonikerClientCapabilities {
  const _MonikerClientCapabilities({this.dynamicRegistration});
  factory _MonikerClientCapabilities.fromJson(Map<String, dynamic> json) => _$MonikerClientCapabilitiesFromJson(json);

/// Whether moniker supports dynamic registration. If this is set to `true`
/// the client supports the new `MonikerRegistrationOptions` return value
/// for the corresponding server capability as well.
@override final  bool? dynamicRegistration;

/// Create a copy of MonikerClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$MonikerClientCapabilitiesCopyWith<_MonikerClientCapabilities> get copyWith => __$MonikerClientCapabilitiesCopyWithImpl<_MonikerClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$MonikerClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _MonikerClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'MonikerClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$MonikerClientCapabilitiesCopyWith<$Res> implements $MonikerClientCapabilitiesCopyWith<$Res> {
  factory _$MonikerClientCapabilitiesCopyWith(_MonikerClientCapabilities value, $Res Function(_MonikerClientCapabilities) _then) = __$MonikerClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class __$MonikerClientCapabilitiesCopyWithImpl<$Res>
    implements _$MonikerClientCapabilitiesCopyWith<$Res> {
  __$MonikerClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _MonikerClientCapabilities _self;
  final $Res Function(_MonikerClientCapabilities) _then;

/// Create a copy of MonikerClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_MonikerClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$TypeHierarchyClientCapabilities {

/// Whether implementation supports dynamic registration. If this is set to
/// `true` the client supports the new `(TextDocumentRegistrationOptions &
/// StaticRegistrationOptions)` return value for the corresponding server
/// capability as well.
 bool? get dynamicRegistration;
/// Create a copy of TypeHierarchyClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$TypeHierarchyClientCapabilitiesCopyWith<TypeHierarchyClientCapabilities> get copyWith => _$TypeHierarchyClientCapabilitiesCopyWithImpl<TypeHierarchyClientCapabilities>(this as TypeHierarchyClientCapabilities, _$identity);

  /// Serializes this TypeHierarchyClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is TypeHierarchyClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'TypeHierarchyClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $TypeHierarchyClientCapabilitiesCopyWith<$Res>  {
  factory $TypeHierarchyClientCapabilitiesCopyWith(TypeHierarchyClientCapabilities value, $Res Function(TypeHierarchyClientCapabilities) _then) = _$TypeHierarchyClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class _$TypeHierarchyClientCapabilitiesCopyWithImpl<$Res>
    implements $TypeHierarchyClientCapabilitiesCopyWith<$Res> {
  _$TypeHierarchyClientCapabilitiesCopyWithImpl(this._self, this._then);

  final TypeHierarchyClientCapabilities _self;
  final $Res Function(TypeHierarchyClientCapabilities) _then;

/// Create a copy of TypeHierarchyClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _TypeHierarchyClientCapabilities implements TypeHierarchyClientCapabilities {
  const _TypeHierarchyClientCapabilities({this.dynamicRegistration});
  factory _TypeHierarchyClientCapabilities.fromJson(Map<String, dynamic> json) => _$TypeHierarchyClientCapabilitiesFromJson(json);

/// Whether implementation supports dynamic registration. If this is set to
/// `true` the client supports the new `(TextDocumentRegistrationOptions &
/// StaticRegistrationOptions)` return value for the corresponding server
/// capability as well.
@override final  bool? dynamicRegistration;

/// Create a copy of TypeHierarchyClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$TypeHierarchyClientCapabilitiesCopyWith<_TypeHierarchyClientCapabilities> get copyWith => __$TypeHierarchyClientCapabilitiesCopyWithImpl<_TypeHierarchyClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$TypeHierarchyClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _TypeHierarchyClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'TypeHierarchyClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$TypeHierarchyClientCapabilitiesCopyWith<$Res> implements $TypeHierarchyClientCapabilitiesCopyWith<$Res> {
  factory _$TypeHierarchyClientCapabilitiesCopyWith(_TypeHierarchyClientCapabilities value, $Res Function(_TypeHierarchyClientCapabilities) _then) = __$TypeHierarchyClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class __$TypeHierarchyClientCapabilitiesCopyWithImpl<$Res>
    implements _$TypeHierarchyClientCapabilitiesCopyWith<$Res> {
  __$TypeHierarchyClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _TypeHierarchyClientCapabilities _self;
  final $Res Function(_TypeHierarchyClientCapabilities) _then;

/// Create a copy of TypeHierarchyClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_TypeHierarchyClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$InlineValueClientCapabilities {

/// Whether implementation supports dynamic registration for inline value
/// providers.
 bool? get dynamicRegistration;
/// Create a copy of InlineValueClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlineValueClientCapabilitiesCopyWith<InlineValueClientCapabilities> get copyWith => _$InlineValueClientCapabilitiesCopyWithImpl<InlineValueClientCapabilities>(this as InlineValueClientCapabilities, _$identity);

  /// Serializes this InlineValueClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlineValueClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'InlineValueClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $InlineValueClientCapabilitiesCopyWith<$Res>  {
  factory $InlineValueClientCapabilitiesCopyWith(InlineValueClientCapabilities value, $Res Function(InlineValueClientCapabilities) _then) = _$InlineValueClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class _$InlineValueClientCapabilitiesCopyWithImpl<$Res>
    implements $InlineValueClientCapabilitiesCopyWith<$Res> {
  _$InlineValueClientCapabilitiesCopyWithImpl(this._self, this._then);

  final InlineValueClientCapabilities _self;
  final $Res Function(InlineValueClientCapabilities) _then;

/// Create a copy of InlineValueClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _InlineValueClientCapabilities implements InlineValueClientCapabilities {
  const _InlineValueClientCapabilities({this.dynamicRegistration});
  factory _InlineValueClientCapabilities.fromJson(Map<String, dynamic> json) => _$InlineValueClientCapabilitiesFromJson(json);

/// Whether implementation supports dynamic registration for inline value
/// providers.
@override final  bool? dynamicRegistration;

/// Create a copy of InlineValueClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlineValueClientCapabilitiesCopyWith<_InlineValueClientCapabilities> get copyWith => __$InlineValueClientCapabilitiesCopyWithImpl<_InlineValueClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlineValueClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlineValueClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'InlineValueClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$InlineValueClientCapabilitiesCopyWith<$Res> implements $InlineValueClientCapabilitiesCopyWith<$Res> {
  factory _$InlineValueClientCapabilitiesCopyWith(_InlineValueClientCapabilities value, $Res Function(_InlineValueClientCapabilities) _then) = __$InlineValueClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class __$InlineValueClientCapabilitiesCopyWithImpl<$Res>
    implements _$InlineValueClientCapabilitiesCopyWith<$Res> {
  __$InlineValueClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _InlineValueClientCapabilities _self;
  final $Res Function(_InlineValueClientCapabilities) _then;

/// Create a copy of InlineValueClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_InlineValueClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$InlayHintClientCapabilities {

/// Whether inlay hints support dynamic registration.
 bool? get dynamicRegistration;/// Indicates which properties a client can resolve lazily on an inlay hint.
 StringsProperties? get resolveSupport;
/// Create a copy of InlayHintClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlayHintClientCapabilitiesCopyWith<InlayHintClientCapabilities> get copyWith => _$InlayHintClientCapabilitiesCopyWithImpl<InlayHintClientCapabilities>(this as InlayHintClientCapabilities, _$identity);

  /// Serializes this InlayHintClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlayHintClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&const DeepCollectionEquality().equals(other.resolveSupport, resolveSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration,const DeepCollectionEquality().hash(resolveSupport));

@override
String toString() {
  return 'InlayHintClientCapabilities(dynamicRegistration: $dynamicRegistration, resolveSupport: $resolveSupport)';
}


}

/// @nodoc
abstract mixin class $InlayHintClientCapabilitiesCopyWith<$Res>  {
  factory $InlayHintClientCapabilitiesCopyWith(InlayHintClientCapabilities value, $Res Function(InlayHintClientCapabilities) _then) = _$InlayHintClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration, StringsProperties? resolveSupport
});




}
/// @nodoc
class _$InlayHintClientCapabilitiesCopyWithImpl<$Res>
    implements $InlayHintClientCapabilitiesCopyWith<$Res> {
  _$InlayHintClientCapabilitiesCopyWithImpl(this._self, this._then);

  final InlayHintClientCapabilities _self;
  final $Res Function(InlayHintClientCapabilities) _then;

/// Create a copy of InlayHintClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,Object? resolveSupport = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,resolveSupport: freezed == resolveSupport ? _self.resolveSupport : resolveSupport // ignore: cast_nullable_to_non_nullable
as StringsProperties?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _InlayHintClientCapabilities implements InlayHintClientCapabilities {
  const _InlayHintClientCapabilities({this.dynamicRegistration, this.resolveSupport});
  factory _InlayHintClientCapabilities.fromJson(Map<String, dynamic> json) => _$InlayHintClientCapabilitiesFromJson(json);

/// Whether inlay hints support dynamic registration.
@override final  bool? dynamicRegistration;
/// Indicates which properties a client can resolve lazily on an inlay hint.
@override final  StringsProperties? resolveSupport;

/// Create a copy of InlayHintClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlayHintClientCapabilitiesCopyWith<_InlayHintClientCapabilities> get copyWith => __$InlayHintClientCapabilitiesCopyWithImpl<_InlayHintClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlayHintClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlayHintClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&const DeepCollectionEquality().equals(other.resolveSupport, resolveSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration,const DeepCollectionEquality().hash(resolveSupport));

@override
String toString() {
  return 'InlayHintClientCapabilities(dynamicRegistration: $dynamicRegistration, resolveSupport: $resolveSupport)';
}


}

/// @nodoc
abstract mixin class _$InlayHintClientCapabilitiesCopyWith<$Res> implements $InlayHintClientCapabilitiesCopyWith<$Res> {
  factory _$InlayHintClientCapabilitiesCopyWith(_InlayHintClientCapabilities value, $Res Function(_InlayHintClientCapabilities) _then) = __$InlayHintClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration, StringsProperties? resolveSupport
});




}
/// @nodoc
class __$InlayHintClientCapabilitiesCopyWithImpl<$Res>
    implements _$InlayHintClientCapabilitiesCopyWith<$Res> {
  __$InlayHintClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _InlayHintClientCapabilities _self;
  final $Res Function(_InlayHintClientCapabilities) _then;

/// Create a copy of InlayHintClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,Object? resolveSupport = freezed,}) {
  return _then(_InlayHintClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,resolveSupport: freezed == resolveSupport ? _self.resolveSupport : resolveSupport // ignore: cast_nullable_to_non_nullable
as StringsProperties?,
  ));
}


}


/// @nodoc
mixin _$DiagnosticClientCapabilities {

/// Whether implementation supports dynamic registration. If this is set to
/// `true` the client supports the new `(TextDocumentRegistrationOptions &
/// StaticRegistrationOptions)` return value for the corresponding server
/// capability as well.
 bool? get dynamicRegistration;/// Whether the clients supports related documents for document diagnostic
/// pulls.
 bool? get relatedDocumentSupport;
/// Create a copy of DiagnosticClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$DiagnosticClientCapabilitiesCopyWith<DiagnosticClientCapabilities> get copyWith => _$DiagnosticClientCapabilitiesCopyWithImpl<DiagnosticClientCapabilities>(this as DiagnosticClientCapabilities, _$identity);

  /// Serializes this DiagnosticClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is DiagnosticClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&(identical(other.relatedDocumentSupport, relatedDocumentSupport) || other.relatedDocumentSupport == relatedDocumentSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration,relatedDocumentSupport);

@override
String toString() {
  return 'DiagnosticClientCapabilities(dynamicRegistration: $dynamicRegistration, relatedDocumentSupport: $relatedDocumentSupport)';
}


}

/// @nodoc
abstract mixin class $DiagnosticClientCapabilitiesCopyWith<$Res>  {
  factory $DiagnosticClientCapabilitiesCopyWith(DiagnosticClientCapabilities value, $Res Function(DiagnosticClientCapabilities) _then) = _$DiagnosticClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration, bool? relatedDocumentSupport
});




}
/// @nodoc
class _$DiagnosticClientCapabilitiesCopyWithImpl<$Res>
    implements $DiagnosticClientCapabilitiesCopyWith<$Res> {
  _$DiagnosticClientCapabilitiesCopyWithImpl(this._self, this._then);

  final DiagnosticClientCapabilities _self;
  final $Res Function(DiagnosticClientCapabilities) _then;

/// Create a copy of DiagnosticClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,Object? relatedDocumentSupport = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,relatedDocumentSupport: freezed == relatedDocumentSupport ? _self.relatedDocumentSupport : relatedDocumentSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _DiagnosticClientCapabilities implements DiagnosticClientCapabilities {
  const _DiagnosticClientCapabilities({this.dynamicRegistration, this.relatedDocumentSupport});
  factory _DiagnosticClientCapabilities.fromJson(Map<String, dynamic> json) => _$DiagnosticClientCapabilitiesFromJson(json);

/// Whether implementation supports dynamic registration. If this is set to
/// `true` the client supports the new `(TextDocumentRegistrationOptions &
/// StaticRegistrationOptions)` return value for the corresponding server
/// capability as well.
@override final  bool? dynamicRegistration;
/// Whether the clients supports related documents for document diagnostic
/// pulls.
@override final  bool? relatedDocumentSupport;

/// Create a copy of DiagnosticClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$DiagnosticClientCapabilitiesCopyWith<_DiagnosticClientCapabilities> get copyWith => __$DiagnosticClientCapabilitiesCopyWithImpl<_DiagnosticClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$DiagnosticClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _DiagnosticClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&(identical(other.relatedDocumentSupport, relatedDocumentSupport) || other.relatedDocumentSupport == relatedDocumentSupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration,relatedDocumentSupport);

@override
String toString() {
  return 'DiagnosticClientCapabilities(dynamicRegistration: $dynamicRegistration, relatedDocumentSupport: $relatedDocumentSupport)';
}


}

/// @nodoc
abstract mixin class _$DiagnosticClientCapabilitiesCopyWith<$Res> implements $DiagnosticClientCapabilitiesCopyWith<$Res> {
  factory _$DiagnosticClientCapabilitiesCopyWith(_DiagnosticClientCapabilities value, $Res Function(_DiagnosticClientCapabilities) _then) = __$DiagnosticClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration, bool? relatedDocumentSupport
});




}
/// @nodoc
class __$DiagnosticClientCapabilitiesCopyWithImpl<$Res>
    implements _$DiagnosticClientCapabilitiesCopyWith<$Res> {
  __$DiagnosticClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _DiagnosticClientCapabilities _self;
  final $Res Function(_DiagnosticClientCapabilities) _then;

/// Create a copy of DiagnosticClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,Object? relatedDocumentSupport = freezed,}) {
  return _then(_DiagnosticClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,relatedDocumentSupport: freezed == relatedDocumentSupport ? _self.relatedDocumentSupport : relatedDocumentSupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$InlineCompletionClientCapabilities {

/// Whether implementation supports dynamic registration for inline
/// completion providers.
 bool? get dynamicRegistration;
/// Create a copy of InlineCompletionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$InlineCompletionClientCapabilitiesCopyWith<InlineCompletionClientCapabilities> get copyWith => _$InlineCompletionClientCapabilitiesCopyWithImpl<InlineCompletionClientCapabilities>(this as InlineCompletionClientCapabilities, _$identity);

  /// Serializes this InlineCompletionClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is InlineCompletionClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'InlineCompletionClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class $InlineCompletionClientCapabilitiesCopyWith<$Res>  {
  factory $InlineCompletionClientCapabilitiesCopyWith(InlineCompletionClientCapabilities value, $Res Function(InlineCompletionClientCapabilities) _then) = _$InlineCompletionClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class _$InlineCompletionClientCapabilitiesCopyWithImpl<$Res>
    implements $InlineCompletionClientCapabilitiesCopyWith<$Res> {
  _$InlineCompletionClientCapabilitiesCopyWithImpl(this._self, this._then);

  final InlineCompletionClientCapabilities _self;
  final $Res Function(InlineCompletionClientCapabilities) _then;

/// Create a copy of InlineCompletionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _InlineCompletionClientCapabilities implements InlineCompletionClientCapabilities {
  const _InlineCompletionClientCapabilities({this.dynamicRegistration});
  factory _InlineCompletionClientCapabilities.fromJson(Map<String, dynamic> json) => _$InlineCompletionClientCapabilitiesFromJson(json);

/// Whether implementation supports dynamic registration for inline
/// completion providers.
@override final  bool? dynamicRegistration;

/// Create a copy of InlineCompletionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$InlineCompletionClientCapabilitiesCopyWith<_InlineCompletionClientCapabilities> get copyWith => __$InlineCompletionClientCapabilitiesCopyWithImpl<_InlineCompletionClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$InlineCompletionClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _InlineCompletionClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration);

@override
String toString() {
  return 'InlineCompletionClientCapabilities(dynamicRegistration: $dynamicRegistration)';
}


}

/// @nodoc
abstract mixin class _$InlineCompletionClientCapabilitiesCopyWith<$Res> implements $InlineCompletionClientCapabilitiesCopyWith<$Res> {
  factory _$InlineCompletionClientCapabilitiesCopyWith(_InlineCompletionClientCapabilities value, $Res Function(_InlineCompletionClientCapabilities) _then) = __$InlineCompletionClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration
});




}
/// @nodoc
class __$InlineCompletionClientCapabilitiesCopyWithImpl<$Res>
    implements _$InlineCompletionClientCapabilitiesCopyWith<$Res> {
  __$InlineCompletionClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _InlineCompletionClientCapabilities _self;
  final $Res Function(_InlineCompletionClientCapabilities) _then;

/// Create a copy of InlineCompletionClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,}) {
  return _then(_InlineCompletionClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$NotebookDocumentSyncClientCapabilities {

/// Whether implementation supports dynamic registration. If this is set to
/// `true` the client supports the new `(TextDocumentRegistrationOptions &
/// StaticRegistrationOptions)` return value for the corresponding server
/// capability as well.
 bool? get dynamicRegistration;/// The client supports sending execution summary data per cell.
 bool? get executionSummarySupport;
/// Create a copy of NotebookDocumentSyncClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$NotebookDocumentSyncClientCapabilitiesCopyWith<NotebookDocumentSyncClientCapabilities> get copyWith => _$NotebookDocumentSyncClientCapabilitiesCopyWithImpl<NotebookDocumentSyncClientCapabilities>(this as NotebookDocumentSyncClientCapabilities, _$identity);

  /// Serializes this NotebookDocumentSyncClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is NotebookDocumentSyncClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&(identical(other.executionSummarySupport, executionSummarySupport) || other.executionSummarySupport == executionSummarySupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration,executionSummarySupport);

@override
String toString() {
  return 'NotebookDocumentSyncClientCapabilities(dynamicRegistration: $dynamicRegistration, executionSummarySupport: $executionSummarySupport)';
}


}

/// @nodoc
abstract mixin class $NotebookDocumentSyncClientCapabilitiesCopyWith<$Res>  {
  factory $NotebookDocumentSyncClientCapabilitiesCopyWith(NotebookDocumentSyncClientCapabilities value, $Res Function(NotebookDocumentSyncClientCapabilities) _then) = _$NotebookDocumentSyncClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool? dynamicRegistration, bool? executionSummarySupport
});




}
/// @nodoc
class _$NotebookDocumentSyncClientCapabilitiesCopyWithImpl<$Res>
    implements $NotebookDocumentSyncClientCapabilitiesCopyWith<$Res> {
  _$NotebookDocumentSyncClientCapabilitiesCopyWithImpl(this._self, this._then);

  final NotebookDocumentSyncClientCapabilities _self;
  final $Res Function(NotebookDocumentSyncClientCapabilities) _then;

/// Create a copy of NotebookDocumentSyncClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? dynamicRegistration = freezed,Object? executionSummarySupport = freezed,}) {
  return _then(_self.copyWith(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,executionSummarySupport: freezed == executionSummarySupport ? _self.executionSummarySupport : executionSummarySupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _NotebookDocumentSyncClientCapabilities implements NotebookDocumentSyncClientCapabilities {
  const _NotebookDocumentSyncClientCapabilities({this.dynamicRegistration, this.executionSummarySupport});
  factory _NotebookDocumentSyncClientCapabilities.fromJson(Map<String, dynamic> json) => _$NotebookDocumentSyncClientCapabilitiesFromJson(json);

/// Whether implementation supports dynamic registration. If this is set to
/// `true` the client supports the new `(TextDocumentRegistrationOptions &
/// StaticRegistrationOptions)` return value for the corresponding server
/// capability as well.
@override final  bool? dynamicRegistration;
/// The client supports sending execution summary data per cell.
@override final  bool? executionSummarySupport;

/// Create a copy of NotebookDocumentSyncClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$NotebookDocumentSyncClientCapabilitiesCopyWith<_NotebookDocumentSyncClientCapabilities> get copyWith => __$NotebookDocumentSyncClientCapabilitiesCopyWithImpl<_NotebookDocumentSyncClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$NotebookDocumentSyncClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _NotebookDocumentSyncClientCapabilities&&(identical(other.dynamicRegistration, dynamicRegistration) || other.dynamicRegistration == dynamicRegistration)&&(identical(other.executionSummarySupport, executionSummarySupport) || other.executionSummarySupport == executionSummarySupport));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,dynamicRegistration,executionSummarySupport);

@override
String toString() {
  return 'NotebookDocumentSyncClientCapabilities(dynamicRegistration: $dynamicRegistration, executionSummarySupport: $executionSummarySupport)';
}


}

/// @nodoc
abstract mixin class _$NotebookDocumentSyncClientCapabilitiesCopyWith<$Res> implements $NotebookDocumentSyncClientCapabilitiesCopyWith<$Res> {
  factory _$NotebookDocumentSyncClientCapabilitiesCopyWith(_NotebookDocumentSyncClientCapabilities value, $Res Function(_NotebookDocumentSyncClientCapabilities) _then) = __$NotebookDocumentSyncClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool? dynamicRegistration, bool? executionSummarySupport
});




}
/// @nodoc
class __$NotebookDocumentSyncClientCapabilitiesCopyWithImpl<$Res>
    implements _$NotebookDocumentSyncClientCapabilitiesCopyWith<$Res> {
  __$NotebookDocumentSyncClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _NotebookDocumentSyncClientCapabilities _self;
  final $Res Function(_NotebookDocumentSyncClientCapabilities) _then;

/// Create a copy of NotebookDocumentSyncClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? dynamicRegistration = freezed,Object? executionSummarySupport = freezed,}) {
  return _then(_NotebookDocumentSyncClientCapabilities(
dynamicRegistration: freezed == dynamicRegistration ? _self.dynamicRegistration : dynamicRegistration // ignore: cast_nullable_to_non_nullable
as bool?,executionSummarySupport: freezed == executionSummarySupport ? _self.executionSummarySupport : executionSummarySupport // ignore: cast_nullable_to_non_nullable
as bool?,
  ));
}


}


/// @nodoc
mixin _$ShowMessageRequestClientCapabilities {

/// Capabilities specific to the `MessageActionItem` type.
 BoolAdditionalPropertiesSupport? get messageActionItem;
/// Create a copy of ShowMessageRequestClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ShowMessageRequestClientCapabilitiesCopyWith<ShowMessageRequestClientCapabilities> get copyWith => _$ShowMessageRequestClientCapabilitiesCopyWithImpl<ShowMessageRequestClientCapabilities>(this as ShowMessageRequestClientCapabilities, _$identity);

  /// Serializes this ShowMessageRequestClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ShowMessageRequestClientCapabilities&&const DeepCollectionEquality().equals(other.messageActionItem, messageActionItem));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(messageActionItem));

@override
String toString() {
  return 'ShowMessageRequestClientCapabilities(messageActionItem: $messageActionItem)';
}


}

/// @nodoc
abstract mixin class $ShowMessageRequestClientCapabilitiesCopyWith<$Res>  {
  factory $ShowMessageRequestClientCapabilitiesCopyWith(ShowMessageRequestClientCapabilities value, $Res Function(ShowMessageRequestClientCapabilities) _then) = _$ShowMessageRequestClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 BoolAdditionalPropertiesSupport? messageActionItem
});




}
/// @nodoc
class _$ShowMessageRequestClientCapabilitiesCopyWithImpl<$Res>
    implements $ShowMessageRequestClientCapabilitiesCopyWith<$Res> {
  _$ShowMessageRequestClientCapabilitiesCopyWithImpl(this._self, this._then);

  final ShowMessageRequestClientCapabilities _self;
  final $Res Function(ShowMessageRequestClientCapabilities) _then;

/// Create a copy of ShowMessageRequestClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? messageActionItem = freezed,}) {
  return _then(_self.copyWith(
messageActionItem: freezed == messageActionItem ? _self.messageActionItem : messageActionItem // ignore: cast_nullable_to_non_nullable
as BoolAdditionalPropertiesSupport?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _ShowMessageRequestClientCapabilities implements ShowMessageRequestClientCapabilities {
  const _ShowMessageRequestClientCapabilities({this.messageActionItem});
  factory _ShowMessageRequestClientCapabilities.fromJson(Map<String, dynamic> json) => _$ShowMessageRequestClientCapabilitiesFromJson(json);

/// Capabilities specific to the `MessageActionItem` type.
@override final  BoolAdditionalPropertiesSupport? messageActionItem;

/// Create a copy of ShowMessageRequestClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ShowMessageRequestClientCapabilitiesCopyWith<_ShowMessageRequestClientCapabilities> get copyWith => __$ShowMessageRequestClientCapabilitiesCopyWithImpl<_ShowMessageRequestClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ShowMessageRequestClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ShowMessageRequestClientCapabilities&&const DeepCollectionEquality().equals(other.messageActionItem, messageActionItem));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(messageActionItem));

@override
String toString() {
  return 'ShowMessageRequestClientCapabilities(messageActionItem: $messageActionItem)';
}


}

/// @nodoc
abstract mixin class _$ShowMessageRequestClientCapabilitiesCopyWith<$Res> implements $ShowMessageRequestClientCapabilitiesCopyWith<$Res> {
  factory _$ShowMessageRequestClientCapabilitiesCopyWith(_ShowMessageRequestClientCapabilities value, $Res Function(_ShowMessageRequestClientCapabilities) _then) = __$ShowMessageRequestClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 BoolAdditionalPropertiesSupport? messageActionItem
});




}
/// @nodoc
class __$ShowMessageRequestClientCapabilitiesCopyWithImpl<$Res>
    implements _$ShowMessageRequestClientCapabilitiesCopyWith<$Res> {
  __$ShowMessageRequestClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _ShowMessageRequestClientCapabilities _self;
  final $Res Function(_ShowMessageRequestClientCapabilities) _then;

/// Create a copy of ShowMessageRequestClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? messageActionItem = freezed,}) {
  return _then(_ShowMessageRequestClientCapabilities(
messageActionItem: freezed == messageActionItem ? _self.messageActionItem : messageActionItem // ignore: cast_nullable_to_non_nullable
as BoolAdditionalPropertiesSupport?,
  ));
}


}


/// @nodoc
mixin _$ShowDocumentClientCapabilities {

/// The client has support for the showDocument request.
 bool get support;
/// Create a copy of ShowDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$ShowDocumentClientCapabilitiesCopyWith<ShowDocumentClientCapabilities> get copyWith => _$ShowDocumentClientCapabilitiesCopyWithImpl<ShowDocumentClientCapabilities>(this as ShowDocumentClientCapabilities, _$identity);

  /// Serializes this ShowDocumentClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is ShowDocumentClientCapabilities&&(identical(other.support, support) || other.support == support));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,support);

@override
String toString() {
  return 'ShowDocumentClientCapabilities(support: $support)';
}


}

/// @nodoc
abstract mixin class $ShowDocumentClientCapabilitiesCopyWith<$Res>  {
  factory $ShowDocumentClientCapabilitiesCopyWith(ShowDocumentClientCapabilities value, $Res Function(ShowDocumentClientCapabilities) _then) = _$ShowDocumentClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 bool support
});




}
/// @nodoc
class _$ShowDocumentClientCapabilitiesCopyWithImpl<$Res>
    implements $ShowDocumentClientCapabilitiesCopyWith<$Res> {
  _$ShowDocumentClientCapabilitiesCopyWithImpl(this._self, this._then);

  final ShowDocumentClientCapabilities _self;
  final $Res Function(ShowDocumentClientCapabilities) _then;

/// Create a copy of ShowDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? support = null,}) {
  return _then(_self.copyWith(
support: null == support ? _self.support : support // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _ShowDocumentClientCapabilities implements ShowDocumentClientCapabilities {
  const _ShowDocumentClientCapabilities({required this.support});
  factory _ShowDocumentClientCapabilities.fromJson(Map<String, dynamic> json) => _$ShowDocumentClientCapabilitiesFromJson(json);

/// The client has support for the showDocument request.
@override final  bool support;

/// Create a copy of ShowDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$ShowDocumentClientCapabilitiesCopyWith<_ShowDocumentClientCapabilities> get copyWith => __$ShowDocumentClientCapabilitiesCopyWithImpl<_ShowDocumentClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$ShowDocumentClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _ShowDocumentClientCapabilities&&(identical(other.support, support) || other.support == support));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,support);

@override
String toString() {
  return 'ShowDocumentClientCapabilities(support: $support)';
}


}

/// @nodoc
abstract mixin class _$ShowDocumentClientCapabilitiesCopyWith<$Res> implements $ShowDocumentClientCapabilitiesCopyWith<$Res> {
  factory _$ShowDocumentClientCapabilitiesCopyWith(_ShowDocumentClientCapabilities value, $Res Function(_ShowDocumentClientCapabilities) _then) = __$ShowDocumentClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 bool support
});




}
/// @nodoc
class __$ShowDocumentClientCapabilitiesCopyWithImpl<$Res>
    implements _$ShowDocumentClientCapabilitiesCopyWith<$Res> {
  __$ShowDocumentClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _ShowDocumentClientCapabilities _self;
  final $Res Function(_ShowDocumentClientCapabilities) _then;

/// Create a copy of ShowDocumentClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? support = null,}) {
  return _then(_ShowDocumentClientCapabilities(
support: null == support ? _self.support : support // ignore: cast_nullable_to_non_nullable
as bool,
  ));
}


}


/// @nodoc
mixin _$RegularExpressionsClientCapabilities {

/// The engine's name.
 String get engine;/// The engine's version.
 String? get version;
/// Create a copy of RegularExpressionsClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$RegularExpressionsClientCapabilitiesCopyWith<RegularExpressionsClientCapabilities> get copyWith => _$RegularExpressionsClientCapabilitiesCopyWithImpl<RegularExpressionsClientCapabilities>(this as RegularExpressionsClientCapabilities, _$identity);

  /// Serializes this RegularExpressionsClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is RegularExpressionsClientCapabilities&&(identical(other.engine, engine) || other.engine == engine)&&(identical(other.version, version) || other.version == version));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,engine,version);

@override
String toString() {
  return 'RegularExpressionsClientCapabilities(engine: $engine, version: $version)';
}


}

/// @nodoc
abstract mixin class $RegularExpressionsClientCapabilitiesCopyWith<$Res>  {
  factory $RegularExpressionsClientCapabilitiesCopyWith(RegularExpressionsClientCapabilities value, $Res Function(RegularExpressionsClientCapabilities) _then) = _$RegularExpressionsClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 String engine, String? version
});




}
/// @nodoc
class _$RegularExpressionsClientCapabilitiesCopyWithImpl<$Res>
    implements $RegularExpressionsClientCapabilitiesCopyWith<$Res> {
  _$RegularExpressionsClientCapabilitiesCopyWithImpl(this._self, this._then);

  final RegularExpressionsClientCapabilities _self;
  final $Res Function(RegularExpressionsClientCapabilities) _then;

/// Create a copy of RegularExpressionsClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? engine = null,Object? version = freezed,}) {
  return _then(_self.copyWith(
engine: null == engine ? _self.engine : engine // ignore: cast_nullable_to_non_nullable
as String,version: freezed == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _RegularExpressionsClientCapabilities implements RegularExpressionsClientCapabilities {
  const _RegularExpressionsClientCapabilities({required this.engine, this.version});
  factory _RegularExpressionsClientCapabilities.fromJson(Map<String, dynamic> json) => _$RegularExpressionsClientCapabilitiesFromJson(json);

/// The engine's name.
@override final  String engine;
/// The engine's version.
@override final  String? version;

/// Create a copy of RegularExpressionsClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$RegularExpressionsClientCapabilitiesCopyWith<_RegularExpressionsClientCapabilities> get copyWith => __$RegularExpressionsClientCapabilitiesCopyWithImpl<_RegularExpressionsClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$RegularExpressionsClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _RegularExpressionsClientCapabilities&&(identical(other.engine, engine) || other.engine == engine)&&(identical(other.version, version) || other.version == version));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,engine,version);

@override
String toString() {
  return 'RegularExpressionsClientCapabilities(engine: $engine, version: $version)';
}


}

/// @nodoc
abstract mixin class _$RegularExpressionsClientCapabilitiesCopyWith<$Res> implements $RegularExpressionsClientCapabilitiesCopyWith<$Res> {
  factory _$RegularExpressionsClientCapabilitiesCopyWith(_RegularExpressionsClientCapabilities value, $Res Function(_RegularExpressionsClientCapabilities) _then) = __$RegularExpressionsClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 String engine, String? version
});




}
/// @nodoc
class __$RegularExpressionsClientCapabilitiesCopyWithImpl<$Res>
    implements _$RegularExpressionsClientCapabilitiesCopyWith<$Res> {
  __$RegularExpressionsClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _RegularExpressionsClientCapabilities _self;
  final $Res Function(_RegularExpressionsClientCapabilities) _then;

/// Create a copy of RegularExpressionsClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? engine = null,Object? version = freezed,}) {
  return _then(_RegularExpressionsClientCapabilities(
engine: null == engine ? _self.engine : engine // ignore: cast_nullable_to_non_nullable
as String,version: freezed == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}


/// @nodoc
mixin _$MarkdownClientCapabilities {

/// A list of HTML tags that the client allows / supports in Markdown.
/// @since 3.17.0
 List<String>? get allowedTags;/// The name of the parser.
 String get parser;/// The version of the parser.
 String? get version;
/// Create a copy of MarkdownClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$MarkdownClientCapabilitiesCopyWith<MarkdownClientCapabilities> get copyWith => _$MarkdownClientCapabilitiesCopyWithImpl<MarkdownClientCapabilities>(this as MarkdownClientCapabilities, _$identity);

  /// Serializes this MarkdownClientCapabilities to a JSON map.
  Map<String, dynamic> toJson();


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is MarkdownClientCapabilities&&const DeepCollectionEquality().equals(other.allowedTags, allowedTags)&&(identical(other.parser, parser) || other.parser == parser)&&(identical(other.version, version) || other.version == version));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(allowedTags),parser,version);

@override
String toString() {
  return 'MarkdownClientCapabilities(allowedTags: $allowedTags, parser: $parser, version: $version)';
}


}

/// @nodoc
abstract mixin class $MarkdownClientCapabilitiesCopyWith<$Res>  {
  factory $MarkdownClientCapabilitiesCopyWith(MarkdownClientCapabilities value, $Res Function(MarkdownClientCapabilities) _then) = _$MarkdownClientCapabilitiesCopyWithImpl;
@useResult
$Res call({
 List<String>? allowedTags, String parser, String? version
});




}
/// @nodoc
class _$MarkdownClientCapabilitiesCopyWithImpl<$Res>
    implements $MarkdownClientCapabilitiesCopyWith<$Res> {
  _$MarkdownClientCapabilitiesCopyWithImpl(this._self, this._then);

  final MarkdownClientCapabilities _self;
  final $Res Function(MarkdownClientCapabilities) _then;

/// Create a copy of MarkdownClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? allowedTags = freezed,Object? parser = null,Object? version = freezed,}) {
  return _then(_self.copyWith(
allowedTags: freezed == allowedTags ? _self.allowedTags : allowedTags // ignore: cast_nullable_to_non_nullable
as List<String>?,parser: null == parser ? _self.parser : parser // ignore: cast_nullable_to_non_nullable
as String,version: freezed == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}

}



/// @nodoc
@JsonSerializable()

class _MarkdownClientCapabilities implements MarkdownClientCapabilities {
  const _MarkdownClientCapabilities({final  List<String>? allowedTags, required this.parser, this.version}): _allowedTags = allowedTags;
  factory _MarkdownClientCapabilities.fromJson(Map<String, dynamic> json) => _$MarkdownClientCapabilitiesFromJson(json);

/// A list of HTML tags that the client allows / supports in Markdown.
/// @since 3.17.0
 final  List<String>? _allowedTags;
/// A list of HTML tags that the client allows / supports in Markdown.
/// @since 3.17.0
@override List<String>? get allowedTags {
  final value = _allowedTags;
  if (value == null) return null;
  if (_allowedTags is EqualUnmodifiableListView) return _allowedTags;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(value);
}

/// The name of the parser.
@override final  String parser;
/// The version of the parser.
@override final  String? version;

/// Create a copy of MarkdownClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$MarkdownClientCapabilitiesCopyWith<_MarkdownClientCapabilities> get copyWith => __$MarkdownClientCapabilitiesCopyWithImpl<_MarkdownClientCapabilities>(this, _$identity);

@override
Map<String, dynamic> toJson() {
  return _$MarkdownClientCapabilitiesToJson(this, );
}

@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _MarkdownClientCapabilities&&const DeepCollectionEquality().equals(other._allowedTags, _allowedTags)&&(identical(other.parser, parser) || other.parser == parser)&&(identical(other.version, version) || other.version == version));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hash(runtimeType,const DeepCollectionEquality().hash(_allowedTags),parser,version);

@override
String toString() {
  return 'MarkdownClientCapabilities(allowedTags: $allowedTags, parser: $parser, version: $version)';
}


}

/// @nodoc
abstract mixin class _$MarkdownClientCapabilitiesCopyWith<$Res> implements $MarkdownClientCapabilitiesCopyWith<$Res> {
  factory _$MarkdownClientCapabilitiesCopyWith(_MarkdownClientCapabilities value, $Res Function(_MarkdownClientCapabilities) _then) = __$MarkdownClientCapabilitiesCopyWithImpl;
@override @useResult
$Res call({
 List<String>? allowedTags, String parser, String? version
});




}
/// @nodoc
class __$MarkdownClientCapabilitiesCopyWithImpl<$Res>
    implements _$MarkdownClientCapabilitiesCopyWith<$Res> {
  __$MarkdownClientCapabilitiesCopyWithImpl(this._self, this._then);

  final _MarkdownClientCapabilities _self;
  final $Res Function(_MarkdownClientCapabilities) _then;

/// Create a copy of MarkdownClientCapabilities
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? allowedTags = freezed,Object? parser = null,Object? version = freezed,}) {
  return _then(_MarkdownClientCapabilities(
allowedTags: freezed == allowedTags ? _self._allowedTags : allowedTags // ignore: cast_nullable_to_non_nullable
as List<String>?,parser: null == parser ? _self.parser : parser // ignore: cast_nullable_to_non_nullable
as String,version: freezed == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as String?,
  ));
}


}

// dart format on
